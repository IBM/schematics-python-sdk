# -*- coding: utf-8 -*-
# (C) Copyright IBM Corp. 2024.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""
Unit Tests for SchematicsV1
"""

from datetime import datetime, timezone
from ibm_cloud_sdk_core.authenticators.no_auth_authenticator import NoAuthAuthenticator
from ibm_cloud_sdk_core.utils import datetime_to_string, string_to_datetime
import base64
import inspect
import io
import json
import os
import pytest
import re
import requests
import responses
import tempfile
import urllib
from ibm_schematics.schematics_v1 import *


_service = SchematicsV1(authenticator=NoAuthAuthenticator())

_base_url = 'https://schematics.cloud.ibm.com'
_service.set_service_url(_base_url)


def preprocess_url(operation_path: str):
    """
    Returns the request url associated with the specified operation path.
    This will be base_url concatenated with a quoted version of operation_path.
    The returned request URL is used to register the mock response so it needs
    to match the request URL that is formed by the requests library.
    """

    # Form the request URL from the base URL and operation path.
    request_url = _base_url + operation_path

    # If the request url does NOT end with a /, then just return it as-is.
    # Otherwise, return a regular expression that matches one or more trailing /.
    if not request_url.endswith('/'):
        return request_url
    return re.compile(request_url.rstrip('/') + '/+')


##############################################################################
# Start of Service: Util
##############################################################################
# region


class TestNewInstance:
    """
    Test Class for new_instance
    """

    def test_new_instance(self):
        """
        new_instance()
        """
        os.environ['TEST_SERVICE_AUTH_TYPE'] = 'noAuth'

        service = SchematicsV1.new_instance(
            service_name='TEST_SERVICE',
        )

        assert service is not None
        assert isinstance(service, SchematicsV1)

    def test_new_instance_without_authenticator(self):
        """
        new_instance_without_authenticator()
        """
        with pytest.raises(ValueError, match='authenticator must be provided'):
            service = SchematicsV1.new_instance(
                service_name='TEST_SERVICE_NOT_FOUND',
            )


class TestListSchematicsLocation:
    """
    Test Class for list_schematics_location
    """

    @responses.activate
    def test_list_schematics_location_all_params(self):
        """
        list_schematics_location()
        """
        # Set up mock
        url = preprocess_url('/v1/locations')
        mock_response = '[{"name": "name", "id": "id", "country": "country", "geography": "geography", "geography_code": "geography_code", "metro": "metro", "multizone_metro": "multizone_metro", "kind": "kind", "paired_region": ["paired_region"], "restricted": true, "agent_metadata": [{"name": "purpose", "value": ["value"]}]}]'
        responses.add(
            responses.GET,
            url,
            body=mock_response,
            content_type='application/json',
            status=200,
        )

        # Invoke method
        response = _service.list_schematics_location()

        # Check for correct operation
        assert len(responses.calls) == 1
        assert response.status_code == 200

    def test_list_schematics_location_all_params_with_retries(self):
        # Enable retries and run test_list_schematics_location_all_params.
        _service.enable_retries()
        self.test_list_schematics_location_all_params()

        # Disable retries and run test_list_schematics_location_all_params.
        _service.disable_retries()
        self.test_list_schematics_location_all_params()


class TestListLocations:
    """
    Test Class for list_locations
    """

    @responses.activate
    def test_list_locations_all_params(self):
        """
        list_locations()
        """
        # Set up mock
        url = preprocess_url('/v2/locations')
        mock_response = '{"locations": [{"region": "region", "metro": "metro", "geography_code": "geography_code", "geography": "geography", "country": "country", "kind": "kind", "paired_region": ["paired_region"], "restricted": true, "display_name": "display_name", "schematics_regional_public_endpoint": "schematics_regional_public_endpoint", "schematics_regional_private_endpoint": "schematics_regional_private_endpoint"}]}'
        responses.add(
            responses.GET,
            url,
            body=mock_response,
            content_type='application/json',
            status=200,
        )

        # Invoke method
        response = _service.list_locations()

        # Check for correct operation
        assert len(responses.calls) == 1
        assert response.status_code == 200

    def test_list_locations_all_params_with_retries(self):
        # Enable retries and run test_list_locations_all_params.
        _service.enable_retries()
        self.test_list_locations_all_params()

        # Disable retries and run test_list_locations_all_params.
        _service.disable_retries()
        self.test_list_locations_all_params()


class TestListResourceGroup:
    """
    Test Class for list_resource_group
    """

    @responses.activate
    def test_list_resource_group_all_params(self):
        """
        list_resource_group()
        """
        # Set up mock
        url = preprocess_url('/v1/resource_groups')
        mock_response = '[{"account_id": "account_id", "crn": "crn", "default": false, "name": "name", "resource_group_id": "resource_group_id", "state": "state"}]'
        responses.add(
            responses.GET,
            url,
            body=mock_response,
            content_type='application/json',
            status=200,
        )

        # Invoke method
        response = _service.list_resource_group()

        # Check for correct operation
        assert len(responses.calls) == 1
        assert response.status_code == 200

    def test_list_resource_group_all_params_with_retries(self):
        # Enable retries and run test_list_resource_group_all_params.
        _service.enable_retries()
        self.test_list_resource_group_all_params()

        # Disable retries and run test_list_resource_group_all_params.
        _service.disable_retries()
        self.test_list_resource_group_all_params()


class TestGetSchematicsVersion:
    """
    Test Class for get_schematics_version
    """

    @responses.activate
    def test_get_schematics_version_all_params(self):
        """
        get_schematics_version()
        """
        # Set up mock
        url = preprocess_url('/v1/version')
        mock_response = '{"builddate": "builddate", "buildno": "buildno", "commitsha": "commitsha", "helm_provider_version": "helm_provider_version", "helm_version": "helm_version", "supported_template_types": {"anyKey": "anyValue"}, "terraform_provider_version": "terraform_provider_version", "terraform_version": "terraform_version"}'
        responses.add(
            responses.GET,
            url,
            body=mock_response,
            content_type='application/json',
            status=200,
        )

        # Invoke method
        response = _service.get_schematics_version()

        # Check for correct operation
        assert len(responses.calls) == 1
        assert response.status_code == 200

    def test_get_schematics_version_all_params_with_retries(self):
        # Enable retries and run test_get_schematics_version_all_params.
        _service.enable_retries()
        self.test_get_schematics_version_all_params()

        # Disable retries and run test_get_schematics_version_all_params.
        _service.disable_retries()
        self.test_get_schematics_version_all_params()


class TestProcessTemplateMetaData:
    """
    Test Class for process_template_meta_data
    """

    @responses.activate
    def test_process_template_meta_data_all_params(self):
        """
        process_template_meta_data()
        """
        # Set up mock
        url = preprocess_url('/v2/template_metadata_processor')
        mock_response = '{"type": "type", "variables": [{"name": "name", "value": "value", "use_default": false, "metadata": {"type": "boolean", "aliases": ["aliases"], "description": "description", "cloud_data_type": "cloud_data_type", "default_value": "default_value", "link_status": "normal", "secure": true, "immutable": false, "hidden": true, "required": true, "options": ["options"], "min_value": 9, "max_value": 9, "min_length": 10, "max_length": 10, "matches": "matches", "position": 8, "group_by": "group_by", "source": "source"}, "link": "link"}]}'
        responses.add(
            responses.POST,
            url,
            body=mock_response,
            content_type='application/json',
            status=200,
        )

        # Construct a dict representation of a GitSource model
        git_source_model = {}
        git_source_model['computed_git_repo_url'] = 'testString'
        git_source_model['git_repo_url'] = 'testString'
        git_source_model['git_token'] = 'testString'
        git_source_model['git_repo_folder'] = 'testString'
        git_source_model['git_release'] = 'testString'
        git_source_model['git_branch'] = 'testString'

        # Construct a dict representation of a CatalogSource model
        catalog_source_model = {}
        catalog_source_model['catalog_name'] = 'testString'
        catalog_source_model['catalog_id'] = 'testString'
        catalog_source_model['offering_name'] = 'testString'
        catalog_source_model['offering_version'] = 'testString'
        catalog_source_model['offering_kind'] = 'testString'
        catalog_source_model['offering_target_kind'] = 'testString'
        catalog_source_model['offering_id'] = 'testString'
        catalog_source_model['offering_version_id'] = 'testString'
        catalog_source_model['offering_version_flavour_name'] = 'testString'
        catalog_source_model['offering_repo_url'] = 'testString'
        catalog_source_model['offering_provisioner_working_directory'] = 'testString'
        catalog_source_model['dry_run'] = True
        catalog_source_model['owning_account'] = 'testString'
        catalog_source_model['item_icon_url'] = 'testString'
        catalog_source_model['item_id'] = 'testString'
        catalog_source_model['item_name'] = 'testString'
        catalog_source_model['item_readme_url'] = 'testString'
        catalog_source_model['item_url'] = 'testString'
        catalog_source_model['launch_url'] = 'testString'

        # Construct a dict representation of a ExternalSource model
        external_source_model = {}
        external_source_model['source_type'] = 'local'
        external_source_model['git'] = git_source_model
        external_source_model['catalog'] = catalog_source_model

        # Set up parameter values
        template_type = 'testString'
        source = external_source_model
        region = 'testString'
        source_type = 'local'
        x_github_token = 'testString'

        # Invoke method
        response = _service.process_template_meta_data(
            template_type,
            source,
            region=region,
            source_type=source_type,
            x_github_token=x_github_token,
            headers={},
        )

        # Check for correct operation
        assert len(responses.calls) == 1
        assert response.status_code == 200
        # Validate body params
        req_body = json.loads(str(responses.calls[0].request.body, 'utf-8'))
        assert req_body['template_type'] == 'testString'
        assert req_body['source'] == external_source_model
        assert req_body['region'] == 'testString'
        assert req_body['source_type'] == 'local'

    def test_process_template_meta_data_all_params_with_retries(self):
        # Enable retries and run test_process_template_meta_data_all_params.
        _service.enable_retries()
        self.test_process_template_meta_data_all_params()

        # Disable retries and run test_process_template_meta_data_all_params.
        _service.disable_retries()
        self.test_process_template_meta_data_all_params()

    @responses.activate
    def test_process_template_meta_data_required_params(self):
        """
        test_process_template_meta_data_required_params()
        """
        # Set up mock
        url = preprocess_url('/v2/template_metadata_processor')
        mock_response = '{"type": "type", "variables": [{"name": "name", "value": "value", "use_default": false, "metadata": {"type": "boolean", "aliases": ["aliases"], "description": "description", "cloud_data_type": "cloud_data_type", "default_value": "default_value", "link_status": "normal", "secure": true, "immutable": false, "hidden": true, "required": true, "options": ["options"], "min_value": 9, "max_value": 9, "min_length": 10, "max_length": 10, "matches": "matches", "position": 8, "group_by": "group_by", "source": "source"}, "link": "link"}]}'
        responses.add(
            responses.POST,
            url,
            body=mock_response,
            content_type='application/json',
            status=200,
        )

        # Construct a dict representation of a GitSource model
        git_source_model = {}
        git_source_model['computed_git_repo_url'] = 'testString'
        git_source_model['git_repo_url'] = 'testString'
        git_source_model['git_token'] = 'testString'
        git_source_model['git_repo_folder'] = 'testString'
        git_source_model['git_release'] = 'testString'
        git_source_model['git_branch'] = 'testString'

        # Construct a dict representation of a CatalogSource model
        catalog_source_model = {}
        catalog_source_model['catalog_name'] = 'testString'
        catalog_source_model['catalog_id'] = 'testString'
        catalog_source_model['offering_name'] = 'testString'
        catalog_source_model['offering_version'] = 'testString'
        catalog_source_model['offering_kind'] = 'testString'
        catalog_source_model['offering_target_kind'] = 'testString'
        catalog_source_model['offering_id'] = 'testString'
        catalog_source_model['offering_version_id'] = 'testString'
        catalog_source_model['offering_version_flavour_name'] = 'testString'
        catalog_source_model['offering_repo_url'] = 'testString'
        catalog_source_model['offering_provisioner_working_directory'] = 'testString'
        catalog_source_model['dry_run'] = True
        catalog_source_model['owning_account'] = 'testString'
        catalog_source_model['item_icon_url'] = 'testString'
        catalog_source_model['item_id'] = 'testString'
        catalog_source_model['item_name'] = 'testString'
        catalog_source_model['item_readme_url'] = 'testString'
        catalog_source_model['item_url'] = 'testString'
        catalog_source_model['launch_url'] = 'testString'

        # Construct a dict representation of a ExternalSource model
        external_source_model = {}
        external_source_model['source_type'] = 'local'
        external_source_model['git'] = git_source_model
        external_source_model['catalog'] = catalog_source_model

        # Set up parameter values
        template_type = 'testString'
        source = external_source_model
        region = 'testString'
        source_type = 'local'

        # Invoke method
        response = _service.process_template_meta_data(
            template_type,
            source,
            region=region,
            source_type=source_type,
            headers={},
        )

        # Check for correct operation
        assert len(responses.calls) == 1
        assert response.status_code == 200
        # Validate body params
        req_body = json.loads(str(responses.calls[0].request.body, 'utf-8'))
        assert req_body['template_type'] == 'testString'
        assert req_body['source'] == external_source_model
        assert req_body['region'] == 'testString'
        assert req_body['source_type'] == 'local'

    def test_process_template_meta_data_required_params_with_retries(self):
        # Enable retries and run test_process_template_meta_data_required_params.
        _service.enable_retries()
        self.test_process_template_meta_data_required_params()

        # Disable retries and run test_process_template_meta_data_required_params.
        _service.disable_retries()
        self.test_process_template_meta_data_required_params()

    @responses.activate
    def test_process_template_meta_data_value_error(self):
        """
        test_process_template_meta_data_value_error()
        """
        # Set up mock
        url = preprocess_url('/v2/template_metadata_processor')
        mock_response = '{"type": "type", "variables": [{"name": "name", "value": "value", "use_default": false, "metadata": {"type": "boolean", "aliases": ["aliases"], "description": "description", "cloud_data_type": "cloud_data_type", "default_value": "default_value", "link_status": "normal", "secure": true, "immutable": false, "hidden": true, "required": true, "options": ["options"], "min_value": 9, "max_value": 9, "min_length": 10, "max_length": 10, "matches": "matches", "position": 8, "group_by": "group_by", "source": "source"}, "link": "link"}]}'
        responses.add(
            responses.POST,
            url,
            body=mock_response,
            content_type='application/json',
            status=200,
        )

        # Construct a dict representation of a GitSource model
        git_source_model = {}
        git_source_model['computed_git_repo_url'] = 'testString'
        git_source_model['git_repo_url'] = 'testString'
        git_source_model['git_token'] = 'testString'
        git_source_model['git_repo_folder'] = 'testString'
        git_source_model['git_release'] = 'testString'
        git_source_model['git_branch'] = 'testString'

        # Construct a dict representation of a CatalogSource model
        catalog_source_model = {}
        catalog_source_model['catalog_name'] = 'testString'
        catalog_source_model['catalog_id'] = 'testString'
        catalog_source_model['offering_name'] = 'testString'
        catalog_source_model['offering_version'] = 'testString'
        catalog_source_model['offering_kind'] = 'testString'
        catalog_source_model['offering_target_kind'] = 'testString'
        catalog_source_model['offering_id'] = 'testString'
        catalog_source_model['offering_version_id'] = 'testString'
        catalog_source_model['offering_version_flavour_name'] = 'testString'
        catalog_source_model['offering_repo_url'] = 'testString'
        catalog_source_model['offering_provisioner_working_directory'] = 'testString'
        catalog_source_model['dry_run'] = True
        catalog_source_model['owning_account'] = 'testString'
        catalog_source_model['item_icon_url'] = 'testString'
        catalog_source_model['item_id'] = 'testString'
        catalog_source_model['item_name'] = 'testString'
        catalog_source_model['item_readme_url'] = 'testString'
        catalog_source_model['item_url'] = 'testString'
        catalog_source_model['launch_url'] = 'testString'

        # Construct a dict representation of a ExternalSource model
        external_source_model = {}
        external_source_model['source_type'] = 'local'
        external_source_model['git'] = git_source_model
        external_source_model['catalog'] = catalog_source_model

        # Set up parameter values
        template_type = 'testString'
        source = external_source_model
        region = 'testString'
        source_type = 'local'

        # Pass in all but one required param and check for a ValueError
        req_param_dict = {
            "template_type": template_type,
            "source": source,
        }
        for param in req_param_dict.keys():
            req_copy = {key: val if key is not param else None for (key, val) in req_param_dict.items()}
            with pytest.raises(ValueError):
                _service.process_template_meta_data(**req_copy)

    def test_process_template_meta_data_value_error_with_retries(self):
        # Enable retries and run test_process_template_meta_data_value_error.
        _service.enable_retries()
        self.test_process_template_meta_data_value_error()

        # Disable retries and run test_process_template_meta_data_value_error.
        _service.disable_retries()
        self.test_process_template_meta_data_value_error()


# endregion
##############################################################################
# End of Service: Util
##############################################################################

##############################################################################
# Start of Service: Workspaces
##############################################################################
# region


class TestNewInstance:
    """
    Test Class for new_instance
    """

    def test_new_instance(self):
        """
        new_instance()
        """
        os.environ['TEST_SERVICE_AUTH_TYPE'] = 'noAuth'

        service = SchematicsV1.new_instance(
            service_name='TEST_SERVICE',
        )

        assert service is not None
        assert isinstance(service, SchematicsV1)

    def test_new_instance_without_authenticator(self):
        """
        new_instance_without_authenticator()
        """
        with pytest.raises(ValueError, match='authenticator must be provided'):
            service = SchematicsV1.new_instance(
                service_name='TEST_SERVICE_NOT_FOUND',
            )


class TestListWorkspaces:
    """
    Test Class for list_workspaces
    """

    @responses.activate
    def test_list_workspaces_all_params(self):
        """
        list_workspaces()
        """
        # Set up mock
        url = preprocess_url('/v1/workspaces')
        mock_response = '{"count": 5, "limit": 5, "offset": 6, "workspaces": [{"applied_shareddata_ids": ["applied_shareddata_ids"], "catalog_ref": {"dry_run": false, "owning_account": "owning_account", "item_icon_url": "item_icon_url", "item_id": "item_id", "item_name": "item_name", "item_readme_url": "item_readme_url", "item_url": "item_url", "launch_url": "launch_url", "offering_version": "offering_version", "service_extensions": [{"name": "flavor", "value": "anyValue", "type": "string"}]}, "created_at": "2019-01-01T12:00:00.000Z", "created_by": "created_by", "crn": "crn", "dependencies": {"parents": ["parents"], "children": ["children"]}, "description": "description", "id": "id", "last_health_check_at": "2019-01-01T12:00:00.000Z", "location": "location", "name": "name", "resource_group": "resource_group", "runtime_data": [{"engine_cmd": "engine_cmd", "engine_name": "engine_name", "engine_version": "engine_version", "id": "id", "log_store_url": "log_store_url", "output_values": [{"anyKey": "anyValue"}], "resources": [[{"anyKey": "anyValue"}]], "state_store_url": "state_store_url"}], "shared_data": {"cluster_id": "cluster_id", "cluster_name": "cluster_name", "entitlement_keys": [{"anyKey": "anyValue"}], "namespace": "namespace", "region": "region", "resource_group_id": "resource_group_id"}, "status": "status", "tags": ["tags"], "template_data": [{"env_values": [{"hidden": true, "name": "name", "secure": true, "value": "value"}], "folder": "folder", "compact": false, "has_githubtoken": false, "id": "id", "type": "type", "uninstall_script_name": "uninstall_script_name", "values": "values", "values_metadata": [{"anyKey": "anyValue"}], "values_url": "values_url", "variablestore": [{"description": "description", "name": "name", "secure": true, "type": "type", "value": "value"}]}], "template_ref": "template_ref", "template_repo": {"branch": "branch", "full_url": "full_url", "has_uploadedgitrepotar": true, "release": "release", "repo_sha_value": "repo_sha_value", "repo_url": "repo_url", "url": "url", "skip_submodules_checkout": true}, "type": ["type"], "updated_at": "2019-01-01T12:00:00.000Z", "updated_by": "updated_by", "cart_id": "cart_id", "project_id": "project_id", "last_action_name": "last_action_name", "last_activity_id": "last_activity_id", "last_job": {"job_id": "job_id", "job_name": "job_name", "job_status": "job_status"}, "workspace_status": {"frozen": true, "frozen_at": "2019-01-01T12:00:00.000Z", "frozen_by": "frozen_by", "locked": true, "locked_by": "locked_by", "locked_time": "2019-01-01T12:00:00.000Z"}, "workspace_status_msg": {"status_code": "status_code", "status_msg": "status_msg"}, "agent": {"id": "id", "name": "name", "assignment_policy_id": "assignment_policy_id"}, "settings": [{"name": "name", "value": "value", "use_default": false, "metadata": {"type": "boolean", "aliases": ["aliases"], "description": "description", "cloud_data_type": "cloud_data_type", "default_value": "default_value", "link_status": "normal", "secure": true, "immutable": false, "hidden": true, "required": true, "options": ["options"], "min_value": 9, "max_value": 9, "min_length": 10, "max_length": 10, "matches": "matches", "position": 8, "group_by": "group_by", "source": "source"}, "link": "link"}], "git_token_ref": "git_token_ref", "encryption": {"crn": "crn", "scheme": "scheme"}}]}'
        responses.add(
            responses.GET,
            url,
            body=mock_response,
            content_type='application/json',
            status=200,
        )

        # Set up parameter values
        offset = 0
        limit = 100
        profile = 'ids'
        resource_group = 'testString'

        # Invoke method
        response = _service.list_workspaces(
            offset=offset,
            limit=limit,
            profile=profile,
            resource_group=resource_group,
            headers={},
        )

        # Check for correct operation
        assert len(responses.calls) == 1
        assert response.status_code == 200
        # Validate query params
        query_string = responses.calls[0].request.url.split('?', 1)[1]
        query_string = urllib.parse.unquote_plus(query_string)
        assert 'offset={}'.format(offset) in query_string
        assert 'limit={}'.format(limit) in query_string
        assert 'profile={}'.format(profile) in query_string
        assert 'resource_group={}'.format(resource_group) in query_string

    def test_list_workspaces_all_params_with_retries(self):
        # Enable retries and run test_list_workspaces_all_params.
        _service.enable_retries()
        self.test_list_workspaces_all_params()

        # Disable retries and run test_list_workspaces_all_params.
        _service.disable_retries()
        self.test_list_workspaces_all_params()

    @responses.activate
    def test_list_workspaces_required_params(self):
        """
        test_list_workspaces_required_params()
        """
        # Set up mock
        url = preprocess_url('/v1/workspaces')
        mock_response = '{"count": 5, "limit": 5, "offset": 6, "workspaces": [{"applied_shareddata_ids": ["applied_shareddata_ids"], "catalog_ref": {"dry_run": false, "owning_account": "owning_account", "item_icon_url": "item_icon_url", "item_id": "item_id", "item_name": "item_name", "item_readme_url": "item_readme_url", "item_url": "item_url", "launch_url": "launch_url", "offering_version": "offering_version", "service_extensions": [{"name": "flavor", "value": "anyValue", "type": "string"}]}, "created_at": "2019-01-01T12:00:00.000Z", "created_by": "created_by", "crn": "crn", "dependencies": {"parents": ["parents"], "children": ["children"]}, "description": "description", "id": "id", "last_health_check_at": "2019-01-01T12:00:00.000Z", "location": "location", "name": "name", "resource_group": "resource_group", "runtime_data": [{"engine_cmd": "engine_cmd", "engine_name": "engine_name", "engine_version": "engine_version", "id": "id", "log_store_url": "log_store_url", "output_values": [{"anyKey": "anyValue"}], "resources": [[{"anyKey": "anyValue"}]], "state_store_url": "state_store_url"}], "shared_data": {"cluster_id": "cluster_id", "cluster_name": "cluster_name", "entitlement_keys": [{"anyKey": "anyValue"}], "namespace": "namespace", "region": "region", "resource_group_id": "resource_group_id"}, "status": "status", "tags": ["tags"], "template_data": [{"env_values": [{"hidden": true, "name": "name", "secure": true, "value": "value"}], "folder": "folder", "compact": false, "has_githubtoken": false, "id": "id", "type": "type", "uninstall_script_name": "uninstall_script_name", "values": "values", "values_metadata": [{"anyKey": "anyValue"}], "values_url": "values_url", "variablestore": [{"description": "description", "name": "name", "secure": true, "type": "type", "value": "value"}]}], "template_ref": "template_ref", "template_repo": {"branch": "branch", "full_url": "full_url", "has_uploadedgitrepotar": true, "release": "release", "repo_sha_value": "repo_sha_value", "repo_url": "repo_url", "url": "url", "skip_submodules_checkout": true}, "type": ["type"], "updated_at": "2019-01-01T12:00:00.000Z", "updated_by": "updated_by", "cart_id": "cart_id", "project_id": "project_id", "last_action_name": "last_action_name", "last_activity_id": "last_activity_id", "last_job": {"job_id": "job_id", "job_name": "job_name", "job_status": "job_status"}, "workspace_status": {"frozen": true, "frozen_at": "2019-01-01T12:00:00.000Z", "frozen_by": "frozen_by", "locked": true, "locked_by": "locked_by", "locked_time": "2019-01-01T12:00:00.000Z"}, "workspace_status_msg": {"status_code": "status_code", "status_msg": "status_msg"}, "agent": {"id": "id", "name": "name", "assignment_policy_id": "assignment_policy_id"}, "settings": [{"name": "name", "value": "value", "use_default": false, "metadata": {"type": "boolean", "aliases": ["aliases"], "description": "description", "cloud_data_type": "cloud_data_type", "default_value": "default_value", "link_status": "normal", "secure": true, "immutable": false, "hidden": true, "required": true, "options": ["options"], "min_value": 9, "max_value": 9, "min_length": 10, "max_length": 10, "matches": "matches", "position": 8, "group_by": "group_by", "source": "source"}, "link": "link"}], "git_token_ref": "git_token_ref", "encryption": {"crn": "crn", "scheme": "scheme"}}]}'
        responses.add(
            responses.GET,
            url,
            body=mock_response,
            content_type='application/json',
            status=200,
        )

        # Invoke method
        response = _service.list_workspaces()

        # Check for correct operation
        assert len(responses.calls) == 1
        assert response.status_code == 200

    def test_list_workspaces_required_params_with_retries(self):
        # Enable retries and run test_list_workspaces_required_params.
        _service.enable_retries()
        self.test_list_workspaces_required_params()

        # Disable retries and run test_list_workspaces_required_params.
        _service.disable_retries()
        self.test_list_workspaces_required_params()


class TestCreateWorkspace:
    """
    Test Class for create_workspace
    """

    @responses.activate
    def test_create_workspace_all_params(self):
        """
        create_workspace()
        """
        # Set up mock
        url = preprocess_url('/v1/workspaces')
        mock_response = '{"applied_shareddata_ids": ["applied_shareddata_ids"], "catalog_ref": {"dry_run": false, "owning_account": "owning_account", "item_icon_url": "item_icon_url", "item_id": "item_id", "item_name": "item_name", "item_readme_url": "item_readme_url", "item_url": "item_url", "launch_url": "launch_url", "offering_version": "offering_version", "service_extensions": [{"name": "flavor", "value": "anyValue", "type": "string"}]}, "created_at": "2019-01-01T12:00:00.000Z", "created_by": "created_by", "crn": "crn", "dependencies": {"parents": ["parents"], "children": ["children"]}, "description": "description", "id": "id", "last_health_check_at": "2019-01-01T12:00:00.000Z", "location": "location", "name": "name", "resource_group": "resource_group", "runtime_data": [{"engine_cmd": "engine_cmd", "engine_name": "engine_name", "engine_version": "engine_version", "id": "id", "log_store_url": "log_store_url", "output_values": [{"anyKey": "anyValue"}], "resources": [[{"anyKey": "anyValue"}]], "state_store_url": "state_store_url"}], "shared_data": {"cluster_id": "cluster_id", "cluster_name": "cluster_name", "entitlement_keys": [{"anyKey": "anyValue"}], "namespace": "namespace", "region": "region", "resource_group_id": "resource_group_id"}, "status": "status", "tags": ["tags"], "template_data": [{"env_values": [{"hidden": true, "name": "name", "secure": true, "value": "value"}], "folder": "folder", "compact": false, "has_githubtoken": false, "id": "id", "type": "type", "uninstall_script_name": "uninstall_script_name", "values": "values", "values_metadata": [{"anyKey": "anyValue"}], "values_url": "values_url", "variablestore": [{"description": "description", "name": "name", "secure": true, "type": "type", "value": "value"}]}], "template_ref": "template_ref", "template_repo": {"branch": "branch", "full_url": "full_url", "has_uploadedgitrepotar": true, "release": "release", "repo_sha_value": "repo_sha_value", "repo_url": "repo_url", "url": "url", "skip_submodules_checkout": true}, "type": ["type"], "updated_at": "2019-01-01T12:00:00.000Z", "updated_by": "updated_by", "cart_id": "cart_id", "project_id": "project_id", "last_action_name": "last_action_name", "last_activity_id": "last_activity_id", "last_job": {"job_id": "job_id", "job_name": "job_name", "job_status": "job_status"}, "workspace_status": {"frozen": true, "frozen_at": "2019-01-01T12:00:00.000Z", "frozen_by": "frozen_by", "locked": true, "locked_by": "locked_by", "locked_time": "2019-01-01T12:00:00.000Z"}, "workspace_status_msg": {"status_code": "status_code", "status_msg": "status_msg"}, "agent": {"id": "id", "name": "name", "assignment_policy_id": "assignment_policy_id"}, "settings": [{"name": "name", "value": "value", "use_default": false, "metadata": {"type": "boolean", "aliases": ["aliases"], "description": "description", "cloud_data_type": "cloud_data_type", "default_value": "default_value", "link_status": "normal", "secure": true, "immutable": false, "hidden": true, "required": true, "options": ["options"], "min_value": 9, "max_value": 9, "min_length": 10, "max_length": 10, "matches": "matches", "position": 8, "group_by": "group_by", "source": "source"}, "link": "link"}], "git_token_ref": "git_token_ref", "encryption": {"crn": "crn", "scheme": "scheme"}}'
        responses.add(
            responses.POST,
            url,
            body=mock_response,
            content_type='application/json',
            status=201,
        )

        # Construct a dict representation of a ServiceExtensions model
        service_extensions_model = {}
        service_extensions_model['name'] = 'flavor'
        service_extensions_model['value'] = 'testString'
        service_extensions_model['type'] = 'string'

        # Construct a dict representation of a CatalogRef model
        catalog_ref_model = {}
        catalog_ref_model['dry_run'] = True
        catalog_ref_model['owning_account'] = 'testString'
        catalog_ref_model['item_icon_url'] = 'testString'
        catalog_ref_model['item_id'] = 'testString'
        catalog_ref_model['item_name'] = 'testString'
        catalog_ref_model['item_readme_url'] = 'testString'
        catalog_ref_model['item_url'] = 'testString'
        catalog_ref_model['launch_url'] = 'testString'
        catalog_ref_model['offering_version'] = 'testString'
        catalog_ref_model['service_extensions'] = [service_extensions_model]

        # Construct a dict representation of a Dependencies model
        dependencies_model = {}
        dependencies_model['parents'] = ['testString']
        dependencies_model['children'] = ['testString']

        # Construct a dict representation of a SharedTargetData model
        shared_target_data_model = {}
        shared_target_data_model['cluster_created_on'] = 'testString'
        shared_target_data_model['cluster_id'] = 'testString'
        shared_target_data_model['cluster_name'] = 'testString'
        shared_target_data_model['cluster_type'] = 'testString'
        shared_target_data_model['entitlement_keys'] = [{'anyKey': 'anyValue'}]
        shared_target_data_model['namespace'] = 'testString'
        shared_target_data_model['region'] = 'testString'
        shared_target_data_model['resource_group_id'] = 'testString'
        shared_target_data_model['worker_count'] = 26
        shared_target_data_model['worker_machine_type'] = 'testString'

        # Construct a dict representation of a EnvironmentValuesMetadata model
        environment_values_metadata_model = {}
        environment_values_metadata_model['hidden'] = True
        environment_values_metadata_model['name'] = 'testString'
        environment_values_metadata_model['secure'] = True

        # Construct a dict representation of a InjectTerraformTemplateInnerTftParametersItem model
        inject_terraform_template_inner_tft_parameters_item_model = {}
        inject_terraform_template_inner_tft_parameters_item_model['name'] = 'testString'
        inject_terraform_template_inner_tft_parameters_item_model['value'] = 'testString'

        # Construct a dict representation of a InjectTerraformTemplateInner model
        inject_terraform_template_inner_model = {}
        inject_terraform_template_inner_model['tft_git_url'] = 'testString'
        inject_terraform_template_inner_model['tft_git_token'] = 'testString'
        inject_terraform_template_inner_model['tft_prefix'] = 'testString'
        inject_terraform_template_inner_model['injection_type'] = 'testString'
        inject_terraform_template_inner_model['tft_name'] = 'testString'
        inject_terraform_template_inner_model['tft_parameters'] = [
            inject_terraform_template_inner_tft_parameters_item_model
        ]

        # Construct a dict representation of a WorkspaceVariableRequest model
        workspace_variable_request_model = {}
        workspace_variable_request_model['description'] = 'testString'
        workspace_variable_request_model['name'] = 'testString'
        workspace_variable_request_model['secure'] = True
        workspace_variable_request_model['type'] = 'testString'
        workspace_variable_request_model['use_default'] = True
        workspace_variable_request_model['value'] = 'testString'

        # Construct a dict representation of a TemplateSourceDataRequest model
        template_source_data_request_model = {}
        template_source_data_request_model['env_values'] = [{'anyKey': 'anyValue'}]
        template_source_data_request_model['env_values_metadata'] = [environment_values_metadata_model]
        template_source_data_request_model['folder'] = 'testString'
        template_source_data_request_model['compact'] = True
        template_source_data_request_model['init_state_file'] = 'testString'
        template_source_data_request_model['injectors'] = [inject_terraform_template_inner_model]
        template_source_data_request_model['type'] = 'testString'
        template_source_data_request_model['uninstall_script_name'] = 'testString'
        template_source_data_request_model['values'] = 'testString'
        template_source_data_request_model['values_metadata'] = [{'anyKey': 'anyValue'}]
        template_source_data_request_model['variablestore'] = [workspace_variable_request_model]

        # Construct a dict representation of a TemplateRepoRequest model
        template_repo_request_model = {}
        template_repo_request_model['branch'] = 'testString'
        template_repo_request_model['release'] = 'testString'
        template_repo_request_model['repo_sha_value'] = 'testString'
        template_repo_request_model['repo_url'] = 'testString'
        template_repo_request_model['url'] = 'testString'
        template_repo_request_model['skip_submodules_checkout'] = True

        # Construct a dict representation of a WorkspaceStatusRequest model
        workspace_status_request_model = {}
        workspace_status_request_model['frozen'] = True
        workspace_status_request_model['frozen_at'] = '2019-01-01T12:00:00Z'
        workspace_status_request_model['frozen_by'] = 'testString'
        workspace_status_request_model['locked'] = True
        workspace_status_request_model['locked_by'] = 'testString'
        workspace_status_request_model['locked_time'] = '2019-01-01T12:00:00Z'

        # Construct a dict representation of a VariableMetadata model
        variable_metadata_model = {}
        variable_metadata_model['type'] = 'boolean'
        variable_metadata_model['aliases'] = ['testString']
        variable_metadata_model['description'] = 'testString'
        variable_metadata_model['cloud_data_type'] = 'testString'
        variable_metadata_model['default_value'] = 'testString'
        variable_metadata_model['link_status'] = 'normal'
        variable_metadata_model['secure'] = True
        variable_metadata_model['immutable'] = True
        variable_metadata_model['hidden'] = True
        variable_metadata_model['required'] = True
        variable_metadata_model['options'] = ['testString']
        variable_metadata_model['min_value'] = 38
        variable_metadata_model['max_value'] = 38
        variable_metadata_model['min_length'] = 38
        variable_metadata_model['max_length'] = 38
        variable_metadata_model['matches'] = 'testString'
        variable_metadata_model['position'] = 38
        variable_metadata_model['group_by'] = 'testString'
        variable_metadata_model['source'] = 'testString'

        # Construct a dict representation of a VariableData model
        variable_data_model = {}
        variable_data_model['name'] = 'testString'
        variable_data_model['value'] = 'testString'
        variable_data_model['use_default'] = True
        variable_data_model['metadata'] = variable_metadata_model

        # Set up parameter values
        applied_shareddata_ids = ['testString']
        catalog_ref = catalog_ref_model
        dependencies = dependencies_model
        description = 'testString'
        location = 'testString'
        name = 'testString'
        resource_group = 'testString'
        shared_data = shared_target_data_model
        tags = ['testString']
        template_data = [template_source_data_request_model]
        template_ref = 'testString'
        template_repo = template_repo_request_model
        type = ['testString']
        workspace_status = workspace_status_request_model
        agent_id = 'testString'
        settings = [variable_data_model]
        x_github_token = 'testString'

        # Invoke method
        response = _service.create_workspace(
            applied_shareddata_ids=applied_shareddata_ids,
            catalog_ref=catalog_ref,
            dependencies=dependencies,
            description=description,
            location=location,
            name=name,
            resource_group=resource_group,
            shared_data=shared_data,
            tags=tags,
            template_data=template_data,
            template_ref=template_ref,
            template_repo=template_repo,
            type=type,
            workspace_status=workspace_status,
            agent_id=agent_id,
            settings=settings,
            x_github_token=x_github_token,
            headers={},
        )

        # Check for correct operation
        assert len(responses.calls) == 1
        assert response.status_code == 201
        # Validate body params
        req_body = json.loads(str(responses.calls[0].request.body, 'utf-8'))
        assert req_body['applied_shareddata_ids'] == ['testString']
        assert req_body['catalog_ref'] == catalog_ref_model
        assert req_body['dependencies'] == dependencies_model
        assert req_body['description'] == 'testString'
        assert req_body['location'] == 'testString'
        assert req_body['name'] == 'testString'
        assert req_body['resource_group'] == 'testString'
        assert req_body['shared_data'] == shared_target_data_model
        assert req_body['tags'] == ['testString']
        assert req_body['template_data'] == [template_source_data_request_model]
        assert req_body['template_ref'] == 'testString'
        assert req_body['template_repo'] == template_repo_request_model
        assert req_body['type'] == ['testString']
        assert req_body['workspace_status'] == workspace_status_request_model
        assert req_body['agent_id'] == 'testString'
        assert req_body['settings'] == [variable_data_model]

    def test_create_workspace_all_params_with_retries(self):
        # Enable retries and run test_create_workspace_all_params.
        _service.enable_retries()
        self.test_create_workspace_all_params()

        # Disable retries and run test_create_workspace_all_params.
        _service.disable_retries()
        self.test_create_workspace_all_params()

    @responses.activate
    def test_create_workspace_required_params(self):
        """
        test_create_workspace_required_params()
        """
        # Set up mock
        url = preprocess_url('/v1/workspaces')
        mock_response = '{"applied_shareddata_ids": ["applied_shareddata_ids"], "catalog_ref": {"dry_run": false, "owning_account": "owning_account", "item_icon_url": "item_icon_url", "item_id": "item_id", "item_name": "item_name", "item_readme_url": "item_readme_url", "item_url": "item_url", "launch_url": "launch_url", "offering_version": "offering_version", "service_extensions": [{"name": "flavor", "value": "anyValue", "type": "string"}]}, "created_at": "2019-01-01T12:00:00.000Z", "created_by": "created_by", "crn": "crn", "dependencies": {"parents": ["parents"], "children": ["children"]}, "description": "description", "id": "id", "last_health_check_at": "2019-01-01T12:00:00.000Z", "location": "location", "name": "name", "resource_group": "resource_group", "runtime_data": [{"engine_cmd": "engine_cmd", "engine_name": "engine_name", "engine_version": "engine_version", "id": "id", "log_store_url": "log_store_url", "output_values": [{"anyKey": "anyValue"}], "resources": [[{"anyKey": "anyValue"}]], "state_store_url": "state_store_url"}], "shared_data": {"cluster_id": "cluster_id", "cluster_name": "cluster_name", "entitlement_keys": [{"anyKey": "anyValue"}], "namespace": "namespace", "region": "region", "resource_group_id": "resource_group_id"}, "status": "status", "tags": ["tags"], "template_data": [{"env_values": [{"hidden": true, "name": "name", "secure": true, "value": "value"}], "folder": "folder", "compact": false, "has_githubtoken": false, "id": "id", "type": "type", "uninstall_script_name": "uninstall_script_name", "values": "values", "values_metadata": [{"anyKey": "anyValue"}], "values_url": "values_url", "variablestore": [{"description": "description", "name": "name", "secure": true, "type": "type", "value": "value"}]}], "template_ref": "template_ref", "template_repo": {"branch": "branch", "full_url": "full_url", "has_uploadedgitrepotar": true, "release": "release", "repo_sha_value": "repo_sha_value", "repo_url": "repo_url", "url": "url", "skip_submodules_checkout": true}, "type": ["type"], "updated_at": "2019-01-01T12:00:00.000Z", "updated_by": "updated_by", "cart_id": "cart_id", "project_id": "project_id", "last_action_name": "last_action_name", "last_activity_id": "last_activity_id", "last_job": {"job_id": "job_id", "job_name": "job_name", "job_status": "job_status"}, "workspace_status": {"frozen": true, "frozen_at": "2019-01-01T12:00:00.000Z", "frozen_by": "frozen_by", "locked": true, "locked_by": "locked_by", "locked_time": "2019-01-01T12:00:00.000Z"}, "workspace_status_msg": {"status_code": "status_code", "status_msg": "status_msg"}, "agent": {"id": "id", "name": "name", "assignment_policy_id": "assignment_policy_id"}, "settings": [{"name": "name", "value": "value", "use_default": false, "metadata": {"type": "boolean", "aliases": ["aliases"], "description": "description", "cloud_data_type": "cloud_data_type", "default_value": "default_value", "link_status": "normal", "secure": true, "immutable": false, "hidden": true, "required": true, "options": ["options"], "min_value": 9, "max_value": 9, "min_length": 10, "max_length": 10, "matches": "matches", "position": 8, "group_by": "group_by", "source": "source"}, "link": "link"}], "git_token_ref": "git_token_ref", "encryption": {"crn": "crn", "scheme": "scheme"}}'
        responses.add(
            responses.POST,
            url,
            body=mock_response,
            content_type='application/json',
            status=201,
        )

        # Construct a dict representation of a ServiceExtensions model
        service_extensions_model = {}
        service_extensions_model['name'] = 'flavor'
        service_extensions_model['value'] = 'testString'
        service_extensions_model['type'] = 'string'

        # Construct a dict representation of a CatalogRef model
        catalog_ref_model = {}
        catalog_ref_model['dry_run'] = True
        catalog_ref_model['owning_account'] = 'testString'
        catalog_ref_model['item_icon_url'] = 'testString'
        catalog_ref_model['item_id'] = 'testString'
        catalog_ref_model['item_name'] = 'testString'
        catalog_ref_model['item_readme_url'] = 'testString'
        catalog_ref_model['item_url'] = 'testString'
        catalog_ref_model['launch_url'] = 'testString'
        catalog_ref_model['offering_version'] = 'testString'
        catalog_ref_model['service_extensions'] = [service_extensions_model]

        # Construct a dict representation of a Dependencies model
        dependencies_model = {}
        dependencies_model['parents'] = ['testString']
        dependencies_model['children'] = ['testString']

        # Construct a dict representation of a SharedTargetData model
        shared_target_data_model = {}
        shared_target_data_model['cluster_created_on'] = 'testString'
        shared_target_data_model['cluster_id'] = 'testString'
        shared_target_data_model['cluster_name'] = 'testString'
        shared_target_data_model['cluster_type'] = 'testString'
        shared_target_data_model['entitlement_keys'] = [{'anyKey': 'anyValue'}]
        shared_target_data_model['namespace'] = 'testString'
        shared_target_data_model['region'] = 'testString'
        shared_target_data_model['resource_group_id'] = 'testString'
        shared_target_data_model['worker_count'] = 26
        shared_target_data_model['worker_machine_type'] = 'testString'

        # Construct a dict representation of a EnvironmentValuesMetadata model
        environment_values_metadata_model = {}
        environment_values_metadata_model['hidden'] = True
        environment_values_metadata_model['name'] = 'testString'
        environment_values_metadata_model['secure'] = True

        # Construct a dict representation of a InjectTerraformTemplateInnerTftParametersItem model
        inject_terraform_template_inner_tft_parameters_item_model = {}
        inject_terraform_template_inner_tft_parameters_item_model['name'] = 'testString'
        inject_terraform_template_inner_tft_parameters_item_model['value'] = 'testString'

        # Construct a dict representation of a InjectTerraformTemplateInner model
        inject_terraform_template_inner_model = {}
        inject_terraform_template_inner_model['tft_git_url'] = 'testString'
        inject_terraform_template_inner_model['tft_git_token'] = 'testString'
        inject_terraform_template_inner_model['tft_prefix'] = 'testString'
        inject_terraform_template_inner_model['injection_type'] = 'testString'
        inject_terraform_template_inner_model['tft_name'] = 'testString'
        inject_terraform_template_inner_model['tft_parameters'] = [
            inject_terraform_template_inner_tft_parameters_item_model
        ]

        # Construct a dict representation of a WorkspaceVariableRequest model
        workspace_variable_request_model = {}
        workspace_variable_request_model['description'] = 'testString'
        workspace_variable_request_model['name'] = 'testString'
        workspace_variable_request_model['secure'] = True
        workspace_variable_request_model['type'] = 'testString'
        workspace_variable_request_model['use_default'] = True
        workspace_variable_request_model['value'] = 'testString'

        # Construct a dict representation of a TemplateSourceDataRequest model
        template_source_data_request_model = {}
        template_source_data_request_model['env_values'] = [{'anyKey': 'anyValue'}]
        template_source_data_request_model['env_values_metadata'] = [environment_values_metadata_model]
        template_source_data_request_model['folder'] = 'testString'
        template_source_data_request_model['compact'] = True
        template_source_data_request_model['init_state_file'] = 'testString'
        template_source_data_request_model['injectors'] = [inject_terraform_template_inner_model]
        template_source_data_request_model['type'] = 'testString'
        template_source_data_request_model['uninstall_script_name'] = 'testString'
        template_source_data_request_model['values'] = 'testString'
        template_source_data_request_model['values_metadata'] = [{'anyKey': 'anyValue'}]
        template_source_data_request_model['variablestore'] = [workspace_variable_request_model]

        # Construct a dict representation of a TemplateRepoRequest model
        template_repo_request_model = {}
        template_repo_request_model['branch'] = 'testString'
        template_repo_request_model['release'] = 'testString'
        template_repo_request_model['repo_sha_value'] = 'testString'
        template_repo_request_model['repo_url'] = 'testString'
        template_repo_request_model['url'] = 'testString'
        template_repo_request_model['skip_submodules_checkout'] = True

        # Construct a dict representation of a WorkspaceStatusRequest model
        workspace_status_request_model = {}
        workspace_status_request_model['frozen'] = True
        workspace_status_request_model['frozen_at'] = '2019-01-01T12:00:00Z'
        workspace_status_request_model['frozen_by'] = 'testString'
        workspace_status_request_model['locked'] = True
        workspace_status_request_model['locked_by'] = 'testString'
        workspace_status_request_model['locked_time'] = '2019-01-01T12:00:00Z'

        # Construct a dict representation of a VariableMetadata model
        variable_metadata_model = {}
        variable_metadata_model['type'] = 'boolean'
        variable_metadata_model['aliases'] = ['testString']
        variable_metadata_model['description'] = 'testString'
        variable_metadata_model['cloud_data_type'] = 'testString'
        variable_metadata_model['default_value'] = 'testString'
        variable_metadata_model['link_status'] = 'normal'
        variable_metadata_model['secure'] = True
        variable_metadata_model['immutable'] = True
        variable_metadata_model['hidden'] = True
        variable_metadata_model['required'] = True
        variable_metadata_model['options'] = ['testString']
        variable_metadata_model['min_value'] = 38
        variable_metadata_model['max_value'] = 38
        variable_metadata_model['min_length'] = 38
        variable_metadata_model['max_length'] = 38
        variable_metadata_model['matches'] = 'testString'
        variable_metadata_model['position'] = 38
        variable_metadata_model['group_by'] = 'testString'
        variable_metadata_model['source'] = 'testString'

        # Construct a dict representation of a VariableData model
        variable_data_model = {}
        variable_data_model['name'] = 'testString'
        variable_data_model['value'] = 'testString'
        variable_data_model['use_default'] = True
        variable_data_model['metadata'] = variable_metadata_model

        # Set up parameter values
        applied_shareddata_ids = ['testString']
        catalog_ref = catalog_ref_model
        dependencies = dependencies_model
        description = 'testString'
        location = 'testString'
        name = 'testString'
        resource_group = 'testString'
        shared_data = shared_target_data_model
        tags = ['testString']
        template_data = [template_source_data_request_model]
        template_ref = 'testString'
        template_repo = template_repo_request_model
        type = ['testString']
        workspace_status = workspace_status_request_model
        agent_id = 'testString'
        settings = [variable_data_model]

        # Invoke method
        response = _service.create_workspace(
            applied_shareddata_ids=applied_shareddata_ids,
            catalog_ref=catalog_ref,
            dependencies=dependencies,
            description=description,
            location=location,
            name=name,
            resource_group=resource_group,
            shared_data=shared_data,
            tags=tags,
            template_data=template_data,
            template_ref=template_ref,
            template_repo=template_repo,
            type=type,
            workspace_status=workspace_status,
            agent_id=agent_id,
            settings=settings,
            headers={},
        )

        # Check for correct operation
        assert len(responses.calls) == 1
        assert response.status_code == 201
        # Validate body params
        req_body = json.loads(str(responses.calls[0].request.body, 'utf-8'))
        assert req_body['applied_shareddata_ids'] == ['testString']
        assert req_body['catalog_ref'] == catalog_ref_model
        assert req_body['dependencies'] == dependencies_model
        assert req_body['description'] == 'testString'
        assert req_body['location'] == 'testString'
        assert req_body['name'] == 'testString'
        assert req_body['resource_group'] == 'testString'
        assert req_body['shared_data'] == shared_target_data_model
        assert req_body['tags'] == ['testString']
        assert req_body['template_data'] == [template_source_data_request_model]
        assert req_body['template_ref'] == 'testString'
        assert req_body['template_repo'] == template_repo_request_model
        assert req_body['type'] == ['testString']
        assert req_body['workspace_status'] == workspace_status_request_model
        assert req_body['agent_id'] == 'testString'
        assert req_body['settings'] == [variable_data_model]

    def test_create_workspace_required_params_with_retries(self):
        # Enable retries and run test_create_workspace_required_params.
        _service.enable_retries()
        self.test_create_workspace_required_params()

        # Disable retries and run test_create_workspace_required_params.
        _service.disable_retries()
        self.test_create_workspace_required_params()


class TestGetWorkspace:
    """
    Test Class for get_workspace
    """

    @responses.activate
    def test_get_workspace_all_params(self):
        """
        get_workspace()
        """
        # Set up mock
        url = preprocess_url('/v1/workspaces/testString')
        mock_response = '{"applied_shareddata_ids": ["applied_shareddata_ids"], "catalog_ref": {"dry_run": false, "owning_account": "owning_account", "item_icon_url": "item_icon_url", "item_id": "item_id", "item_name": "item_name", "item_readme_url": "item_readme_url", "item_url": "item_url", "launch_url": "launch_url", "offering_version": "offering_version", "service_extensions": [{"name": "flavor", "value": "anyValue", "type": "string"}]}, "created_at": "2019-01-01T12:00:00.000Z", "created_by": "created_by", "crn": "crn", "dependencies": {"parents": ["parents"], "children": ["children"]}, "description": "description", "id": "id", "last_health_check_at": "2019-01-01T12:00:00.000Z", "location": "location", "name": "name", "resource_group": "resource_group", "runtime_data": [{"engine_cmd": "engine_cmd", "engine_name": "engine_name", "engine_version": "engine_version", "id": "id", "log_store_url": "log_store_url", "output_values": [{"anyKey": "anyValue"}], "resources": [[{"anyKey": "anyValue"}]], "state_store_url": "state_store_url"}], "shared_data": {"cluster_id": "cluster_id", "cluster_name": "cluster_name", "entitlement_keys": [{"anyKey": "anyValue"}], "namespace": "namespace", "region": "region", "resource_group_id": "resource_group_id"}, "status": "status", "tags": ["tags"], "template_data": [{"env_values": [{"hidden": true, "name": "name", "secure": true, "value": "value"}], "folder": "folder", "compact": false, "has_githubtoken": false, "id": "id", "type": "type", "uninstall_script_name": "uninstall_script_name", "values": "values", "values_metadata": [{"anyKey": "anyValue"}], "values_url": "values_url", "variablestore": [{"description": "description", "name": "name", "secure": true, "type": "type", "value": "value"}]}], "template_ref": "template_ref", "template_repo": {"branch": "branch", "full_url": "full_url", "has_uploadedgitrepotar": true, "release": "release", "repo_sha_value": "repo_sha_value", "repo_url": "repo_url", "url": "url", "skip_submodules_checkout": true}, "type": ["type"], "updated_at": "2019-01-01T12:00:00.000Z", "updated_by": "updated_by", "cart_id": "cart_id", "project_id": "project_id", "last_action_name": "last_action_name", "last_activity_id": "last_activity_id", "last_job": {"job_id": "job_id", "job_name": "job_name", "job_status": "job_status"}, "workspace_status": {"frozen": true, "frozen_at": "2019-01-01T12:00:00.000Z", "frozen_by": "frozen_by", "locked": true, "locked_by": "locked_by", "locked_time": "2019-01-01T12:00:00.000Z"}, "workspace_status_msg": {"status_code": "status_code", "status_msg": "status_msg"}, "agent": {"id": "id", "name": "name", "assignment_policy_id": "assignment_policy_id"}, "settings": [{"name": "name", "value": "value", "use_default": false, "metadata": {"type": "boolean", "aliases": ["aliases"], "description": "description", "cloud_data_type": "cloud_data_type", "default_value": "default_value", "link_status": "normal", "secure": true, "immutable": false, "hidden": true, "required": true, "options": ["options"], "min_value": 9, "max_value": 9, "min_length": 10, "max_length": 10, "matches": "matches", "position": 8, "group_by": "group_by", "source": "source"}, "link": "link"}], "git_token_ref": "git_token_ref", "encryption": {"crn": "crn", "scheme": "scheme"}}'
        responses.add(
            responses.GET,
            url,
            body=mock_response,
            content_type='application/json',
            status=200,
        )

        # Set up parameter values
        w_id = 'testString'

        # Invoke method
        response = _service.get_workspace(
            w_id,
            headers={},
        )

        # Check for correct operation
        assert len(responses.calls) == 1
        assert response.status_code == 200

    def test_get_workspace_all_params_with_retries(self):
        # Enable retries and run test_get_workspace_all_params.
        _service.enable_retries()
        self.test_get_workspace_all_params()

        # Disable retries and run test_get_workspace_all_params.
        _service.disable_retries()
        self.test_get_workspace_all_params()

    @responses.activate
    def test_get_workspace_value_error(self):
        """
        test_get_workspace_value_error()
        """
        # Set up mock
        url = preprocess_url('/v1/workspaces/testString')
        mock_response = '{"applied_shareddata_ids": ["applied_shareddata_ids"], "catalog_ref": {"dry_run": false, "owning_account": "owning_account", "item_icon_url": "item_icon_url", "item_id": "item_id", "item_name": "item_name", "item_readme_url": "item_readme_url", "item_url": "item_url", "launch_url": "launch_url", "offering_version": "offering_version", "service_extensions": [{"name": "flavor", "value": "anyValue", "type": "string"}]}, "created_at": "2019-01-01T12:00:00.000Z", "created_by": "created_by", "crn": "crn", "dependencies": {"parents": ["parents"], "children": ["children"]}, "description": "description", "id": "id", "last_health_check_at": "2019-01-01T12:00:00.000Z", "location": "location", "name": "name", "resource_group": "resource_group", "runtime_data": [{"engine_cmd": "engine_cmd", "engine_name": "engine_name", "engine_version": "engine_version", "id": "id", "log_store_url": "log_store_url", "output_values": [{"anyKey": "anyValue"}], "resources": [[{"anyKey": "anyValue"}]], "state_store_url": "state_store_url"}], "shared_data": {"cluster_id": "cluster_id", "cluster_name": "cluster_name", "entitlement_keys": [{"anyKey": "anyValue"}], "namespace": "namespace", "region": "region", "resource_group_id": "resource_group_id"}, "status": "status", "tags": ["tags"], "template_data": [{"env_values": [{"hidden": true, "name": "name", "secure": true, "value": "value"}], "folder": "folder", "compact": false, "has_githubtoken": false, "id": "id", "type": "type", "uninstall_script_name": "uninstall_script_name", "values": "values", "values_metadata": [{"anyKey": "anyValue"}], "values_url": "values_url", "variablestore": [{"description": "description", "name": "name", "secure": true, "type": "type", "value": "value"}]}], "template_ref": "template_ref", "template_repo": {"branch": "branch", "full_url": "full_url", "has_uploadedgitrepotar": true, "release": "release", "repo_sha_value": "repo_sha_value", "repo_url": "repo_url", "url": "url", "skip_submodules_checkout": true}, "type": ["type"], "updated_at": "2019-01-01T12:00:00.000Z", "updated_by": "updated_by", "cart_id": "cart_id", "project_id": "project_id", "last_action_name": "last_action_name", "last_activity_id": "last_activity_id", "last_job": {"job_id": "job_id", "job_name": "job_name", "job_status": "job_status"}, "workspace_status": {"frozen": true, "frozen_at": "2019-01-01T12:00:00.000Z", "frozen_by": "frozen_by", "locked": true, "locked_by": "locked_by", "locked_time": "2019-01-01T12:00:00.000Z"}, "workspace_status_msg": {"status_code": "status_code", "status_msg": "status_msg"}, "agent": {"id": "id", "name": "name", "assignment_policy_id": "assignment_policy_id"}, "settings": [{"name": "name", "value": "value", "use_default": false, "metadata": {"type": "boolean", "aliases": ["aliases"], "description": "description", "cloud_data_type": "cloud_data_type", "default_value": "default_value", "link_status": "normal", "secure": true, "immutable": false, "hidden": true, "required": true, "options": ["options"], "min_value": 9, "max_value": 9, "min_length": 10, "max_length": 10, "matches": "matches", "position": 8, "group_by": "group_by", "source": "source"}, "link": "link"}], "git_token_ref": "git_token_ref", "encryption": {"crn": "crn", "scheme": "scheme"}}'
        responses.add(
            responses.GET,
            url,
            body=mock_response,
            content_type='application/json',
            status=200,
        )

        # Set up parameter values
        w_id = 'testString'

        # Pass in all but one required param and check for a ValueError
        req_param_dict = {
            "w_id": w_id,
        }
        for param in req_param_dict.keys():
            req_copy = {key: val if key is not param else None for (key, val) in req_param_dict.items()}
            with pytest.raises(ValueError):
                _service.get_workspace(**req_copy)

    def test_get_workspace_value_error_with_retries(self):
        # Enable retries and run test_get_workspace_value_error.
        _service.enable_retries()
        self.test_get_workspace_value_error()

        # Disable retries and run test_get_workspace_value_error.
        _service.disable_retries()
        self.test_get_workspace_value_error()


class TestReplaceWorkspace:
    """
    Test Class for replace_workspace
    """

    @responses.activate
    def test_replace_workspace_all_params(self):
        """
        replace_workspace()
        """
        # Set up mock
        url = preprocess_url('/v1/workspaces/testString')
        mock_response = '{"applied_shareddata_ids": ["applied_shareddata_ids"], "catalog_ref": {"dry_run": false, "owning_account": "owning_account", "item_icon_url": "item_icon_url", "item_id": "item_id", "item_name": "item_name", "item_readme_url": "item_readme_url", "item_url": "item_url", "launch_url": "launch_url", "offering_version": "offering_version", "service_extensions": [{"name": "flavor", "value": "anyValue", "type": "string"}]}, "created_at": "2019-01-01T12:00:00.000Z", "created_by": "created_by", "crn": "crn", "dependencies": {"parents": ["parents"], "children": ["children"]}, "description": "description", "id": "id", "last_health_check_at": "2019-01-01T12:00:00.000Z", "location": "location", "name": "name", "resource_group": "resource_group", "runtime_data": [{"engine_cmd": "engine_cmd", "engine_name": "engine_name", "engine_version": "engine_version", "id": "id", "log_store_url": "log_store_url", "output_values": [{"anyKey": "anyValue"}], "resources": [[{"anyKey": "anyValue"}]], "state_store_url": "state_store_url"}], "shared_data": {"cluster_id": "cluster_id", "cluster_name": "cluster_name", "entitlement_keys": [{"anyKey": "anyValue"}], "namespace": "namespace", "region": "region", "resource_group_id": "resource_group_id"}, "status": "status", "tags": ["tags"], "template_data": [{"env_values": [{"hidden": true, "name": "name", "secure": true, "value": "value"}], "folder": "folder", "compact": false, "has_githubtoken": false, "id": "id", "type": "type", "uninstall_script_name": "uninstall_script_name", "values": "values", "values_metadata": [{"anyKey": "anyValue"}], "values_url": "values_url", "variablestore": [{"description": "description", "name": "name", "secure": true, "type": "type", "value": "value"}]}], "template_ref": "template_ref", "template_repo": {"branch": "branch", "full_url": "full_url", "has_uploadedgitrepotar": true, "release": "release", "repo_sha_value": "repo_sha_value", "repo_url": "repo_url", "url": "url", "skip_submodules_checkout": true}, "type": ["type"], "updated_at": "2019-01-01T12:00:00.000Z", "updated_by": "updated_by", "cart_id": "cart_id", "project_id": "project_id", "last_action_name": "last_action_name", "last_activity_id": "last_activity_id", "last_job": {"job_id": "job_id", "job_name": "job_name", "job_status": "job_status"}, "workspace_status": {"frozen": true, "frozen_at": "2019-01-01T12:00:00.000Z", "frozen_by": "frozen_by", "locked": true, "locked_by": "locked_by", "locked_time": "2019-01-01T12:00:00.000Z"}, "workspace_status_msg": {"status_code": "status_code", "status_msg": "status_msg"}, "agent": {"id": "id", "name": "name", "assignment_policy_id": "assignment_policy_id"}, "settings": [{"name": "name", "value": "value", "use_default": false, "metadata": {"type": "boolean", "aliases": ["aliases"], "description": "description", "cloud_data_type": "cloud_data_type", "default_value": "default_value", "link_status": "normal", "secure": true, "immutable": false, "hidden": true, "required": true, "options": ["options"], "min_value": 9, "max_value": 9, "min_length": 10, "max_length": 10, "matches": "matches", "position": 8, "group_by": "group_by", "source": "source"}, "link": "link"}], "git_token_ref": "git_token_ref", "encryption": {"crn": "crn", "scheme": "scheme"}}'
        responses.add(
            responses.PUT,
            url,
            body=mock_response,
            content_type='application/json',
            status=200,
        )

        # Construct a dict representation of a ServiceExtensions model
        service_extensions_model = {}
        service_extensions_model['name'] = 'flavor'
        service_extensions_model['value'] = 'testString'
        service_extensions_model['type'] = 'string'

        # Construct a dict representation of a CatalogRef model
        catalog_ref_model = {}
        catalog_ref_model['dry_run'] = True
        catalog_ref_model['owning_account'] = 'testString'
        catalog_ref_model['item_icon_url'] = 'testString'
        catalog_ref_model['item_id'] = 'testString'
        catalog_ref_model['item_name'] = 'testString'
        catalog_ref_model['item_readme_url'] = 'testString'
        catalog_ref_model['item_url'] = 'testString'
        catalog_ref_model['launch_url'] = 'testString'
        catalog_ref_model['offering_version'] = 'testString'
        catalog_ref_model['service_extensions'] = [service_extensions_model]

        # Construct a dict representation of a Dependencies model
        dependencies_model = {}
        dependencies_model['parents'] = ['testString']
        dependencies_model['children'] = ['testString']

        # Construct a dict representation of a SharedTargetData model
        shared_target_data_model = {}
        shared_target_data_model['cluster_created_on'] = 'testString'
        shared_target_data_model['cluster_id'] = 'testString'
        shared_target_data_model['cluster_name'] = 'testString'
        shared_target_data_model['cluster_type'] = 'testString'
        shared_target_data_model['entitlement_keys'] = [{'anyKey': 'anyValue'}]
        shared_target_data_model['namespace'] = 'testString'
        shared_target_data_model['region'] = 'testString'
        shared_target_data_model['resource_group_id'] = 'testString'
        shared_target_data_model['worker_count'] = 26
        shared_target_data_model['worker_machine_type'] = 'testString'

        # Construct a dict representation of a EnvironmentValuesMetadata model
        environment_values_metadata_model = {}
        environment_values_metadata_model['hidden'] = True
        environment_values_metadata_model['name'] = 'testString'
        environment_values_metadata_model['secure'] = True

        # Construct a dict representation of a InjectTerraformTemplateInnerTftParametersItem model
        inject_terraform_template_inner_tft_parameters_item_model = {}
        inject_terraform_template_inner_tft_parameters_item_model['name'] = 'testString'
        inject_terraform_template_inner_tft_parameters_item_model['value'] = 'testString'

        # Construct a dict representation of a InjectTerraformTemplateInner model
        inject_terraform_template_inner_model = {}
        inject_terraform_template_inner_model['tft_git_url'] = 'testString'
        inject_terraform_template_inner_model['tft_git_token'] = 'testString'
        inject_terraform_template_inner_model['tft_prefix'] = 'testString'
        inject_terraform_template_inner_model['injection_type'] = 'testString'
        inject_terraform_template_inner_model['tft_name'] = 'testString'
        inject_terraform_template_inner_model['tft_parameters'] = [
            inject_terraform_template_inner_tft_parameters_item_model
        ]

        # Construct a dict representation of a WorkspaceVariableRequest model
        workspace_variable_request_model = {}
        workspace_variable_request_model['description'] = 'testString'
        workspace_variable_request_model['name'] = 'testString'
        workspace_variable_request_model['secure'] = True
        workspace_variable_request_model['type'] = 'testString'
        workspace_variable_request_model['use_default'] = True
        workspace_variable_request_model['value'] = 'testString'

        # Construct a dict representation of a TemplateSourceDataRequest model
        template_source_data_request_model = {}
        template_source_data_request_model['env_values'] = [{'anyKey': 'anyValue'}]
        template_source_data_request_model['env_values_metadata'] = [environment_values_metadata_model]
        template_source_data_request_model['folder'] = 'testString'
        template_source_data_request_model['compact'] = True
        template_source_data_request_model['init_state_file'] = 'testString'
        template_source_data_request_model['injectors'] = [inject_terraform_template_inner_model]
        template_source_data_request_model['type'] = 'testString'
        template_source_data_request_model['uninstall_script_name'] = 'testString'
        template_source_data_request_model['values'] = 'testString'
        template_source_data_request_model['values_metadata'] = [{'anyKey': 'anyValue'}]
        template_source_data_request_model['variablestore'] = [workspace_variable_request_model]

        # Construct a dict representation of a TemplateRepoUpdateRequest model
        template_repo_update_request_model = {}
        template_repo_update_request_model['branch'] = 'testString'
        template_repo_update_request_model['release'] = 'testString'
        template_repo_update_request_model['repo_sha_value'] = 'testString'
        template_repo_update_request_model['repo_url'] = 'testString'
        template_repo_update_request_model['url'] = 'testString'
        template_repo_update_request_model['skip_submodules_checkout'] = True

        # Construct a dict representation of a WorkspaceStatusUpdateRequest model
        workspace_status_update_request_model = {}
        workspace_status_update_request_model['frozen'] = True
        workspace_status_update_request_model['frozen_at'] = '2019-01-01T12:00:00Z'
        workspace_status_update_request_model['frozen_by'] = 'testString'
        workspace_status_update_request_model['locked'] = True
        workspace_status_update_request_model['locked_by'] = 'testString'
        workspace_status_update_request_model['locked_time'] = '2019-01-01T12:00:00Z'

        # Construct a dict representation of a WorkspaceStatusMessage model
        workspace_status_message_model = {}
        workspace_status_message_model['status_code'] = 'testString'
        workspace_status_message_model['status_msg'] = 'testString'

        # Construct a dict representation of a VariableMetadata model
        variable_metadata_model = {}
        variable_metadata_model['type'] = 'boolean'
        variable_metadata_model['aliases'] = ['testString']
        variable_metadata_model['description'] = 'testString'
        variable_metadata_model['cloud_data_type'] = 'testString'
        variable_metadata_model['default_value'] = 'testString'
        variable_metadata_model['link_status'] = 'normal'
        variable_metadata_model['secure'] = True
        variable_metadata_model['immutable'] = True
        variable_metadata_model['hidden'] = True
        variable_metadata_model['required'] = True
        variable_metadata_model['options'] = ['testString']
        variable_metadata_model['min_value'] = 38
        variable_metadata_model['max_value'] = 38
        variable_metadata_model['min_length'] = 38
        variable_metadata_model['max_length'] = 38
        variable_metadata_model['matches'] = 'testString'
        variable_metadata_model['position'] = 38
        variable_metadata_model['group_by'] = 'testString'
        variable_metadata_model['source'] = 'testString'

        # Construct a dict representation of a VariableData model
        variable_data_model = {}
        variable_data_model['name'] = 'testString'
        variable_data_model['value'] = 'testString'
        variable_data_model['use_default'] = True
        variable_data_model['metadata'] = variable_metadata_model

        # Set up parameter values
        w_id = 'testString'
        catalog_ref = catalog_ref_model
        description = 'testString'
        dependencies = dependencies_model
        name = 'testString'
        shared_data = shared_target_data_model
        tags = ['testString']
        template_data = [template_source_data_request_model]
        template_repo = template_repo_update_request_model
        type = ['testString']
        workspace_status = workspace_status_update_request_model
        workspace_status_msg = workspace_status_message_model
        agent_id = 'testString'
        settings = [variable_data_model]
        x_github_token = 'testString'

        # Invoke method
        response = _service.replace_workspace(
            w_id,
            catalog_ref=catalog_ref,
            description=description,
            dependencies=dependencies,
            name=name,
            shared_data=shared_data,
            tags=tags,
            template_data=template_data,
            template_repo=template_repo,
            type=type,
            workspace_status=workspace_status,
            workspace_status_msg=workspace_status_msg,
            agent_id=agent_id,
            settings=settings,
            x_github_token=x_github_token,
            headers={},
        )

        # Check for correct operation
        assert len(responses.calls) == 1
        assert response.status_code == 200
        # Validate body params
        req_body = json.loads(str(responses.calls[0].request.body, 'utf-8'))
        assert req_body['catalog_ref'] == catalog_ref_model
        assert req_body['description'] == 'testString'
        assert req_body['dependencies'] == dependencies_model
        assert req_body['name'] == 'testString'
        assert req_body['shared_data'] == shared_target_data_model
        assert req_body['tags'] == ['testString']
        assert req_body['template_data'] == [template_source_data_request_model]
        assert req_body['template_repo'] == template_repo_update_request_model
        assert req_body['type'] == ['testString']
        assert req_body['workspace_status'] == workspace_status_update_request_model
        assert req_body['workspace_status_msg'] == workspace_status_message_model
        assert req_body['agent_id'] == 'testString'
        assert req_body['settings'] == [variable_data_model]

    def test_replace_workspace_all_params_with_retries(self):
        # Enable retries and run test_replace_workspace_all_params.
        _service.enable_retries()
        self.test_replace_workspace_all_params()

        # Disable retries and run test_replace_workspace_all_params.
        _service.disable_retries()
        self.test_replace_workspace_all_params()

    @responses.activate
    def test_replace_workspace_required_params(self):
        """
        test_replace_workspace_required_params()
        """
        # Set up mock
        url = preprocess_url('/v1/workspaces/testString')
        mock_response = '{"applied_shareddata_ids": ["applied_shareddata_ids"], "catalog_ref": {"dry_run": false, "owning_account": "owning_account", "item_icon_url": "item_icon_url", "item_id": "item_id", "item_name": "item_name", "item_readme_url": "item_readme_url", "item_url": "item_url", "launch_url": "launch_url", "offering_version": "offering_version", "service_extensions": [{"name": "flavor", "value": "anyValue", "type": "string"}]}, "created_at": "2019-01-01T12:00:00.000Z", "created_by": "created_by", "crn": "crn", "dependencies": {"parents": ["parents"], "children": ["children"]}, "description": "description", "id": "id", "last_health_check_at": "2019-01-01T12:00:00.000Z", "location": "location", "name": "name", "resource_group": "resource_group", "runtime_data": [{"engine_cmd": "engine_cmd", "engine_name": "engine_name", "engine_version": "engine_version", "id": "id", "log_store_url": "log_store_url", "output_values": [{"anyKey": "anyValue"}], "resources": [[{"anyKey": "anyValue"}]], "state_store_url": "state_store_url"}], "shared_data": {"cluster_id": "cluster_id", "cluster_name": "cluster_name", "entitlement_keys": [{"anyKey": "anyValue"}], "namespace": "namespace", "region": "region", "resource_group_id": "resource_group_id"}, "status": "status", "tags": ["tags"], "template_data": [{"env_values": [{"hidden": true, "name": "name", "secure": true, "value": "value"}], "folder": "folder", "compact": false, "has_githubtoken": false, "id": "id", "type": "type", "uninstall_script_name": "uninstall_script_name", "values": "values", "values_metadata": [{"anyKey": "anyValue"}], "values_url": "values_url", "variablestore": [{"description": "description", "name": "name", "secure": true, "type": "type", "value": "value"}]}], "template_ref": "template_ref", "template_repo": {"branch": "branch", "full_url": "full_url", "has_uploadedgitrepotar": true, "release": "release", "repo_sha_value": "repo_sha_value", "repo_url": "repo_url", "url": "url", "skip_submodules_checkout": true}, "type": ["type"], "updated_at": "2019-01-01T12:00:00.000Z", "updated_by": "updated_by", "cart_id": "cart_id", "project_id": "project_id", "last_action_name": "last_action_name", "last_activity_id": "last_activity_id", "last_job": {"job_id": "job_id", "job_name": "job_name", "job_status": "job_status"}, "workspace_status": {"frozen": true, "frozen_at": "2019-01-01T12:00:00.000Z", "frozen_by": "frozen_by", "locked": true, "locked_by": "locked_by", "locked_time": "2019-01-01T12:00:00.000Z"}, "workspace_status_msg": {"status_code": "status_code", "status_msg": "status_msg"}, "agent": {"id": "id", "name": "name", "assignment_policy_id": "assignment_policy_id"}, "settings": [{"name": "name", "value": "value", "use_default": false, "metadata": {"type": "boolean", "aliases": ["aliases"], "description": "description", "cloud_data_type": "cloud_data_type", "default_value": "default_value", "link_status": "normal", "secure": true, "immutable": false, "hidden": true, "required": true, "options": ["options"], "min_value": 9, "max_value": 9, "min_length": 10, "max_length": 10, "matches": "matches", "position": 8, "group_by": "group_by", "source": "source"}, "link": "link"}], "git_token_ref": "git_token_ref", "encryption": {"crn": "crn", "scheme": "scheme"}}'
        responses.add(
            responses.PUT,
            url,
            body=mock_response,
            content_type='application/json',
            status=200,
        )

        # Construct a dict representation of a ServiceExtensions model
        service_extensions_model = {}
        service_extensions_model['name'] = 'flavor'
        service_extensions_model['value'] = 'testString'
        service_extensions_model['type'] = 'string'

        # Construct a dict representation of a CatalogRef model
        catalog_ref_model = {}
        catalog_ref_model['dry_run'] = True
        catalog_ref_model['owning_account'] = 'testString'
        catalog_ref_model['item_icon_url'] = 'testString'
        catalog_ref_model['item_id'] = 'testString'
        catalog_ref_model['item_name'] = 'testString'
        catalog_ref_model['item_readme_url'] = 'testString'
        catalog_ref_model['item_url'] = 'testString'
        catalog_ref_model['launch_url'] = 'testString'
        catalog_ref_model['offering_version'] = 'testString'
        catalog_ref_model['service_extensions'] = [service_extensions_model]

        # Construct a dict representation of a Dependencies model
        dependencies_model = {}
        dependencies_model['parents'] = ['testString']
        dependencies_model['children'] = ['testString']

        # Construct a dict representation of a SharedTargetData model
        shared_target_data_model = {}
        shared_target_data_model['cluster_created_on'] = 'testString'
        shared_target_data_model['cluster_id'] = 'testString'
        shared_target_data_model['cluster_name'] = 'testString'
        shared_target_data_model['cluster_type'] = 'testString'
        shared_target_data_model['entitlement_keys'] = [{'anyKey': 'anyValue'}]
        shared_target_data_model['namespace'] = 'testString'
        shared_target_data_model['region'] = 'testString'
        shared_target_data_model['resource_group_id'] = 'testString'
        shared_target_data_model['worker_count'] = 26
        shared_target_data_model['worker_machine_type'] = 'testString'

        # Construct a dict representation of a EnvironmentValuesMetadata model
        environment_values_metadata_model = {}
        environment_values_metadata_model['hidden'] = True
        environment_values_metadata_model['name'] = 'testString'
        environment_values_metadata_model['secure'] = True

        # Construct a dict representation of a InjectTerraformTemplateInnerTftParametersItem model
        inject_terraform_template_inner_tft_parameters_item_model = {}
        inject_terraform_template_inner_tft_parameters_item_model['name'] = 'testString'
        inject_terraform_template_inner_tft_parameters_item_model['value'] = 'testString'

        # Construct a dict representation of a InjectTerraformTemplateInner model
        inject_terraform_template_inner_model = {}
        inject_terraform_template_inner_model['tft_git_url'] = 'testString'
        inject_terraform_template_inner_model['tft_git_token'] = 'testString'
        inject_terraform_template_inner_model['tft_prefix'] = 'testString'
        inject_terraform_template_inner_model['injection_type'] = 'testString'
        inject_terraform_template_inner_model['tft_name'] = 'testString'
        inject_terraform_template_inner_model['tft_parameters'] = [
            inject_terraform_template_inner_tft_parameters_item_model
        ]

        # Construct a dict representation of a WorkspaceVariableRequest model
        workspace_variable_request_model = {}
        workspace_variable_request_model['description'] = 'testString'
        workspace_variable_request_model['name'] = 'testString'
        workspace_variable_request_model['secure'] = True
        workspace_variable_request_model['type'] = 'testString'
        workspace_variable_request_model['use_default'] = True
        workspace_variable_request_model['value'] = 'testString'

        # Construct a dict representation of a TemplateSourceDataRequest model
        template_source_data_request_model = {}
        template_source_data_request_model['env_values'] = [{'anyKey': 'anyValue'}]
        template_source_data_request_model['env_values_metadata'] = [environment_values_metadata_model]
        template_source_data_request_model['folder'] = 'testString'
        template_source_data_request_model['compact'] = True
        template_source_data_request_model['init_state_file'] = 'testString'
        template_source_data_request_model['injectors'] = [inject_terraform_template_inner_model]
        template_source_data_request_model['type'] = 'testString'
        template_source_data_request_model['uninstall_script_name'] = 'testString'
        template_source_data_request_model['values'] = 'testString'
        template_source_data_request_model['values_metadata'] = [{'anyKey': 'anyValue'}]
        template_source_data_request_model['variablestore'] = [workspace_variable_request_model]

        # Construct a dict representation of a TemplateRepoUpdateRequest model
        template_repo_update_request_model = {}
        template_repo_update_request_model['branch'] = 'testString'
        template_repo_update_request_model['release'] = 'testString'
        template_repo_update_request_model['repo_sha_value'] = 'testString'
        template_repo_update_request_model['repo_url'] = 'testString'
        template_repo_update_request_model['url'] = 'testString'
        template_repo_update_request_model['skip_submodules_checkout'] = True

        # Construct a dict representation of a WorkspaceStatusUpdateRequest model
        workspace_status_update_request_model = {}
        workspace_status_update_request_model['frozen'] = True
        workspace_status_update_request_model['frozen_at'] = '2019-01-01T12:00:00Z'
        workspace_status_update_request_model['frozen_by'] = 'testString'
        workspace_status_update_request_model['locked'] = True
        workspace_status_update_request_model['locked_by'] = 'testString'
        workspace_status_update_request_model['locked_time'] = '2019-01-01T12:00:00Z'

        # Construct a dict representation of a WorkspaceStatusMessage model
        workspace_status_message_model = {}
        workspace_status_message_model['status_code'] = 'testString'
        workspace_status_message_model['status_msg'] = 'testString'

        # Construct a dict representation of a VariableMetadata model
        variable_metadata_model = {}
        variable_metadata_model['type'] = 'boolean'
        variable_metadata_model['aliases'] = ['testString']
        variable_metadata_model['description'] = 'testString'
        variable_metadata_model['cloud_data_type'] = 'testString'
        variable_metadata_model['default_value'] = 'testString'
        variable_metadata_model['link_status'] = 'normal'
        variable_metadata_model['secure'] = True
        variable_metadata_model['immutable'] = True
        variable_metadata_model['hidden'] = True
        variable_metadata_model['required'] = True
        variable_metadata_model['options'] = ['testString']
        variable_metadata_model['min_value'] = 38
        variable_metadata_model['max_value'] = 38
        variable_metadata_model['min_length'] = 38
        variable_metadata_model['max_length'] = 38
        variable_metadata_model['matches'] = 'testString'
        variable_metadata_model['position'] = 38
        variable_metadata_model['group_by'] = 'testString'
        variable_metadata_model['source'] = 'testString'

        # Construct a dict representation of a VariableData model
        variable_data_model = {}
        variable_data_model['name'] = 'testString'
        variable_data_model['value'] = 'testString'
        variable_data_model['use_default'] = True
        variable_data_model['metadata'] = variable_metadata_model

        # Set up parameter values
        w_id = 'testString'
        catalog_ref = catalog_ref_model
        description = 'testString'
        dependencies = dependencies_model
        name = 'testString'
        shared_data = shared_target_data_model
        tags = ['testString']
        template_data = [template_source_data_request_model]
        template_repo = template_repo_update_request_model
        type = ['testString']
        workspace_status = workspace_status_update_request_model
        workspace_status_msg = workspace_status_message_model
        agent_id = 'testString'
        settings = [variable_data_model]

        # Invoke method
        response = _service.replace_workspace(
            w_id,
            catalog_ref=catalog_ref,
            description=description,
            dependencies=dependencies,
            name=name,
            shared_data=shared_data,
            tags=tags,
            template_data=template_data,
            template_repo=template_repo,
            type=type,
            workspace_status=workspace_status,
            workspace_status_msg=workspace_status_msg,
            agent_id=agent_id,
            settings=settings,
            headers={},
        )

        # Check for correct operation
        assert len(responses.calls) == 1
        assert response.status_code == 200
        # Validate body params
        req_body = json.loads(str(responses.calls[0].request.body, 'utf-8'))
        assert req_body['catalog_ref'] == catalog_ref_model
        assert req_body['description'] == 'testString'
        assert req_body['dependencies'] == dependencies_model
        assert req_body['name'] == 'testString'
        assert req_body['shared_data'] == shared_target_data_model
        assert req_body['tags'] == ['testString']
        assert req_body['template_data'] == [template_source_data_request_model]
        assert req_body['template_repo'] == template_repo_update_request_model
        assert req_body['type'] == ['testString']
        assert req_body['workspace_status'] == workspace_status_update_request_model
        assert req_body['workspace_status_msg'] == workspace_status_message_model
        assert req_body['agent_id'] == 'testString'
        assert req_body['settings'] == [variable_data_model]

    def test_replace_workspace_required_params_with_retries(self):
        # Enable retries and run test_replace_workspace_required_params.
        _service.enable_retries()
        self.test_replace_workspace_required_params()

        # Disable retries and run test_replace_workspace_required_params.
        _service.disable_retries()
        self.test_replace_workspace_required_params()

    @responses.activate
    def test_replace_workspace_value_error(self):
        """
        test_replace_workspace_value_error()
        """
        # Set up mock
        url = preprocess_url('/v1/workspaces/testString')
        mock_response = '{"applied_shareddata_ids": ["applied_shareddata_ids"], "catalog_ref": {"dry_run": false, "owning_account": "owning_account", "item_icon_url": "item_icon_url", "item_id": "item_id", "item_name": "item_name", "item_readme_url": "item_readme_url", "item_url": "item_url", "launch_url": "launch_url", "offering_version": "offering_version", "service_extensions": [{"name": "flavor", "value": "anyValue", "type": "string"}]}, "created_at": "2019-01-01T12:00:00.000Z", "created_by": "created_by", "crn": "crn", "dependencies": {"parents": ["parents"], "children": ["children"]}, "description": "description", "id": "id", "last_health_check_at": "2019-01-01T12:00:00.000Z", "location": "location", "name": "name", "resource_group": "resource_group", "runtime_data": [{"engine_cmd": "engine_cmd", "engine_name": "engine_name", "engine_version": "engine_version", "id": "id", "log_store_url": "log_store_url", "output_values": [{"anyKey": "anyValue"}], "resources": [[{"anyKey": "anyValue"}]], "state_store_url": "state_store_url"}], "shared_data": {"cluster_id": "cluster_id", "cluster_name": "cluster_name", "entitlement_keys": [{"anyKey": "anyValue"}], "namespace": "namespace", "region": "region", "resource_group_id": "resource_group_id"}, "status": "status", "tags": ["tags"], "template_data": [{"env_values": [{"hidden": true, "name": "name", "secure": true, "value": "value"}], "folder": "folder", "compact": false, "has_githubtoken": false, "id": "id", "type": "type", "uninstall_script_name": "uninstall_script_name", "values": "values", "values_metadata": [{"anyKey": "anyValue"}], "values_url": "values_url", "variablestore": [{"description": "description", "name": "name", "secure": true, "type": "type", "value": "value"}]}], "template_ref": "template_ref", "template_repo": {"branch": "branch", "full_url": "full_url", "has_uploadedgitrepotar": true, "release": "release", "repo_sha_value": "repo_sha_value", "repo_url": "repo_url", "url": "url", "skip_submodules_checkout": true}, "type": ["type"], "updated_at": "2019-01-01T12:00:00.000Z", "updated_by": "updated_by", "cart_id": "cart_id", "project_id": "project_id", "last_action_name": "last_action_name", "last_activity_id": "last_activity_id", "last_job": {"job_id": "job_id", "job_name": "job_name", "job_status": "job_status"}, "workspace_status": {"frozen": true, "frozen_at": "2019-01-01T12:00:00.000Z", "frozen_by": "frozen_by", "locked": true, "locked_by": "locked_by", "locked_time": "2019-01-01T12:00:00.000Z"}, "workspace_status_msg": {"status_code": "status_code", "status_msg": "status_msg"}, "agent": {"id": "id", "name": "name", "assignment_policy_id": "assignment_policy_id"}, "settings": [{"name": "name", "value": "value", "use_default": false, "metadata": {"type": "boolean", "aliases": ["aliases"], "description": "description", "cloud_data_type": "cloud_data_type", "default_value": "default_value", "link_status": "normal", "secure": true, "immutable": false, "hidden": true, "required": true, "options": ["options"], "min_value": 9, "max_value": 9, "min_length": 10, "max_length": 10, "matches": "matches", "position": 8, "group_by": "group_by", "source": "source"}, "link": "link"}], "git_token_ref": "git_token_ref", "encryption": {"crn": "crn", "scheme": "scheme"}}'
        responses.add(
            responses.PUT,
            url,
            body=mock_response,
            content_type='application/json',
            status=200,
        )

        # Construct a dict representation of a ServiceExtensions model
        service_extensions_model = {}
        service_extensions_model['name'] = 'flavor'
        service_extensions_model['value'] = 'testString'
        service_extensions_model['type'] = 'string'

        # Construct a dict representation of a CatalogRef model
        catalog_ref_model = {}
        catalog_ref_model['dry_run'] = True
        catalog_ref_model['owning_account'] = 'testString'
        catalog_ref_model['item_icon_url'] = 'testString'
        catalog_ref_model['item_id'] = 'testString'
        catalog_ref_model['item_name'] = 'testString'
        catalog_ref_model['item_readme_url'] = 'testString'
        catalog_ref_model['item_url'] = 'testString'
        catalog_ref_model['launch_url'] = 'testString'
        catalog_ref_model['offering_version'] = 'testString'
        catalog_ref_model['service_extensions'] = [service_extensions_model]

        # Construct a dict representation of a Dependencies model
        dependencies_model = {}
        dependencies_model['parents'] = ['testString']
        dependencies_model['children'] = ['testString']

        # Construct a dict representation of a SharedTargetData model
        shared_target_data_model = {}
        shared_target_data_model['cluster_created_on'] = 'testString'
        shared_target_data_model['cluster_id'] = 'testString'
        shared_target_data_model['cluster_name'] = 'testString'
        shared_target_data_model['cluster_type'] = 'testString'
        shared_target_data_model['entitlement_keys'] = [{'anyKey': 'anyValue'}]
        shared_target_data_model['namespace'] = 'testString'
        shared_target_data_model['region'] = 'testString'
        shared_target_data_model['resource_group_id'] = 'testString'
        shared_target_data_model['worker_count'] = 26
        shared_target_data_model['worker_machine_type'] = 'testString'

        # Construct a dict representation of a EnvironmentValuesMetadata model
        environment_values_metadata_model = {}
        environment_values_metadata_model['hidden'] = True
        environment_values_metadata_model['name'] = 'testString'
        environment_values_metadata_model['secure'] = True

        # Construct a dict representation of a InjectTerraformTemplateInnerTftParametersItem model
        inject_terraform_template_inner_tft_parameters_item_model = {}
        inject_terraform_template_inner_tft_parameters_item_model['name'] = 'testString'
        inject_terraform_template_inner_tft_parameters_item_model['value'] = 'testString'

        # Construct a dict representation of a InjectTerraformTemplateInner model
        inject_terraform_template_inner_model = {}
        inject_terraform_template_inner_model['tft_git_url'] = 'testString'
        inject_terraform_template_inner_model['tft_git_token'] = 'testString'
        inject_terraform_template_inner_model['tft_prefix'] = 'testString'
        inject_terraform_template_inner_model['injection_type'] = 'testString'
        inject_terraform_template_inner_model['tft_name'] = 'testString'
        inject_terraform_template_inner_model['tft_parameters'] = [
            inject_terraform_template_inner_tft_parameters_item_model
        ]

        # Construct a dict representation of a WorkspaceVariableRequest model
        workspace_variable_request_model = {}
        workspace_variable_request_model['description'] = 'testString'
        workspace_variable_request_model['name'] = 'testString'
        workspace_variable_request_model['secure'] = True
        workspace_variable_request_model['type'] = 'testString'
        workspace_variable_request_model['use_default'] = True
        workspace_variable_request_model['value'] = 'testString'

        # Construct a dict representation of a TemplateSourceDataRequest model
        template_source_data_request_model = {}
        template_source_data_request_model['env_values'] = [{'anyKey': 'anyValue'}]
        template_source_data_request_model['env_values_metadata'] = [environment_values_metadata_model]
        template_source_data_request_model['folder'] = 'testString'
        template_source_data_request_model['compact'] = True
        template_source_data_request_model['init_state_file'] = 'testString'
        template_source_data_request_model['injectors'] = [inject_terraform_template_inner_model]
        template_source_data_request_model['type'] = 'testString'
        template_source_data_request_model['uninstall_script_name'] = 'testString'
        template_source_data_request_model['values'] = 'testString'
        template_source_data_request_model['values_metadata'] = [{'anyKey': 'anyValue'}]
        template_source_data_request_model['variablestore'] = [workspace_variable_request_model]

        # Construct a dict representation of a TemplateRepoUpdateRequest model
        template_repo_update_request_model = {}
        template_repo_update_request_model['branch'] = 'testString'
        template_repo_update_request_model['release'] = 'testString'
        template_repo_update_request_model['repo_sha_value'] = 'testString'
        template_repo_update_request_model['repo_url'] = 'testString'
        template_repo_update_request_model['url'] = 'testString'
        template_repo_update_request_model['skip_submodules_checkout'] = True

        # Construct a dict representation of a WorkspaceStatusUpdateRequest model
        workspace_status_update_request_model = {}
        workspace_status_update_request_model['frozen'] = True
        workspace_status_update_request_model['frozen_at'] = '2019-01-01T12:00:00Z'
        workspace_status_update_request_model['frozen_by'] = 'testString'
        workspace_status_update_request_model['locked'] = True
        workspace_status_update_request_model['locked_by'] = 'testString'
        workspace_status_update_request_model['locked_time'] = '2019-01-01T12:00:00Z'

        # Construct a dict representation of a WorkspaceStatusMessage model
        workspace_status_message_model = {}
        workspace_status_message_model['status_code'] = 'testString'
        workspace_status_message_model['status_msg'] = 'testString'

        # Construct a dict representation of a VariableMetadata model
        variable_metadata_model = {}
        variable_metadata_model['type'] = 'boolean'
        variable_metadata_model['aliases'] = ['testString']
        variable_metadata_model['description'] = 'testString'
        variable_metadata_model['cloud_data_type'] = 'testString'
        variable_metadata_model['default_value'] = 'testString'
        variable_metadata_model['link_status'] = 'normal'
        variable_metadata_model['secure'] = True
        variable_metadata_model['immutable'] = True
        variable_metadata_model['hidden'] = True
        variable_metadata_model['required'] = True
        variable_metadata_model['options'] = ['testString']
        variable_metadata_model['min_value'] = 38
        variable_metadata_model['max_value'] = 38
        variable_metadata_model['min_length'] = 38
        variable_metadata_model['max_length'] = 38
        variable_metadata_model['matches'] = 'testString'
        variable_metadata_model['position'] = 38
        variable_metadata_model['group_by'] = 'testString'
        variable_metadata_model['source'] = 'testString'

        # Construct a dict representation of a VariableData model
        variable_data_model = {}
        variable_data_model['name'] = 'testString'
        variable_data_model['value'] = 'testString'
        variable_data_model['use_default'] = True
        variable_data_model['metadata'] = variable_metadata_model

        # Set up parameter values
        w_id = 'testString'
        catalog_ref = catalog_ref_model
        description = 'testString'
        dependencies = dependencies_model
        name = 'testString'
        shared_data = shared_target_data_model
        tags = ['testString']
        template_data = [template_source_data_request_model]
        template_repo = template_repo_update_request_model
        type = ['testString']
        workspace_status = workspace_status_update_request_model
        workspace_status_msg = workspace_status_message_model
        agent_id = 'testString'
        settings = [variable_data_model]

        # Pass in all but one required param and check for a ValueError
        req_param_dict = {
            "w_id": w_id,
        }
        for param in req_param_dict.keys():
            req_copy = {key: val if key is not param else None for (key, val) in req_param_dict.items()}
            with pytest.raises(ValueError):
                _service.replace_workspace(**req_copy)

    def test_replace_workspace_value_error_with_retries(self):
        # Enable retries and run test_replace_workspace_value_error.
        _service.enable_retries()
        self.test_replace_workspace_value_error()

        # Disable retries and run test_replace_workspace_value_error.
        _service.disable_retries()
        self.test_replace_workspace_value_error()


class TestDeleteWorkspace:
    """
    Test Class for delete_workspace
    """

    @responses.activate
    def test_delete_workspace_all_params(self):
        """
        delete_workspace()
        """
        # Set up mock
        url = preprocess_url('/v1/workspaces/testString')
        mock_response = '"operation_response"'
        responses.add(
            responses.DELETE,
            url,
            body=mock_response,
            content_type='application/json',
            status=200,
        )

        # Set up parameter values
        refresh_token = 'testString'
        w_id = 'testString'
        destroy_resources = 'testString'

        # Invoke method
        response = _service.delete_workspace(
            refresh_token,
            w_id,
            destroy_resources=destroy_resources,
            headers={},
        )

        # Check for correct operation
        assert len(responses.calls) == 1
        assert response.status_code == 200
        # Validate query params
        query_string = responses.calls[0].request.url.split('?', 1)[1]
        query_string = urllib.parse.unquote_plus(query_string)
        assert 'destroy_resources={}'.format(destroy_resources) in query_string

    def test_delete_workspace_all_params_with_retries(self):
        # Enable retries and run test_delete_workspace_all_params.
        _service.enable_retries()
        self.test_delete_workspace_all_params()

        # Disable retries and run test_delete_workspace_all_params.
        _service.disable_retries()
        self.test_delete_workspace_all_params()

    @responses.activate
    def test_delete_workspace_required_params(self):
        """
        test_delete_workspace_required_params()
        """
        # Set up mock
        url = preprocess_url('/v1/workspaces/testString')
        mock_response = '"operation_response"'
        responses.add(
            responses.DELETE,
            url,
            body=mock_response,
            content_type='application/json',
            status=200,
        )

        # Set up parameter values
        refresh_token = 'testString'
        w_id = 'testString'

        # Invoke method
        response = _service.delete_workspace(
            refresh_token,
            w_id,
            headers={},
        )

        # Check for correct operation
        assert len(responses.calls) == 1
        assert response.status_code == 200

    def test_delete_workspace_required_params_with_retries(self):
        # Enable retries and run test_delete_workspace_required_params.
        _service.enable_retries()
        self.test_delete_workspace_required_params()

        # Disable retries and run test_delete_workspace_required_params.
        _service.disable_retries()
        self.test_delete_workspace_required_params()

    @responses.activate
    def test_delete_workspace_value_error(self):
        """
        test_delete_workspace_value_error()
        """
        # Set up mock
        url = preprocess_url('/v1/workspaces/testString')
        mock_response = '"operation_response"'
        responses.add(
            responses.DELETE,
            url,
            body=mock_response,
            content_type='application/json',
            status=200,
        )

        # Set up parameter values
        refresh_token = 'testString'
        w_id = 'testString'

        # Pass in all but one required param and check for a ValueError
        req_param_dict = {
            "refresh_token": refresh_token,
            "w_id": w_id,
        }
        for param in req_param_dict.keys():
            req_copy = {key: val if key is not param else None for (key, val) in req_param_dict.items()}
            with pytest.raises(ValueError):
                _service.delete_workspace(**req_copy)

    def test_delete_workspace_value_error_with_retries(self):
        # Enable retries and run test_delete_workspace_value_error.
        _service.enable_retries()
        self.test_delete_workspace_value_error()

        # Disable retries and run test_delete_workspace_value_error.
        _service.disable_retries()
        self.test_delete_workspace_value_error()


class TestUpdateWorkspace:
    """
    Test Class for update_workspace
    """

    @responses.activate
    def test_update_workspace_all_params(self):
        """
        update_workspace()
        """
        # Set up mock
        url = preprocess_url('/v1/workspaces/testString')
        mock_response = '{"applied_shareddata_ids": ["applied_shareddata_ids"], "catalog_ref": {"dry_run": false, "owning_account": "owning_account", "item_icon_url": "item_icon_url", "item_id": "item_id", "item_name": "item_name", "item_readme_url": "item_readme_url", "item_url": "item_url", "launch_url": "launch_url", "offering_version": "offering_version", "service_extensions": [{"name": "flavor", "value": "anyValue", "type": "string"}]}, "created_at": "2019-01-01T12:00:00.000Z", "created_by": "created_by", "crn": "crn", "dependencies": {"parents": ["parents"], "children": ["children"]}, "description": "description", "id": "id", "last_health_check_at": "2019-01-01T12:00:00.000Z", "location": "location", "name": "name", "resource_group": "resource_group", "runtime_data": [{"engine_cmd": "engine_cmd", "engine_name": "engine_name", "engine_version": "engine_version", "id": "id", "log_store_url": "log_store_url", "output_values": [{"anyKey": "anyValue"}], "resources": [[{"anyKey": "anyValue"}]], "state_store_url": "state_store_url"}], "shared_data": {"cluster_id": "cluster_id", "cluster_name": "cluster_name", "entitlement_keys": [{"anyKey": "anyValue"}], "namespace": "namespace", "region": "region", "resource_group_id": "resource_group_id"}, "status": "status", "tags": ["tags"], "template_data": [{"env_values": [{"hidden": true, "name": "name", "secure": true, "value": "value"}], "folder": "folder", "compact": false, "has_githubtoken": false, "id": "id", "type": "type", "uninstall_script_name": "uninstall_script_name", "values": "values", "values_metadata": [{"anyKey": "anyValue"}], "values_url": "values_url", "variablestore": [{"description": "description", "name": "name", "secure": true, "type": "type", "value": "value"}]}], "template_ref": "template_ref", "template_repo": {"branch": "branch", "full_url": "full_url", "has_uploadedgitrepotar": true, "release": "release", "repo_sha_value": "repo_sha_value", "repo_url": "repo_url", "url": "url", "skip_submodules_checkout": true}, "type": ["type"], "updated_at": "2019-01-01T12:00:00.000Z", "updated_by": "updated_by", "cart_id": "cart_id", "project_id": "project_id", "last_action_name": "last_action_name", "last_activity_id": "last_activity_id", "last_job": {"job_id": "job_id", "job_name": "job_name", "job_status": "job_status"}, "workspace_status": {"frozen": true, "frozen_at": "2019-01-01T12:00:00.000Z", "frozen_by": "frozen_by", "locked": true, "locked_by": "locked_by", "locked_time": "2019-01-01T12:00:00.000Z"}, "workspace_status_msg": {"status_code": "status_code", "status_msg": "status_msg"}, "agent": {"id": "id", "name": "name", "assignment_policy_id": "assignment_policy_id"}, "settings": [{"name": "name", "value": "value", "use_default": false, "metadata": {"type": "boolean", "aliases": ["aliases"], "description": "description", "cloud_data_type": "cloud_data_type", "default_value": "default_value", "link_status": "normal", "secure": true, "immutable": false, "hidden": true, "required": true, "options": ["options"], "min_value": 9, "max_value": 9, "min_length": 10, "max_length": 10, "matches": "matches", "position": 8, "group_by": "group_by", "source": "source"}, "link": "link"}], "git_token_ref": "git_token_ref", "encryption": {"crn": "crn", "scheme": "scheme"}}'
        responses.add(
            responses.PATCH,
            url,
            body=mock_response,
            content_type='application/json',
            status=200,
        )

        # Construct a dict representation of a ServiceExtensions model
        service_extensions_model = {}
        service_extensions_model['name'] = 'flavor'
        service_extensions_model['value'] = 'testString'
        service_extensions_model['type'] = 'string'

        # Construct a dict representation of a CatalogRef model
        catalog_ref_model = {}
        catalog_ref_model['dry_run'] = True
        catalog_ref_model['owning_account'] = 'testString'
        catalog_ref_model['item_icon_url'] = 'testString'
        catalog_ref_model['item_id'] = 'testString'
        catalog_ref_model['item_name'] = 'testString'
        catalog_ref_model['item_readme_url'] = 'testString'
        catalog_ref_model['item_url'] = 'testString'
        catalog_ref_model['launch_url'] = 'testString'
        catalog_ref_model['offering_version'] = 'testString'
        catalog_ref_model['service_extensions'] = [service_extensions_model]

        # Construct a dict representation of a Dependencies model
        dependencies_model = {}
        dependencies_model['parents'] = ['testString']
        dependencies_model['children'] = ['testString']

        # Construct a dict representation of a SharedTargetData model
        shared_target_data_model = {}
        shared_target_data_model['cluster_created_on'] = 'testString'
        shared_target_data_model['cluster_id'] = 'testString'
        shared_target_data_model['cluster_name'] = 'testString'
        shared_target_data_model['cluster_type'] = 'testString'
        shared_target_data_model['entitlement_keys'] = [{'anyKey': 'anyValue'}]
        shared_target_data_model['namespace'] = 'testString'
        shared_target_data_model['region'] = 'testString'
        shared_target_data_model['resource_group_id'] = 'testString'
        shared_target_data_model['worker_count'] = 26
        shared_target_data_model['worker_machine_type'] = 'testString'

        # Construct a dict representation of a EnvironmentValuesMetadata model
        environment_values_metadata_model = {}
        environment_values_metadata_model['hidden'] = True
        environment_values_metadata_model['name'] = 'testString'
        environment_values_metadata_model['secure'] = True

        # Construct a dict representation of a InjectTerraformTemplateInnerTftParametersItem model
        inject_terraform_template_inner_tft_parameters_item_model = {}
        inject_terraform_template_inner_tft_parameters_item_model['name'] = 'testString'
        inject_terraform_template_inner_tft_parameters_item_model['value'] = 'testString'

        # Construct a dict representation of a InjectTerraformTemplateInner model
        inject_terraform_template_inner_model = {}
        inject_terraform_template_inner_model['tft_git_url'] = 'testString'
        inject_terraform_template_inner_model['tft_git_token'] = 'testString'
        inject_terraform_template_inner_model['tft_prefix'] = 'testString'
        inject_terraform_template_inner_model['injection_type'] = 'testString'
        inject_terraform_template_inner_model['tft_name'] = 'testString'
        inject_terraform_template_inner_model['tft_parameters'] = [
            inject_terraform_template_inner_tft_parameters_item_model
        ]

        # Construct a dict representation of a WorkspaceVariableRequest model
        workspace_variable_request_model = {}
        workspace_variable_request_model['description'] = 'testString'
        workspace_variable_request_model['name'] = 'testString'
        workspace_variable_request_model['secure'] = True
        workspace_variable_request_model['type'] = 'testString'
        workspace_variable_request_model['use_default'] = True
        workspace_variable_request_model['value'] = 'testString'

        # Construct a dict representation of a TemplateSourceDataRequest model
        template_source_data_request_model = {}
        template_source_data_request_model['env_values'] = [{'anyKey': 'anyValue'}]
        template_source_data_request_model['env_values_metadata'] = [environment_values_metadata_model]
        template_source_data_request_model['folder'] = 'testString'
        template_source_data_request_model['compact'] = True
        template_source_data_request_model['init_state_file'] = 'testString'
        template_source_data_request_model['injectors'] = [inject_terraform_template_inner_model]
        template_source_data_request_model['type'] = 'testString'
        template_source_data_request_model['uninstall_script_name'] = 'testString'
        template_source_data_request_model['values'] = 'testString'
        template_source_data_request_model['values_metadata'] = [{'anyKey': 'anyValue'}]
        template_source_data_request_model['variablestore'] = [workspace_variable_request_model]

        # Construct a dict representation of a TemplateRepoUpdateRequest model
        template_repo_update_request_model = {}
        template_repo_update_request_model['branch'] = 'testString'
        template_repo_update_request_model['release'] = 'testString'
        template_repo_update_request_model['repo_sha_value'] = 'testString'
        template_repo_update_request_model['repo_url'] = 'testString'
        template_repo_update_request_model['url'] = 'testString'
        template_repo_update_request_model['skip_submodules_checkout'] = True

        # Construct a dict representation of a WorkspaceStatusUpdateRequest model
        workspace_status_update_request_model = {}
        workspace_status_update_request_model['frozen'] = True
        workspace_status_update_request_model['frozen_at'] = '2019-01-01T12:00:00Z'
        workspace_status_update_request_model['frozen_by'] = 'testString'
        workspace_status_update_request_model['locked'] = True
        workspace_status_update_request_model['locked_by'] = 'testString'
        workspace_status_update_request_model['locked_time'] = '2019-01-01T12:00:00Z'

        # Construct a dict representation of a WorkspaceStatusMessage model
        workspace_status_message_model = {}
        workspace_status_message_model['status_code'] = 'testString'
        workspace_status_message_model['status_msg'] = 'testString'

        # Construct a dict representation of a VariableMetadata model
        variable_metadata_model = {}
        variable_metadata_model['type'] = 'boolean'
        variable_metadata_model['aliases'] = ['testString']
        variable_metadata_model['description'] = 'testString'
        variable_metadata_model['cloud_data_type'] = 'testString'
        variable_metadata_model['default_value'] = 'testString'
        variable_metadata_model['link_status'] = 'normal'
        variable_metadata_model['secure'] = True
        variable_metadata_model['immutable'] = True
        variable_metadata_model['hidden'] = True
        variable_metadata_model['required'] = True
        variable_metadata_model['options'] = ['testString']
        variable_metadata_model['min_value'] = 38
        variable_metadata_model['max_value'] = 38
        variable_metadata_model['min_length'] = 38
        variable_metadata_model['max_length'] = 38
        variable_metadata_model['matches'] = 'testString'
        variable_metadata_model['position'] = 38
        variable_metadata_model['group_by'] = 'testString'
        variable_metadata_model['source'] = 'testString'

        # Construct a dict representation of a VariableData model
        variable_data_model = {}
        variable_data_model['name'] = 'testString'
        variable_data_model['value'] = 'testString'
        variable_data_model['use_default'] = True
        variable_data_model['metadata'] = variable_metadata_model

        # Set up parameter values
        w_id = 'testString'
        catalog_ref = catalog_ref_model
        description = 'testString'
        dependencies = dependencies_model
        name = 'testString'
        shared_data = shared_target_data_model
        tags = ['testString']
        template_data = [template_source_data_request_model]
        template_repo = template_repo_update_request_model
        type = ['testString']
        workspace_status = workspace_status_update_request_model
        workspace_status_msg = workspace_status_message_model
        agent_id = 'testString'
        settings = [variable_data_model]

        # Invoke method
        response = _service.update_workspace(
            w_id,
            catalog_ref=catalog_ref,
            description=description,
            dependencies=dependencies,
            name=name,
            shared_data=shared_data,
            tags=tags,
            template_data=template_data,
            template_repo=template_repo,
            type=type,
            workspace_status=workspace_status,
            workspace_status_msg=workspace_status_msg,
            agent_id=agent_id,
            settings=settings,
            headers={},
        )

        # Check for correct operation
        assert len(responses.calls) == 1
        assert response.status_code == 200
        # Validate body params
        req_body = json.loads(str(responses.calls[0].request.body, 'utf-8'))
        assert req_body['catalog_ref'] == catalog_ref_model
        assert req_body['description'] == 'testString'
        assert req_body['dependencies'] == dependencies_model
        assert req_body['name'] == 'testString'
        assert req_body['shared_data'] == shared_target_data_model
        assert req_body['tags'] == ['testString']
        assert req_body['template_data'] == [template_source_data_request_model]
        assert req_body['template_repo'] == template_repo_update_request_model
        assert req_body['type'] == ['testString']
        assert req_body['workspace_status'] == workspace_status_update_request_model
        assert req_body['workspace_status_msg'] == workspace_status_message_model
        assert req_body['agent_id'] == 'testString'
        assert req_body['settings'] == [variable_data_model]

    def test_update_workspace_all_params_with_retries(self):
        # Enable retries and run test_update_workspace_all_params.
        _service.enable_retries()
        self.test_update_workspace_all_params()

        # Disable retries and run test_update_workspace_all_params.
        _service.disable_retries()
        self.test_update_workspace_all_params()

    @responses.activate
    def test_update_workspace_value_error(self):
        """
        test_update_workspace_value_error()
        """
        # Set up mock
        url = preprocess_url('/v1/workspaces/testString')
        mock_response = '{"applied_shareddata_ids": ["applied_shareddata_ids"], "catalog_ref": {"dry_run": false, "owning_account": "owning_account", "item_icon_url": "item_icon_url", "item_id": "item_id", "item_name": "item_name", "item_readme_url": "item_readme_url", "item_url": "item_url", "launch_url": "launch_url", "offering_version": "offering_version", "service_extensions": [{"name": "flavor", "value": "anyValue", "type": "string"}]}, "created_at": "2019-01-01T12:00:00.000Z", "created_by": "created_by", "crn": "crn", "dependencies": {"parents": ["parents"], "children": ["children"]}, "description": "description", "id": "id", "last_health_check_at": "2019-01-01T12:00:00.000Z", "location": "location", "name": "name", "resource_group": "resource_group", "runtime_data": [{"engine_cmd": "engine_cmd", "engine_name": "engine_name", "engine_version": "engine_version", "id": "id", "log_store_url": "log_store_url", "output_values": [{"anyKey": "anyValue"}], "resources": [[{"anyKey": "anyValue"}]], "state_store_url": "state_store_url"}], "shared_data": {"cluster_id": "cluster_id", "cluster_name": "cluster_name", "entitlement_keys": [{"anyKey": "anyValue"}], "namespace": "namespace", "region": "region", "resource_group_id": "resource_group_id"}, "status": "status", "tags": ["tags"], "template_data": [{"env_values": [{"hidden": true, "name": "name", "secure": true, "value": "value"}], "folder": "folder", "compact": false, "has_githubtoken": false, "id": "id", "type": "type", "uninstall_script_name": "uninstall_script_name", "values": "values", "values_metadata": [{"anyKey": "anyValue"}], "values_url": "values_url", "variablestore": [{"description": "description", "name": "name", "secure": true, "type": "type", "value": "value"}]}], "template_ref": "template_ref", "template_repo": {"branch": "branch", "full_url": "full_url", "has_uploadedgitrepotar": true, "release": "release", "repo_sha_value": "repo_sha_value", "repo_url": "repo_url", "url": "url", "skip_submodules_checkout": true}, "type": ["type"], "updated_at": "2019-01-01T12:00:00.000Z", "updated_by": "updated_by", "cart_id": "cart_id", "project_id": "project_id", "last_action_name": "last_action_name", "last_activity_id": "last_activity_id", "last_job": {"job_id": "job_id", "job_name": "job_name", "job_status": "job_status"}, "workspace_status": {"frozen": true, "frozen_at": "2019-01-01T12:00:00.000Z", "frozen_by": "frozen_by", "locked": true, "locked_by": "locked_by", "locked_time": "2019-01-01T12:00:00.000Z"}, "workspace_status_msg": {"status_code": "status_code", "status_msg": "status_msg"}, "agent": {"id": "id", "name": "name", "assignment_policy_id": "assignment_policy_id"}, "settings": [{"name": "name", "value": "value", "use_default": false, "metadata": {"type": "boolean", "aliases": ["aliases"], "description": "description", "cloud_data_type": "cloud_data_type", "default_value": "default_value", "link_status": "normal", "secure": true, "immutable": false, "hidden": true, "required": true, "options": ["options"], "min_value": 9, "max_value": 9, "min_length": 10, "max_length": 10, "matches": "matches", "position": 8, "group_by": "group_by", "source": "source"}, "link": "link"}], "git_token_ref": "git_token_ref", "encryption": {"crn": "crn", "scheme": "scheme"}}'
        responses.add(
            responses.PATCH,
            url,
            body=mock_response,
            content_type='application/json',
            status=200,
        )

        # Construct a dict representation of a ServiceExtensions model
        service_extensions_model = {}
        service_extensions_model['name'] = 'flavor'
        service_extensions_model['value'] = 'testString'
        service_extensions_model['type'] = 'string'

        # Construct a dict representation of a CatalogRef model
        catalog_ref_model = {}
        catalog_ref_model['dry_run'] = True
        catalog_ref_model['owning_account'] = 'testString'
        catalog_ref_model['item_icon_url'] = 'testString'
        catalog_ref_model['item_id'] = 'testString'
        catalog_ref_model['item_name'] = 'testString'
        catalog_ref_model['item_readme_url'] = 'testString'
        catalog_ref_model['item_url'] = 'testString'
        catalog_ref_model['launch_url'] = 'testString'
        catalog_ref_model['offering_version'] = 'testString'
        catalog_ref_model['service_extensions'] = [service_extensions_model]

        # Construct a dict representation of a Dependencies model
        dependencies_model = {}
        dependencies_model['parents'] = ['testString']
        dependencies_model['children'] = ['testString']

        # Construct a dict representation of a SharedTargetData model
        shared_target_data_model = {}
        shared_target_data_model['cluster_created_on'] = 'testString'
        shared_target_data_model['cluster_id'] = 'testString'
        shared_target_data_model['cluster_name'] = 'testString'
        shared_target_data_model['cluster_type'] = 'testString'
        shared_target_data_model['entitlement_keys'] = [{'anyKey': 'anyValue'}]
        shared_target_data_model['namespace'] = 'testString'
        shared_target_data_model['region'] = 'testString'
        shared_target_data_model['resource_group_id'] = 'testString'
        shared_target_data_model['worker_count'] = 26
        shared_target_data_model['worker_machine_type'] = 'testString'

        # Construct a dict representation of a EnvironmentValuesMetadata model
        environment_values_metadata_model = {}
        environment_values_metadata_model['hidden'] = True
        environment_values_metadata_model['name'] = 'testString'
        environment_values_metadata_model['secure'] = True

        # Construct a dict representation of a InjectTerraformTemplateInnerTftParametersItem model
        inject_terraform_template_inner_tft_parameters_item_model = {}
        inject_terraform_template_inner_tft_parameters_item_model['name'] = 'testString'
        inject_terraform_template_inner_tft_parameters_item_model['value'] = 'testString'

        # Construct a dict representation of a InjectTerraformTemplateInner model
        inject_terraform_template_inner_model = {}
        inject_terraform_template_inner_model['tft_git_url'] = 'testString'
        inject_terraform_template_inner_model['tft_git_token'] = 'testString'
        inject_terraform_template_inner_model['tft_prefix'] = 'testString'
        inject_terraform_template_inner_model['injection_type'] = 'testString'
        inject_terraform_template_inner_model['tft_name'] = 'testString'
        inject_terraform_template_inner_model['tft_parameters'] = [
            inject_terraform_template_inner_tft_parameters_item_model
        ]

        # Construct a dict representation of a WorkspaceVariableRequest model
        workspace_variable_request_model = {}
        workspace_variable_request_model['description'] = 'testString'
        workspace_variable_request_model['name'] = 'testString'
        workspace_variable_request_model['secure'] = True
        workspace_variable_request_model['type'] = 'testString'
        workspace_variable_request_model['use_default'] = True
        workspace_variable_request_model['value'] = 'testString'

        # Construct a dict representation of a TemplateSourceDataRequest model
        template_source_data_request_model = {}
        template_source_data_request_model['env_values'] = [{'anyKey': 'anyValue'}]
        template_source_data_request_model['env_values_metadata'] = [environment_values_metadata_model]
        template_source_data_request_model['folder'] = 'testString'
        template_source_data_request_model['compact'] = True
        template_source_data_request_model['init_state_file'] = 'testString'
        template_source_data_request_model['injectors'] = [inject_terraform_template_inner_model]
        template_source_data_request_model['type'] = 'testString'
        template_source_data_request_model['uninstall_script_name'] = 'testString'
        template_source_data_request_model['values'] = 'testString'
        template_source_data_request_model['values_metadata'] = [{'anyKey': 'anyValue'}]
        template_source_data_request_model['variablestore'] = [workspace_variable_request_model]

        # Construct a dict representation of a TemplateRepoUpdateRequest model
        template_repo_update_request_model = {}
        template_repo_update_request_model['branch'] = 'testString'
        template_repo_update_request_model['release'] = 'testString'
        template_repo_update_request_model['repo_sha_value'] = 'testString'
        template_repo_update_request_model['repo_url'] = 'testString'
        template_repo_update_request_model['url'] = 'testString'
        template_repo_update_request_model['skip_submodules_checkout'] = True

        # Construct a dict representation of a WorkspaceStatusUpdateRequest model
        workspace_status_update_request_model = {}
        workspace_status_update_request_model['frozen'] = True
        workspace_status_update_request_model['frozen_at'] = '2019-01-01T12:00:00Z'
        workspace_status_update_request_model['frozen_by'] = 'testString'
        workspace_status_update_request_model['locked'] = True
        workspace_status_update_request_model['locked_by'] = 'testString'
        workspace_status_update_request_model['locked_time'] = '2019-01-01T12:00:00Z'

        # Construct a dict representation of a WorkspaceStatusMessage model
        workspace_status_message_model = {}
        workspace_status_message_model['status_code'] = 'testString'
        workspace_status_message_model['status_msg'] = 'testString'

        # Construct a dict representation of a VariableMetadata model
        variable_metadata_model = {}
        variable_metadata_model['type'] = 'boolean'
        variable_metadata_model['aliases'] = ['testString']
        variable_metadata_model['description'] = 'testString'
        variable_metadata_model['cloud_data_type'] = 'testString'
        variable_metadata_model['default_value'] = 'testString'
        variable_metadata_model['link_status'] = 'normal'
        variable_metadata_model['secure'] = True
        variable_metadata_model['immutable'] = True
        variable_metadata_model['hidden'] = True
        variable_metadata_model['required'] = True
        variable_metadata_model['options'] = ['testString']
        variable_metadata_model['min_value'] = 38
        variable_metadata_model['max_value'] = 38
        variable_metadata_model['min_length'] = 38
        variable_metadata_model['max_length'] = 38
        variable_metadata_model['matches'] = 'testString'
        variable_metadata_model['position'] = 38
        variable_metadata_model['group_by'] = 'testString'
        variable_metadata_model['source'] = 'testString'

        # Construct a dict representation of a VariableData model
        variable_data_model = {}
        variable_data_model['name'] = 'testString'
        variable_data_model['value'] = 'testString'
        variable_data_model['use_default'] = True
        variable_data_model['metadata'] = variable_metadata_model

        # Set up parameter values
        w_id = 'testString'
        catalog_ref = catalog_ref_model
        description = 'testString'
        dependencies = dependencies_model
        name = 'testString'
        shared_data = shared_target_data_model
        tags = ['testString']
        template_data = [template_source_data_request_model]
        template_repo = template_repo_update_request_model
        type = ['testString']
        workspace_status = workspace_status_update_request_model
        workspace_status_msg = workspace_status_message_model
        agent_id = 'testString'
        settings = [variable_data_model]

        # Pass in all but one required param and check for a ValueError
        req_param_dict = {
            "w_id": w_id,
        }
        for param in req_param_dict.keys():
            req_copy = {key: val if key is not param else None for (key, val) in req_param_dict.items()}
            with pytest.raises(ValueError):
                _service.update_workspace(**req_copy)

    def test_update_workspace_value_error_with_retries(self):
        # Enable retries and run test_update_workspace_value_error.
        _service.enable_retries()
        self.test_update_workspace_value_error()

        # Disable retries and run test_update_workspace_value_error.
        _service.disable_retries()
        self.test_update_workspace_value_error()


class TestGetWorkspaceReadme:
    """
    Test Class for get_workspace_readme
    """

    @responses.activate
    def test_get_workspace_readme_all_params(self):
        """
        get_workspace_readme()
        """
        # Set up mock
        url = preprocess_url('/v1/workspaces/testString/templates/readme')
        mock_response = '{"readme": "readme"}'
        responses.add(
            responses.GET,
            url,
            body=mock_response,
            content_type='application/json',
            status=200,
        )

        # Set up parameter values
        w_id = 'testString'
        ref = 'testString'
        formatted = 'markdown'

        # Invoke method
        response = _service.get_workspace_readme(
            w_id,
            ref=ref,
            formatted=formatted,
            headers={},
        )

        # Check for correct operation
        assert len(responses.calls) == 1
        assert response.status_code == 200
        # Validate query params
        query_string = responses.calls[0].request.url.split('?', 1)[1]
        query_string = urllib.parse.unquote_plus(query_string)
        assert 'ref={}'.format(ref) in query_string
        assert 'formatted={}'.format(formatted) in query_string

    def test_get_workspace_readme_all_params_with_retries(self):
        # Enable retries and run test_get_workspace_readme_all_params.
        _service.enable_retries()
        self.test_get_workspace_readme_all_params()

        # Disable retries and run test_get_workspace_readme_all_params.
        _service.disable_retries()
        self.test_get_workspace_readme_all_params()

    @responses.activate
    def test_get_workspace_readme_required_params(self):
        """
        test_get_workspace_readme_required_params()
        """
        # Set up mock
        url = preprocess_url('/v1/workspaces/testString/templates/readme')
        mock_response = '{"readme": "readme"}'
        responses.add(
            responses.GET,
            url,
            body=mock_response,
            content_type='application/json',
            status=200,
        )

        # Set up parameter values
        w_id = 'testString'

        # Invoke method
        response = _service.get_workspace_readme(
            w_id,
            headers={},
        )

        # Check for correct operation
        assert len(responses.calls) == 1
        assert response.status_code == 200

    def test_get_workspace_readme_required_params_with_retries(self):
        # Enable retries and run test_get_workspace_readme_required_params.
        _service.enable_retries()
        self.test_get_workspace_readme_required_params()

        # Disable retries and run test_get_workspace_readme_required_params.
        _service.disable_retries()
        self.test_get_workspace_readme_required_params()

    @responses.activate
    def test_get_workspace_readme_value_error(self):
        """
        test_get_workspace_readme_value_error()
        """
        # Set up mock
        url = preprocess_url('/v1/workspaces/testString/templates/readme')
        mock_response = '{"readme": "readme"}'
        responses.add(
            responses.GET,
            url,
            body=mock_response,
            content_type='application/json',
            status=200,
        )

        # Set up parameter values
        w_id = 'testString'

        # Pass in all but one required param and check for a ValueError
        req_param_dict = {
            "w_id": w_id,
        }
        for param in req_param_dict.keys():
            req_copy = {key: val if key is not param else None for (key, val) in req_param_dict.items()}
            with pytest.raises(ValueError):
                _service.get_workspace_readme(**req_copy)

    def test_get_workspace_readme_value_error_with_retries(self):
        # Enable retries and run test_get_workspace_readme_value_error.
        _service.enable_retries()
        self.test_get_workspace_readme_value_error()

        # Disable retries and run test_get_workspace_readme_value_error.
        _service.disable_retries()
        self.test_get_workspace_readme_value_error()


class TestTemplateRepoUpload:
    """
    Test Class for template_repo_upload
    """

    @responses.activate
    def test_template_repo_upload_all_params(self):
        """
        template_repo_upload()
        """
        # Set up mock
        url = preprocess_url('/v1/workspaces/testString/template_data/testString/template_repo_upload')
        mock_response = '{"file_value": "file_value", "has_received_file": false, "id": "id"}'
        responses.add(
            responses.PUT,
            url,
            body=mock_response,
            content_type='application/json',
            status=200,
        )

        # Set up parameter values
        w_id = 'testString'
        t_id = 'testString'
        file = io.BytesIO(b'This is a mock file.').getvalue()
        file_content_type = 'testString'

        # Invoke method
        response = _service.template_repo_upload(
            w_id,
            t_id,
            file=file,
            file_content_type=file_content_type,
            headers={},
        )

        # Check for correct operation
        assert len(responses.calls) == 1
        assert response.status_code == 200

    def test_template_repo_upload_all_params_with_retries(self):
        # Enable retries and run test_template_repo_upload_all_params.
        _service.enable_retries()
        self.test_template_repo_upload_all_params()

        # Disable retries and run test_template_repo_upload_all_params.
        _service.disable_retries()
        self.test_template_repo_upload_all_params()

    @responses.activate
    def test_template_repo_upload_required_params(self):
        """
        test_template_repo_upload_required_params()
        """
        # Set up mock
        url = preprocess_url('/v1/workspaces/testString/template_data/testString/template_repo_upload')
        mock_response = '{"file_value": "file_value", "has_received_file": false, "id": "id"}'
        responses.add(
            responses.PUT,
            url,
            body=mock_response,
            content_type='application/json',
            status=200,
        )

        # Set up parameter values
        w_id = 'testString'
        t_id = 'testString'

        # Invoke method
        response = _service.template_repo_upload(
            w_id,
            t_id,
            headers={},
        )

        # Check for correct operation
        assert len(responses.calls) == 1
        assert response.status_code == 200

    def test_template_repo_upload_required_params_with_retries(self):
        # Enable retries and run test_template_repo_upload_required_params.
        _service.enable_retries()
        self.test_template_repo_upload_required_params()

        # Disable retries and run test_template_repo_upload_required_params.
        _service.disable_retries()
        self.test_template_repo_upload_required_params()

    @responses.activate
    def test_template_repo_upload_value_error(self):
        """
        test_template_repo_upload_value_error()
        """
        # Set up mock
        url = preprocess_url('/v1/workspaces/testString/template_data/testString/template_repo_upload')
        mock_response = '{"file_value": "file_value", "has_received_file": false, "id": "id"}'
        responses.add(
            responses.PUT,
            url,
            body=mock_response,
            content_type='application/json',
            status=200,
        )

        # Set up parameter values
        w_id = 'testString'
        t_id = 'testString'

        # Pass in all but one required param and check for a ValueError
        req_param_dict = {
            "w_id": w_id,
            "t_id": t_id,
        }
        for param in req_param_dict.keys():
            req_copy = {key: val if key is not param else None for (key, val) in req_param_dict.items()}
            with pytest.raises(ValueError):
                _service.template_repo_upload(**req_copy)

    def test_template_repo_upload_value_error_with_retries(self):
        # Enable retries and run test_template_repo_upload_value_error.
        _service.enable_retries()
        self.test_template_repo_upload_value_error()

        # Disable retries and run test_template_repo_upload_value_error.
        _service.disable_retries()
        self.test_template_repo_upload_value_error()


class TestGetWorkspaceInputs:
    """
    Test Class for get_workspace_inputs
    """

    @responses.activate
    def test_get_workspace_inputs_all_params(self):
        """
        get_workspace_inputs()
        """
        # Set up mock
        url = preprocess_url('/v1/workspaces/testString/template_data/testString/values')
        mock_response = '{"values_metadata": [{"anyKey": "anyValue"}]}'
        responses.add(
            responses.GET,
            url,
            body=mock_response,
            content_type='application/json',
            status=200,
        )

        # Set up parameter values
        w_id = 'testString'
        t_id = 'testString'

        # Invoke method
        response = _service.get_workspace_inputs(
            w_id,
            t_id,
            headers={},
        )

        # Check for correct operation
        assert len(responses.calls) == 1
        assert response.status_code == 200

    def test_get_workspace_inputs_all_params_with_retries(self):
        # Enable retries and run test_get_workspace_inputs_all_params.
        _service.enable_retries()
        self.test_get_workspace_inputs_all_params()

        # Disable retries and run test_get_workspace_inputs_all_params.
        _service.disable_retries()
        self.test_get_workspace_inputs_all_params()

    @responses.activate
    def test_get_workspace_inputs_value_error(self):
        """
        test_get_workspace_inputs_value_error()
        """
        # Set up mock
        url = preprocess_url('/v1/workspaces/testString/template_data/testString/values')
        mock_response = '{"values_metadata": [{"anyKey": "anyValue"}]}'
        responses.add(
            responses.GET,
            url,
            body=mock_response,
            content_type='application/json',
            status=200,
        )

        # Set up parameter values
        w_id = 'testString'
        t_id = 'testString'

        # Pass in all but one required param and check for a ValueError
        req_param_dict = {
            "w_id": w_id,
            "t_id": t_id,
        }
        for param in req_param_dict.keys():
            req_copy = {key: val if key is not param else None for (key, val) in req_param_dict.items()}
            with pytest.raises(ValueError):
                _service.get_workspace_inputs(**req_copy)

    def test_get_workspace_inputs_value_error_with_retries(self):
        # Enable retries and run test_get_workspace_inputs_value_error.
        _service.enable_retries()
        self.test_get_workspace_inputs_value_error()

        # Disable retries and run test_get_workspace_inputs_value_error.
        _service.disable_retries()
        self.test_get_workspace_inputs_value_error()


class TestReplaceWorkspaceInputs:
    """
    Test Class for replace_workspace_inputs
    """

    @responses.activate
    def test_replace_workspace_inputs_all_params(self):
        """
        replace_workspace_inputs()
        """
        # Set up mock
        url = preprocess_url('/v1/workspaces/testString/template_data/testString/values')
        mock_response = '{"env_values": [{"anyKey": "anyValue"}], "env_values_map": [{"hidden": true, "name": "name", "secure": true, "value": "value"}], "values": "values", "variablestore": [{"description": "description", "name": "name", "secure": true, "type": "type", "value": "value"}]}'
        responses.add(
            responses.PUT,
            url,
            body=mock_response,
            content_type='application/json',
            status=200,
        )

        # Construct a dict representation of a WorkspaceVariableRequest model
        workspace_variable_request_model = {}
        workspace_variable_request_model['description'] = 'testString'
        workspace_variable_request_model['name'] = 'testString'
        workspace_variable_request_model['secure'] = True
        workspace_variable_request_model['type'] = 'testString'
        workspace_variable_request_model['use_default'] = True
        workspace_variable_request_model['value'] = 'testString'

        # Set up parameter values
        w_id = 'testString'
        t_id = 'testString'
        env_values = [{'anyKey': 'anyValue'}]
        values = 'testString'
        variablestore = [workspace_variable_request_model]

        # Invoke method
        response = _service.replace_workspace_inputs(
            w_id,
            t_id,
            env_values=env_values,
            values=values,
            variablestore=variablestore,
            headers={},
        )

        # Check for correct operation
        assert len(responses.calls) == 1
        assert response.status_code == 200
        # Validate body params
        req_body = json.loads(str(responses.calls[0].request.body, 'utf-8'))
        assert req_body['env_values'] == [{'anyKey': 'anyValue'}]
        assert req_body['values'] == 'testString'
        assert req_body['variablestore'] == [workspace_variable_request_model]

    def test_replace_workspace_inputs_all_params_with_retries(self):
        # Enable retries and run test_replace_workspace_inputs_all_params.
        _service.enable_retries()
        self.test_replace_workspace_inputs_all_params()

        # Disable retries and run test_replace_workspace_inputs_all_params.
        _service.disable_retries()
        self.test_replace_workspace_inputs_all_params()

    @responses.activate
    def test_replace_workspace_inputs_value_error(self):
        """
        test_replace_workspace_inputs_value_error()
        """
        # Set up mock
        url = preprocess_url('/v1/workspaces/testString/template_data/testString/values')
        mock_response = '{"env_values": [{"anyKey": "anyValue"}], "env_values_map": [{"hidden": true, "name": "name", "secure": true, "value": "value"}], "values": "values", "variablestore": [{"description": "description", "name": "name", "secure": true, "type": "type", "value": "value"}]}'
        responses.add(
            responses.PUT,
            url,
            body=mock_response,
            content_type='application/json',
            status=200,
        )

        # Construct a dict representation of a WorkspaceVariableRequest model
        workspace_variable_request_model = {}
        workspace_variable_request_model['description'] = 'testString'
        workspace_variable_request_model['name'] = 'testString'
        workspace_variable_request_model['secure'] = True
        workspace_variable_request_model['type'] = 'testString'
        workspace_variable_request_model['use_default'] = True
        workspace_variable_request_model['value'] = 'testString'

        # Set up parameter values
        w_id = 'testString'
        t_id = 'testString'
        env_values = [{'anyKey': 'anyValue'}]
        values = 'testString'
        variablestore = [workspace_variable_request_model]

        # Pass in all but one required param and check for a ValueError
        req_param_dict = {
            "w_id": w_id,
            "t_id": t_id,
        }
        for param in req_param_dict.keys():
            req_copy = {key: val if key is not param else None for (key, val) in req_param_dict.items()}
            with pytest.raises(ValueError):
                _service.replace_workspace_inputs(**req_copy)

    def test_replace_workspace_inputs_value_error_with_retries(self):
        # Enable retries and run test_replace_workspace_inputs_value_error.
        _service.enable_retries()
        self.test_replace_workspace_inputs_value_error()

        # Disable retries and run test_replace_workspace_inputs_value_error.
        _service.disable_retries()
        self.test_replace_workspace_inputs_value_error()


class TestGetAllWorkspaceInputs:
    """
    Test Class for get_all_workspace_inputs
    """

    @responses.activate
    def test_get_all_workspace_inputs_all_params(self):
        """
        get_all_workspace_inputs()
        """
        # Set up mock
        url = preprocess_url('/v1/workspaces/testString/templates/values')
        mock_response = '{"runtime_data": [{"engine_cmd": "engine_cmd", "engine_name": "engine_name", "engine_version": "engine_version", "id": "id", "log_store_url": "log_store_url", "output_values": [{"anyKey": "anyValue"}], "resources": [[{"anyKey": "anyValue"}]], "state_store_url": "state_store_url"}], "shared_data": {"cluster_created_on": "cluster_created_on", "cluster_id": "cluster_id", "cluster_name": "cluster_name", "cluster_type": "cluster_type", "entitlement_keys": [{"anyKey": "anyValue"}], "namespace": "namespace", "region": "region", "resource_group_id": "resource_group_id", "worker_count": 12, "worker_machine_type": "worker_machine_type"}, "template_data": [{"env_values": [{"hidden": true, "name": "name", "secure": true, "value": "value"}], "folder": "folder", "compact": false, "has_githubtoken": false, "id": "id", "type": "type", "uninstall_script_name": "uninstall_script_name", "values": "values", "values_metadata": [{"anyKey": "anyValue"}], "values_url": "values_url", "variablestore": [{"description": "description", "name": "name", "secure": true, "type": "type", "value": "value"}]}]}'
        responses.add(
            responses.GET,
            url,
            body=mock_response,
            content_type='application/json',
            status=200,
        )

        # Set up parameter values
        w_id = 'testString'

        # Invoke method
        response = _service.get_all_workspace_inputs(
            w_id,
            headers={},
        )

        # Check for correct operation
        assert len(responses.calls) == 1
        assert response.status_code == 200

    def test_get_all_workspace_inputs_all_params_with_retries(self):
        # Enable retries and run test_get_all_workspace_inputs_all_params.
        _service.enable_retries()
        self.test_get_all_workspace_inputs_all_params()

        # Disable retries and run test_get_all_workspace_inputs_all_params.
        _service.disable_retries()
        self.test_get_all_workspace_inputs_all_params()

    @responses.activate
    def test_get_all_workspace_inputs_value_error(self):
        """
        test_get_all_workspace_inputs_value_error()
        """
        # Set up mock
        url = preprocess_url('/v1/workspaces/testString/templates/values')
        mock_response = '{"runtime_data": [{"engine_cmd": "engine_cmd", "engine_name": "engine_name", "engine_version": "engine_version", "id": "id", "log_store_url": "log_store_url", "output_values": [{"anyKey": "anyValue"}], "resources": [[{"anyKey": "anyValue"}]], "state_store_url": "state_store_url"}], "shared_data": {"cluster_created_on": "cluster_created_on", "cluster_id": "cluster_id", "cluster_name": "cluster_name", "cluster_type": "cluster_type", "entitlement_keys": [{"anyKey": "anyValue"}], "namespace": "namespace", "region": "region", "resource_group_id": "resource_group_id", "worker_count": 12, "worker_machine_type": "worker_machine_type"}, "template_data": [{"env_values": [{"hidden": true, "name": "name", "secure": true, "value": "value"}], "folder": "folder", "compact": false, "has_githubtoken": false, "id": "id", "type": "type", "uninstall_script_name": "uninstall_script_name", "values": "values", "values_metadata": [{"anyKey": "anyValue"}], "values_url": "values_url", "variablestore": [{"description": "description", "name": "name", "secure": true, "type": "type", "value": "value"}]}]}'
        responses.add(
            responses.GET,
            url,
            body=mock_response,
            content_type='application/json',
            status=200,
        )

        # Set up parameter values
        w_id = 'testString'

        # Pass in all but one required param and check for a ValueError
        req_param_dict = {
            "w_id": w_id,
        }
        for param in req_param_dict.keys():
            req_copy = {key: val if key is not param else None for (key, val) in req_param_dict.items()}
            with pytest.raises(ValueError):
                _service.get_all_workspace_inputs(**req_copy)

    def test_get_all_workspace_inputs_value_error_with_retries(self):
        # Enable retries and run test_get_all_workspace_inputs_value_error.
        _service.enable_retries()
        self.test_get_all_workspace_inputs_value_error()

        # Disable retries and run test_get_all_workspace_inputs_value_error.
        _service.disable_retries()
        self.test_get_all_workspace_inputs_value_error()


class TestGetWorkspaceInputMetadata:
    """
    Test Class for get_workspace_input_metadata
    """

    @responses.activate
    def test_get_workspace_input_metadata_all_params(self):
        """
        get_workspace_input_metadata()
        """
        # Set up mock
        url = preprocess_url('/v1/workspaces/testString/template_data/testString/values_metadata')
        mock_response = '[{"anyKey": "anyValue"}]'
        responses.add(
            responses.GET,
            url,
            body=mock_response,
            content_type='application/json',
            status=200,
        )

        # Set up parameter values
        w_id = 'testString'
        t_id = 'testString'

        # Invoke method
        response = _service.get_workspace_input_metadata(
            w_id,
            t_id,
            headers={},
        )

        # Check for correct operation
        assert len(responses.calls) == 1
        assert response.status_code == 200

    def test_get_workspace_input_metadata_all_params_with_retries(self):
        # Enable retries and run test_get_workspace_input_metadata_all_params.
        _service.enable_retries()
        self.test_get_workspace_input_metadata_all_params()

        # Disable retries and run test_get_workspace_input_metadata_all_params.
        _service.disable_retries()
        self.test_get_workspace_input_metadata_all_params()

    @responses.activate
    def test_get_workspace_input_metadata_value_error(self):
        """
        test_get_workspace_input_metadata_value_error()
        """
        # Set up mock
        url = preprocess_url('/v1/workspaces/testString/template_data/testString/values_metadata')
        mock_response = '[{"anyKey": "anyValue"}]'
        responses.add(
            responses.GET,
            url,
            body=mock_response,
            content_type='application/json',
            status=200,
        )

        # Set up parameter values
        w_id = 'testString'
        t_id = 'testString'

        # Pass in all but one required param and check for a ValueError
        req_param_dict = {
            "w_id": w_id,
            "t_id": t_id,
        }
        for param in req_param_dict.keys():
            req_copy = {key: val if key is not param else None for (key, val) in req_param_dict.items()}
            with pytest.raises(ValueError):
                _service.get_workspace_input_metadata(**req_copy)

    def test_get_workspace_input_metadata_value_error_with_retries(self):
        # Enable retries and run test_get_workspace_input_metadata_value_error.
        _service.enable_retries()
        self.test_get_workspace_input_metadata_value_error()

        # Disable retries and run test_get_workspace_input_metadata_value_error.
        _service.disable_retries()
        self.test_get_workspace_input_metadata_value_error()


class TestGetWorkspaceOutputs:
    """
    Test Class for get_workspace_outputs
    """

    @responses.activate
    def test_get_workspace_outputs_all_params(self):
        """
        get_workspace_outputs()
        """
        # Set up mock
        url = preprocess_url('/v1/workspaces/testString/output_values')
        mock_response = (
            '[{"folder": "folder", "id": "id", "output_values": [{"anyKey": "anyValue"}], "value_type": "value_type"}]'
        )
        responses.add(
            responses.GET,
            url,
            body=mock_response,
            content_type='application/json',
            status=200,
        )

        # Set up parameter values
        w_id = 'testString'

        # Invoke method
        response = _service.get_workspace_outputs(
            w_id,
            headers={},
        )

        # Check for correct operation
        assert len(responses.calls) == 1
        assert response.status_code == 200

    def test_get_workspace_outputs_all_params_with_retries(self):
        # Enable retries and run test_get_workspace_outputs_all_params.
        _service.enable_retries()
        self.test_get_workspace_outputs_all_params()

        # Disable retries and run test_get_workspace_outputs_all_params.
        _service.disable_retries()
        self.test_get_workspace_outputs_all_params()

    @responses.activate
    def test_get_workspace_outputs_value_error(self):
        """
        test_get_workspace_outputs_value_error()
        """
        # Set up mock
        url = preprocess_url('/v1/workspaces/testString/output_values')
        mock_response = (
            '[{"folder": "folder", "id": "id", "output_values": [{"anyKey": "anyValue"}], "value_type": "value_type"}]'
        )
        responses.add(
            responses.GET,
            url,
            body=mock_response,
            content_type='application/json',
            status=200,
        )

        # Set up parameter values
        w_id = 'testString'

        # Pass in all but one required param and check for a ValueError
        req_param_dict = {
            "w_id": w_id,
        }
        for param in req_param_dict.keys():
            req_copy = {key: val if key is not param else None for (key, val) in req_param_dict.items()}
            with pytest.raises(ValueError):
                _service.get_workspace_outputs(**req_copy)

    def test_get_workspace_outputs_value_error_with_retries(self):
        # Enable retries and run test_get_workspace_outputs_value_error.
        _service.enable_retries()
        self.test_get_workspace_outputs_value_error()

        # Disable retries and run test_get_workspace_outputs_value_error.
        _service.disable_retries()
        self.test_get_workspace_outputs_value_error()


class TestGetWorkspaceResources:
    """
    Test Class for get_workspace_resources
    """

    @responses.activate
    def test_get_workspace_resources_all_params(self):
        """
        get_workspace_resources()
        """
        # Set up mock
        url = preprocess_url('/v1/workspaces/testString/resources')
        mock_response = '[{"folder": "folder", "id": "id", "generated_at": "2019-01-01T12:00:00.000Z", "null_resources": [{"anyKey": "anyValue"}], "related_resources": [{"anyKey": "anyValue"}], "resources": [{"anyKey": "anyValue"}], "resources_count": 15, "type": "type"}]'
        responses.add(
            responses.GET,
            url,
            body=mock_response,
            content_type='application/json',
            status=200,
        )

        # Set up parameter values
        w_id = 'testString'

        # Invoke method
        response = _service.get_workspace_resources(
            w_id,
            headers={},
        )

        # Check for correct operation
        assert len(responses.calls) == 1
        assert response.status_code == 200

    def test_get_workspace_resources_all_params_with_retries(self):
        # Enable retries and run test_get_workspace_resources_all_params.
        _service.enable_retries()
        self.test_get_workspace_resources_all_params()

        # Disable retries and run test_get_workspace_resources_all_params.
        _service.disable_retries()
        self.test_get_workspace_resources_all_params()

    @responses.activate
    def test_get_workspace_resources_value_error(self):
        """
        test_get_workspace_resources_value_error()
        """
        # Set up mock
        url = preprocess_url('/v1/workspaces/testString/resources')
        mock_response = '[{"folder": "folder", "id": "id", "generated_at": "2019-01-01T12:00:00.000Z", "null_resources": [{"anyKey": "anyValue"}], "related_resources": [{"anyKey": "anyValue"}], "resources": [{"anyKey": "anyValue"}], "resources_count": 15, "type": "type"}]'
        responses.add(
            responses.GET,
            url,
            body=mock_response,
            content_type='application/json',
            status=200,
        )

        # Set up parameter values
        w_id = 'testString'

        # Pass in all but one required param and check for a ValueError
        req_param_dict = {
            "w_id": w_id,
        }
        for param in req_param_dict.keys():
            req_copy = {key: val if key is not param else None for (key, val) in req_param_dict.items()}
            with pytest.raises(ValueError):
                _service.get_workspace_resources(**req_copy)

    def test_get_workspace_resources_value_error_with_retries(self):
        # Enable retries and run test_get_workspace_resources_value_error.
        _service.enable_retries()
        self.test_get_workspace_resources_value_error()

        # Disable retries and run test_get_workspace_resources_value_error.
        _service.disable_retries()
        self.test_get_workspace_resources_value_error()


class TestGetWorkspaceState:
    """
    Test Class for get_workspace_state
    """

    @responses.activate
    def test_get_workspace_state_all_params(self):
        """
        get_workspace_state()
        """
        # Set up mock
        url = preprocess_url('/v1/workspaces/testString/state_stores')
        mock_response = '{"runtime_data": [{"engine_name": "engine_name", "engine_version": "engine_version", "id": "id", "state_store_url": "state_store_url"}]}'
        responses.add(
            responses.GET,
            url,
            body=mock_response,
            content_type='application/json',
            status=200,
        )

        # Set up parameter values
        w_id = 'testString'

        # Invoke method
        response = _service.get_workspace_state(
            w_id,
            headers={},
        )

        # Check for correct operation
        assert len(responses.calls) == 1
        assert response.status_code == 200

    def test_get_workspace_state_all_params_with_retries(self):
        # Enable retries and run test_get_workspace_state_all_params.
        _service.enable_retries()
        self.test_get_workspace_state_all_params()

        # Disable retries and run test_get_workspace_state_all_params.
        _service.disable_retries()
        self.test_get_workspace_state_all_params()

    @responses.activate
    def test_get_workspace_state_value_error(self):
        """
        test_get_workspace_state_value_error()
        """
        # Set up mock
        url = preprocess_url('/v1/workspaces/testString/state_stores')
        mock_response = '{"runtime_data": [{"engine_name": "engine_name", "engine_version": "engine_version", "id": "id", "state_store_url": "state_store_url"}]}'
        responses.add(
            responses.GET,
            url,
            body=mock_response,
            content_type='application/json',
            status=200,
        )

        # Set up parameter values
        w_id = 'testString'

        # Pass in all but one required param and check for a ValueError
        req_param_dict = {
            "w_id": w_id,
        }
        for param in req_param_dict.keys():
            req_copy = {key: val if key is not param else None for (key, val) in req_param_dict.items()}
            with pytest.raises(ValueError):
                _service.get_workspace_state(**req_copy)

    def test_get_workspace_state_value_error_with_retries(self):
        # Enable retries and run test_get_workspace_state_value_error.
        _service.enable_retries()
        self.test_get_workspace_state_value_error()

        # Disable retries and run test_get_workspace_state_value_error.
        _service.disable_retries()
        self.test_get_workspace_state_value_error()


class TestGetWorkspaceTemplateState:
    """
    Test Class for get_workspace_template_state
    """

    @responses.activate
    def test_get_workspace_template_state_all_params(self):
        """
        get_workspace_template_state()
        """
        # Set up mock
        url = preprocess_url('/v1/workspaces/testString/runtime_data/testString/state_store')
        mock_response = '{"version": 7, "terraform_version": "terraform_version", "serial": 6, "lineage": "lineage", "modules": [{"anyKey": "anyValue"}]}'
        responses.add(
            responses.GET,
            url,
            body=mock_response,
            content_type='application/json',
            status=200,
        )

        # Set up parameter values
        w_id = 'testString'
        t_id = 'testString'

        # Invoke method
        response = _service.get_workspace_template_state(
            w_id,
            t_id,
            headers={},
        )

        # Check for correct operation
        assert len(responses.calls) == 1
        assert response.status_code == 200

    def test_get_workspace_template_state_all_params_with_retries(self):
        # Enable retries and run test_get_workspace_template_state_all_params.
        _service.enable_retries()
        self.test_get_workspace_template_state_all_params()

        # Disable retries and run test_get_workspace_template_state_all_params.
        _service.disable_retries()
        self.test_get_workspace_template_state_all_params()

    @responses.activate
    def test_get_workspace_template_state_value_error(self):
        """
        test_get_workspace_template_state_value_error()
        """
        # Set up mock
        url = preprocess_url('/v1/workspaces/testString/runtime_data/testString/state_store')
        mock_response = '{"version": 7, "terraform_version": "terraform_version", "serial": 6, "lineage": "lineage", "modules": [{"anyKey": "anyValue"}]}'
        responses.add(
            responses.GET,
            url,
            body=mock_response,
            content_type='application/json',
            status=200,
        )

        # Set up parameter values
        w_id = 'testString'
        t_id = 'testString'

        # Pass in all but one required param and check for a ValueError
        req_param_dict = {
            "w_id": w_id,
            "t_id": t_id,
        }
        for param in req_param_dict.keys():
            req_copy = {key: val if key is not param else None for (key, val) in req_param_dict.items()}
            with pytest.raises(ValueError):
                _service.get_workspace_template_state(**req_copy)

    def test_get_workspace_template_state_value_error_with_retries(self):
        # Enable retries and run test_get_workspace_template_state_value_error.
        _service.enable_retries()
        self.test_get_workspace_template_state_value_error()

        # Disable retries and run test_get_workspace_template_state_value_error.
        _service.disable_retries()
        self.test_get_workspace_template_state_value_error()


class TestGetWorkspaceActivityLogs:
    """
    Test Class for get_workspace_activity_logs
    """

    @responses.activate
    def test_get_workspace_activity_logs_all_params(self):
        """
        get_workspace_activity_logs()
        """
        # Set up mock
        url = preprocess_url('/v1/workspaces/testString/actions/testString/logs')
        mock_response = '{"action_id": "action_id", "name": "name", "templates": [{"log_url": "log_url", "template_id": "template_id", "template_type": "template_type"}]}'
        responses.add(
            responses.GET,
            url,
            body=mock_response,
            content_type='application/json',
            status=200,
        )

        # Set up parameter values
        w_id = 'testString'
        activity_id = 'testString'

        # Invoke method
        response = _service.get_workspace_activity_logs(
            w_id,
            activity_id,
            headers={},
        )

        # Check for correct operation
        assert len(responses.calls) == 1
        assert response.status_code == 200

    def test_get_workspace_activity_logs_all_params_with_retries(self):
        # Enable retries and run test_get_workspace_activity_logs_all_params.
        _service.enable_retries()
        self.test_get_workspace_activity_logs_all_params()

        # Disable retries and run test_get_workspace_activity_logs_all_params.
        _service.disable_retries()
        self.test_get_workspace_activity_logs_all_params()

    @responses.activate
    def test_get_workspace_activity_logs_value_error(self):
        """
        test_get_workspace_activity_logs_value_error()
        """
        # Set up mock
        url = preprocess_url('/v1/workspaces/testString/actions/testString/logs')
        mock_response = '{"action_id": "action_id", "name": "name", "templates": [{"log_url": "log_url", "template_id": "template_id", "template_type": "template_type"}]}'
        responses.add(
            responses.GET,
            url,
            body=mock_response,
            content_type='application/json',
            status=200,
        )

        # Set up parameter values
        w_id = 'testString'
        activity_id = 'testString'

        # Pass in all but one required param and check for a ValueError
        req_param_dict = {
            "w_id": w_id,
            "activity_id": activity_id,
        }
        for param in req_param_dict.keys():
            req_copy = {key: val if key is not param else None for (key, val) in req_param_dict.items()}
            with pytest.raises(ValueError):
                _service.get_workspace_activity_logs(**req_copy)

    def test_get_workspace_activity_logs_value_error_with_retries(self):
        # Enable retries and run test_get_workspace_activity_logs_value_error.
        _service.enable_retries()
        self.test_get_workspace_activity_logs_value_error()

        # Disable retries and run test_get_workspace_activity_logs_value_error.
        _service.disable_retries()
        self.test_get_workspace_activity_logs_value_error()


class TestGetWorkspaceLogUrls:
    """
    Test Class for get_workspace_log_urls
    """

    @responses.activate
    def test_get_workspace_log_urls_all_params(self):
        """
        get_workspace_log_urls()
        """
        # Set up mock
        url = preprocess_url('/v1/workspaces/testString/log_stores')
        mock_response = '{"runtime_data": [{"engine_name": "engine_name", "engine_version": "engine_version", "id": "id", "log_store_url": "log_store_url"}]}'
        responses.add(
            responses.GET,
            url,
            body=mock_response,
            content_type='application/json',
            status=200,
        )

        # Set up parameter values
        w_id = 'testString'

        # Invoke method
        response = _service.get_workspace_log_urls(
            w_id,
            headers={},
        )

        # Check for correct operation
        assert len(responses.calls) == 1
        assert response.status_code == 200

    def test_get_workspace_log_urls_all_params_with_retries(self):
        # Enable retries and run test_get_workspace_log_urls_all_params.
        _service.enable_retries()
        self.test_get_workspace_log_urls_all_params()

        # Disable retries and run test_get_workspace_log_urls_all_params.
        _service.disable_retries()
        self.test_get_workspace_log_urls_all_params()

    @responses.activate
    def test_get_workspace_log_urls_value_error(self):
        """
        test_get_workspace_log_urls_value_error()
        """
        # Set up mock
        url = preprocess_url('/v1/workspaces/testString/log_stores')
        mock_response = '{"runtime_data": [{"engine_name": "engine_name", "engine_version": "engine_version", "id": "id", "log_store_url": "log_store_url"}]}'
        responses.add(
            responses.GET,
            url,
            body=mock_response,
            content_type='application/json',
            status=200,
        )

        # Set up parameter values
        w_id = 'testString'

        # Pass in all but one required param and check for a ValueError
        req_param_dict = {
            "w_id": w_id,
        }
        for param in req_param_dict.keys():
            req_copy = {key: val if key is not param else None for (key, val) in req_param_dict.items()}
            with pytest.raises(ValueError):
                _service.get_workspace_log_urls(**req_copy)

    def test_get_workspace_log_urls_value_error_with_retries(self):
        # Enable retries and run test_get_workspace_log_urls_value_error.
        _service.enable_retries()
        self.test_get_workspace_log_urls_value_error()

        # Disable retries and run test_get_workspace_log_urls_value_error.
        _service.disable_retries()
        self.test_get_workspace_log_urls_value_error()


class TestGetTemplateLogs:
    """
    Test Class for get_template_logs
    """

    @responses.activate
    def test_get_template_logs_all_params(self):
        """
        get_template_logs()
        """
        # Set up mock
        url = preprocess_url('/v1/workspaces/testString/runtime_data/testString/log_store')
        mock_response = '"operation_response"'
        responses.add(
            responses.GET,
            url,
            body=mock_response,
            content_type='application/json',
            status=200,
        )

        # Set up parameter values
        w_id = 'testString'
        t_id = 'testString'
        log_tf_cmd = True
        log_tf_prefix = True
        log_tf_null_resource = True
        log_tf_ansible = True

        # Invoke method
        response = _service.get_template_logs(
            w_id,
            t_id,
            log_tf_cmd=log_tf_cmd,
            log_tf_prefix=log_tf_prefix,
            log_tf_null_resource=log_tf_null_resource,
            log_tf_ansible=log_tf_ansible,
            headers={},
        )

        # Check for correct operation
        assert len(responses.calls) == 1
        assert response.status_code == 200
        # Validate query params
        query_string = responses.calls[0].request.url.split('?', 1)[1]
        query_string = urllib.parse.unquote_plus(query_string)
        assert 'log_tf_cmd={}'.format('true' if log_tf_cmd else 'false') in query_string
        assert 'log_tf_prefix={}'.format('true' if log_tf_prefix else 'false') in query_string
        assert 'log_tf_null_resource={}'.format('true' if log_tf_null_resource else 'false') in query_string
        assert 'log_tf_ansible={}'.format('true' if log_tf_ansible else 'false') in query_string

    def test_get_template_logs_all_params_with_retries(self):
        # Enable retries and run test_get_template_logs_all_params.
        _service.enable_retries()
        self.test_get_template_logs_all_params()

        # Disable retries and run test_get_template_logs_all_params.
        _service.disable_retries()
        self.test_get_template_logs_all_params()

    @responses.activate
    def test_get_template_logs_required_params(self):
        """
        test_get_template_logs_required_params()
        """
        # Set up mock
        url = preprocess_url('/v1/workspaces/testString/runtime_data/testString/log_store')
        mock_response = '"operation_response"'
        responses.add(
            responses.GET,
            url,
            body=mock_response,
            content_type='application/json',
            status=200,
        )

        # Set up parameter values
        w_id = 'testString'
        t_id = 'testString'

        # Invoke method
        response = _service.get_template_logs(
            w_id,
            t_id,
            headers={},
        )

        # Check for correct operation
        assert len(responses.calls) == 1
        assert response.status_code == 200

    def test_get_template_logs_required_params_with_retries(self):
        # Enable retries and run test_get_template_logs_required_params.
        _service.enable_retries()
        self.test_get_template_logs_required_params()

        # Disable retries and run test_get_template_logs_required_params.
        _service.disable_retries()
        self.test_get_template_logs_required_params()

    @responses.activate
    def test_get_template_logs_value_error(self):
        """
        test_get_template_logs_value_error()
        """
        # Set up mock
        url = preprocess_url('/v1/workspaces/testString/runtime_data/testString/log_store')
        mock_response = '"operation_response"'
        responses.add(
            responses.GET,
            url,
            body=mock_response,
            content_type='application/json',
            status=200,
        )

        # Set up parameter values
        w_id = 'testString'
        t_id = 'testString'

        # Pass in all but one required param and check for a ValueError
        req_param_dict = {
            "w_id": w_id,
            "t_id": t_id,
        }
        for param in req_param_dict.keys():
            req_copy = {key: val if key is not param else None for (key, val) in req_param_dict.items()}
            with pytest.raises(ValueError):
                _service.get_template_logs(**req_copy)

    def test_get_template_logs_value_error_with_retries(self):
        # Enable retries and run test_get_template_logs_value_error.
        _service.enable_retries()
        self.test_get_template_logs_value_error()

        # Disable retries and run test_get_template_logs_value_error.
        _service.disable_retries()
        self.test_get_template_logs_value_error()


class TestGetTemplateActivityLog:
    """
    Test Class for get_template_activity_log
    """

    @responses.activate
    def test_get_template_activity_log_all_params(self):
        """
        get_template_activity_log()
        """
        # Set up mock
        url = preprocess_url('/v1/workspaces/testString/runtime_data/testString/log_store/actions/testString')
        mock_response = '"operation_response"'
        responses.add(
            responses.GET,
            url,
            body=mock_response,
            content_type='application/json',
            status=200,
        )

        # Set up parameter values
        w_id = 'testString'
        t_id = 'testString'
        activity_id = 'testString'
        log_tf_cmd = True
        log_tf_prefix = True
        log_tf_null_resource = True
        log_tf_ansible = True

        # Invoke method
        response = _service.get_template_activity_log(
            w_id,
            t_id,
            activity_id,
            log_tf_cmd=log_tf_cmd,
            log_tf_prefix=log_tf_prefix,
            log_tf_null_resource=log_tf_null_resource,
            log_tf_ansible=log_tf_ansible,
            headers={},
        )

        # Check for correct operation
        assert len(responses.calls) == 1
        assert response.status_code == 200
        # Validate query params
        query_string = responses.calls[0].request.url.split('?', 1)[1]
        query_string = urllib.parse.unquote_plus(query_string)
        assert 'log_tf_cmd={}'.format('true' if log_tf_cmd else 'false') in query_string
        assert 'log_tf_prefix={}'.format('true' if log_tf_prefix else 'false') in query_string
        assert 'log_tf_null_resource={}'.format('true' if log_tf_null_resource else 'false') in query_string
        assert 'log_tf_ansible={}'.format('true' if log_tf_ansible else 'false') in query_string

    def test_get_template_activity_log_all_params_with_retries(self):
        # Enable retries and run test_get_template_activity_log_all_params.
        _service.enable_retries()
        self.test_get_template_activity_log_all_params()

        # Disable retries and run test_get_template_activity_log_all_params.
        _service.disable_retries()
        self.test_get_template_activity_log_all_params()

    @responses.activate
    def test_get_template_activity_log_required_params(self):
        """
        test_get_template_activity_log_required_params()
        """
        # Set up mock
        url = preprocess_url('/v1/workspaces/testString/runtime_data/testString/log_store/actions/testString')
        mock_response = '"operation_response"'
        responses.add(
            responses.GET,
            url,
            body=mock_response,
            content_type='application/json',
            status=200,
        )

        # Set up parameter values
        w_id = 'testString'
        t_id = 'testString'
        activity_id = 'testString'

        # Invoke method
        response = _service.get_template_activity_log(
            w_id,
            t_id,
            activity_id,
            headers={},
        )

        # Check for correct operation
        assert len(responses.calls) == 1
        assert response.status_code == 200

    def test_get_template_activity_log_required_params_with_retries(self):
        # Enable retries and run test_get_template_activity_log_required_params.
        _service.enable_retries()
        self.test_get_template_activity_log_required_params()

        # Disable retries and run test_get_template_activity_log_required_params.
        _service.disable_retries()
        self.test_get_template_activity_log_required_params()

    @responses.activate
    def test_get_template_activity_log_value_error(self):
        """
        test_get_template_activity_log_value_error()
        """
        # Set up mock
        url = preprocess_url('/v1/workspaces/testString/runtime_data/testString/log_store/actions/testString')
        mock_response = '"operation_response"'
        responses.add(
            responses.GET,
            url,
            body=mock_response,
            content_type='application/json',
            status=200,
        )

        # Set up parameter values
        w_id = 'testString'
        t_id = 'testString'
        activity_id = 'testString'

        # Pass in all but one required param and check for a ValueError
        req_param_dict = {
            "w_id": w_id,
            "t_id": t_id,
            "activity_id": activity_id,
        }
        for param in req_param_dict.keys():
            req_copy = {key: val if key is not param else None for (key, val) in req_param_dict.items()}
            with pytest.raises(ValueError):
                _service.get_template_activity_log(**req_copy)

    def test_get_template_activity_log_value_error_with_retries(self):
        # Enable retries and run test_get_template_activity_log_value_error.
        _service.enable_retries()
        self.test_get_template_activity_log_value_error()

        # Disable retries and run test_get_template_activity_log_value_error.
        _service.disable_retries()
        self.test_get_template_activity_log_value_error()


# endregion
##############################################################################
# End of Service: Workspaces
##############################################################################

##############################################################################
# Start of Service: Actions
##############################################################################
# region


class TestNewInstance:
    """
    Test Class for new_instance
    """

    def test_new_instance(self):
        """
        new_instance()
        """
        os.environ['TEST_SERVICE_AUTH_TYPE'] = 'noAuth'

        service = SchematicsV1.new_instance(
            service_name='TEST_SERVICE',
        )

        assert service is not None
        assert isinstance(service, SchematicsV1)

    def test_new_instance_without_authenticator(self):
        """
        new_instance_without_authenticator()
        """
        with pytest.raises(ValueError, match='authenticator must be provided'):
            service = SchematicsV1.new_instance(
                service_name='TEST_SERVICE_NOT_FOUND',
            )


class TestListActions:
    """
    Test Class for list_actions
    """

    @responses.activate
    def test_list_actions_all_params(self):
        """
        list_actions()
        """
        # Set up mock
        url = preprocess_url('/v2/actions')
        mock_response = '{"total_count": 11, "limit": 5, "offset": 6, "actions": [{"name": "Stop Action", "description": "This Action can be used to Stop the targets", "id": "id", "crn": "crn", "location": "us-south", "resource_group": "resource_group", "namespace": "namespace", "tags": ["tags"], "playbook_name": "playbook_name", "user_state": {"state": "draft", "set_by": "set_by", "set_at": "2019-01-01T12:00:00.000Z"}, "state": {"status_code": "normal", "status_message": "status_message"}, "sys_lock": {"sys_locked": true, "sys_locked_by": "sys_locked_by", "sys_locked_at": "2019-01-01T12:00:00.000Z"}, "created_at": "2019-01-01T12:00:00.000Z", "created_by": "created_by", "updated_at": "2019-01-01T12:00:00.000Z", "updated_by": "updated_by", "agent": {"id": "id", "name": "name", "assignment_policy_id": "assignment_policy_id"}, "encryption": {"crn": "crn", "scheme": "scheme"}}]}'
        responses.add(
            responses.GET,
            url,
            body=mock_response,
            content_type='application/json',
            status=200,
        )

        # Set up parameter values
        offset = 0
        limit = 100
        sort = 'testString'
        profile = 'ids'

        # Invoke method
        response = _service.list_actions(
            offset=offset,
            limit=limit,
            sort=sort,
            profile=profile,
            headers={},
        )

        # Check for correct operation
        assert len(responses.calls) == 1
        assert response.status_code == 200
        # Validate query params
        query_string = responses.calls[0].request.url.split('?', 1)[1]
        query_string = urllib.parse.unquote_plus(query_string)
        assert 'offset={}'.format(offset) in query_string
        assert 'limit={}'.format(limit) in query_string
        assert 'sort={}'.format(sort) in query_string
        assert 'profile={}'.format(profile) in query_string

    def test_list_actions_all_params_with_retries(self):
        # Enable retries and run test_list_actions_all_params.
        _service.enable_retries()
        self.test_list_actions_all_params()

        # Disable retries and run test_list_actions_all_params.
        _service.disable_retries()
        self.test_list_actions_all_params()

    @responses.activate
    def test_list_actions_required_params(self):
        """
        test_list_actions_required_params()
        """
        # Set up mock
        url = preprocess_url('/v2/actions')
        mock_response = '{"total_count": 11, "limit": 5, "offset": 6, "actions": [{"name": "Stop Action", "description": "This Action can be used to Stop the targets", "id": "id", "crn": "crn", "location": "us-south", "resource_group": "resource_group", "namespace": "namespace", "tags": ["tags"], "playbook_name": "playbook_name", "user_state": {"state": "draft", "set_by": "set_by", "set_at": "2019-01-01T12:00:00.000Z"}, "state": {"status_code": "normal", "status_message": "status_message"}, "sys_lock": {"sys_locked": true, "sys_locked_by": "sys_locked_by", "sys_locked_at": "2019-01-01T12:00:00.000Z"}, "created_at": "2019-01-01T12:00:00.000Z", "created_by": "created_by", "updated_at": "2019-01-01T12:00:00.000Z", "updated_by": "updated_by", "agent": {"id": "id", "name": "name", "assignment_policy_id": "assignment_policy_id"}, "encryption": {"crn": "crn", "scheme": "scheme"}}]}'
        responses.add(
            responses.GET,
            url,
            body=mock_response,
            content_type='application/json',
            status=200,
        )

        # Invoke method
        response = _service.list_actions()

        # Check for correct operation
        assert len(responses.calls) == 1
        assert response.status_code == 200

    def test_list_actions_required_params_with_retries(self):
        # Enable retries and run test_list_actions_required_params.
        _service.enable_retries()
        self.test_list_actions_required_params()

        # Disable retries and run test_list_actions_required_params.
        _service.disable_retries()
        self.test_list_actions_required_params()


class TestCreateAction:
    """
    Test Class for create_action
    """

    @responses.activate
    def test_create_action_all_params(self):
        """
        create_action()
        """
        # Set up mock
        url = preprocess_url('/v2/actions')
        mock_response = '{"name": "Stop Action", "description": "The description of your action. The description can be up to 2048 characters long in size. **Example** you can use the description to stop the targets.", "location": "us-south", "resource_group": "resource_group", "bastion_connection_type": "ssh", "inventory_connection_type": "ssh", "tags": ["tags"], "user_state": {"state": "draft", "set_by": "set_by", "set_at": "2019-01-01T12:00:00.000Z"}, "source_readme_url": "source_readme_url", "source": {"source_type": "local", "git": {"computed_git_repo_url": "computed_git_repo_url", "git_repo_url": "git_repo_url", "git_token": "git_token", "git_repo_folder": "git_repo_folder", "git_release": "git_release", "git_branch": "git_branch", "git_commit": "git_commit", "git_commit_timestamp": "git_commit_timestamp"}, "catalog": {"catalog_name": "catalog_name", "catalog_id": "catalog_id", "offering_name": "offering_name", "offering_version": "offering_version", "offering_kind": "offering_kind", "offering_target_kind": "offering_target_kind", "offering_id": "offering_id", "offering_version_id": "offering_version_id", "offering_version_flavour_name": "offering_version_flavour_name", "offering_repo_url": "offering_repo_url", "offering_provisioner_working_directory": "offering_provisioner_working_directory", "dry_run": false, "owning_account": "owning_account", "item_icon_url": "item_icon_url", "item_id": "item_id", "item_name": "item_name", "item_readme_url": "item_readme_url", "item_url": "item_url", "launch_url": "launch_url"}}, "source_type": "local", "command_parameter": "command_parameter", "inventory": "inventory", "credentials": [{"name": "name", "value": "-----BEGIN OPENSSH PRIVATE KEY-----\nXXXXXXXXXXXXX\n-----END OPENSSH PRIVATE KEY-----\n", "use_default": false, "metadata": {"type": "string", "aliases": ["aliases"], "description": "description", "cloud_data_type": "cloud_data_type", "default_value": "default_value", "link_status": "normal", "immutable": false, "hidden": true, "required": true, "position": 8, "group_by": "group_by", "source": "source"}, "link": "link"}], "bastion": {"name": "name", "host": "host"}, "bastion_credential": {"name": "name", "value": "-----BEGIN OPENSSH PRIVATE KEY-----\nXXXXXXXXXXXXX\n-----END OPENSSH PRIVATE KEY-----\n", "use_default": false, "metadata": {"type": "string", "aliases": ["aliases"], "description": "description", "cloud_data_type": "cloud_data_type", "default_value": "default_value", "link_status": "normal", "immutable": false, "hidden": true, "required": true, "position": 8, "group_by": "group_by", "source": "source"}, "link": "link"}, "targets_ini": "targets_ini", "inputs": [{"name": "name", "value": "value", "use_default": false, "metadata": {"type": "boolean", "aliases": ["aliases"], "description": "description", "cloud_data_type": "cloud_data_type", "default_value": "default_value", "link_status": "normal", "secure": true, "immutable": false, "hidden": true, "required": true, "options": ["options"], "min_value": 9, "max_value": 9, "min_length": 10, "max_length": 10, "matches": "matches", "position": 8, "group_by": "group_by", "source": "source"}, "link": "link"}], "outputs": [{"name": "name", "value": "value", "use_default": false, "metadata": {"type": "boolean", "aliases": ["aliases"], "description": "description", "cloud_data_type": "cloud_data_type", "default_value": "default_value", "link_status": "normal", "secure": true, "immutable": false, "hidden": true, "required": true, "options": ["options"], "min_value": 9, "max_value": 9, "min_length": 10, "max_length": 10, "matches": "matches", "position": 8, "group_by": "group_by", "source": "source"}, "link": "link"}], "settings": [{"name": "name", "value": "value", "use_default": false, "metadata": {"type": "boolean", "aliases": ["aliases"], "description": "description", "cloud_data_type": "cloud_data_type", "default_value": "default_value", "link_status": "normal", "secure": true, "immutable": false, "hidden": true, "required": true, "options": ["options"], "min_value": 9, "max_value": 9, "min_length": 10, "max_length": 10, "matches": "matches", "position": 8, "group_by": "group_by", "source": "source"}, "link": "link"}], "id": "id", "crn": "crn", "account": "account", "source_created_at": "2019-01-01T12:00:00.000Z", "source_created_by": "source_created_by", "source_updated_at": "2019-01-01T12:00:00.000Z", "source_updated_by": "source_updated_by", "created_at": "2019-01-01T12:00:00.000Z", "created_by": "created_by", "updated_at": "2019-01-01T12:00:00.000Z", "updated_by": "updated_by", "state": {"status_code": "normal", "status_job_id": "status_job_id", "status_message": "status_message"}, "playbook_names": ["playbook_names"], "sys_lock": {"sys_locked": true, "sys_locked_by": "sys_locked_by", "sys_locked_at": "2019-01-01T12:00:00.000Z"}, "git_token_ref": "git_token_ref", "encryption": {"crn": "crn", "scheme": "scheme"}}'
        responses.add(
            responses.POST,
            url,
            body=mock_response,
            content_type='application/json',
            status=201,
        )

        # Construct a dict representation of a UserState model
        user_state_model = {}
        user_state_model['state'] = 'draft'
        user_state_model['set_by'] = 'testString'
        user_state_model['set_at'] = '2019-01-01T12:00:00Z'

        # Construct a dict representation of a GitSource model
        git_source_model = {}
        git_source_model['computed_git_repo_url'] = 'testString'
        git_source_model['git_repo_url'] = 'testString'
        git_source_model['git_token'] = 'testString'
        git_source_model['git_repo_folder'] = 'testString'
        git_source_model['git_release'] = 'testString'
        git_source_model['git_branch'] = 'testString'

        # Construct a dict representation of a CatalogSource model
        catalog_source_model = {}
        catalog_source_model['catalog_name'] = 'testString'
        catalog_source_model['catalog_id'] = 'testString'
        catalog_source_model['offering_name'] = 'testString'
        catalog_source_model['offering_version'] = 'testString'
        catalog_source_model['offering_kind'] = 'testString'
        catalog_source_model['offering_target_kind'] = 'testString'
        catalog_source_model['offering_id'] = 'testString'
        catalog_source_model['offering_version_id'] = 'testString'
        catalog_source_model['offering_version_flavour_name'] = 'testString'
        catalog_source_model['offering_repo_url'] = 'testString'
        catalog_source_model['offering_provisioner_working_directory'] = 'testString'
        catalog_source_model['dry_run'] = True
        catalog_source_model['owning_account'] = 'testString'
        catalog_source_model['item_icon_url'] = 'testString'
        catalog_source_model['item_id'] = 'testString'
        catalog_source_model['item_name'] = 'testString'
        catalog_source_model['item_readme_url'] = 'testString'
        catalog_source_model['item_url'] = 'testString'
        catalog_source_model['launch_url'] = 'testString'

        # Construct a dict representation of a ExternalSource model
        external_source_model = {}
        external_source_model['source_type'] = 'local'
        external_source_model['git'] = git_source_model
        external_source_model['catalog'] = catalog_source_model

        # Construct a dict representation of a CredentialVariableMetadata model
        credential_variable_metadata_model = {}
        credential_variable_metadata_model['type'] = 'string'
        credential_variable_metadata_model['aliases'] = ['testString']
        credential_variable_metadata_model['description'] = 'testString'
        credential_variable_metadata_model['cloud_data_type'] = 'testString'
        credential_variable_metadata_model['default_value'] = 'testString'
        credential_variable_metadata_model['link_status'] = 'normal'
        credential_variable_metadata_model['immutable'] = True
        credential_variable_metadata_model['hidden'] = True
        credential_variable_metadata_model['required'] = True
        credential_variable_metadata_model['position'] = 38
        credential_variable_metadata_model['group_by'] = 'testString'
        credential_variable_metadata_model['source'] = 'testString'

        # Construct a dict representation of a CredentialVariableData model
        credential_variable_data_model = {}
        credential_variable_data_model['name'] = 'testString'
        credential_variable_data_model['value'] = (
            '-----BEGIN OPENSSH PRIVATE KEY-----\\nXXXXXXXXXXXXX\\n-----END OPENSSH PRIVATE KEY-----\\n'
        )
        credential_variable_data_model['use_default'] = True
        credential_variable_data_model['metadata'] = credential_variable_metadata_model

        # Construct a dict representation of a BastionResourceDefinition model
        bastion_resource_definition_model = {}
        bastion_resource_definition_model['name'] = 'testString'
        bastion_resource_definition_model['host'] = 'testString'

        # Construct a dict representation of a VariableMetadata model
        variable_metadata_model = {}
        variable_metadata_model['type'] = 'boolean'
        variable_metadata_model['aliases'] = ['testString']
        variable_metadata_model['description'] = 'testString'
        variable_metadata_model['cloud_data_type'] = 'testString'
        variable_metadata_model['default_value'] = 'testString'
        variable_metadata_model['link_status'] = 'normal'
        variable_metadata_model['secure'] = True
        variable_metadata_model['immutable'] = True
        variable_metadata_model['hidden'] = True
        variable_metadata_model['required'] = True
        variable_metadata_model['options'] = ['testString']
        variable_metadata_model['min_value'] = 38
        variable_metadata_model['max_value'] = 38
        variable_metadata_model['min_length'] = 38
        variable_metadata_model['max_length'] = 38
        variable_metadata_model['matches'] = 'testString'
        variable_metadata_model['position'] = 38
        variable_metadata_model['group_by'] = 'testString'
        variable_metadata_model['source'] = 'testString'

        # Construct a dict representation of a VariableData model
        variable_data_model = {}
        variable_data_model['name'] = 'testString'
        variable_data_model['value'] = 'testString'
        variable_data_model['use_default'] = True
        variable_data_model['metadata'] = variable_metadata_model

        # Set up parameter values
        name = 'Stop Action'
        description = 'The description of your action. The description can be up to 2048 characters long in size. **Example** you can use the description to stop the targets.'
        location = 'us-south'
        resource_group = 'testString'
        bastion_connection_type = 'ssh'
        inventory_connection_type = 'ssh'
        tags = ['testString']
        user_state = user_state_model
        source_readme_url = 'testString'
        source = external_source_model
        source_type = 'local'
        command_parameter = 'testString'
        inventory = 'testString'
        credentials = [credential_variable_data_model]
        bastion = bastion_resource_definition_model
        bastion_credential = credential_variable_data_model
        targets_ini = 'testString'
        inputs = [variable_data_model]
        outputs = [variable_data_model]
        settings = [variable_data_model]
        x_github_token = 'testString'

        # Invoke method
        response = _service.create_action(
            name=name,
            description=description,
            location=location,
            resource_group=resource_group,
            bastion_connection_type=bastion_connection_type,
            inventory_connection_type=inventory_connection_type,
            tags=tags,
            user_state=user_state,
            source_readme_url=source_readme_url,
            source=source,
            source_type=source_type,
            command_parameter=command_parameter,
            inventory=inventory,
            credentials=credentials,
            bastion=bastion,
            bastion_credential=bastion_credential,
            targets_ini=targets_ini,
            inputs=inputs,
            outputs=outputs,
            settings=settings,
            x_github_token=x_github_token,
            headers={},
        )

        # Check for correct operation
        assert len(responses.calls) == 1
        assert response.status_code == 201
        # Validate body params
        req_body = json.loads(str(responses.calls[0].request.body, 'utf-8'))
        assert req_body['name'] == 'Stop Action'
        assert (
            req_body['description']
            == 'The description of your action. The description can be up to 2048 characters long in size. **Example** you can use the description to stop the targets.'
        )
        assert req_body['location'] == 'us-south'
        assert req_body['resource_group'] == 'testString'
        assert req_body['bastion_connection_type'] == 'ssh'
        assert req_body['inventory_connection_type'] == 'ssh'
        assert req_body['tags'] == ['testString']
        assert req_body['user_state'] == user_state_model
        assert req_body['source_readme_url'] == 'testString'
        assert req_body['source'] == external_source_model
        assert req_body['source_type'] == 'local'
        assert req_body['command_parameter'] == 'testString'
        assert req_body['inventory'] == 'testString'
        assert req_body['credentials'] == [credential_variable_data_model]
        assert req_body['bastion'] == bastion_resource_definition_model
        assert req_body['bastion_credential'] == credential_variable_data_model
        assert req_body['targets_ini'] == 'testString'
        assert req_body['inputs'] == [variable_data_model]
        assert req_body['outputs'] == [variable_data_model]
        assert req_body['settings'] == [variable_data_model]

    def test_create_action_all_params_with_retries(self):
        # Enable retries and run test_create_action_all_params.
        _service.enable_retries()
        self.test_create_action_all_params()

        # Disable retries and run test_create_action_all_params.
        _service.disable_retries()
        self.test_create_action_all_params()

    @responses.activate
    def test_create_action_required_params(self):
        """
        test_create_action_required_params()
        """
        # Set up mock
        url = preprocess_url('/v2/actions')
        mock_response = '{"name": "Stop Action", "description": "The description of your action. The description can be up to 2048 characters long in size. **Example** you can use the description to stop the targets.", "location": "us-south", "resource_group": "resource_group", "bastion_connection_type": "ssh", "inventory_connection_type": "ssh", "tags": ["tags"], "user_state": {"state": "draft", "set_by": "set_by", "set_at": "2019-01-01T12:00:00.000Z"}, "source_readme_url": "source_readme_url", "source": {"source_type": "local", "git": {"computed_git_repo_url": "computed_git_repo_url", "git_repo_url": "git_repo_url", "git_token": "git_token", "git_repo_folder": "git_repo_folder", "git_release": "git_release", "git_branch": "git_branch", "git_commit": "git_commit", "git_commit_timestamp": "git_commit_timestamp"}, "catalog": {"catalog_name": "catalog_name", "catalog_id": "catalog_id", "offering_name": "offering_name", "offering_version": "offering_version", "offering_kind": "offering_kind", "offering_target_kind": "offering_target_kind", "offering_id": "offering_id", "offering_version_id": "offering_version_id", "offering_version_flavour_name": "offering_version_flavour_name", "offering_repo_url": "offering_repo_url", "offering_provisioner_working_directory": "offering_provisioner_working_directory", "dry_run": false, "owning_account": "owning_account", "item_icon_url": "item_icon_url", "item_id": "item_id", "item_name": "item_name", "item_readme_url": "item_readme_url", "item_url": "item_url", "launch_url": "launch_url"}}, "source_type": "local", "command_parameter": "command_parameter", "inventory": "inventory", "credentials": [{"name": "name", "value": "-----BEGIN OPENSSH PRIVATE KEY-----\nXXXXXXXXXXXXX\n-----END OPENSSH PRIVATE KEY-----\n", "use_default": false, "metadata": {"type": "string", "aliases": ["aliases"], "description": "description", "cloud_data_type": "cloud_data_type", "default_value": "default_value", "link_status": "normal", "immutable": false, "hidden": true, "required": true, "position": 8, "group_by": "group_by", "source": "source"}, "link": "link"}], "bastion": {"name": "name", "host": "host"}, "bastion_credential": {"name": "name", "value": "-----BEGIN OPENSSH PRIVATE KEY-----\nXXXXXXXXXXXXX\n-----END OPENSSH PRIVATE KEY-----\n", "use_default": false, "metadata": {"type": "string", "aliases": ["aliases"], "description": "description", "cloud_data_type": "cloud_data_type", "default_value": "default_value", "link_status": "normal", "immutable": false, "hidden": true, "required": true, "position": 8, "group_by": "group_by", "source": "source"}, "link": "link"}, "targets_ini": "targets_ini", "inputs": [{"name": "name", "value": "value", "use_default": false, "metadata": {"type": "boolean", "aliases": ["aliases"], "description": "description", "cloud_data_type": "cloud_data_type", "default_value": "default_value", "link_status": "normal", "secure": true, "immutable": false, "hidden": true, "required": true, "options": ["options"], "min_value": 9, "max_value": 9, "min_length": 10, "max_length": 10, "matches": "matches", "position": 8, "group_by": "group_by", "source": "source"}, "link": "link"}], "outputs": [{"name": "name", "value": "value", "use_default": false, "metadata": {"type": "boolean", "aliases": ["aliases"], "description": "description", "cloud_data_type": "cloud_data_type", "default_value": "default_value", "link_status": "normal", "secure": true, "immutable": false, "hidden": true, "required": true, "options": ["options"], "min_value": 9, "max_value": 9, "min_length": 10, "max_length": 10, "matches": "matches", "position": 8, "group_by": "group_by", "source": "source"}, "link": "link"}], "settings": [{"name": "name", "value": "value", "use_default": false, "metadata": {"type": "boolean", "aliases": ["aliases"], "description": "description", "cloud_data_type": "cloud_data_type", "default_value": "default_value", "link_status": "normal", "secure": true, "immutable": false, "hidden": true, "required": true, "options": ["options"], "min_value": 9, "max_value": 9, "min_length": 10, "max_length": 10, "matches": "matches", "position": 8, "group_by": "group_by", "source": "source"}, "link": "link"}], "id": "id", "crn": "crn", "account": "account", "source_created_at": "2019-01-01T12:00:00.000Z", "source_created_by": "source_created_by", "source_updated_at": "2019-01-01T12:00:00.000Z", "source_updated_by": "source_updated_by", "created_at": "2019-01-01T12:00:00.000Z", "created_by": "created_by", "updated_at": "2019-01-01T12:00:00.000Z", "updated_by": "updated_by", "state": {"status_code": "normal", "status_job_id": "status_job_id", "status_message": "status_message"}, "playbook_names": ["playbook_names"], "sys_lock": {"sys_locked": true, "sys_locked_by": "sys_locked_by", "sys_locked_at": "2019-01-01T12:00:00.000Z"}, "git_token_ref": "git_token_ref", "encryption": {"crn": "crn", "scheme": "scheme"}}'
        responses.add(
            responses.POST,
            url,
            body=mock_response,
            content_type='application/json',
            status=201,
        )

        # Construct a dict representation of a UserState model
        user_state_model = {}
        user_state_model['state'] = 'draft'
        user_state_model['set_by'] = 'testString'
        user_state_model['set_at'] = '2019-01-01T12:00:00Z'

        # Construct a dict representation of a GitSource model
        git_source_model = {}
        git_source_model['computed_git_repo_url'] = 'testString'
        git_source_model['git_repo_url'] = 'testString'
        git_source_model['git_token'] = 'testString'
        git_source_model['git_repo_folder'] = 'testString'
        git_source_model['git_release'] = 'testString'
        git_source_model['git_branch'] = 'testString'

        # Construct a dict representation of a CatalogSource model
        catalog_source_model = {}
        catalog_source_model['catalog_name'] = 'testString'
        catalog_source_model['catalog_id'] = 'testString'
        catalog_source_model['offering_name'] = 'testString'
        catalog_source_model['offering_version'] = 'testString'
        catalog_source_model['offering_kind'] = 'testString'
        catalog_source_model['offering_target_kind'] = 'testString'
        catalog_source_model['offering_id'] = 'testString'
        catalog_source_model['offering_version_id'] = 'testString'
        catalog_source_model['offering_version_flavour_name'] = 'testString'
        catalog_source_model['offering_repo_url'] = 'testString'
        catalog_source_model['offering_provisioner_working_directory'] = 'testString'
        catalog_source_model['dry_run'] = True
        catalog_source_model['owning_account'] = 'testString'
        catalog_source_model['item_icon_url'] = 'testString'
        catalog_source_model['item_id'] = 'testString'
        catalog_source_model['item_name'] = 'testString'
        catalog_source_model['item_readme_url'] = 'testString'
        catalog_source_model['item_url'] = 'testString'
        catalog_source_model['launch_url'] = 'testString'

        # Construct a dict representation of a ExternalSource model
        external_source_model = {}
        external_source_model['source_type'] = 'local'
        external_source_model['git'] = git_source_model
        external_source_model['catalog'] = catalog_source_model

        # Construct a dict representation of a CredentialVariableMetadata model
        credential_variable_metadata_model = {}
        credential_variable_metadata_model['type'] = 'string'
        credential_variable_metadata_model['aliases'] = ['testString']
        credential_variable_metadata_model['description'] = 'testString'
        credential_variable_metadata_model['cloud_data_type'] = 'testString'
        credential_variable_metadata_model['default_value'] = 'testString'
        credential_variable_metadata_model['link_status'] = 'normal'
        credential_variable_metadata_model['immutable'] = True
        credential_variable_metadata_model['hidden'] = True
        credential_variable_metadata_model['required'] = True
        credential_variable_metadata_model['position'] = 38
        credential_variable_metadata_model['group_by'] = 'testString'
        credential_variable_metadata_model['source'] = 'testString'

        # Construct a dict representation of a CredentialVariableData model
        credential_variable_data_model = {}
        credential_variable_data_model['name'] = 'testString'
        credential_variable_data_model['value'] = (
            '-----BEGIN OPENSSH PRIVATE KEY-----\\nXXXXXXXXXXXXX\\n-----END OPENSSH PRIVATE KEY-----\\n'
        )
        credential_variable_data_model['use_default'] = True
        credential_variable_data_model['metadata'] = credential_variable_metadata_model

        # Construct a dict representation of a BastionResourceDefinition model
        bastion_resource_definition_model = {}
        bastion_resource_definition_model['name'] = 'testString'
        bastion_resource_definition_model['host'] = 'testString'

        # Construct a dict representation of a VariableMetadata model
        variable_metadata_model = {}
        variable_metadata_model['type'] = 'boolean'
        variable_metadata_model['aliases'] = ['testString']
        variable_metadata_model['description'] = 'testString'
        variable_metadata_model['cloud_data_type'] = 'testString'
        variable_metadata_model['default_value'] = 'testString'
        variable_metadata_model['link_status'] = 'normal'
        variable_metadata_model['secure'] = True
        variable_metadata_model['immutable'] = True
        variable_metadata_model['hidden'] = True
        variable_metadata_model['required'] = True
        variable_metadata_model['options'] = ['testString']
        variable_metadata_model['min_value'] = 38
        variable_metadata_model['max_value'] = 38
        variable_metadata_model['min_length'] = 38
        variable_metadata_model['max_length'] = 38
        variable_metadata_model['matches'] = 'testString'
        variable_metadata_model['position'] = 38
        variable_metadata_model['group_by'] = 'testString'
        variable_metadata_model['source'] = 'testString'

        # Construct a dict representation of a VariableData model
        variable_data_model = {}
        variable_data_model['name'] = 'testString'
        variable_data_model['value'] = 'testString'
        variable_data_model['use_default'] = True
        variable_data_model['metadata'] = variable_metadata_model

        # Set up parameter values
        name = 'Stop Action'
        description = 'The description of your action. The description can be up to 2048 characters long in size. **Example** you can use the description to stop the targets.'
        location = 'us-south'
        resource_group = 'testString'
        bastion_connection_type = 'ssh'
        inventory_connection_type = 'ssh'
        tags = ['testString']
        user_state = user_state_model
        source_readme_url = 'testString'
        source = external_source_model
        source_type = 'local'
        command_parameter = 'testString'
        inventory = 'testString'
        credentials = [credential_variable_data_model]
        bastion = bastion_resource_definition_model
        bastion_credential = credential_variable_data_model
        targets_ini = 'testString'
        inputs = [variable_data_model]
        outputs = [variable_data_model]
        settings = [variable_data_model]

        # Invoke method
        response = _service.create_action(
            name=name,
            description=description,
            location=location,
            resource_group=resource_group,
            bastion_connection_type=bastion_connection_type,
            inventory_connection_type=inventory_connection_type,
            tags=tags,
            user_state=user_state,
            source_readme_url=source_readme_url,
            source=source,
            source_type=source_type,
            command_parameter=command_parameter,
            inventory=inventory,
            credentials=credentials,
            bastion=bastion,
            bastion_credential=bastion_credential,
            targets_ini=targets_ini,
            inputs=inputs,
            outputs=outputs,
            settings=settings,
            headers={},
        )

        # Check for correct operation
        assert len(responses.calls) == 1
        assert response.status_code == 201
        # Validate body params
        req_body = json.loads(str(responses.calls[0].request.body, 'utf-8'))
        assert req_body['name'] == 'Stop Action'
        assert (
            req_body['description']
            == 'The description of your action. The description can be up to 2048 characters long in size. **Example** you can use the description to stop the targets.'
        )
        assert req_body['location'] == 'us-south'
        assert req_body['resource_group'] == 'testString'
        assert req_body['bastion_connection_type'] == 'ssh'
        assert req_body['inventory_connection_type'] == 'ssh'
        assert req_body['tags'] == ['testString']
        assert req_body['user_state'] == user_state_model
        assert req_body['source_readme_url'] == 'testString'
        assert req_body['source'] == external_source_model
        assert req_body['source_type'] == 'local'
        assert req_body['command_parameter'] == 'testString'
        assert req_body['inventory'] == 'testString'
        assert req_body['credentials'] == [credential_variable_data_model]
        assert req_body['bastion'] == bastion_resource_definition_model
        assert req_body['bastion_credential'] == credential_variable_data_model
        assert req_body['targets_ini'] == 'testString'
        assert req_body['inputs'] == [variable_data_model]
        assert req_body['outputs'] == [variable_data_model]
        assert req_body['settings'] == [variable_data_model]

    def test_create_action_required_params_with_retries(self):
        # Enable retries and run test_create_action_required_params.
        _service.enable_retries()
        self.test_create_action_required_params()

        # Disable retries and run test_create_action_required_params.
        _service.disable_retries()
        self.test_create_action_required_params()


class TestGetAction:
    """
    Test Class for get_action
    """

    @responses.activate
    def test_get_action_all_params(self):
        """
        get_action()
        """
        # Set up mock
        url = preprocess_url('/v2/actions/testString')
        mock_response = '{"name": "Stop Action", "description": "The description of your action. The description can be up to 2048 characters long in size. **Example** you can use the description to stop the targets.", "location": "us-south", "resource_group": "resource_group", "bastion_connection_type": "ssh", "inventory_connection_type": "ssh", "tags": ["tags"], "user_state": {"state": "draft", "set_by": "set_by", "set_at": "2019-01-01T12:00:00.000Z"}, "source_readme_url": "source_readme_url", "source": {"source_type": "local", "git": {"computed_git_repo_url": "computed_git_repo_url", "git_repo_url": "git_repo_url", "git_token": "git_token", "git_repo_folder": "git_repo_folder", "git_release": "git_release", "git_branch": "git_branch", "git_commit": "git_commit", "git_commit_timestamp": "git_commit_timestamp"}, "catalog": {"catalog_name": "catalog_name", "catalog_id": "catalog_id", "offering_name": "offering_name", "offering_version": "offering_version", "offering_kind": "offering_kind", "offering_target_kind": "offering_target_kind", "offering_id": "offering_id", "offering_version_id": "offering_version_id", "offering_version_flavour_name": "offering_version_flavour_name", "offering_repo_url": "offering_repo_url", "offering_provisioner_working_directory": "offering_provisioner_working_directory", "dry_run": false, "owning_account": "owning_account", "item_icon_url": "item_icon_url", "item_id": "item_id", "item_name": "item_name", "item_readme_url": "item_readme_url", "item_url": "item_url", "launch_url": "launch_url"}}, "source_type": "local", "command_parameter": "command_parameter", "inventory": "inventory", "credentials": [{"name": "name", "value": "-----BEGIN OPENSSH PRIVATE KEY-----\nXXXXXXXXXXXXX\n-----END OPENSSH PRIVATE KEY-----\n", "use_default": false, "metadata": {"type": "string", "aliases": ["aliases"], "description": "description", "cloud_data_type": "cloud_data_type", "default_value": "default_value", "link_status": "normal", "immutable": false, "hidden": true, "required": true, "position": 8, "group_by": "group_by", "source": "source"}, "link": "link"}], "bastion": {"name": "name", "host": "host"}, "bastion_credential": {"name": "name", "value": "-----BEGIN OPENSSH PRIVATE KEY-----\nXXXXXXXXXXXXX\n-----END OPENSSH PRIVATE KEY-----\n", "use_default": false, "metadata": {"type": "string", "aliases": ["aliases"], "description": "description", "cloud_data_type": "cloud_data_type", "default_value": "default_value", "link_status": "normal", "immutable": false, "hidden": true, "required": true, "position": 8, "group_by": "group_by", "source": "source"}, "link": "link"}, "targets_ini": "targets_ini", "inputs": [{"name": "name", "value": "value", "use_default": false, "metadata": {"type": "boolean", "aliases": ["aliases"], "description": "description", "cloud_data_type": "cloud_data_type", "default_value": "default_value", "link_status": "normal", "secure": true, "immutable": false, "hidden": true, "required": true, "options": ["options"], "min_value": 9, "max_value": 9, "min_length": 10, "max_length": 10, "matches": "matches", "position": 8, "group_by": "group_by", "source": "source"}, "link": "link"}], "outputs": [{"name": "name", "value": "value", "use_default": false, "metadata": {"type": "boolean", "aliases": ["aliases"], "description": "description", "cloud_data_type": "cloud_data_type", "default_value": "default_value", "link_status": "normal", "secure": true, "immutable": false, "hidden": true, "required": true, "options": ["options"], "min_value": 9, "max_value": 9, "min_length": 10, "max_length": 10, "matches": "matches", "position": 8, "group_by": "group_by", "source": "source"}, "link": "link"}], "settings": [{"name": "name", "value": "value", "use_default": false, "metadata": {"type": "boolean", "aliases": ["aliases"], "description": "description", "cloud_data_type": "cloud_data_type", "default_value": "default_value", "link_status": "normal", "secure": true, "immutable": false, "hidden": true, "required": true, "options": ["options"], "min_value": 9, "max_value": 9, "min_length": 10, "max_length": 10, "matches": "matches", "position": 8, "group_by": "group_by", "source": "source"}, "link": "link"}], "id": "id", "crn": "crn", "account": "account", "source_created_at": "2019-01-01T12:00:00.000Z", "source_created_by": "source_created_by", "source_updated_at": "2019-01-01T12:00:00.000Z", "source_updated_by": "source_updated_by", "created_at": "2019-01-01T12:00:00.000Z", "created_by": "created_by", "updated_at": "2019-01-01T12:00:00.000Z", "updated_by": "updated_by", "state": {"status_code": "normal", "status_job_id": "status_job_id", "status_message": "status_message"}, "playbook_names": ["playbook_names"], "sys_lock": {"sys_locked": true, "sys_locked_by": "sys_locked_by", "sys_locked_at": "2019-01-01T12:00:00.000Z"}, "git_token_ref": "git_token_ref", "encryption": {"crn": "crn", "scheme": "scheme"}}'
        responses.add(
            responses.GET,
            url,
            body=mock_response,
            content_type='application/json',
            status=200,
        )

        # Set up parameter values
        action_id = 'testString'
        profile = 'summary'

        # Invoke method
        response = _service.get_action(
            action_id,
            profile=profile,
            headers={},
        )

        # Check for correct operation
        assert len(responses.calls) == 1
        assert response.status_code == 200
        # Validate query params
        query_string = responses.calls[0].request.url.split('?', 1)[1]
        query_string = urllib.parse.unquote_plus(query_string)
        assert 'profile={}'.format(profile) in query_string

    def test_get_action_all_params_with_retries(self):
        # Enable retries and run test_get_action_all_params.
        _service.enable_retries()
        self.test_get_action_all_params()

        # Disable retries and run test_get_action_all_params.
        _service.disable_retries()
        self.test_get_action_all_params()

    @responses.activate
    def test_get_action_required_params(self):
        """
        test_get_action_required_params()
        """
        # Set up mock
        url = preprocess_url('/v2/actions/testString')
        mock_response = '{"name": "Stop Action", "description": "The description of your action. The description can be up to 2048 characters long in size. **Example** you can use the description to stop the targets.", "location": "us-south", "resource_group": "resource_group", "bastion_connection_type": "ssh", "inventory_connection_type": "ssh", "tags": ["tags"], "user_state": {"state": "draft", "set_by": "set_by", "set_at": "2019-01-01T12:00:00.000Z"}, "source_readme_url": "source_readme_url", "source": {"source_type": "local", "git": {"computed_git_repo_url": "computed_git_repo_url", "git_repo_url": "git_repo_url", "git_token": "git_token", "git_repo_folder": "git_repo_folder", "git_release": "git_release", "git_branch": "git_branch", "git_commit": "git_commit", "git_commit_timestamp": "git_commit_timestamp"}, "catalog": {"catalog_name": "catalog_name", "catalog_id": "catalog_id", "offering_name": "offering_name", "offering_version": "offering_version", "offering_kind": "offering_kind", "offering_target_kind": "offering_target_kind", "offering_id": "offering_id", "offering_version_id": "offering_version_id", "offering_version_flavour_name": "offering_version_flavour_name", "offering_repo_url": "offering_repo_url", "offering_provisioner_working_directory": "offering_provisioner_working_directory", "dry_run": false, "owning_account": "owning_account", "item_icon_url": "item_icon_url", "item_id": "item_id", "item_name": "item_name", "item_readme_url": "item_readme_url", "item_url": "item_url", "launch_url": "launch_url"}}, "source_type": "local", "command_parameter": "command_parameter", "inventory": "inventory", "credentials": [{"name": "name", "value": "-----BEGIN OPENSSH PRIVATE KEY-----\nXXXXXXXXXXXXX\n-----END OPENSSH PRIVATE KEY-----\n", "use_default": false, "metadata": {"type": "string", "aliases": ["aliases"], "description": "description", "cloud_data_type": "cloud_data_type", "default_value": "default_value", "link_status": "normal", "immutable": false, "hidden": true, "required": true, "position": 8, "group_by": "group_by", "source": "source"}, "link": "link"}], "bastion": {"name": "name", "host": "host"}, "bastion_credential": {"name": "name", "value": "-----BEGIN OPENSSH PRIVATE KEY-----\nXXXXXXXXXXXXX\n-----END OPENSSH PRIVATE KEY-----\n", "use_default": false, "metadata": {"type": "string", "aliases": ["aliases"], "description": "description", "cloud_data_type": "cloud_data_type", "default_value": "default_value", "link_status": "normal", "immutable": false, "hidden": true, "required": true, "position": 8, "group_by": "group_by", "source": "source"}, "link": "link"}, "targets_ini": "targets_ini", "inputs": [{"name": "name", "value": "value", "use_default": false, "metadata": {"type": "boolean", "aliases": ["aliases"], "description": "description", "cloud_data_type": "cloud_data_type", "default_value": "default_value", "link_status": "normal", "secure": true, "immutable": false, "hidden": true, "required": true, "options": ["options"], "min_value": 9, "max_value": 9, "min_length": 10, "max_length": 10, "matches": "matches", "position": 8, "group_by": "group_by", "source": "source"}, "link": "link"}], "outputs": [{"name": "name", "value": "value", "use_default": false, "metadata": {"type": "boolean", "aliases": ["aliases"], "description": "description", "cloud_data_type": "cloud_data_type", "default_value": "default_value", "link_status": "normal", "secure": true, "immutable": false, "hidden": true, "required": true, "options": ["options"], "min_value": 9, "max_value": 9, "min_length": 10, "max_length": 10, "matches": "matches", "position": 8, "group_by": "group_by", "source": "source"}, "link": "link"}], "settings": [{"name": "name", "value": "value", "use_default": false, "metadata": {"type": "boolean", "aliases": ["aliases"], "description": "description", "cloud_data_type": "cloud_data_type", "default_value": "default_value", "link_status": "normal", "secure": true, "immutable": false, "hidden": true, "required": true, "options": ["options"], "min_value": 9, "max_value": 9, "min_length": 10, "max_length": 10, "matches": "matches", "position": 8, "group_by": "group_by", "source": "source"}, "link": "link"}], "id": "id", "crn": "crn", "account": "account", "source_created_at": "2019-01-01T12:00:00.000Z", "source_created_by": "source_created_by", "source_updated_at": "2019-01-01T12:00:00.000Z", "source_updated_by": "source_updated_by", "created_at": "2019-01-01T12:00:00.000Z", "created_by": "created_by", "updated_at": "2019-01-01T12:00:00.000Z", "updated_by": "updated_by", "state": {"status_code": "normal", "status_job_id": "status_job_id", "status_message": "status_message"}, "playbook_names": ["playbook_names"], "sys_lock": {"sys_locked": true, "sys_locked_by": "sys_locked_by", "sys_locked_at": "2019-01-01T12:00:00.000Z"}, "git_token_ref": "git_token_ref", "encryption": {"crn": "crn", "scheme": "scheme"}}'
        responses.add(
            responses.GET,
            url,
            body=mock_response,
            content_type='application/json',
            status=200,
        )

        # Set up parameter values
        action_id = 'testString'

        # Invoke method
        response = _service.get_action(
            action_id,
            headers={},
        )

        # Check for correct operation
        assert len(responses.calls) == 1
        assert response.status_code == 200

    def test_get_action_required_params_with_retries(self):
        # Enable retries and run test_get_action_required_params.
        _service.enable_retries()
        self.test_get_action_required_params()

        # Disable retries and run test_get_action_required_params.
        _service.disable_retries()
        self.test_get_action_required_params()

    @responses.activate
    def test_get_action_value_error(self):
        """
        test_get_action_value_error()
        """
        # Set up mock
        url = preprocess_url('/v2/actions/testString')
        mock_response = '{"name": "Stop Action", "description": "The description of your action. The description can be up to 2048 characters long in size. **Example** you can use the description to stop the targets.", "location": "us-south", "resource_group": "resource_group", "bastion_connection_type": "ssh", "inventory_connection_type": "ssh", "tags": ["tags"], "user_state": {"state": "draft", "set_by": "set_by", "set_at": "2019-01-01T12:00:00.000Z"}, "source_readme_url": "source_readme_url", "source": {"source_type": "local", "git": {"computed_git_repo_url": "computed_git_repo_url", "git_repo_url": "git_repo_url", "git_token": "git_token", "git_repo_folder": "git_repo_folder", "git_release": "git_release", "git_branch": "git_branch", "git_commit": "git_commit", "git_commit_timestamp": "git_commit_timestamp"}, "catalog": {"catalog_name": "catalog_name", "catalog_id": "catalog_id", "offering_name": "offering_name", "offering_version": "offering_version", "offering_kind": "offering_kind", "offering_target_kind": "offering_target_kind", "offering_id": "offering_id", "offering_version_id": "offering_version_id", "offering_version_flavour_name": "offering_version_flavour_name", "offering_repo_url": "offering_repo_url", "offering_provisioner_working_directory": "offering_provisioner_working_directory", "dry_run": false, "owning_account": "owning_account", "item_icon_url": "item_icon_url", "item_id": "item_id", "item_name": "item_name", "item_readme_url": "item_readme_url", "item_url": "item_url", "launch_url": "launch_url"}}, "source_type": "local", "command_parameter": "command_parameter", "inventory": "inventory", "credentials": [{"name": "name", "value": "-----BEGIN OPENSSH PRIVATE KEY-----\nXXXXXXXXXXXXX\n-----END OPENSSH PRIVATE KEY-----\n", "use_default": false, "metadata": {"type": "string", "aliases": ["aliases"], "description": "description", "cloud_data_type": "cloud_data_type", "default_value": "default_value", "link_status": "normal", "immutable": false, "hidden": true, "required": true, "position": 8, "group_by": "group_by", "source": "source"}, "link": "link"}], "bastion": {"name": "name", "host": "host"}, "bastion_credential": {"name": "name", "value": "-----BEGIN OPENSSH PRIVATE KEY-----\nXXXXXXXXXXXXX\n-----END OPENSSH PRIVATE KEY-----\n", "use_default": false, "metadata": {"type": "string", "aliases": ["aliases"], "description": "description", "cloud_data_type": "cloud_data_type", "default_value": "default_value", "link_status": "normal", "immutable": false, "hidden": true, "required": true, "position": 8, "group_by": "group_by", "source": "source"}, "link": "link"}, "targets_ini": "targets_ini", "inputs": [{"name": "name", "value": "value", "use_default": false, "metadata": {"type": "boolean", "aliases": ["aliases"], "description": "description", "cloud_data_type": "cloud_data_type", "default_value": "default_value", "link_status": "normal", "secure": true, "immutable": false, "hidden": true, "required": true, "options": ["options"], "min_value": 9, "max_value": 9, "min_length": 10, "max_length": 10, "matches": "matches", "position": 8, "group_by": "group_by", "source": "source"}, "link": "link"}], "outputs": [{"name": "name", "value": "value", "use_default": false, "metadata": {"type": "boolean", "aliases": ["aliases"], "description": "description", "cloud_data_type": "cloud_data_type", "default_value": "default_value", "link_status": "normal", "secure": true, "immutable": false, "hidden": true, "required": true, "options": ["options"], "min_value": 9, "max_value": 9, "min_length": 10, "max_length": 10, "matches": "matches", "position": 8, "group_by": "group_by", "source": "source"}, "link": "link"}], "settings": [{"name": "name", "value": "value", "use_default": false, "metadata": {"type": "boolean", "aliases": ["aliases"], "description": "description", "cloud_data_type": "cloud_data_type", "default_value": "default_value", "link_status": "normal", "secure": true, "immutable": false, "hidden": true, "required": true, "options": ["options"], "min_value": 9, "max_value": 9, "min_length": 10, "max_length": 10, "matches": "matches", "position": 8, "group_by": "group_by", "source": "source"}, "link": "link"}], "id": "id", "crn": "crn", "account": "account", "source_created_at": "2019-01-01T12:00:00.000Z", "source_created_by": "source_created_by", "source_updated_at": "2019-01-01T12:00:00.000Z", "source_updated_by": "source_updated_by", "created_at": "2019-01-01T12:00:00.000Z", "created_by": "created_by", "updated_at": "2019-01-01T12:00:00.000Z", "updated_by": "updated_by", "state": {"status_code": "normal", "status_job_id": "status_job_id", "status_message": "status_message"}, "playbook_names": ["playbook_names"], "sys_lock": {"sys_locked": true, "sys_locked_by": "sys_locked_by", "sys_locked_at": "2019-01-01T12:00:00.000Z"}, "git_token_ref": "git_token_ref", "encryption": {"crn": "crn", "scheme": "scheme"}}'
        responses.add(
            responses.GET,
            url,
            body=mock_response,
            content_type='application/json',
            status=200,
        )

        # Set up parameter values
        action_id = 'testString'

        # Pass in all but one required param and check for a ValueError
        req_param_dict = {
            "action_id": action_id,
        }
        for param in req_param_dict.keys():
            req_copy = {key: val if key is not param else None for (key, val) in req_param_dict.items()}
            with pytest.raises(ValueError):
                _service.get_action(**req_copy)

    def test_get_action_value_error_with_retries(self):
        # Enable retries and run test_get_action_value_error.
        _service.enable_retries()
        self.test_get_action_value_error()

        # Disable retries and run test_get_action_value_error.
        _service.disable_retries()
        self.test_get_action_value_error()


class TestDeleteAction:
    """
    Test Class for delete_action
    """

    @responses.activate
    def test_delete_action_all_params(self):
        """
        delete_action()
        """
        # Set up mock
        url = preprocess_url('/v2/actions/testString')
        responses.add(
            responses.DELETE,
            url,
            status=204,
        )

        # Set up parameter values
        action_id = 'testString'
        force = True
        propagate = True

        # Invoke method
        response = _service.delete_action(
            action_id,
            force=force,
            propagate=propagate,
            headers={},
        )

        # Check for correct operation
        assert len(responses.calls) == 1
        assert response.status_code == 204

    def test_delete_action_all_params_with_retries(self):
        # Enable retries and run test_delete_action_all_params.
        _service.enable_retries()
        self.test_delete_action_all_params()

        # Disable retries and run test_delete_action_all_params.
        _service.disable_retries()
        self.test_delete_action_all_params()

    @responses.activate
    def test_delete_action_required_params(self):
        """
        test_delete_action_required_params()
        """
        # Set up mock
        url = preprocess_url('/v2/actions/testString')
        responses.add(
            responses.DELETE,
            url,
            status=204,
        )

        # Set up parameter values
        action_id = 'testString'

        # Invoke method
        response = _service.delete_action(
            action_id,
            headers={},
        )

        # Check for correct operation
        assert len(responses.calls) == 1
        assert response.status_code == 204

    def test_delete_action_required_params_with_retries(self):
        # Enable retries and run test_delete_action_required_params.
        _service.enable_retries()
        self.test_delete_action_required_params()

        # Disable retries and run test_delete_action_required_params.
        _service.disable_retries()
        self.test_delete_action_required_params()

    @responses.activate
    def test_delete_action_value_error(self):
        """
        test_delete_action_value_error()
        """
        # Set up mock
        url = preprocess_url('/v2/actions/testString')
        responses.add(
            responses.DELETE,
            url,
            status=204,
        )

        # Set up parameter values
        action_id = 'testString'

        # Pass in all but one required param and check for a ValueError
        req_param_dict = {
            "action_id": action_id,
        }
        for param in req_param_dict.keys():
            req_copy = {key: val if key is not param else None for (key, val) in req_param_dict.items()}
            with pytest.raises(ValueError):
                _service.delete_action(**req_copy)

    def test_delete_action_value_error_with_retries(self):
        # Enable retries and run test_delete_action_value_error.
        _service.enable_retries()
        self.test_delete_action_value_error()

        # Disable retries and run test_delete_action_value_error.
        _service.disable_retries()
        self.test_delete_action_value_error()


class TestUpdateAction:
    """
    Test Class for update_action
    """

    @responses.activate
    def test_update_action_all_params(self):
        """
        update_action()
        """
        # Set up mock
        url = preprocess_url('/v2/actions/testString')
        mock_response = '{"name": "Stop Action", "description": "The description of your action. The description can be up to 2048 characters long in size. **Example** you can use the description to stop the targets.", "location": "us-south", "resource_group": "resource_group", "bastion_connection_type": "ssh", "inventory_connection_type": "ssh", "tags": ["tags"], "user_state": {"state": "draft", "set_by": "set_by", "set_at": "2019-01-01T12:00:00.000Z"}, "source_readme_url": "source_readme_url", "source": {"source_type": "local", "git": {"computed_git_repo_url": "computed_git_repo_url", "git_repo_url": "git_repo_url", "git_token": "git_token", "git_repo_folder": "git_repo_folder", "git_release": "git_release", "git_branch": "git_branch", "git_commit": "git_commit", "git_commit_timestamp": "git_commit_timestamp"}, "catalog": {"catalog_name": "catalog_name", "catalog_id": "catalog_id", "offering_name": "offering_name", "offering_version": "offering_version", "offering_kind": "offering_kind", "offering_target_kind": "offering_target_kind", "offering_id": "offering_id", "offering_version_id": "offering_version_id", "offering_version_flavour_name": "offering_version_flavour_name", "offering_repo_url": "offering_repo_url", "offering_provisioner_working_directory": "offering_provisioner_working_directory", "dry_run": false, "owning_account": "owning_account", "item_icon_url": "item_icon_url", "item_id": "item_id", "item_name": "item_name", "item_readme_url": "item_readme_url", "item_url": "item_url", "launch_url": "launch_url"}}, "source_type": "local", "command_parameter": "command_parameter", "inventory": "inventory", "credentials": [{"name": "name", "value": "-----BEGIN OPENSSH PRIVATE KEY-----\nXXXXXXXXXXXXX\n-----END OPENSSH PRIVATE KEY-----\n", "use_default": false, "metadata": {"type": "string", "aliases": ["aliases"], "description": "description", "cloud_data_type": "cloud_data_type", "default_value": "default_value", "link_status": "normal", "immutable": false, "hidden": true, "required": true, "position": 8, "group_by": "group_by", "source": "source"}, "link": "link"}], "bastion": {"name": "name", "host": "host"}, "bastion_credential": {"name": "name", "value": "-----BEGIN OPENSSH PRIVATE KEY-----\nXXXXXXXXXXXXX\n-----END OPENSSH PRIVATE KEY-----\n", "use_default": false, "metadata": {"type": "string", "aliases": ["aliases"], "description": "description", "cloud_data_type": "cloud_data_type", "default_value": "default_value", "link_status": "normal", "immutable": false, "hidden": true, "required": true, "position": 8, "group_by": "group_by", "source": "source"}, "link": "link"}, "targets_ini": "targets_ini", "inputs": [{"name": "name", "value": "value", "use_default": false, "metadata": {"type": "boolean", "aliases": ["aliases"], "description": "description", "cloud_data_type": "cloud_data_type", "default_value": "default_value", "link_status": "normal", "secure": true, "immutable": false, "hidden": true, "required": true, "options": ["options"], "min_value": 9, "max_value": 9, "min_length": 10, "max_length": 10, "matches": "matches", "position": 8, "group_by": "group_by", "source": "source"}, "link": "link"}], "outputs": [{"name": "name", "value": "value", "use_default": false, "metadata": {"type": "boolean", "aliases": ["aliases"], "description": "description", "cloud_data_type": "cloud_data_type", "default_value": "default_value", "link_status": "normal", "secure": true, "immutable": false, "hidden": true, "required": true, "options": ["options"], "min_value": 9, "max_value": 9, "min_length": 10, "max_length": 10, "matches": "matches", "position": 8, "group_by": "group_by", "source": "source"}, "link": "link"}], "settings": [{"name": "name", "value": "value", "use_default": false, "metadata": {"type": "boolean", "aliases": ["aliases"], "description": "description", "cloud_data_type": "cloud_data_type", "default_value": "default_value", "link_status": "normal", "secure": true, "immutable": false, "hidden": true, "required": true, "options": ["options"], "min_value": 9, "max_value": 9, "min_length": 10, "max_length": 10, "matches": "matches", "position": 8, "group_by": "group_by", "source": "source"}, "link": "link"}], "id": "id", "crn": "crn", "account": "account", "source_created_at": "2019-01-01T12:00:00.000Z", "source_created_by": "source_created_by", "source_updated_at": "2019-01-01T12:00:00.000Z", "source_updated_by": "source_updated_by", "created_at": "2019-01-01T12:00:00.000Z", "created_by": "created_by", "updated_at": "2019-01-01T12:00:00.000Z", "updated_by": "updated_by", "state": {"status_code": "normal", "status_job_id": "status_job_id", "status_message": "status_message"}, "playbook_names": ["playbook_names"], "sys_lock": {"sys_locked": true, "sys_locked_by": "sys_locked_by", "sys_locked_at": "2019-01-01T12:00:00.000Z"}, "git_token_ref": "git_token_ref", "encryption": {"crn": "crn", "scheme": "scheme"}}'
        responses.add(
            responses.PATCH,
            url,
            body=mock_response,
            content_type='application/json',
            status=200,
        )

        # Construct a dict representation of a UserState model
        user_state_model = {}
        user_state_model['state'] = 'draft'
        user_state_model['set_by'] = 'testString'
        user_state_model['set_at'] = '2019-01-01T12:00:00Z'

        # Construct a dict representation of a GitSource model
        git_source_model = {}
        git_source_model['computed_git_repo_url'] = 'testString'
        git_source_model['git_repo_url'] = 'testString'
        git_source_model['git_token'] = 'testString'
        git_source_model['git_repo_folder'] = 'testString'
        git_source_model['git_release'] = 'testString'
        git_source_model['git_branch'] = 'testString'

        # Construct a dict representation of a CatalogSource model
        catalog_source_model = {}
        catalog_source_model['catalog_name'] = 'testString'
        catalog_source_model['catalog_id'] = 'testString'
        catalog_source_model['offering_name'] = 'testString'
        catalog_source_model['offering_version'] = 'testString'
        catalog_source_model['offering_kind'] = 'testString'
        catalog_source_model['offering_target_kind'] = 'testString'
        catalog_source_model['offering_id'] = 'testString'
        catalog_source_model['offering_version_id'] = 'testString'
        catalog_source_model['offering_version_flavour_name'] = 'testString'
        catalog_source_model['offering_repo_url'] = 'testString'
        catalog_source_model['offering_provisioner_working_directory'] = 'testString'
        catalog_source_model['dry_run'] = True
        catalog_source_model['owning_account'] = 'testString'
        catalog_source_model['item_icon_url'] = 'testString'
        catalog_source_model['item_id'] = 'testString'
        catalog_source_model['item_name'] = 'testString'
        catalog_source_model['item_readme_url'] = 'testString'
        catalog_source_model['item_url'] = 'testString'
        catalog_source_model['launch_url'] = 'testString'

        # Construct a dict representation of a ExternalSource model
        external_source_model = {}
        external_source_model['source_type'] = 'local'
        external_source_model['git'] = git_source_model
        external_source_model['catalog'] = catalog_source_model

        # Construct a dict representation of a CredentialVariableMetadata model
        credential_variable_metadata_model = {}
        credential_variable_metadata_model['type'] = 'string'
        credential_variable_metadata_model['aliases'] = ['testString']
        credential_variable_metadata_model['description'] = 'testString'
        credential_variable_metadata_model['cloud_data_type'] = 'testString'
        credential_variable_metadata_model['default_value'] = 'testString'
        credential_variable_metadata_model['link_status'] = 'normal'
        credential_variable_metadata_model['immutable'] = True
        credential_variable_metadata_model['hidden'] = True
        credential_variable_metadata_model['required'] = True
        credential_variable_metadata_model['position'] = 38
        credential_variable_metadata_model['group_by'] = 'testString'
        credential_variable_metadata_model['source'] = 'testString'

        # Construct a dict representation of a CredentialVariableData model
        credential_variable_data_model = {}
        credential_variable_data_model['name'] = 'testString'
        credential_variable_data_model['value'] = (
            '-----BEGIN OPENSSH PRIVATE KEY-----\\nXXXXXXXXXXXXX\\n-----END OPENSSH PRIVATE KEY-----\\n'
        )
        credential_variable_data_model['use_default'] = True
        credential_variable_data_model['metadata'] = credential_variable_metadata_model

        # Construct a dict representation of a BastionResourceDefinition model
        bastion_resource_definition_model = {}
        bastion_resource_definition_model['name'] = 'testString'
        bastion_resource_definition_model['host'] = 'testString'

        # Construct a dict representation of a VariableMetadata model
        variable_metadata_model = {}
        variable_metadata_model['type'] = 'boolean'
        variable_metadata_model['aliases'] = ['testString']
        variable_metadata_model['description'] = 'testString'
        variable_metadata_model['cloud_data_type'] = 'testString'
        variable_metadata_model['default_value'] = 'testString'
        variable_metadata_model['link_status'] = 'normal'
        variable_metadata_model['secure'] = True
        variable_metadata_model['immutable'] = True
        variable_metadata_model['hidden'] = True
        variable_metadata_model['required'] = True
        variable_metadata_model['options'] = ['testString']
        variable_metadata_model['min_value'] = 38
        variable_metadata_model['max_value'] = 38
        variable_metadata_model['min_length'] = 38
        variable_metadata_model['max_length'] = 38
        variable_metadata_model['matches'] = 'testString'
        variable_metadata_model['position'] = 38
        variable_metadata_model['group_by'] = 'testString'
        variable_metadata_model['source'] = 'testString'

        # Construct a dict representation of a VariableData model
        variable_data_model = {}
        variable_data_model['name'] = 'testString'
        variable_data_model['value'] = 'testString'
        variable_data_model['use_default'] = True
        variable_data_model['metadata'] = variable_metadata_model

        # Set up parameter values
        action_id = 'testString'
        name = 'Stop Action'
        description = 'The description of your action. The description can be up to 2048 characters long in size. **Example** you can use the description to stop the targets.'
        location = 'us-south'
        resource_group = 'testString'
        bastion_connection_type = 'ssh'
        inventory_connection_type = 'ssh'
        tags = ['testString']
        user_state = user_state_model
        source_readme_url = 'testString'
        source = external_source_model
        source_type = 'local'
        command_parameter = 'testString'
        inventory = 'testString'
        credentials = [credential_variable_data_model]
        bastion = bastion_resource_definition_model
        bastion_credential = credential_variable_data_model
        targets_ini = 'testString'
        inputs = [variable_data_model]
        outputs = [variable_data_model]
        settings = [variable_data_model]
        x_github_token = 'testString'

        # Invoke method
        response = _service.update_action(
            action_id,
            name=name,
            description=description,
            location=location,
            resource_group=resource_group,
            bastion_connection_type=bastion_connection_type,
            inventory_connection_type=inventory_connection_type,
            tags=tags,
            user_state=user_state,
            source_readme_url=source_readme_url,
            source=source,
            source_type=source_type,
            command_parameter=command_parameter,
            inventory=inventory,
            credentials=credentials,
            bastion=bastion,
            bastion_credential=bastion_credential,
            targets_ini=targets_ini,
            inputs=inputs,
            outputs=outputs,
            settings=settings,
            x_github_token=x_github_token,
            headers={},
        )

        # Check for correct operation
        assert len(responses.calls) == 1
        assert response.status_code == 200
        # Validate body params
        req_body = json.loads(str(responses.calls[0].request.body, 'utf-8'))
        assert req_body['name'] == 'Stop Action'
        assert (
            req_body['description']
            == 'The description of your action. The description can be up to 2048 characters long in size. **Example** you can use the description to stop the targets.'
        )
        assert req_body['location'] == 'us-south'
        assert req_body['resource_group'] == 'testString'
        assert req_body['bastion_connection_type'] == 'ssh'
        assert req_body['inventory_connection_type'] == 'ssh'
        assert req_body['tags'] == ['testString']
        assert req_body['user_state'] == user_state_model
        assert req_body['source_readme_url'] == 'testString'
        assert req_body['source'] == external_source_model
        assert req_body['source_type'] == 'local'
        assert req_body['command_parameter'] == 'testString'
        assert req_body['inventory'] == 'testString'
        assert req_body['credentials'] == [credential_variable_data_model]
        assert req_body['bastion'] == bastion_resource_definition_model
        assert req_body['bastion_credential'] == credential_variable_data_model
        assert req_body['targets_ini'] == 'testString'
        assert req_body['inputs'] == [variable_data_model]
        assert req_body['outputs'] == [variable_data_model]
        assert req_body['settings'] == [variable_data_model]

    def test_update_action_all_params_with_retries(self):
        # Enable retries and run test_update_action_all_params.
        _service.enable_retries()
        self.test_update_action_all_params()

        # Disable retries and run test_update_action_all_params.
        _service.disable_retries()
        self.test_update_action_all_params()

    @responses.activate
    def test_update_action_required_params(self):
        """
        test_update_action_required_params()
        """
        # Set up mock
        url = preprocess_url('/v2/actions/testString')
        mock_response = '{"name": "Stop Action", "description": "The description of your action. The description can be up to 2048 characters long in size. **Example** you can use the description to stop the targets.", "location": "us-south", "resource_group": "resource_group", "bastion_connection_type": "ssh", "inventory_connection_type": "ssh", "tags": ["tags"], "user_state": {"state": "draft", "set_by": "set_by", "set_at": "2019-01-01T12:00:00.000Z"}, "source_readme_url": "source_readme_url", "source": {"source_type": "local", "git": {"computed_git_repo_url": "computed_git_repo_url", "git_repo_url": "git_repo_url", "git_token": "git_token", "git_repo_folder": "git_repo_folder", "git_release": "git_release", "git_branch": "git_branch", "git_commit": "git_commit", "git_commit_timestamp": "git_commit_timestamp"}, "catalog": {"catalog_name": "catalog_name", "catalog_id": "catalog_id", "offering_name": "offering_name", "offering_version": "offering_version", "offering_kind": "offering_kind", "offering_target_kind": "offering_target_kind", "offering_id": "offering_id", "offering_version_id": "offering_version_id", "offering_version_flavour_name": "offering_version_flavour_name", "offering_repo_url": "offering_repo_url", "offering_provisioner_working_directory": "offering_provisioner_working_directory", "dry_run": false, "owning_account": "owning_account", "item_icon_url": "item_icon_url", "item_id": "item_id", "item_name": "item_name", "item_readme_url": "item_readme_url", "item_url": "item_url", "launch_url": "launch_url"}}, "source_type": "local", "command_parameter": "command_parameter", "inventory": "inventory", "credentials": [{"name": "name", "value": "-----BEGIN OPENSSH PRIVATE KEY-----\nXXXXXXXXXXXXX\n-----END OPENSSH PRIVATE KEY-----\n", "use_default": false, "metadata": {"type": "string", "aliases": ["aliases"], "description": "description", "cloud_data_type": "cloud_data_type", "default_value": "default_value", "link_status": "normal", "immutable": false, "hidden": true, "required": true, "position": 8, "group_by": "group_by", "source": "source"}, "link": "link"}], "bastion": {"name": "name", "host": "host"}, "bastion_credential": {"name": "name", "value": "-----BEGIN OPENSSH PRIVATE KEY-----\nXXXXXXXXXXXXX\n-----END OPENSSH PRIVATE KEY-----\n", "use_default": false, "metadata": {"type": "string", "aliases": ["aliases"], "description": "description", "cloud_data_type": "cloud_data_type", "default_value": "default_value", "link_status": "normal", "immutable": false, "hidden": true, "required": true, "position": 8, "group_by": "group_by", "source": "source"}, "link": "link"}, "targets_ini": "targets_ini", "inputs": [{"name": "name", "value": "value", "use_default": false, "metadata": {"type": "boolean", "aliases": ["aliases"], "description": "description", "cloud_data_type": "cloud_data_type", "default_value": "default_value", "link_status": "normal", "secure": true, "immutable": false, "hidden": true, "required": true, "options": ["options"], "min_value": 9, "max_value": 9, "min_length": 10, "max_length": 10, "matches": "matches", "position": 8, "group_by": "group_by", "source": "source"}, "link": "link"}], "outputs": [{"name": "name", "value": "value", "use_default": false, "metadata": {"type": "boolean", "aliases": ["aliases"], "description": "description", "cloud_data_type": "cloud_data_type", "default_value": "default_value", "link_status": "normal", "secure": true, "immutable": false, "hidden": true, "required": true, "options": ["options"], "min_value": 9, "max_value": 9, "min_length": 10, "max_length": 10, "matches": "matches", "position": 8, "group_by": "group_by", "source": "source"}, "link": "link"}], "settings": [{"name": "name", "value": "value", "use_default": false, "metadata": {"type": "boolean", "aliases": ["aliases"], "description": "description", "cloud_data_type": "cloud_data_type", "default_value": "default_value", "link_status": "normal", "secure": true, "immutable": false, "hidden": true, "required": true, "options": ["options"], "min_value": 9, "max_value": 9, "min_length": 10, "max_length": 10, "matches": "matches", "position": 8, "group_by": "group_by", "source": "source"}, "link": "link"}], "id": "id", "crn": "crn", "account": "account", "source_created_at": "2019-01-01T12:00:00.000Z", "source_created_by": "source_created_by", "source_updated_at": "2019-01-01T12:00:00.000Z", "source_updated_by": "source_updated_by", "created_at": "2019-01-01T12:00:00.000Z", "created_by": "created_by", "updated_at": "2019-01-01T12:00:00.000Z", "updated_by": "updated_by", "state": {"status_code": "normal", "status_job_id": "status_job_id", "status_message": "status_message"}, "playbook_names": ["playbook_names"], "sys_lock": {"sys_locked": true, "sys_locked_by": "sys_locked_by", "sys_locked_at": "2019-01-01T12:00:00.000Z"}, "git_token_ref": "git_token_ref", "encryption": {"crn": "crn", "scheme": "scheme"}}'
        responses.add(
            responses.PATCH,
            url,
            body=mock_response,
            content_type='application/json',
            status=200,
        )

        # Construct a dict representation of a UserState model
        user_state_model = {}
        user_state_model['state'] = 'draft'
        user_state_model['set_by'] = 'testString'
        user_state_model['set_at'] = '2019-01-01T12:00:00Z'

        # Construct a dict representation of a GitSource model
        git_source_model = {}
        git_source_model['computed_git_repo_url'] = 'testString'
        git_source_model['git_repo_url'] = 'testString'
        git_source_model['git_token'] = 'testString'
        git_source_model['git_repo_folder'] = 'testString'
        git_source_model['git_release'] = 'testString'
        git_source_model['git_branch'] = 'testString'

        # Construct a dict representation of a CatalogSource model
        catalog_source_model = {}
        catalog_source_model['catalog_name'] = 'testString'
        catalog_source_model['catalog_id'] = 'testString'
        catalog_source_model['offering_name'] = 'testString'
        catalog_source_model['offering_version'] = 'testString'
        catalog_source_model['offering_kind'] = 'testString'
        catalog_source_model['offering_target_kind'] = 'testString'
        catalog_source_model['offering_id'] = 'testString'
        catalog_source_model['offering_version_id'] = 'testString'
        catalog_source_model['offering_version_flavour_name'] = 'testString'
        catalog_source_model['offering_repo_url'] = 'testString'
        catalog_source_model['offering_provisioner_working_directory'] = 'testString'
        catalog_source_model['dry_run'] = True
        catalog_source_model['owning_account'] = 'testString'
        catalog_source_model['item_icon_url'] = 'testString'
        catalog_source_model['item_id'] = 'testString'
        catalog_source_model['item_name'] = 'testString'
        catalog_source_model['item_readme_url'] = 'testString'
        catalog_source_model['item_url'] = 'testString'
        catalog_source_model['launch_url'] = 'testString'

        # Construct a dict representation of a ExternalSource model
        external_source_model = {}
        external_source_model['source_type'] = 'local'
        external_source_model['git'] = git_source_model
        external_source_model['catalog'] = catalog_source_model

        # Construct a dict representation of a CredentialVariableMetadata model
        credential_variable_metadata_model = {}
        credential_variable_metadata_model['type'] = 'string'
        credential_variable_metadata_model['aliases'] = ['testString']
        credential_variable_metadata_model['description'] = 'testString'
        credential_variable_metadata_model['cloud_data_type'] = 'testString'
        credential_variable_metadata_model['default_value'] = 'testString'
        credential_variable_metadata_model['link_status'] = 'normal'
        credential_variable_metadata_model['immutable'] = True
        credential_variable_metadata_model['hidden'] = True
        credential_variable_metadata_model['required'] = True
        credential_variable_metadata_model['position'] = 38
        credential_variable_metadata_model['group_by'] = 'testString'
        credential_variable_metadata_model['source'] = 'testString'

        # Construct a dict representation of a CredentialVariableData model
        credential_variable_data_model = {}
        credential_variable_data_model['name'] = 'testString'
        credential_variable_data_model['value'] = (
            '-----BEGIN OPENSSH PRIVATE KEY-----\\nXXXXXXXXXXXXX\\n-----END OPENSSH PRIVATE KEY-----\\n'
        )
        credential_variable_data_model['use_default'] = True
        credential_variable_data_model['metadata'] = credential_variable_metadata_model

        # Construct a dict representation of a BastionResourceDefinition model
        bastion_resource_definition_model = {}
        bastion_resource_definition_model['name'] = 'testString'
        bastion_resource_definition_model['host'] = 'testString'

        # Construct a dict representation of a VariableMetadata model
        variable_metadata_model = {}
        variable_metadata_model['type'] = 'boolean'
        variable_metadata_model['aliases'] = ['testString']
        variable_metadata_model['description'] = 'testString'
        variable_metadata_model['cloud_data_type'] = 'testString'
        variable_metadata_model['default_value'] = 'testString'
        variable_metadata_model['link_status'] = 'normal'
        variable_metadata_model['secure'] = True
        variable_metadata_model['immutable'] = True
        variable_metadata_model['hidden'] = True
        variable_metadata_model['required'] = True
        variable_metadata_model['options'] = ['testString']
        variable_metadata_model['min_value'] = 38
        variable_metadata_model['max_value'] = 38
        variable_metadata_model['min_length'] = 38
        variable_metadata_model['max_length'] = 38
        variable_metadata_model['matches'] = 'testString'
        variable_metadata_model['position'] = 38
        variable_metadata_model['group_by'] = 'testString'
        variable_metadata_model['source'] = 'testString'

        # Construct a dict representation of a VariableData model
        variable_data_model = {}
        variable_data_model['name'] = 'testString'
        variable_data_model['value'] = 'testString'
        variable_data_model['use_default'] = True
        variable_data_model['metadata'] = variable_metadata_model

        # Set up parameter values
        action_id = 'testString'
        name = 'Stop Action'
        description = 'The description of your action. The description can be up to 2048 characters long in size. **Example** you can use the description to stop the targets.'
        location = 'us-south'
        resource_group = 'testString'
        bastion_connection_type = 'ssh'
        inventory_connection_type = 'ssh'
        tags = ['testString']
        user_state = user_state_model
        source_readme_url = 'testString'
        source = external_source_model
        source_type = 'local'
        command_parameter = 'testString'
        inventory = 'testString'
        credentials = [credential_variable_data_model]
        bastion = bastion_resource_definition_model
        bastion_credential = credential_variable_data_model
        targets_ini = 'testString'
        inputs = [variable_data_model]
        outputs = [variable_data_model]
        settings = [variable_data_model]

        # Invoke method
        response = _service.update_action(
            action_id,
            name=name,
            description=description,
            location=location,
            resource_group=resource_group,
            bastion_connection_type=bastion_connection_type,
            inventory_connection_type=inventory_connection_type,
            tags=tags,
            user_state=user_state,
            source_readme_url=source_readme_url,
            source=source,
            source_type=source_type,
            command_parameter=command_parameter,
            inventory=inventory,
            credentials=credentials,
            bastion=bastion,
            bastion_credential=bastion_credential,
            targets_ini=targets_ini,
            inputs=inputs,
            outputs=outputs,
            settings=settings,
            headers={},
        )

        # Check for correct operation
        assert len(responses.calls) == 1
        assert response.status_code == 200
        # Validate body params
        req_body = json.loads(str(responses.calls[0].request.body, 'utf-8'))
        assert req_body['name'] == 'Stop Action'
        assert (
            req_body['description']
            == 'The description of your action. The description can be up to 2048 characters long in size. **Example** you can use the description to stop the targets.'
        )
        assert req_body['location'] == 'us-south'
        assert req_body['resource_group'] == 'testString'
        assert req_body['bastion_connection_type'] == 'ssh'
        assert req_body['inventory_connection_type'] == 'ssh'
        assert req_body['tags'] == ['testString']
        assert req_body['user_state'] == user_state_model
        assert req_body['source_readme_url'] == 'testString'
        assert req_body['source'] == external_source_model
        assert req_body['source_type'] == 'local'
        assert req_body['command_parameter'] == 'testString'
        assert req_body['inventory'] == 'testString'
        assert req_body['credentials'] == [credential_variable_data_model]
        assert req_body['bastion'] == bastion_resource_definition_model
        assert req_body['bastion_credential'] == credential_variable_data_model
        assert req_body['targets_ini'] == 'testString'
        assert req_body['inputs'] == [variable_data_model]
        assert req_body['outputs'] == [variable_data_model]
        assert req_body['settings'] == [variable_data_model]

    def test_update_action_required_params_with_retries(self):
        # Enable retries and run test_update_action_required_params.
        _service.enable_retries()
        self.test_update_action_required_params()

        # Disable retries and run test_update_action_required_params.
        _service.disable_retries()
        self.test_update_action_required_params()

    @responses.activate
    def test_update_action_value_error(self):
        """
        test_update_action_value_error()
        """
        # Set up mock
        url = preprocess_url('/v2/actions/testString')
        mock_response = '{"name": "Stop Action", "description": "The description of your action. The description can be up to 2048 characters long in size. **Example** you can use the description to stop the targets.", "location": "us-south", "resource_group": "resource_group", "bastion_connection_type": "ssh", "inventory_connection_type": "ssh", "tags": ["tags"], "user_state": {"state": "draft", "set_by": "set_by", "set_at": "2019-01-01T12:00:00.000Z"}, "source_readme_url": "source_readme_url", "source": {"source_type": "local", "git": {"computed_git_repo_url": "computed_git_repo_url", "git_repo_url": "git_repo_url", "git_token": "git_token", "git_repo_folder": "git_repo_folder", "git_release": "git_release", "git_branch": "git_branch", "git_commit": "git_commit", "git_commit_timestamp": "git_commit_timestamp"}, "catalog": {"catalog_name": "catalog_name", "catalog_id": "catalog_id", "offering_name": "offering_name", "offering_version": "offering_version", "offering_kind": "offering_kind", "offering_target_kind": "offering_target_kind", "offering_id": "offering_id", "offering_version_id": "offering_version_id", "offering_version_flavour_name": "offering_version_flavour_name", "offering_repo_url": "offering_repo_url", "offering_provisioner_working_directory": "offering_provisioner_working_directory", "dry_run": false, "owning_account": "owning_account", "item_icon_url": "item_icon_url", "item_id": "item_id", "item_name": "item_name", "item_readme_url": "item_readme_url", "item_url": "item_url", "launch_url": "launch_url"}}, "source_type": "local", "command_parameter": "command_parameter", "inventory": "inventory", "credentials": [{"name": "name", "value": "-----BEGIN OPENSSH PRIVATE KEY-----\nXXXXXXXXXXXXX\n-----END OPENSSH PRIVATE KEY-----\n", "use_default": false, "metadata": {"type": "string", "aliases": ["aliases"], "description": "description", "cloud_data_type": "cloud_data_type", "default_value": "default_value", "link_status": "normal", "immutable": false, "hidden": true, "required": true, "position": 8, "group_by": "group_by", "source": "source"}, "link": "link"}], "bastion": {"name": "name", "host": "host"}, "bastion_credential": {"name": "name", "value": "-----BEGIN OPENSSH PRIVATE KEY-----\nXXXXXXXXXXXXX\n-----END OPENSSH PRIVATE KEY-----\n", "use_default": false, "metadata": {"type": "string", "aliases": ["aliases"], "description": "description", "cloud_data_type": "cloud_data_type", "default_value": "default_value", "link_status": "normal", "immutable": false, "hidden": true, "required": true, "position": 8, "group_by": "group_by", "source": "source"}, "link": "link"}, "targets_ini": "targets_ini", "inputs": [{"name": "name", "value": "value", "use_default": false, "metadata": {"type": "boolean", "aliases": ["aliases"], "description": "description", "cloud_data_type": "cloud_data_type", "default_value": "default_value", "link_status": "normal", "secure": true, "immutable": false, "hidden": true, "required": true, "options": ["options"], "min_value": 9, "max_value": 9, "min_length": 10, "max_length": 10, "matches": "matches", "position": 8, "group_by": "group_by", "source": "source"}, "link": "link"}], "outputs": [{"name": "name", "value": "value", "use_default": false, "metadata": {"type": "boolean", "aliases": ["aliases"], "description": "description", "cloud_data_type": "cloud_data_type", "default_value": "default_value", "link_status": "normal", "secure": true, "immutable": false, "hidden": true, "required": true, "options": ["options"], "min_value": 9, "max_value": 9, "min_length": 10, "max_length": 10, "matches": "matches", "position": 8, "group_by": "group_by", "source": "source"}, "link": "link"}], "settings": [{"name": "name", "value": "value", "use_default": false, "metadata": {"type": "boolean", "aliases": ["aliases"], "description": "description", "cloud_data_type": "cloud_data_type", "default_value": "default_value", "link_status": "normal", "secure": true, "immutable": false, "hidden": true, "required": true, "options": ["options"], "min_value": 9, "max_value": 9, "min_length": 10, "max_length": 10, "matches": "matches", "position": 8, "group_by": "group_by", "source": "source"}, "link": "link"}], "id": "id", "crn": "crn", "account": "account", "source_created_at": "2019-01-01T12:00:00.000Z", "source_created_by": "source_created_by", "source_updated_at": "2019-01-01T12:00:00.000Z", "source_updated_by": "source_updated_by", "created_at": "2019-01-01T12:00:00.000Z", "created_by": "created_by", "updated_at": "2019-01-01T12:00:00.000Z", "updated_by": "updated_by", "state": {"status_code": "normal", "status_job_id": "status_job_id", "status_message": "status_message"}, "playbook_names": ["playbook_names"], "sys_lock": {"sys_locked": true, "sys_locked_by": "sys_locked_by", "sys_locked_at": "2019-01-01T12:00:00.000Z"}, "git_token_ref": "git_token_ref", "encryption": {"crn": "crn", "scheme": "scheme"}}'
        responses.add(
            responses.PATCH,
            url,
            body=mock_response,
            content_type='application/json',
            status=200,
        )

        # Construct a dict representation of a UserState model
        user_state_model = {}
        user_state_model['state'] = 'draft'
        user_state_model['set_by'] = 'testString'
        user_state_model['set_at'] = '2019-01-01T12:00:00Z'

        # Construct a dict representation of a GitSource model
        git_source_model = {}
        git_source_model['computed_git_repo_url'] = 'testString'
        git_source_model['git_repo_url'] = 'testString'
        git_source_model['git_token'] = 'testString'
        git_source_model['git_repo_folder'] = 'testString'
        git_source_model['git_release'] = 'testString'
        git_source_model['git_branch'] = 'testString'

        # Construct a dict representation of a CatalogSource model
        catalog_source_model = {}
        catalog_source_model['catalog_name'] = 'testString'
        catalog_source_model['catalog_id'] = 'testString'
        catalog_source_model['offering_name'] = 'testString'
        catalog_source_model['offering_version'] = 'testString'
        catalog_source_model['offering_kind'] = 'testString'
        catalog_source_model['offering_target_kind'] = 'testString'
        catalog_source_model['offering_id'] = 'testString'
        catalog_source_model['offering_version_id'] = 'testString'
        catalog_source_model['offering_version_flavour_name'] = 'testString'
        catalog_source_model['offering_repo_url'] = 'testString'
        catalog_source_model['offering_provisioner_working_directory'] = 'testString'
        catalog_source_model['dry_run'] = True
        catalog_source_model['owning_account'] = 'testString'
        catalog_source_model['item_icon_url'] = 'testString'
        catalog_source_model['item_id'] = 'testString'
        catalog_source_model['item_name'] = 'testString'
        catalog_source_model['item_readme_url'] = 'testString'
        catalog_source_model['item_url'] = 'testString'
        catalog_source_model['launch_url'] = 'testString'

        # Construct a dict representation of a ExternalSource model
        external_source_model = {}
        external_source_model['source_type'] = 'local'
        external_source_model['git'] = git_source_model
        external_source_model['catalog'] = catalog_source_model

        # Construct a dict representation of a CredentialVariableMetadata model
        credential_variable_metadata_model = {}
        credential_variable_metadata_model['type'] = 'string'
        credential_variable_metadata_model['aliases'] = ['testString']
        credential_variable_metadata_model['description'] = 'testString'
        credential_variable_metadata_model['cloud_data_type'] = 'testString'
        credential_variable_metadata_model['default_value'] = 'testString'
        credential_variable_metadata_model['link_status'] = 'normal'
        credential_variable_metadata_model['immutable'] = True
        credential_variable_metadata_model['hidden'] = True
        credential_variable_metadata_model['required'] = True
        credential_variable_metadata_model['position'] = 38
        credential_variable_metadata_model['group_by'] = 'testString'
        credential_variable_metadata_model['source'] = 'testString'

        # Construct a dict representation of a CredentialVariableData model
        credential_variable_data_model = {}
        credential_variable_data_model['name'] = 'testString'
        credential_variable_data_model['value'] = (
            '-----BEGIN OPENSSH PRIVATE KEY-----\\nXXXXXXXXXXXXX\\n-----END OPENSSH PRIVATE KEY-----\\n'
        )
        credential_variable_data_model['use_default'] = True
        credential_variable_data_model['metadata'] = credential_variable_metadata_model

        # Construct a dict representation of a BastionResourceDefinition model
        bastion_resource_definition_model = {}
        bastion_resource_definition_model['name'] = 'testString'
        bastion_resource_definition_model['host'] = 'testString'

        # Construct a dict representation of a VariableMetadata model
        variable_metadata_model = {}
        variable_metadata_model['type'] = 'boolean'
        variable_metadata_model['aliases'] = ['testString']
        variable_metadata_model['description'] = 'testString'
        variable_metadata_model['cloud_data_type'] = 'testString'
        variable_metadata_model['default_value'] = 'testString'
        variable_metadata_model['link_status'] = 'normal'
        variable_metadata_model['secure'] = True
        variable_metadata_model['immutable'] = True
        variable_metadata_model['hidden'] = True
        variable_metadata_model['required'] = True
        variable_metadata_model['options'] = ['testString']
        variable_metadata_model['min_value'] = 38
        variable_metadata_model['max_value'] = 38
        variable_metadata_model['min_length'] = 38
        variable_metadata_model['max_length'] = 38
        variable_metadata_model['matches'] = 'testString'
        variable_metadata_model['position'] = 38
        variable_metadata_model['group_by'] = 'testString'
        variable_metadata_model['source'] = 'testString'

        # Construct a dict representation of a VariableData model
        variable_data_model = {}
        variable_data_model['name'] = 'testString'
        variable_data_model['value'] = 'testString'
        variable_data_model['use_default'] = True
        variable_data_model['metadata'] = variable_metadata_model

        # Set up parameter values
        action_id = 'testString'
        name = 'Stop Action'
        description = 'The description of your action. The description can be up to 2048 characters long in size. **Example** you can use the description to stop the targets.'
        location = 'us-south'
        resource_group = 'testString'
        bastion_connection_type = 'ssh'
        inventory_connection_type = 'ssh'
        tags = ['testString']
        user_state = user_state_model
        source_readme_url = 'testString'
        source = external_source_model
        source_type = 'local'
        command_parameter = 'testString'
        inventory = 'testString'
        credentials = [credential_variable_data_model]
        bastion = bastion_resource_definition_model
        bastion_credential = credential_variable_data_model
        targets_ini = 'testString'
        inputs = [variable_data_model]
        outputs = [variable_data_model]
        settings = [variable_data_model]

        # Pass in all but one required param and check for a ValueError
        req_param_dict = {
            "action_id": action_id,
        }
        for param in req_param_dict.keys():
            req_copy = {key: val if key is not param else None for (key, val) in req_param_dict.items()}
            with pytest.raises(ValueError):
                _service.update_action(**req_copy)

    def test_update_action_value_error_with_retries(self):
        # Enable retries and run test_update_action_value_error.
        _service.enable_retries()
        self.test_update_action_value_error()

        # Disable retries and run test_update_action_value_error.
        _service.disable_retries()
        self.test_update_action_value_error()


class TestUploadTemplateTarAction:
    """
    Test Class for upload_template_tar_action
    """

    @responses.activate
    def test_upload_template_tar_action_all_params(self):
        """
        upload_template_tar_action()
        """
        # Set up mock
        url = preprocess_url('/v2/actions/testString/template_repo_upload')
        mock_response = '{"file_value": "file_value", "has_received_file": false, "id": "id"}'
        responses.add(
            responses.PUT,
            url,
            body=mock_response,
            content_type='application/json',
            status=200,
        )

        # Set up parameter values
        action_id = 'testString'
        file = io.BytesIO(b'This is a mock file.').getvalue()
        file_content_type = 'testString'

        # Invoke method
        response = _service.upload_template_tar_action(
            action_id,
            file=file,
            file_content_type=file_content_type,
            headers={},
        )

        # Check for correct operation
        assert len(responses.calls) == 1
        assert response.status_code == 200

    def test_upload_template_tar_action_all_params_with_retries(self):
        # Enable retries and run test_upload_template_tar_action_all_params.
        _service.enable_retries()
        self.test_upload_template_tar_action_all_params()

        # Disable retries and run test_upload_template_tar_action_all_params.
        _service.disable_retries()
        self.test_upload_template_tar_action_all_params()

    @responses.activate
    def test_upload_template_tar_action_required_params(self):
        """
        test_upload_template_tar_action_required_params()
        """
        # Set up mock
        url = preprocess_url('/v2/actions/testString/template_repo_upload')
        mock_response = '{"file_value": "file_value", "has_received_file": false, "id": "id"}'
        responses.add(
            responses.PUT,
            url,
            body=mock_response,
            content_type='application/json',
            status=200,
        )

        # Set up parameter values
        action_id = 'testString'

        # Invoke method
        response = _service.upload_template_tar_action(
            action_id,
            headers={},
        )

        # Check for correct operation
        assert len(responses.calls) == 1
        assert response.status_code == 200

    def test_upload_template_tar_action_required_params_with_retries(self):
        # Enable retries and run test_upload_template_tar_action_required_params.
        _service.enable_retries()
        self.test_upload_template_tar_action_required_params()

        # Disable retries and run test_upload_template_tar_action_required_params.
        _service.disable_retries()
        self.test_upload_template_tar_action_required_params()

    @responses.activate
    def test_upload_template_tar_action_value_error(self):
        """
        test_upload_template_tar_action_value_error()
        """
        # Set up mock
        url = preprocess_url('/v2/actions/testString/template_repo_upload')
        mock_response = '{"file_value": "file_value", "has_received_file": false, "id": "id"}'
        responses.add(
            responses.PUT,
            url,
            body=mock_response,
            content_type='application/json',
            status=200,
        )

        # Set up parameter values
        action_id = 'testString'

        # Pass in all but one required param and check for a ValueError
        req_param_dict = {
            "action_id": action_id,
        }
        for param in req_param_dict.keys():
            req_copy = {key: val if key is not param else None for (key, val) in req_param_dict.items()}
            with pytest.raises(ValueError):
                _service.upload_template_tar_action(**req_copy)

    def test_upload_template_tar_action_value_error_with_retries(self):
        # Enable retries and run test_upload_template_tar_action_value_error.
        _service.enable_retries()
        self.test_upload_template_tar_action_value_error()

        # Disable retries and run test_upload_template_tar_action_value_error.
        _service.disable_retries()
        self.test_upload_template_tar_action_value_error()


# endregion
##############################################################################
# End of Service: Actions
##############################################################################

##############################################################################
# Start of Service: Jobs
##############################################################################
# region


class TestNewInstance:
    """
    Test Class for new_instance
    """

    def test_new_instance(self):
        """
        new_instance()
        """
        os.environ['TEST_SERVICE_AUTH_TYPE'] = 'noAuth'

        service = SchematicsV1.new_instance(
            service_name='TEST_SERVICE',
        )

        assert service is not None
        assert isinstance(service, SchematicsV1)

    def test_new_instance_without_authenticator(self):
        """
        new_instance_without_authenticator()
        """
        with pytest.raises(ValueError, match='authenticator must be provided'):
            service = SchematicsV1.new_instance(
                service_name='TEST_SERVICE_NOT_FOUND',
            )


class TestListWorkspaceActivities:
    """
    Test Class for list_workspace_activities
    """

    @responses.activate
    def test_list_workspace_activities_all_params(self):
        """
        list_workspace_activities()
        """
        # Set up mock
        url = preprocess_url('/v1/workspaces/testString/actions')
        mock_response = '{"actions": [{"action_id": "action_id", "message": ["message"], "name": "name", "performed_at": "2019-01-01T12:00:00.000Z", "performed_by": "performed_by", "status": "status", "templates": [{"end_time": "2019-01-01T12:00:00.000Z", "log_summary": {"activity_status": "activity_status", "detected_template_type": "detected_template_type", "discarded_files": 15, "error": "error", "resources_added": 15, "resources_destroyed": 19, "resources_modified": 18, "scanned_files": 13, "template_variable_count": 23, "time_taken": 10}, "log_url": "log_url", "message": "message", "start_time": "2019-01-01T12:00:00.000Z", "status": "status", "template_id": "template_id", "template_type": "template_type"}]}], "workspace_id": "workspace_id", "workspace_name": "workspace_name"}'
        responses.add(
            responses.GET,
            url,
            body=mock_response,
            content_type='application/json',
            status=200,
        )

        # Set up parameter values
        w_id = 'testString'
        offset = 0
        limit = 100

        # Invoke method
        response = _service.list_workspace_activities(
            w_id,
            offset=offset,
            limit=limit,
            headers={},
        )

        # Check for correct operation
        assert len(responses.calls) == 1
        assert response.status_code == 200
        # Validate query params
        query_string = responses.calls[0].request.url.split('?', 1)[1]
        query_string = urllib.parse.unquote_plus(query_string)
        assert 'offset={}'.format(offset) in query_string
        assert 'limit={}'.format(limit) in query_string

    def test_list_workspace_activities_all_params_with_retries(self):
        # Enable retries and run test_list_workspace_activities_all_params.
        _service.enable_retries()
        self.test_list_workspace_activities_all_params()

        # Disable retries and run test_list_workspace_activities_all_params.
        _service.disable_retries()
        self.test_list_workspace_activities_all_params()

    @responses.activate
    def test_list_workspace_activities_required_params(self):
        """
        test_list_workspace_activities_required_params()
        """
        # Set up mock
        url = preprocess_url('/v1/workspaces/testString/actions')
        mock_response = '{"actions": [{"action_id": "action_id", "message": ["message"], "name": "name", "performed_at": "2019-01-01T12:00:00.000Z", "performed_by": "performed_by", "status": "status", "templates": [{"end_time": "2019-01-01T12:00:00.000Z", "log_summary": {"activity_status": "activity_status", "detected_template_type": "detected_template_type", "discarded_files": 15, "error": "error", "resources_added": 15, "resources_destroyed": 19, "resources_modified": 18, "scanned_files": 13, "template_variable_count": 23, "time_taken": 10}, "log_url": "log_url", "message": "message", "start_time": "2019-01-01T12:00:00.000Z", "status": "status", "template_id": "template_id", "template_type": "template_type"}]}], "workspace_id": "workspace_id", "workspace_name": "workspace_name"}'
        responses.add(
            responses.GET,
            url,
            body=mock_response,
            content_type='application/json',
            status=200,
        )

        # Set up parameter values
        w_id = 'testString'

        # Invoke method
        response = _service.list_workspace_activities(
            w_id,
            headers={},
        )

        # Check for correct operation
        assert len(responses.calls) == 1
        assert response.status_code == 200

    def test_list_workspace_activities_required_params_with_retries(self):
        # Enable retries and run test_list_workspace_activities_required_params.
        _service.enable_retries()
        self.test_list_workspace_activities_required_params()

        # Disable retries and run test_list_workspace_activities_required_params.
        _service.disable_retries()
        self.test_list_workspace_activities_required_params()

    @responses.activate
    def test_list_workspace_activities_value_error(self):
        """
        test_list_workspace_activities_value_error()
        """
        # Set up mock
        url = preprocess_url('/v1/workspaces/testString/actions')
        mock_response = '{"actions": [{"action_id": "action_id", "message": ["message"], "name": "name", "performed_at": "2019-01-01T12:00:00.000Z", "performed_by": "performed_by", "status": "status", "templates": [{"end_time": "2019-01-01T12:00:00.000Z", "log_summary": {"activity_status": "activity_status", "detected_template_type": "detected_template_type", "discarded_files": 15, "error": "error", "resources_added": 15, "resources_destroyed": 19, "resources_modified": 18, "scanned_files": 13, "template_variable_count": 23, "time_taken": 10}, "log_url": "log_url", "message": "message", "start_time": "2019-01-01T12:00:00.000Z", "status": "status", "template_id": "template_id", "template_type": "template_type"}]}], "workspace_id": "workspace_id", "workspace_name": "workspace_name"}'
        responses.add(
            responses.GET,
            url,
            body=mock_response,
            content_type='application/json',
            status=200,
        )

        # Set up parameter values
        w_id = 'testString'

        # Pass in all but one required param and check for a ValueError
        req_param_dict = {
            "w_id": w_id,
        }
        for param in req_param_dict.keys():
            req_copy = {key: val if key is not param else None for (key, val) in req_param_dict.items()}
            with pytest.raises(ValueError):
                _service.list_workspace_activities(**req_copy)

    def test_list_workspace_activities_value_error_with_retries(self):
        # Enable retries and run test_list_workspace_activities_value_error.
        _service.enable_retries()
        self.test_list_workspace_activities_value_error()

        # Disable retries and run test_list_workspace_activities_value_error.
        _service.disable_retries()
        self.test_list_workspace_activities_value_error()


class TestGetWorkspaceActivity:
    """
    Test Class for get_workspace_activity
    """

    @responses.activate
    def test_get_workspace_activity_all_params(self):
        """
        get_workspace_activity()
        """
        # Set up mock
        url = preprocess_url('/v1/workspaces/testString/actions/testString')
        mock_response = '{"action_id": "action_id", "message": ["message"], "name": "name", "performed_at": "2019-01-01T12:00:00.000Z", "performed_by": "performed_by", "status": "status", "templates": [{"end_time": "2019-01-01T12:00:00.000Z", "log_summary": {"activity_status": "activity_status", "detected_template_type": "detected_template_type", "discarded_files": 15, "error": "error", "resources_added": 15, "resources_destroyed": 19, "resources_modified": 18, "scanned_files": 13, "template_variable_count": 23, "time_taken": 10}, "log_url": "log_url", "message": "message", "start_time": "2019-01-01T12:00:00.000Z", "status": "status", "template_id": "template_id", "template_type": "template_type"}]}'
        responses.add(
            responses.GET,
            url,
            body=mock_response,
            content_type='application/json',
            status=200,
        )

        # Set up parameter values
        w_id = 'testString'
        activity_id = 'testString'

        # Invoke method
        response = _service.get_workspace_activity(
            w_id,
            activity_id,
            headers={},
        )

        # Check for correct operation
        assert len(responses.calls) == 1
        assert response.status_code == 200

    def test_get_workspace_activity_all_params_with_retries(self):
        # Enable retries and run test_get_workspace_activity_all_params.
        _service.enable_retries()
        self.test_get_workspace_activity_all_params()

        # Disable retries and run test_get_workspace_activity_all_params.
        _service.disable_retries()
        self.test_get_workspace_activity_all_params()

    @responses.activate
    def test_get_workspace_activity_value_error(self):
        """
        test_get_workspace_activity_value_error()
        """
        # Set up mock
        url = preprocess_url('/v1/workspaces/testString/actions/testString')
        mock_response = '{"action_id": "action_id", "message": ["message"], "name": "name", "performed_at": "2019-01-01T12:00:00.000Z", "performed_by": "performed_by", "status": "status", "templates": [{"end_time": "2019-01-01T12:00:00.000Z", "log_summary": {"activity_status": "activity_status", "detected_template_type": "detected_template_type", "discarded_files": 15, "error": "error", "resources_added": 15, "resources_destroyed": 19, "resources_modified": 18, "scanned_files": 13, "template_variable_count": 23, "time_taken": 10}, "log_url": "log_url", "message": "message", "start_time": "2019-01-01T12:00:00.000Z", "status": "status", "template_id": "template_id", "template_type": "template_type"}]}'
        responses.add(
            responses.GET,
            url,
            body=mock_response,
            content_type='application/json',
            status=200,
        )

        # Set up parameter values
        w_id = 'testString'
        activity_id = 'testString'

        # Pass in all but one required param and check for a ValueError
        req_param_dict = {
            "w_id": w_id,
            "activity_id": activity_id,
        }
        for param in req_param_dict.keys():
            req_copy = {key: val if key is not param else None for (key, val) in req_param_dict.items()}
            with pytest.raises(ValueError):
                _service.get_workspace_activity(**req_copy)

    def test_get_workspace_activity_value_error_with_retries(self):
        # Enable retries and run test_get_workspace_activity_value_error.
        _service.enable_retries()
        self.test_get_workspace_activity_value_error()

        # Disable retries and run test_get_workspace_activity_value_error.
        _service.disable_retries()
        self.test_get_workspace_activity_value_error()


class TestDeleteWorkspaceActivity:
    """
    Test Class for delete_workspace_activity
    """

    @responses.activate
    def test_delete_workspace_activity_all_params(self):
        """
        delete_workspace_activity()
        """
        # Set up mock
        url = preprocess_url('/v1/workspaces/testString/actions/testString')
        mock_response = '{"activityid": "activityid"}'
        responses.add(
            responses.DELETE,
            url,
            body=mock_response,
            content_type='application/json',
            status=202,
        )

        # Set up parameter values
        w_id = 'testString'
        activity_id = 'testString'

        # Invoke method
        response = _service.delete_workspace_activity(
            w_id,
            activity_id,
            headers={},
        )

        # Check for correct operation
        assert len(responses.calls) == 1
        assert response.status_code == 202

    def test_delete_workspace_activity_all_params_with_retries(self):
        # Enable retries and run test_delete_workspace_activity_all_params.
        _service.enable_retries()
        self.test_delete_workspace_activity_all_params()

        # Disable retries and run test_delete_workspace_activity_all_params.
        _service.disable_retries()
        self.test_delete_workspace_activity_all_params()

    @responses.activate
    def test_delete_workspace_activity_value_error(self):
        """
        test_delete_workspace_activity_value_error()
        """
        # Set up mock
        url = preprocess_url('/v1/workspaces/testString/actions/testString')
        mock_response = '{"activityid": "activityid"}'
        responses.add(
            responses.DELETE,
            url,
            body=mock_response,
            content_type='application/json',
            status=202,
        )

        # Set up parameter values
        w_id = 'testString'
        activity_id = 'testString'

        # Pass in all but one required param and check for a ValueError
        req_param_dict = {
            "w_id": w_id,
            "activity_id": activity_id,
        }
        for param in req_param_dict.keys():
            req_copy = {key: val if key is not param else None for (key, val) in req_param_dict.items()}
            with pytest.raises(ValueError):
                _service.delete_workspace_activity(**req_copy)

    def test_delete_workspace_activity_value_error_with_retries(self):
        # Enable retries and run test_delete_workspace_activity_value_error.
        _service.enable_retries()
        self.test_delete_workspace_activity_value_error()

        # Disable retries and run test_delete_workspace_activity_value_error.
        _service.disable_retries()
        self.test_delete_workspace_activity_value_error()


class TestRunWorkspaceCommands:
    """
    Test Class for run_workspace_commands
    """

    @responses.activate
    def test_run_workspace_commands_all_params(self):
        """
        run_workspace_commands()
        """
        # Set up mock
        url = preprocess_url('/v1/workspaces/testString/commands')
        mock_response = '{"activityid": "activityid"}'
        responses.add(
            responses.PUT,
            url,
            body=mock_response,
            content_type='application/json',
            status=200,
        )

        # Construct a dict representation of a TerraformCommand model
        terraform_command_model = {}
        terraform_command_model['command'] = 'testString'
        terraform_command_model['command_params'] = 'testString'
        terraform_command_model['command_name'] = 'testString'
        terraform_command_model['command_desc'] = 'testString'
        terraform_command_model['command_on_error'] = 'testString'
        terraform_command_model['command_depends_on'] = 'testString'
        terraform_command_model['command_status'] = 'testString'

        # Set up parameter values
        w_id = 'testString'
        refresh_token = 'testString'
        commands = [terraform_command_model]
        operation_name = 'testString'
        description = 'testString'

        # Invoke method
        response = _service.run_workspace_commands(
            w_id,
            refresh_token,
            commands=commands,
            operation_name=operation_name,
            description=description,
            headers={},
        )

        # Check for correct operation
        assert len(responses.calls) == 1
        assert response.status_code == 200
        # Validate body params
        req_body = json.loads(str(responses.calls[0].request.body, 'utf-8'))
        assert req_body['commands'] == [terraform_command_model]
        assert req_body['operation_name'] == 'testString'
        assert req_body['description'] == 'testString'

    def test_run_workspace_commands_all_params_with_retries(self):
        # Enable retries and run test_run_workspace_commands_all_params.
        _service.enable_retries()
        self.test_run_workspace_commands_all_params()

        # Disable retries and run test_run_workspace_commands_all_params.
        _service.disable_retries()
        self.test_run_workspace_commands_all_params()

    @responses.activate
    def test_run_workspace_commands_value_error(self):
        """
        test_run_workspace_commands_value_error()
        """
        # Set up mock
        url = preprocess_url('/v1/workspaces/testString/commands')
        mock_response = '{"activityid": "activityid"}'
        responses.add(
            responses.PUT,
            url,
            body=mock_response,
            content_type='application/json',
            status=200,
        )

        # Construct a dict representation of a TerraformCommand model
        terraform_command_model = {}
        terraform_command_model['command'] = 'testString'
        terraform_command_model['command_params'] = 'testString'
        terraform_command_model['command_name'] = 'testString'
        terraform_command_model['command_desc'] = 'testString'
        terraform_command_model['command_on_error'] = 'testString'
        terraform_command_model['command_depends_on'] = 'testString'
        terraform_command_model['command_status'] = 'testString'

        # Set up parameter values
        w_id = 'testString'
        refresh_token = 'testString'
        commands = [terraform_command_model]
        operation_name = 'testString'
        description = 'testString'

        # Pass in all but one required param and check for a ValueError
        req_param_dict = {
            "w_id": w_id,
            "refresh_token": refresh_token,
        }
        for param in req_param_dict.keys():
            req_copy = {key: val if key is not param else None for (key, val) in req_param_dict.items()}
            with pytest.raises(ValueError):
                _service.run_workspace_commands(**req_copy)

    def test_run_workspace_commands_value_error_with_retries(self):
        # Enable retries and run test_run_workspace_commands_value_error.
        _service.enable_retries()
        self.test_run_workspace_commands_value_error()

        # Disable retries and run test_run_workspace_commands_value_error.
        _service.disable_retries()
        self.test_run_workspace_commands_value_error()


class TestApplyWorkspaceCommand:
    """
    Test Class for apply_workspace_command
    """

    @responses.activate
    def test_apply_workspace_command_all_params(self):
        """
        apply_workspace_command()
        """
        # Set up mock
        url = preprocess_url('/v1/workspaces/testString/apply')
        mock_response = '{"activityid": "activityid"}'
        responses.add(
            responses.PUT,
            url,
            body=mock_response,
            content_type='application/json',
            status=202,
        )

        # Construct a dict representation of a WorkspaceActivityOptionsTemplate model
        workspace_activity_options_template_model = {}
        workspace_activity_options_template_model['target'] = ['testString']
        workspace_activity_options_template_model['tf_vars'] = ['testString']

        # Set up parameter values
        w_id = 'testString'
        refresh_token = 'testString'
        action_options = workspace_activity_options_template_model
        delegated_token = 'testString'

        # Invoke method
        response = _service.apply_workspace_command(
            w_id,
            refresh_token,
            action_options=action_options,
            delegated_token=delegated_token,
            headers={},
        )

        # Check for correct operation
        assert len(responses.calls) == 1
        assert response.status_code == 202
        # Validate body params
        req_body = json.loads(str(responses.calls[0].request.body, 'utf-8'))
        assert req_body['action_options'] == workspace_activity_options_template_model

    def test_apply_workspace_command_all_params_with_retries(self):
        # Enable retries and run test_apply_workspace_command_all_params.
        _service.enable_retries()
        self.test_apply_workspace_command_all_params()

        # Disable retries and run test_apply_workspace_command_all_params.
        _service.disable_retries()
        self.test_apply_workspace_command_all_params()

    @responses.activate
    def test_apply_workspace_command_required_params(self):
        """
        test_apply_workspace_command_required_params()
        """
        # Set up mock
        url = preprocess_url('/v1/workspaces/testString/apply')
        mock_response = '{"activityid": "activityid"}'
        responses.add(
            responses.PUT,
            url,
            body=mock_response,
            content_type='application/json',
            status=202,
        )

        # Construct a dict representation of a WorkspaceActivityOptionsTemplate model
        workspace_activity_options_template_model = {}
        workspace_activity_options_template_model['target'] = ['testString']
        workspace_activity_options_template_model['tf_vars'] = ['testString']

        # Set up parameter values
        w_id = 'testString'
        refresh_token = 'testString'
        action_options = workspace_activity_options_template_model

        # Invoke method
        response = _service.apply_workspace_command(
            w_id,
            refresh_token,
            action_options=action_options,
            headers={},
        )

        # Check for correct operation
        assert len(responses.calls) == 1
        assert response.status_code == 202
        # Validate body params
        req_body = json.loads(str(responses.calls[0].request.body, 'utf-8'))
        assert req_body['action_options'] == workspace_activity_options_template_model

    def test_apply_workspace_command_required_params_with_retries(self):
        # Enable retries and run test_apply_workspace_command_required_params.
        _service.enable_retries()
        self.test_apply_workspace_command_required_params()

        # Disable retries and run test_apply_workspace_command_required_params.
        _service.disable_retries()
        self.test_apply_workspace_command_required_params()

    @responses.activate
    def test_apply_workspace_command_value_error(self):
        """
        test_apply_workspace_command_value_error()
        """
        # Set up mock
        url = preprocess_url('/v1/workspaces/testString/apply')
        mock_response = '{"activityid": "activityid"}'
        responses.add(
            responses.PUT,
            url,
            body=mock_response,
            content_type='application/json',
            status=202,
        )

        # Construct a dict representation of a WorkspaceActivityOptionsTemplate model
        workspace_activity_options_template_model = {}
        workspace_activity_options_template_model['target'] = ['testString']
        workspace_activity_options_template_model['tf_vars'] = ['testString']

        # Set up parameter values
        w_id = 'testString'
        refresh_token = 'testString'
        action_options = workspace_activity_options_template_model

        # Pass in all but one required param and check for a ValueError
        req_param_dict = {
            "w_id": w_id,
            "refresh_token": refresh_token,
        }
        for param in req_param_dict.keys():
            req_copy = {key: val if key is not param else None for (key, val) in req_param_dict.items()}
            with pytest.raises(ValueError):
                _service.apply_workspace_command(**req_copy)

    def test_apply_workspace_command_value_error_with_retries(self):
        # Enable retries and run test_apply_workspace_command_value_error.
        _service.enable_retries()
        self.test_apply_workspace_command_value_error()

        # Disable retries and run test_apply_workspace_command_value_error.
        _service.disable_retries()
        self.test_apply_workspace_command_value_error()


class TestDestroyWorkspaceCommand:
    """
    Test Class for destroy_workspace_command
    """

    @responses.activate
    def test_destroy_workspace_command_all_params(self):
        """
        destroy_workspace_command()
        """
        # Set up mock
        url = preprocess_url('/v1/workspaces/testString/destroy')
        mock_response = '{"activityid": "activityid"}'
        responses.add(
            responses.PUT,
            url,
            body=mock_response,
            content_type='application/json',
            status=202,
        )

        # Construct a dict representation of a WorkspaceActivityOptionsTemplate model
        workspace_activity_options_template_model = {}
        workspace_activity_options_template_model['target'] = ['testString']
        workspace_activity_options_template_model['tf_vars'] = ['testString']

        # Set up parameter values
        w_id = 'testString'
        refresh_token = 'testString'
        action_options = workspace_activity_options_template_model
        delegated_token = 'testString'

        # Invoke method
        response = _service.destroy_workspace_command(
            w_id,
            refresh_token,
            action_options=action_options,
            delegated_token=delegated_token,
            headers={},
        )

        # Check for correct operation
        assert len(responses.calls) == 1
        assert response.status_code == 202
        # Validate body params
        req_body = json.loads(str(responses.calls[0].request.body, 'utf-8'))
        assert req_body['action_options'] == workspace_activity_options_template_model

    def test_destroy_workspace_command_all_params_with_retries(self):
        # Enable retries and run test_destroy_workspace_command_all_params.
        _service.enable_retries()
        self.test_destroy_workspace_command_all_params()

        # Disable retries and run test_destroy_workspace_command_all_params.
        _service.disable_retries()
        self.test_destroy_workspace_command_all_params()

    @responses.activate
    def test_destroy_workspace_command_required_params(self):
        """
        test_destroy_workspace_command_required_params()
        """
        # Set up mock
        url = preprocess_url('/v1/workspaces/testString/destroy')
        mock_response = '{"activityid": "activityid"}'
        responses.add(
            responses.PUT,
            url,
            body=mock_response,
            content_type='application/json',
            status=202,
        )

        # Construct a dict representation of a WorkspaceActivityOptionsTemplate model
        workspace_activity_options_template_model = {}
        workspace_activity_options_template_model['target'] = ['testString']
        workspace_activity_options_template_model['tf_vars'] = ['testString']

        # Set up parameter values
        w_id = 'testString'
        refresh_token = 'testString'
        action_options = workspace_activity_options_template_model

        # Invoke method
        response = _service.destroy_workspace_command(
            w_id,
            refresh_token,
            action_options=action_options,
            headers={},
        )

        # Check for correct operation
        assert len(responses.calls) == 1
        assert response.status_code == 202
        # Validate body params
        req_body = json.loads(str(responses.calls[0].request.body, 'utf-8'))
        assert req_body['action_options'] == workspace_activity_options_template_model

    def test_destroy_workspace_command_required_params_with_retries(self):
        # Enable retries and run test_destroy_workspace_command_required_params.
        _service.enable_retries()
        self.test_destroy_workspace_command_required_params()

        # Disable retries and run test_destroy_workspace_command_required_params.
        _service.disable_retries()
        self.test_destroy_workspace_command_required_params()

    @responses.activate
    def test_destroy_workspace_command_value_error(self):
        """
        test_destroy_workspace_command_value_error()
        """
        # Set up mock
        url = preprocess_url('/v1/workspaces/testString/destroy')
        mock_response = '{"activityid": "activityid"}'
        responses.add(
            responses.PUT,
            url,
            body=mock_response,
            content_type='application/json',
            status=202,
        )

        # Construct a dict representation of a WorkspaceActivityOptionsTemplate model
        workspace_activity_options_template_model = {}
        workspace_activity_options_template_model['target'] = ['testString']
        workspace_activity_options_template_model['tf_vars'] = ['testString']

        # Set up parameter values
        w_id = 'testString'
        refresh_token = 'testString'
        action_options = workspace_activity_options_template_model

        # Pass in all but one required param and check for a ValueError
        req_param_dict = {
            "w_id": w_id,
            "refresh_token": refresh_token,
        }
        for param in req_param_dict.keys():
            req_copy = {key: val if key is not param else None for (key, val) in req_param_dict.items()}
            with pytest.raises(ValueError):
                _service.destroy_workspace_command(**req_copy)

    def test_destroy_workspace_command_value_error_with_retries(self):
        # Enable retries and run test_destroy_workspace_command_value_error.
        _service.enable_retries()
        self.test_destroy_workspace_command_value_error()

        # Disable retries and run test_destroy_workspace_command_value_error.
        _service.disable_retries()
        self.test_destroy_workspace_command_value_error()


class TestPlanWorkspaceCommand:
    """
    Test Class for plan_workspace_command
    """

    @responses.activate
    def test_plan_workspace_command_all_params(self):
        """
        plan_workspace_command()
        """
        # Set up mock
        url = preprocess_url('/v1/workspaces/testString/plan')
        mock_response = '{"activityid": "activityid"}'
        responses.add(
            responses.POST,
            url,
            body=mock_response,
            content_type='application/json',
            status=202,
        )

        # Construct a dict representation of a WorkspaceActivityOptionsTemplate model
        workspace_activity_options_template_model = {}
        workspace_activity_options_template_model['target'] = ['testString']
        workspace_activity_options_template_model['tf_vars'] = ['testString']

        # Set up parameter values
        w_id = 'testString'
        refresh_token = 'testString'
        action_options = workspace_activity_options_template_model
        delegated_token = 'testString'

        # Invoke method
        response = _service.plan_workspace_command(
            w_id,
            refresh_token,
            action_options=action_options,
            delegated_token=delegated_token,
            headers={},
        )

        # Check for correct operation
        assert len(responses.calls) == 1
        assert response.status_code == 202
        # Validate body params
        req_body = json.loads(str(responses.calls[0].request.body, 'utf-8'))
        assert req_body['action_options'] == workspace_activity_options_template_model

    def test_plan_workspace_command_all_params_with_retries(self):
        # Enable retries and run test_plan_workspace_command_all_params.
        _service.enable_retries()
        self.test_plan_workspace_command_all_params()

        # Disable retries and run test_plan_workspace_command_all_params.
        _service.disable_retries()
        self.test_plan_workspace_command_all_params()

    @responses.activate
    def test_plan_workspace_command_required_params(self):
        """
        test_plan_workspace_command_required_params()
        """
        # Set up mock
        url = preprocess_url('/v1/workspaces/testString/plan')
        mock_response = '{"activityid": "activityid"}'
        responses.add(
            responses.POST,
            url,
            body=mock_response,
            content_type='application/json',
            status=202,
        )

        # Construct a dict representation of a WorkspaceActivityOptionsTemplate model
        workspace_activity_options_template_model = {}
        workspace_activity_options_template_model['target'] = ['testString']
        workspace_activity_options_template_model['tf_vars'] = ['testString']

        # Set up parameter values
        w_id = 'testString'
        refresh_token = 'testString'
        action_options = workspace_activity_options_template_model

        # Invoke method
        response = _service.plan_workspace_command(
            w_id,
            refresh_token,
            action_options=action_options,
            headers={},
        )

        # Check for correct operation
        assert len(responses.calls) == 1
        assert response.status_code == 202
        # Validate body params
        req_body = json.loads(str(responses.calls[0].request.body, 'utf-8'))
        assert req_body['action_options'] == workspace_activity_options_template_model

    def test_plan_workspace_command_required_params_with_retries(self):
        # Enable retries and run test_plan_workspace_command_required_params.
        _service.enable_retries()
        self.test_plan_workspace_command_required_params()

        # Disable retries and run test_plan_workspace_command_required_params.
        _service.disable_retries()
        self.test_plan_workspace_command_required_params()

    @responses.activate
    def test_plan_workspace_command_value_error(self):
        """
        test_plan_workspace_command_value_error()
        """
        # Set up mock
        url = preprocess_url('/v1/workspaces/testString/plan')
        mock_response = '{"activityid": "activityid"}'
        responses.add(
            responses.POST,
            url,
            body=mock_response,
            content_type='application/json',
            status=202,
        )

        # Construct a dict representation of a WorkspaceActivityOptionsTemplate model
        workspace_activity_options_template_model = {}
        workspace_activity_options_template_model['target'] = ['testString']
        workspace_activity_options_template_model['tf_vars'] = ['testString']

        # Set up parameter values
        w_id = 'testString'
        refresh_token = 'testString'
        action_options = workspace_activity_options_template_model

        # Pass in all but one required param and check for a ValueError
        req_param_dict = {
            "w_id": w_id,
            "refresh_token": refresh_token,
        }
        for param in req_param_dict.keys():
            req_copy = {key: val if key is not param else None for (key, val) in req_param_dict.items()}
            with pytest.raises(ValueError):
                _service.plan_workspace_command(**req_copy)

    def test_plan_workspace_command_value_error_with_retries(self):
        # Enable retries and run test_plan_workspace_command_value_error.
        _service.enable_retries()
        self.test_plan_workspace_command_value_error()

        # Disable retries and run test_plan_workspace_command_value_error.
        _service.disable_retries()
        self.test_plan_workspace_command_value_error()


class TestRefreshWorkspaceCommand:
    """
    Test Class for refresh_workspace_command
    """

    @responses.activate
    def test_refresh_workspace_command_all_params(self):
        """
        refresh_workspace_command()
        """
        # Set up mock
        url = preprocess_url('/v1/workspaces/testString/refresh')
        mock_response = '{"activityid": "activityid"}'
        responses.add(
            responses.PUT,
            url,
            body=mock_response,
            content_type='application/json',
            status=202,
        )

        # Set up parameter values
        w_id = 'testString'
        refresh_token = 'testString'
        delegated_token = 'testString'

        # Invoke method
        response = _service.refresh_workspace_command(
            w_id,
            refresh_token,
            delegated_token=delegated_token,
            headers={},
        )

        # Check for correct operation
        assert len(responses.calls) == 1
        assert response.status_code == 202

    def test_refresh_workspace_command_all_params_with_retries(self):
        # Enable retries and run test_refresh_workspace_command_all_params.
        _service.enable_retries()
        self.test_refresh_workspace_command_all_params()

        # Disable retries and run test_refresh_workspace_command_all_params.
        _service.disable_retries()
        self.test_refresh_workspace_command_all_params()

    @responses.activate
    def test_refresh_workspace_command_required_params(self):
        """
        test_refresh_workspace_command_required_params()
        """
        # Set up mock
        url = preprocess_url('/v1/workspaces/testString/refresh')
        mock_response = '{"activityid": "activityid"}'
        responses.add(
            responses.PUT,
            url,
            body=mock_response,
            content_type='application/json',
            status=202,
        )

        # Set up parameter values
        w_id = 'testString'
        refresh_token = 'testString'

        # Invoke method
        response = _service.refresh_workspace_command(
            w_id,
            refresh_token,
            headers={},
        )

        # Check for correct operation
        assert len(responses.calls) == 1
        assert response.status_code == 202

    def test_refresh_workspace_command_required_params_with_retries(self):
        # Enable retries and run test_refresh_workspace_command_required_params.
        _service.enable_retries()
        self.test_refresh_workspace_command_required_params()

        # Disable retries and run test_refresh_workspace_command_required_params.
        _service.disable_retries()
        self.test_refresh_workspace_command_required_params()

    @responses.activate
    def test_refresh_workspace_command_value_error(self):
        """
        test_refresh_workspace_command_value_error()
        """
        # Set up mock
        url = preprocess_url('/v1/workspaces/testString/refresh')
        mock_response = '{"activityid": "activityid"}'
        responses.add(
            responses.PUT,
            url,
            body=mock_response,
            content_type='application/json',
            status=202,
        )

        # Set up parameter values
        w_id = 'testString'
        refresh_token = 'testString'

        # Pass in all but one required param and check for a ValueError
        req_param_dict = {
            "w_id": w_id,
            "refresh_token": refresh_token,
        }
        for param in req_param_dict.keys():
            req_copy = {key: val if key is not param else None for (key, val) in req_param_dict.items()}
            with pytest.raises(ValueError):
                _service.refresh_workspace_command(**req_copy)

    def test_refresh_workspace_command_value_error_with_retries(self):
        # Enable retries and run test_refresh_workspace_command_value_error.
        _service.enable_retries()
        self.test_refresh_workspace_command_value_error()

        # Disable retries and run test_refresh_workspace_command_value_error.
        _service.disable_retries()
        self.test_refresh_workspace_command_value_error()


class TestListJobs:
    """
    Test Class for list_jobs
    """

    @responses.activate
    def test_list_jobs_all_params(self):
        """
        list_jobs()
        """
        # Set up mock
        url = preprocess_url('/v2/jobs')
        mock_response = '{"total_count": 11, "limit": 5, "offset": 6, "jobs": [{"id": "id", "name": "name", "description": "description", "command_object": "workspace", "command_object_id": "command_object_id", "command_name": "workspace_plan", "tags": ["tags"], "location": "us-south", "resource_group": "resource_group", "submitted_at": "2019-01-01T12:00:00.000Z", "submitted_by": "submitted_by", "duration": "duration", "start_at": "2019-01-01T12:00:00.000Z", "end_at": "2019-01-01T12:00:00.000Z", "status": {"position_in_queue": 17, "total_in_queue": 14, "workspace_job_status": {"workspace_name": "workspace_name", "status_code": "job_pending", "status_message": "status_message", "flow_status": {"flow_id": "flow_id", "flow_name": "flow_name", "status_code": "job_pending", "status_message": "status_message", "workitems": [{"workspace_id": "workspace_id", "workspace_name": "workspace_name", "job_id": "job_id", "status_code": "job_pending", "status_message": "status_message", "updated_at": "2019-01-01T12:00:00.000Z"}], "updated_at": "2019-01-01T12:00:00.000Z"}, "template_status": [{"template_id": "template_id", "template_name": "template_name", "flow_index": 10, "status_code": "job_pending", "status_message": "status_message", "updated_at": "2019-01-01T12:00:00.000Z"}], "updated_at": "2019-01-01T12:00:00.000Z", "commands": [{"name": "name", "outcome": "outcome"}]}, "action_job_status": {"action_name": "action_name", "status_code": "job_pending", "status_message": "status_message", "bastion_status_code": "none", "bastion_status_message": "bastion_status_message", "targets_status_code": "none", "targets_status_message": "targets_status_message", "updated_at": "2019-01-01T12:00:00.000Z"}, "system_job_status": {"system_status_message": "system_status_message", "system_status_code": "job_pending", "schematics_resource_status": [{"status_code": "job_pending", "status_message": "status_message", "schematics_resource_id": "schematics_resource_id", "updated_at": "2019-01-01T12:00:00.000Z"}], "updated_at": "2019-01-01T12:00:00.000Z"}, "flow_job_status": {"flow_id": "flow_id", "flow_name": "flow_name", "status_code": "job_pending", "status_message": "status_message", "workitems": [{"workspace_id": "workspace_id", "workspace_name": "workspace_name", "job_id": "job_id", "status_code": "job_pending", "status_message": "status_message", "updated_at": "2019-01-01T12:00:00.000Z"}], "updated_at": "2019-01-01T12:00:00.000Z"}}, "log_summary": {"job_id": "job_id", "job_type": "repo_download_job", "log_start_at": "2019-01-01T12:00:00.000Z", "log_analyzed_till": "2019-01-01T12:00:00.000Z", "elapsed_time": 12, "log_errors": [{"error_code": "error_code", "error_msg": "error_msg", "error_count": 11}], "repo_download_job": {"scanned_file_count": 18, "quarantined_file_count": 22, "detected_filetype": "detected_filetype", "inputs_count": "inputs_count", "outputs_count": "outputs_count"}, "workspace_job": {"resources_add": 13, "resources_modify": 16, "resources_destroy": 17}, "flow_job": {"workitems_completed": 19, "workitems_pending": 17, "workitems_failed": 16, "workitems": [{"workspace_id": "workspace_id", "job_id": "job_id", "resources_add": 13, "resources_modify": 16, "resources_destroy": 17, "log_url": "log_url"}]}, "action_job": {"target_count": 12, "task_count": 10, "play_count": 10, "recap": {"target": ["target"], "ok": 2, "changed": 7, "failed": 6, "skipped": 7, "unreachable": 11}}, "system_job": {"target_count": 12, "success": 7, "failed": 6}}, "updated_at": "2019-01-01T12:00:00.000Z", "job_runner_id": "job_runner_id", "agent": {"id": "id", "name": "name", "assignment_policy_id": "assignment_policy_id"}}]}'
        responses.add(
            responses.GET,
            url,
            body=mock_response,
            content_type='application/json',
            status=200,
        )

        # Set up parameter values
        offset = 0
        limit = 100
        sort = 'testString'
        profile = 'ids'
        resource = 'workspaces'
        resource_id = 'testString'
        action_id = 'testString'
        workspace_id = 'testString'
        list = 'all'

        # Invoke method
        response = _service.list_jobs(
            offset=offset,
            limit=limit,
            sort=sort,
            profile=profile,
            resource=resource,
            resource_id=resource_id,
            action_id=action_id,
            workspace_id=workspace_id,
            list=list,
            headers={},
        )

        # Check for correct operation
        assert len(responses.calls) == 1
        assert response.status_code == 200
        # Validate query params
        query_string = responses.calls[0].request.url.split('?', 1)[1]
        query_string = urllib.parse.unquote_plus(query_string)
        assert 'offset={}'.format(offset) in query_string
        assert 'limit={}'.format(limit) in query_string
        assert 'sort={}'.format(sort) in query_string
        assert 'profile={}'.format(profile) in query_string
        assert 'resource={}'.format(resource) in query_string
        assert 'resource_id={}'.format(resource_id) in query_string
        assert 'action_id={}'.format(action_id) in query_string
        assert 'workspace_id={}'.format(workspace_id) in query_string
        assert 'list={}'.format(list) in query_string

    def test_list_jobs_all_params_with_retries(self):
        # Enable retries and run test_list_jobs_all_params.
        _service.enable_retries()
        self.test_list_jobs_all_params()

        # Disable retries and run test_list_jobs_all_params.
        _service.disable_retries()
        self.test_list_jobs_all_params()

    @responses.activate
    def test_list_jobs_required_params(self):
        """
        test_list_jobs_required_params()
        """
        # Set up mock
        url = preprocess_url('/v2/jobs')
        mock_response = '{"total_count": 11, "limit": 5, "offset": 6, "jobs": [{"id": "id", "name": "name", "description": "description", "command_object": "workspace", "command_object_id": "command_object_id", "command_name": "workspace_plan", "tags": ["tags"], "location": "us-south", "resource_group": "resource_group", "submitted_at": "2019-01-01T12:00:00.000Z", "submitted_by": "submitted_by", "duration": "duration", "start_at": "2019-01-01T12:00:00.000Z", "end_at": "2019-01-01T12:00:00.000Z", "status": {"position_in_queue": 17, "total_in_queue": 14, "workspace_job_status": {"workspace_name": "workspace_name", "status_code": "job_pending", "status_message": "status_message", "flow_status": {"flow_id": "flow_id", "flow_name": "flow_name", "status_code": "job_pending", "status_message": "status_message", "workitems": [{"workspace_id": "workspace_id", "workspace_name": "workspace_name", "job_id": "job_id", "status_code": "job_pending", "status_message": "status_message", "updated_at": "2019-01-01T12:00:00.000Z"}], "updated_at": "2019-01-01T12:00:00.000Z"}, "template_status": [{"template_id": "template_id", "template_name": "template_name", "flow_index": 10, "status_code": "job_pending", "status_message": "status_message", "updated_at": "2019-01-01T12:00:00.000Z"}], "updated_at": "2019-01-01T12:00:00.000Z", "commands": [{"name": "name", "outcome": "outcome"}]}, "action_job_status": {"action_name": "action_name", "status_code": "job_pending", "status_message": "status_message", "bastion_status_code": "none", "bastion_status_message": "bastion_status_message", "targets_status_code": "none", "targets_status_message": "targets_status_message", "updated_at": "2019-01-01T12:00:00.000Z"}, "system_job_status": {"system_status_message": "system_status_message", "system_status_code": "job_pending", "schematics_resource_status": [{"status_code": "job_pending", "status_message": "status_message", "schematics_resource_id": "schematics_resource_id", "updated_at": "2019-01-01T12:00:00.000Z"}], "updated_at": "2019-01-01T12:00:00.000Z"}, "flow_job_status": {"flow_id": "flow_id", "flow_name": "flow_name", "status_code": "job_pending", "status_message": "status_message", "workitems": [{"workspace_id": "workspace_id", "workspace_name": "workspace_name", "job_id": "job_id", "status_code": "job_pending", "status_message": "status_message", "updated_at": "2019-01-01T12:00:00.000Z"}], "updated_at": "2019-01-01T12:00:00.000Z"}}, "log_summary": {"job_id": "job_id", "job_type": "repo_download_job", "log_start_at": "2019-01-01T12:00:00.000Z", "log_analyzed_till": "2019-01-01T12:00:00.000Z", "elapsed_time": 12, "log_errors": [{"error_code": "error_code", "error_msg": "error_msg", "error_count": 11}], "repo_download_job": {"scanned_file_count": 18, "quarantined_file_count": 22, "detected_filetype": "detected_filetype", "inputs_count": "inputs_count", "outputs_count": "outputs_count"}, "workspace_job": {"resources_add": 13, "resources_modify": 16, "resources_destroy": 17}, "flow_job": {"workitems_completed": 19, "workitems_pending": 17, "workitems_failed": 16, "workitems": [{"workspace_id": "workspace_id", "job_id": "job_id", "resources_add": 13, "resources_modify": 16, "resources_destroy": 17, "log_url": "log_url"}]}, "action_job": {"target_count": 12, "task_count": 10, "play_count": 10, "recap": {"target": ["target"], "ok": 2, "changed": 7, "failed": 6, "skipped": 7, "unreachable": 11}}, "system_job": {"target_count": 12, "success": 7, "failed": 6}}, "updated_at": "2019-01-01T12:00:00.000Z", "job_runner_id": "job_runner_id", "agent": {"id": "id", "name": "name", "assignment_policy_id": "assignment_policy_id"}}]}'
        responses.add(
            responses.GET,
            url,
            body=mock_response,
            content_type='application/json',
            status=200,
        )

        # Invoke method
        response = _service.list_jobs()

        # Check for correct operation
        assert len(responses.calls) == 1
        assert response.status_code == 200

    def test_list_jobs_required_params_with_retries(self):
        # Enable retries and run test_list_jobs_required_params.
        _service.enable_retries()
        self.test_list_jobs_required_params()

        # Disable retries and run test_list_jobs_required_params.
        _service.disable_retries()
        self.test_list_jobs_required_params()


class TestCreateJob:
    """
    Test Class for create_job
    """

    @responses.activate
    def test_create_job_all_params(self):
        """
        create_job()
        """
        # Set up mock
        url = preprocess_url('/v2/jobs')
        mock_response = '{"command_object": "workspace", "command_object_id": "command_object_id", "command_name": "workspace_plan", "command_parameter": "command_parameter", "command_options": ["command_options"], "inputs": [{"name": "name", "value": "value", "use_default": false, "metadata": {"type": "boolean", "aliases": ["aliases"], "description": "description", "cloud_data_type": "cloud_data_type", "default_value": "default_value", "link_status": "normal", "secure": true, "immutable": false, "hidden": true, "required": true, "options": ["options"], "min_value": 9, "max_value": 9, "min_length": 10, "max_length": 10, "matches": "matches", "position": 8, "group_by": "group_by", "source": "source"}, "link": "link"}], "settings": [{"name": "name", "value": "value", "use_default": false, "metadata": {"type": "boolean", "aliases": ["aliases"], "description": "description", "cloud_data_type": "cloud_data_type", "default_value": "default_value", "link_status": "normal", "secure": true, "immutable": false, "hidden": true, "required": true, "options": ["options"], "min_value": 9, "max_value": 9, "min_length": 10, "max_length": 10, "matches": "matches", "position": 8, "group_by": "group_by", "source": "source"}, "link": "link"}], "tags": ["tags"], "id": "id", "name": "name", "description": "description", "location": "us-south", "resource_group": "resource_group", "submitted_at": "2019-01-01T12:00:00.000Z", "submitted_by": "submitted_by", "start_at": "2019-01-01T12:00:00.000Z", "end_at": "2019-01-01T12:00:00.000Z", "duration": "duration", "status": {"position_in_queue": 17, "total_in_queue": 14, "workspace_job_status": {"workspace_name": "workspace_name", "status_code": "job_pending", "status_message": "status_message", "flow_status": {"flow_id": "flow_id", "flow_name": "flow_name", "status_code": "job_pending", "status_message": "status_message", "workitems": [{"workspace_id": "workspace_id", "workspace_name": "workspace_name", "job_id": "job_id", "status_code": "job_pending", "status_message": "status_message", "updated_at": "2019-01-01T12:00:00.000Z"}], "updated_at": "2019-01-01T12:00:00.000Z"}, "template_status": [{"template_id": "template_id", "template_name": "template_name", "flow_index": 10, "status_code": "job_pending", "status_message": "status_message", "updated_at": "2019-01-01T12:00:00.000Z"}], "updated_at": "2019-01-01T12:00:00.000Z", "commands": [{"name": "name", "outcome": "outcome"}]}, "action_job_status": {"action_name": "action_name", "status_code": "job_pending", "status_message": "status_message", "bastion_status_code": "none", "bastion_status_message": "bastion_status_message", "targets_status_code": "none", "targets_status_message": "targets_status_message", "updated_at": "2019-01-01T12:00:00.000Z"}, "system_job_status": {"system_status_message": "system_status_message", "system_status_code": "job_pending", "schematics_resource_status": [{"status_code": "job_pending", "status_message": "status_message", "schematics_resource_id": "schematics_resource_id", "updated_at": "2019-01-01T12:00:00.000Z"}], "updated_at": "2019-01-01T12:00:00.000Z"}, "flow_job_status": {"flow_id": "flow_id", "flow_name": "flow_name", "status_code": "job_pending", "status_message": "status_message", "workitems": [{"workspace_id": "workspace_id", "workspace_name": "workspace_name", "job_id": "job_id", "status_code": "job_pending", "status_message": "status_message", "updated_at": "2019-01-01T12:00:00.000Z"}], "updated_at": "2019-01-01T12:00:00.000Z"}}, "cart_order_data": [{"name": "name", "value": "value", "type": "type", "usage_kind": ["servicetags"]}], "data": {"job_type": "repo_download_job", "workspace_job_data": {"workspace_name": "workspace_name", "flow_id": "flow_id", "flow_name": "flow_name", "inputs": [{"name": "name", "value": "value", "use_default": false, "metadata": {"type": "boolean", "aliases": ["aliases"], "description": "description", "cloud_data_type": "cloud_data_type", "default_value": "default_value", "link_status": "normal", "secure": true, "immutable": false, "hidden": true, "required": true, "options": ["options"], "min_value": 9, "max_value": 9, "min_length": 10, "max_length": 10, "matches": "matches", "position": 8, "group_by": "group_by", "source": "source"}, "link": "link"}], "outputs": [{"name": "name", "value": "value", "use_default": false, "metadata": {"type": "boolean", "aliases": ["aliases"], "description": "description", "cloud_data_type": "cloud_data_type", "default_value": "default_value", "link_status": "normal", "secure": true, "immutable": false, "hidden": true, "required": true, "options": ["options"], "min_value": 9, "max_value": 9, "min_length": 10, "max_length": 10, "matches": "matches", "position": 8, "group_by": "group_by", "source": "source"}, "link": "link"}], "settings": [{"name": "name", "value": "value", "use_default": false, "metadata": {"type": "boolean", "aliases": ["aliases"], "description": "description", "cloud_data_type": "cloud_data_type", "default_value": "default_value", "link_status": "normal", "secure": true, "immutable": false, "hidden": true, "required": true, "options": ["options"], "min_value": 9, "max_value": 9, "min_length": 10, "max_length": 10, "matches": "matches", "position": 8, "group_by": "group_by", "source": "source"}, "link": "link"}], "template_data": [{"template_id": "template_id", "template_name": "template_name", "flow_index": 10, "inputs": [{"name": "name", "value": "value", "use_default": false, "metadata": {"type": "boolean", "aliases": ["aliases"], "description": "description", "cloud_data_type": "cloud_data_type", "default_value": "default_value", "link_status": "normal", "secure": true, "immutable": false, "hidden": true, "required": true, "options": ["options"], "min_value": 9, "max_value": 9, "min_length": 10, "max_length": 10, "matches": "matches", "position": 8, "group_by": "group_by", "source": "source"}, "link": "link"}], "outputs": [{"name": "name", "value": "value", "use_default": false, "metadata": {"type": "boolean", "aliases": ["aliases"], "description": "description", "cloud_data_type": "cloud_data_type", "default_value": "default_value", "link_status": "normal", "secure": true, "immutable": false, "hidden": true, "required": true, "options": ["options"], "min_value": 9, "max_value": 9, "min_length": 10, "max_length": 10, "matches": "matches", "position": 8, "group_by": "group_by", "source": "source"}, "link": "link"}], "settings": [{"name": "name", "value": "value", "use_default": false, "metadata": {"type": "boolean", "aliases": ["aliases"], "description": "description", "cloud_data_type": "cloud_data_type", "default_value": "default_value", "link_status": "normal", "secure": true, "immutable": false, "hidden": true, "required": true, "options": ["options"], "min_value": 9, "max_value": 9, "min_length": 10, "max_length": 10, "matches": "matches", "position": 8, "group_by": "group_by", "source": "source"}, "link": "link"}], "updated_at": "2019-01-01T12:00:00.000Z"}], "updated_at": "2019-01-01T12:00:00.000Z"}, "action_job_data": {"action_name": "action_name", "inputs": [{"name": "name", "value": "value", "use_default": false, "metadata": {"type": "boolean", "aliases": ["aliases"], "description": "description", "cloud_data_type": "cloud_data_type", "default_value": "default_value", "link_status": "normal", "secure": true, "immutable": false, "hidden": true, "required": true, "options": ["options"], "min_value": 9, "max_value": 9, "min_length": 10, "max_length": 10, "matches": "matches", "position": 8, "group_by": "group_by", "source": "source"}, "link": "link"}], "outputs": [{"name": "name", "value": "value", "use_default": false, "metadata": {"type": "boolean", "aliases": ["aliases"], "description": "description", "cloud_data_type": "cloud_data_type", "default_value": "default_value", "link_status": "normal", "secure": true, "immutable": false, "hidden": true, "required": true, "options": ["options"], "min_value": 9, "max_value": 9, "min_length": 10, "max_length": 10, "matches": "matches", "position": 8, "group_by": "group_by", "source": "source"}, "link": "link"}], "settings": [{"name": "name", "value": "value", "use_default": false, "metadata": {"type": "boolean", "aliases": ["aliases"], "description": "description", "cloud_data_type": "cloud_data_type", "default_value": "default_value", "link_status": "normal", "secure": true, "immutable": false, "hidden": true, "required": true, "options": ["options"], "min_value": 9, "max_value": 9, "min_length": 10, "max_length": 10, "matches": "matches", "position": 8, "group_by": "group_by", "source": "source"}, "link": "link"}], "updated_at": "2019-01-01T12:00:00.000Z", "inventory_record": {"name": "name", "id": "id", "description": "description", "location": "us-south", "resource_group": "resource_group", "created_at": "2019-01-01T12:00:00.000Z", "created_by": "created_by", "updated_at": "2019-01-01T12:00:00.000Z", "updated_by": "updated_by", "inventories_ini": "inventories_ini", "resource_queries": ["resource_queries"]}, "materialized_inventory": "materialized_inventory"}, "system_job_data": {"key_id": "key_id", "schematics_resource_id": ["schematics_resource_id"], "updated_at": "2019-01-01T12:00:00.000Z"}, "flow_job_data": {"flow_id": "flow_id", "flow_name": "flow_name", "workitems": [{"command_object_id": "command_object_id", "command_object_name": "command_object_name", "layers": "layers", "source_type": "local", "source": {"source_type": "local", "git": {"computed_git_repo_url": "computed_git_repo_url", "git_repo_url": "git_repo_url", "git_token": "git_token", "git_repo_folder": "git_repo_folder", "git_release": "git_release", "git_branch": "git_branch", "git_commit": "git_commit", "git_commit_timestamp": "git_commit_timestamp"}, "catalog": {"catalog_name": "catalog_name", "catalog_id": "catalog_id", "offering_name": "offering_name", "offering_version": "offering_version", "offering_kind": "offering_kind", "offering_target_kind": "offering_target_kind", "offering_id": "offering_id", "offering_version_id": "offering_version_id", "offering_version_flavour_name": "offering_version_flavour_name", "offering_repo_url": "offering_repo_url", "offering_provisioner_working_directory": "offering_provisioner_working_directory", "dry_run": false, "owning_account": "owning_account", "item_icon_url": "item_icon_url", "item_id": "item_id", "item_name": "item_name", "item_readme_url": "item_readme_url", "item_url": "item_url", "launch_url": "launch_url"}}, "inputs": [{"name": "name", "value": "value", "use_default": false, "metadata": {"type": "boolean", "aliases": ["aliases"], "description": "description", "cloud_data_type": "cloud_data_type", "default_value": "default_value", "link_status": "normal", "secure": true, "immutable": false, "hidden": true, "required": true, "options": ["options"], "min_value": 9, "max_value": 9, "min_length": 10, "max_length": 10, "matches": "matches", "position": 8, "group_by": "group_by", "source": "source"}, "link": "link"}], "outputs": [{"name": "name", "value": "value", "use_default": false, "metadata": {"type": "boolean", "aliases": ["aliases"], "description": "description", "cloud_data_type": "cloud_data_type", "default_value": "default_value", "link_status": "normal", "secure": true, "immutable": false, "hidden": true, "required": true, "options": ["options"], "min_value": 9, "max_value": 9, "min_length": 10, "max_length": 10, "matches": "matches", "position": 8, "group_by": "group_by", "source": "source"}, "link": "link"}], "settings": [{"name": "name", "value": "value", "use_default": false, "metadata": {"type": "boolean", "aliases": ["aliases"], "description": "description", "cloud_data_type": "cloud_data_type", "default_value": "default_value", "link_status": "normal", "secure": true, "immutable": false, "hidden": true, "required": true, "options": ["options"], "min_value": 9, "max_value": 9, "min_length": 10, "max_length": 10, "matches": "matches", "position": 8, "group_by": "group_by", "source": "source"}, "link": "link"}], "last_job": {"command_object": "workspace", "command_object_name": "command_object_name", "command_object_id": "command_object_id", "command_name": "workspace_plan", "job_id": "job_id", "job_status": "job_pending"}, "updated_at": "2019-01-01T12:00:00.000Z"}], "updated_at": "2019-01-01T12:00:00.000Z"}}, "bastion": {"name": "name", "host": "host"}, "log_summary": {"job_id": "job_id", "job_type": "repo_download_job", "log_start_at": "2019-01-01T12:00:00.000Z", "log_analyzed_till": "2019-01-01T12:00:00.000Z", "elapsed_time": 12, "log_errors": [{"error_code": "error_code", "error_msg": "error_msg", "error_count": 11}], "repo_download_job": {"scanned_file_count": 18, "quarantined_file_count": 22, "detected_filetype": "detected_filetype", "inputs_count": "inputs_count", "outputs_count": "outputs_count"}, "workspace_job": {"resources_add": 13, "resources_modify": 16, "resources_destroy": 17}, "flow_job": {"workitems_completed": 19, "workitems_pending": 17, "workitems_failed": 16, "workitems": [{"workspace_id": "workspace_id", "job_id": "job_id", "resources_add": 13, "resources_modify": 16, "resources_destroy": 17, "log_url": "log_url"}]}, "action_job": {"target_count": 12, "task_count": 10, "play_count": 10, "recap": {"target": ["target"], "ok": 2, "changed": 7, "failed": 6, "skipped": 7, "unreachable": 11}}, "system_job": {"target_count": 12, "success": 7, "failed": 6}}, "log_store_url": "log_store_url", "state_store_url": "state_store_url", "results_url": "results_url", "updated_at": "2019-01-01T12:00:00.000Z", "job_runner_id": "job_runner_id", "agent": {"id": "id", "name": "name", "assignment_policy_id": "assignment_policy_id"}}'
        responses.add(
            responses.POST,
            url,
            body=mock_response,
            content_type='application/json',
            status=201,
        )

        # Construct a dict representation of a VariableMetadata model
        variable_metadata_model = {}
        variable_metadata_model['type'] = 'boolean'
        variable_metadata_model['aliases'] = ['testString']
        variable_metadata_model['description'] = 'testString'
        variable_metadata_model['cloud_data_type'] = 'testString'
        variable_metadata_model['default_value'] = 'testString'
        variable_metadata_model['link_status'] = 'normal'
        variable_metadata_model['secure'] = True
        variable_metadata_model['immutable'] = True
        variable_metadata_model['hidden'] = True
        variable_metadata_model['required'] = True
        variable_metadata_model['options'] = ['testString']
        variable_metadata_model['min_value'] = 38
        variable_metadata_model['max_value'] = 38
        variable_metadata_model['min_length'] = 38
        variable_metadata_model['max_length'] = 38
        variable_metadata_model['matches'] = 'testString'
        variable_metadata_model['position'] = 38
        variable_metadata_model['group_by'] = 'testString'
        variable_metadata_model['source'] = 'testString'

        # Construct a dict representation of a VariableData model
        variable_data_model = {}
        variable_data_model['name'] = 'testString'
        variable_data_model['value'] = 'testString'
        variable_data_model['use_default'] = True
        variable_data_model['metadata'] = variable_metadata_model

        # Construct a dict representation of a JobStatusWorkitem model
        job_status_workitem_model = {}
        job_status_workitem_model['workspace_id'] = 'testString'
        job_status_workitem_model['workspace_name'] = 'testString'
        job_status_workitem_model['job_id'] = 'testString'
        job_status_workitem_model['status_code'] = 'job_pending'
        job_status_workitem_model['status_message'] = 'testString'
        job_status_workitem_model['updated_at'] = '2019-01-01T12:00:00Z'

        # Construct a dict representation of a JobStatusFlow model
        job_status_flow_model = {}
        job_status_flow_model['flow_id'] = 'testString'
        job_status_flow_model['flow_name'] = 'testString'
        job_status_flow_model['status_code'] = 'job_pending'
        job_status_flow_model['status_message'] = 'testString'
        job_status_flow_model['workitems'] = [job_status_workitem_model]
        job_status_flow_model['updated_at'] = '2019-01-01T12:00:00Z'

        # Construct a dict representation of a JobStatusTemplate model
        job_status_template_model = {}
        job_status_template_model['template_id'] = 'testString'
        job_status_template_model['template_name'] = 'testString'
        job_status_template_model['flow_index'] = 38
        job_status_template_model['status_code'] = 'job_pending'
        job_status_template_model['status_message'] = 'testString'
        job_status_template_model['updated_at'] = '2019-01-01T12:00:00Z'

        # Construct a dict representation of a JobStatusWorkspace model
        job_status_workspace_model = {}
        job_status_workspace_model['workspace_name'] = 'testString'
        job_status_workspace_model['status_code'] = 'job_pending'
        job_status_workspace_model['status_message'] = 'testString'
        job_status_workspace_model['flow_status'] = job_status_flow_model
        job_status_workspace_model['template_status'] = [job_status_template_model]
        job_status_workspace_model['updated_at'] = '2019-01-01T12:00:00Z'

        # Construct a dict representation of a JobStatusAction model
        job_status_action_model = {}
        job_status_action_model['action_name'] = 'testString'
        job_status_action_model['status_code'] = 'job_pending'
        job_status_action_model['status_message'] = 'testString'
        job_status_action_model['bastion_status_code'] = 'none'
        job_status_action_model['bastion_status_message'] = 'testString'
        job_status_action_model['targets_status_code'] = 'none'
        job_status_action_model['targets_status_message'] = 'testString'
        job_status_action_model['updated_at'] = '2019-01-01T12:00:00Z'

        # Construct a dict representation of a JobStatusSchematicsResources model
        job_status_schematics_resources_model = {}
        job_status_schematics_resources_model['status_code'] = 'job_pending'
        job_status_schematics_resources_model['status_message'] = 'testString'
        job_status_schematics_resources_model['schematics_resource_id'] = 'testString'
        job_status_schematics_resources_model['updated_at'] = '2019-01-01T12:00:00Z'

        # Construct a dict representation of a JobStatusSystem model
        job_status_system_model = {}
        job_status_system_model['system_status_message'] = 'testString'
        job_status_system_model['system_status_code'] = 'job_pending'
        job_status_system_model['schematics_resource_status'] = [job_status_schematics_resources_model]
        job_status_system_model['updated_at'] = '2019-01-01T12:00:00Z'

        # Construct a dict representation of a JobStatus model
        job_status_model = {}
        job_status_model['position_in_queue'] = 72.5
        job_status_model['total_in_queue'] = 72.5
        job_status_model['workspace_job_status'] = job_status_workspace_model
        job_status_model['action_job_status'] = job_status_action_model
        job_status_model['system_job_status'] = job_status_system_model
        job_status_model['flow_job_status'] = job_status_flow_model

        # Construct a dict representation of a CartOrderData model
        cart_order_data_model = {}
        cart_order_data_model['name'] = 'testString'
        cart_order_data_model['value'] = 'testString'
        cart_order_data_model['type'] = 'testString'
        cart_order_data_model['usage_kind'] = ['servicetags']

        # Construct a dict representation of a JobDataTemplate model
        job_data_template_model = {}
        job_data_template_model['template_id'] = 'testString'
        job_data_template_model['template_name'] = 'testString'
        job_data_template_model['flow_index'] = 38
        job_data_template_model['inputs'] = [variable_data_model]
        job_data_template_model['outputs'] = [variable_data_model]
        job_data_template_model['settings'] = [variable_data_model]
        job_data_template_model['updated_at'] = '2019-01-01T12:00:00Z'

        # Construct a dict representation of a JobDataWorkspace model
        job_data_workspace_model = {}
        job_data_workspace_model['workspace_name'] = 'testString'
        job_data_workspace_model['flow_id'] = 'testString'
        job_data_workspace_model['flow_name'] = 'testString'
        job_data_workspace_model['inputs'] = [variable_data_model]
        job_data_workspace_model['outputs'] = [variable_data_model]
        job_data_workspace_model['settings'] = [variable_data_model]
        job_data_workspace_model['template_data'] = [job_data_template_model]
        job_data_workspace_model['updated_at'] = '2019-01-01T12:00:00Z'

        # Construct a dict representation of a InventoryResourceRecord model
        inventory_resource_record_model = {}
        inventory_resource_record_model['name'] = 'testString'
        inventory_resource_record_model['description'] = 'testString'
        inventory_resource_record_model['location'] = 'us-south'
        inventory_resource_record_model['resource_group'] = 'testString'
        inventory_resource_record_model['inventories_ini'] = 'testString'
        inventory_resource_record_model['resource_queries'] = ['testString']

        # Construct a dict representation of a JobDataAction model
        job_data_action_model = {}
        job_data_action_model['action_name'] = 'testString'
        job_data_action_model['inputs'] = [variable_data_model]
        job_data_action_model['outputs'] = [variable_data_model]
        job_data_action_model['settings'] = [variable_data_model]
        job_data_action_model['updated_at'] = '2019-01-01T12:00:00Z'
        job_data_action_model['inventory_record'] = inventory_resource_record_model
        job_data_action_model['materialized_inventory'] = 'testString'

        # Construct a dict representation of a JobDataSystem model
        job_data_system_model = {}
        job_data_system_model['key_id'] = 'testString'
        job_data_system_model['schematics_resource_id'] = ['testString']
        job_data_system_model['updated_at'] = '2019-01-01T12:00:00Z'

        # Construct a dict representation of a GitSource model
        git_source_model = {}
        git_source_model['computed_git_repo_url'] = 'testString'
        git_source_model['git_repo_url'] = 'testString'
        git_source_model['git_token'] = 'testString'
        git_source_model['git_repo_folder'] = 'testString'
        git_source_model['git_release'] = 'testString'
        git_source_model['git_branch'] = 'testString'

        # Construct a dict representation of a CatalogSource model
        catalog_source_model = {}
        catalog_source_model['catalog_name'] = 'testString'
        catalog_source_model['catalog_id'] = 'testString'
        catalog_source_model['offering_name'] = 'testString'
        catalog_source_model['offering_version'] = 'testString'
        catalog_source_model['offering_kind'] = 'testString'
        catalog_source_model['offering_target_kind'] = 'testString'
        catalog_source_model['offering_id'] = 'testString'
        catalog_source_model['offering_version_id'] = 'testString'
        catalog_source_model['offering_version_flavour_name'] = 'testString'
        catalog_source_model['offering_repo_url'] = 'testString'
        catalog_source_model['offering_provisioner_working_directory'] = 'testString'
        catalog_source_model['dry_run'] = True
        catalog_source_model['owning_account'] = 'testString'
        catalog_source_model['item_icon_url'] = 'testString'
        catalog_source_model['item_id'] = 'testString'
        catalog_source_model['item_name'] = 'testString'
        catalog_source_model['item_readme_url'] = 'testString'
        catalog_source_model['item_url'] = 'testString'
        catalog_source_model['launch_url'] = 'testString'

        # Construct a dict representation of a ExternalSource model
        external_source_model = {}
        external_source_model['source_type'] = 'local'
        external_source_model['git'] = git_source_model
        external_source_model['catalog'] = catalog_source_model

        # Construct a dict representation of a JobDataWorkItemLastJob model
        job_data_work_item_last_job_model = {}
        job_data_work_item_last_job_model['command_object'] = 'workspace'
        job_data_work_item_last_job_model['command_object_name'] = 'testString'
        job_data_work_item_last_job_model['command_object_id'] = 'testString'
        job_data_work_item_last_job_model['command_name'] = 'workspace_plan'
        job_data_work_item_last_job_model['job_id'] = 'testString'
        job_data_work_item_last_job_model['job_status'] = 'job_pending'

        # Construct a dict representation of a JobDataWorkItem model
        job_data_work_item_model = {}
        job_data_work_item_model['command_object_id'] = 'testString'
        job_data_work_item_model['command_object_name'] = 'testString'
        job_data_work_item_model['layers'] = 'testString'
        job_data_work_item_model['source_type'] = 'local'
        job_data_work_item_model['source'] = external_source_model
        job_data_work_item_model['inputs'] = [variable_data_model]
        job_data_work_item_model['outputs'] = [variable_data_model]
        job_data_work_item_model['settings'] = [variable_data_model]
        job_data_work_item_model['last_job'] = job_data_work_item_last_job_model
        job_data_work_item_model['updated_at'] = '2019-01-01T12:00:00Z'

        # Construct a dict representation of a JobDataFlow model
        job_data_flow_model = {}
        job_data_flow_model['flow_id'] = 'testString'
        job_data_flow_model['flow_name'] = 'testString'
        job_data_flow_model['workitems'] = [job_data_work_item_model]
        job_data_flow_model['updated_at'] = '2019-01-01T12:00:00Z'

        # Construct a dict representation of a JobData model
        job_data_model = {}
        job_data_model['job_type'] = 'repo_download_job'
        job_data_model['workspace_job_data'] = job_data_workspace_model
        job_data_model['action_job_data'] = job_data_action_model
        job_data_model['system_job_data'] = job_data_system_model
        job_data_model['flow_job_data'] = job_data_flow_model

        # Construct a dict representation of a BastionResourceDefinition model
        bastion_resource_definition_model = {}
        bastion_resource_definition_model['name'] = 'testString'
        bastion_resource_definition_model['host'] = 'testString'

        # Construct a dict representation of a JobLogSummaryRepoDownloadJob model
        job_log_summary_repo_download_job_model = {}

        # Construct a dict representation of a JobLogSummaryWorkspaceJob model
        job_log_summary_workspace_job_model = {}

        # Construct a dict representation of a JobLogSummaryWorkitems model
        job_log_summary_workitems_model = {}
        job_log_summary_workitems_model['workspace_id'] = 'testString'
        job_log_summary_workitems_model['job_id'] = 'testString'
        job_log_summary_workitems_model['log_url'] = 'testString'

        # Construct a dict representation of a JobLogSummaryFlowJob model
        job_log_summary_flow_job_model = {}
        job_log_summary_flow_job_model['workitems'] = [job_log_summary_workitems_model]

        # Construct a dict representation of a JobLogSummaryActionJobRecap model
        job_log_summary_action_job_recap_model = {}
        job_log_summary_action_job_recap_model['target'] = ['testString']
        job_log_summary_action_job_recap_model['ok'] = 72.5
        job_log_summary_action_job_recap_model['changed'] = 72.5
        job_log_summary_action_job_recap_model['failed'] = 72.5
        job_log_summary_action_job_recap_model['skipped'] = 72.5
        job_log_summary_action_job_recap_model['unreachable'] = 72.5

        # Construct a dict representation of a JobLogSummaryActionJob model
        job_log_summary_action_job_model = {}
        job_log_summary_action_job_model['recap'] = job_log_summary_action_job_recap_model

        # Construct a dict representation of a JobLogSummarySystemJob model
        job_log_summary_system_job_model = {}
        job_log_summary_system_job_model['success'] = 72.5
        job_log_summary_system_job_model['failed'] = 72.5

        # Construct a dict representation of a JobLogSummary model
        job_log_summary_model = {}
        job_log_summary_model['job_type'] = 'repo_download_job'
        job_log_summary_model['repo_download_job'] = job_log_summary_repo_download_job_model
        job_log_summary_model['workspace_job'] = job_log_summary_workspace_job_model
        job_log_summary_model['flow_job'] = job_log_summary_flow_job_model
        job_log_summary_model['action_job'] = job_log_summary_action_job_model
        job_log_summary_model['system_job'] = job_log_summary_system_job_model

        # Construct a dict representation of a AgentInfo model
        agent_info_model = {}
        agent_info_model['id'] = 'testString'
        agent_info_model['name'] = 'testString'
        agent_info_model['assignment_policy_id'] = 'testString'

        # Set up parameter values
        refresh_token = 'testString'
        command_object = 'workspace'
        command_object_id = 'testString'
        command_name = 'workspace_plan'
        command_parameter = 'testString'
        command_options = ['testString']
        inputs = [variable_data_model]
        settings = [variable_data_model]
        tags = ['testString']
        location = 'us-south'
        status = job_status_model
        cart_order_data = [cart_order_data_model]
        data = job_data_model
        bastion = bastion_resource_definition_model
        log_summary = job_log_summary_model
        agent = agent_info_model

        # Invoke method
        response = _service.create_job(
            refresh_token,
            command_object=command_object,
            command_object_id=command_object_id,
            command_name=command_name,
            command_parameter=command_parameter,
            command_options=command_options,
            inputs=inputs,
            settings=settings,
            tags=tags,
            location=location,
            status=status,
            cart_order_data=cart_order_data,
            data=data,
            bastion=bastion,
            log_summary=log_summary,
            agent=agent,
            headers={},
        )

        # Check for correct operation
        assert len(responses.calls) == 1
        assert response.status_code == 201
        # Validate body params
        req_body = json.loads(str(responses.calls[0].request.body, 'utf-8'))
        assert req_body['command_object'] == 'workspace'
        assert req_body['command_object_id'] == 'testString'
        assert req_body['command_name'] == 'workspace_plan'
        assert req_body['command_parameter'] == 'testString'
        assert req_body['command_options'] == ['testString']
        assert req_body['inputs'] == [variable_data_model]
        assert req_body['settings'] == [variable_data_model]
        assert req_body['tags'] == ['testString']
        assert req_body['location'] == 'us-south'
        assert req_body['status'] == job_status_model
        assert req_body['cart_order_data'] == [cart_order_data_model]
        assert req_body['data'] == job_data_model
        assert req_body['bastion'] == bastion_resource_definition_model
        assert req_body['log_summary'] == job_log_summary_model
        assert req_body['agent'] == agent_info_model

    def test_create_job_all_params_with_retries(self):
        # Enable retries and run test_create_job_all_params.
        _service.enable_retries()
        self.test_create_job_all_params()

        # Disable retries and run test_create_job_all_params.
        _service.disable_retries()
        self.test_create_job_all_params()

    @responses.activate
    def test_create_job_value_error(self):
        """
        test_create_job_value_error()
        """
        # Set up mock
        url = preprocess_url('/v2/jobs')
        mock_response = '{"command_object": "workspace", "command_object_id": "command_object_id", "command_name": "workspace_plan", "command_parameter": "command_parameter", "command_options": ["command_options"], "inputs": [{"name": "name", "value": "value", "use_default": false, "metadata": {"type": "boolean", "aliases": ["aliases"], "description": "description", "cloud_data_type": "cloud_data_type", "default_value": "default_value", "link_status": "normal", "secure": true, "immutable": false, "hidden": true, "required": true, "options": ["options"], "min_value": 9, "max_value": 9, "min_length": 10, "max_length": 10, "matches": "matches", "position": 8, "group_by": "group_by", "source": "source"}, "link": "link"}], "settings": [{"name": "name", "value": "value", "use_default": false, "metadata": {"type": "boolean", "aliases": ["aliases"], "description": "description", "cloud_data_type": "cloud_data_type", "default_value": "default_value", "link_status": "normal", "secure": true, "immutable": false, "hidden": true, "required": true, "options": ["options"], "min_value": 9, "max_value": 9, "min_length": 10, "max_length": 10, "matches": "matches", "position": 8, "group_by": "group_by", "source": "source"}, "link": "link"}], "tags": ["tags"], "id": "id", "name": "name", "description": "description", "location": "us-south", "resource_group": "resource_group", "submitted_at": "2019-01-01T12:00:00.000Z", "submitted_by": "submitted_by", "start_at": "2019-01-01T12:00:00.000Z", "end_at": "2019-01-01T12:00:00.000Z", "duration": "duration", "status": {"position_in_queue": 17, "total_in_queue": 14, "workspace_job_status": {"workspace_name": "workspace_name", "status_code": "job_pending", "status_message": "status_message", "flow_status": {"flow_id": "flow_id", "flow_name": "flow_name", "status_code": "job_pending", "status_message": "status_message", "workitems": [{"workspace_id": "workspace_id", "workspace_name": "workspace_name", "job_id": "job_id", "status_code": "job_pending", "status_message": "status_message", "updated_at": "2019-01-01T12:00:00.000Z"}], "updated_at": "2019-01-01T12:00:00.000Z"}, "template_status": [{"template_id": "template_id", "template_name": "template_name", "flow_index": 10, "status_code": "job_pending", "status_message": "status_message", "updated_at": "2019-01-01T12:00:00.000Z"}], "updated_at": "2019-01-01T12:00:00.000Z", "commands": [{"name": "name", "outcome": "outcome"}]}, "action_job_status": {"action_name": "action_name", "status_code": "job_pending", "status_message": "status_message", "bastion_status_code": "none", "bastion_status_message": "bastion_status_message", "targets_status_code": "none", "targets_status_message": "targets_status_message", "updated_at": "2019-01-01T12:00:00.000Z"}, "system_job_status": {"system_status_message": "system_status_message", "system_status_code": "job_pending", "schematics_resource_status": [{"status_code": "job_pending", "status_message": "status_message", "schematics_resource_id": "schematics_resource_id", "updated_at": "2019-01-01T12:00:00.000Z"}], "updated_at": "2019-01-01T12:00:00.000Z"}, "flow_job_status": {"flow_id": "flow_id", "flow_name": "flow_name", "status_code": "job_pending", "status_message": "status_message", "workitems": [{"workspace_id": "workspace_id", "workspace_name": "workspace_name", "job_id": "job_id", "status_code": "job_pending", "status_message": "status_message", "updated_at": "2019-01-01T12:00:00.000Z"}], "updated_at": "2019-01-01T12:00:00.000Z"}}, "cart_order_data": [{"name": "name", "value": "value", "type": "type", "usage_kind": ["servicetags"]}], "data": {"job_type": "repo_download_job", "workspace_job_data": {"workspace_name": "workspace_name", "flow_id": "flow_id", "flow_name": "flow_name", "inputs": [{"name": "name", "value": "value", "use_default": false, "metadata": {"type": "boolean", "aliases": ["aliases"], "description": "description", "cloud_data_type": "cloud_data_type", "default_value": "default_value", "link_status": "normal", "secure": true, "immutable": false, "hidden": true, "required": true, "options": ["options"], "min_value": 9, "max_value": 9, "min_length": 10, "max_length": 10, "matches": "matches", "position": 8, "group_by": "group_by", "source": "source"}, "link": "link"}], "outputs": [{"name": "name", "value": "value", "use_default": false, "metadata": {"type": "boolean", "aliases": ["aliases"], "description": "description", "cloud_data_type": "cloud_data_type", "default_value": "default_value", "link_status": "normal", "secure": true, "immutable": false, "hidden": true, "required": true, "options": ["options"], "min_value": 9, "max_value": 9, "min_length": 10, "max_length": 10, "matches": "matches", "position": 8, "group_by": "group_by", "source": "source"}, "link": "link"}], "settings": [{"name": "name", "value": "value", "use_default": false, "metadata": {"type": "boolean", "aliases": ["aliases"], "description": "description", "cloud_data_type": "cloud_data_type", "default_value": "default_value", "link_status": "normal", "secure": true, "immutable": false, "hidden": true, "required": true, "options": ["options"], "min_value": 9, "max_value": 9, "min_length": 10, "max_length": 10, "matches": "matches", "position": 8, "group_by": "group_by", "source": "source"}, "link": "link"}], "template_data": [{"template_id": "template_id", "template_name": "template_name", "flow_index": 10, "inputs": [{"name": "name", "value": "value", "use_default": false, "metadata": {"type": "boolean", "aliases": ["aliases"], "description": "description", "cloud_data_type": "cloud_data_type", "default_value": "default_value", "link_status": "normal", "secure": true, "immutable": false, "hidden": true, "required": true, "options": ["options"], "min_value": 9, "max_value": 9, "min_length": 10, "max_length": 10, "matches": "matches", "position": 8, "group_by": "group_by", "source": "source"}, "link": "link"}], "outputs": [{"name": "name", "value": "value", "use_default": false, "metadata": {"type": "boolean", "aliases": ["aliases"], "description": "description", "cloud_data_type": "cloud_data_type", "default_value": "default_value", "link_status": "normal", "secure": true, "immutable": false, "hidden": true, "required": true, "options": ["options"], "min_value": 9, "max_value": 9, "min_length": 10, "max_length": 10, "matches": "matches", "position": 8, "group_by": "group_by", "source": "source"}, "link": "link"}], "settings": [{"name": "name", "value": "value", "use_default": false, "metadata": {"type": "boolean", "aliases": ["aliases"], "description": "description", "cloud_data_type": "cloud_data_type", "default_value": "default_value", "link_status": "normal", "secure": true, "immutable": false, "hidden": true, "required": true, "options": ["options"], "min_value": 9, "max_value": 9, "min_length": 10, "max_length": 10, "matches": "matches", "position": 8, "group_by": "group_by", "source": "source"}, "link": "link"}], "updated_at": "2019-01-01T12:00:00.000Z"}], "updated_at": "2019-01-01T12:00:00.000Z"}, "action_job_data": {"action_name": "action_name", "inputs": [{"name": "name", "value": "value", "use_default": false, "metadata": {"type": "boolean", "aliases": ["aliases"], "description": "description", "cloud_data_type": "cloud_data_type", "default_value": "default_value", "link_status": "normal", "secure": true, "immutable": false, "hidden": true, "required": true, "options": ["options"], "min_value": 9, "max_value": 9, "min_length": 10, "max_length": 10, "matches": "matches", "position": 8, "group_by": "group_by", "source": "source"}, "link": "link"}], "outputs": [{"name": "name", "value": "value", "use_default": false, "metadata": {"type": "boolean", "aliases": ["aliases"], "description": "description", "cloud_data_type": "cloud_data_type", "default_value": "default_value", "link_status": "normal", "secure": true, "immutable": false, "hidden": true, "required": true, "options": ["options"], "min_value": 9, "max_value": 9, "min_length": 10, "max_length": 10, "matches": "matches", "position": 8, "group_by": "group_by", "source": "source"}, "link": "link"}], "settings": [{"name": "name", "value": "value", "use_default": false, "metadata": {"type": "boolean", "aliases": ["aliases"], "description": "description", "cloud_data_type": "cloud_data_type", "default_value": "default_value", "link_status": "normal", "secure": true, "immutable": false, "hidden": true, "required": true, "options": ["options"], "min_value": 9, "max_value": 9, "min_length": 10, "max_length": 10, "matches": "matches", "position": 8, "group_by": "group_by", "source": "source"}, "link": "link"}], "updated_at": "2019-01-01T12:00:00.000Z", "inventory_record": {"name": "name", "id": "id", "description": "description", "location": "us-south", "resource_group": "resource_group", "created_at": "2019-01-01T12:00:00.000Z", "created_by": "created_by", "updated_at": "2019-01-01T12:00:00.000Z", "updated_by": "updated_by", "inventories_ini": "inventories_ini", "resource_queries": ["resource_queries"]}, "materialized_inventory": "materialized_inventory"}, "system_job_data": {"key_id": "key_id", "schematics_resource_id": ["schematics_resource_id"], "updated_at": "2019-01-01T12:00:00.000Z"}, "flow_job_data": {"flow_id": "flow_id", "flow_name": "flow_name", "workitems": [{"command_object_id": "command_object_id", "command_object_name": "command_object_name", "layers": "layers", "source_type": "local", "source": {"source_type": "local", "git": {"computed_git_repo_url": "computed_git_repo_url", "git_repo_url": "git_repo_url", "git_token": "git_token", "git_repo_folder": "git_repo_folder", "git_release": "git_release", "git_branch": "git_branch", "git_commit": "git_commit", "git_commit_timestamp": "git_commit_timestamp"}, "catalog": {"catalog_name": "catalog_name", "catalog_id": "catalog_id", "offering_name": "offering_name", "offering_version": "offering_version", "offering_kind": "offering_kind", "offering_target_kind": "offering_target_kind", "offering_id": "offering_id", "offering_version_id": "offering_version_id", "offering_version_flavour_name": "offering_version_flavour_name", "offering_repo_url": "offering_repo_url", "offering_provisioner_working_directory": "offering_provisioner_working_directory", "dry_run": false, "owning_account": "owning_account", "item_icon_url": "item_icon_url", "item_id": "item_id", "item_name": "item_name", "item_readme_url": "item_readme_url", "item_url": "item_url", "launch_url": "launch_url"}}, "inputs": [{"name": "name", "value": "value", "use_default": false, "metadata": {"type": "boolean", "aliases": ["aliases"], "description": "description", "cloud_data_type": "cloud_data_type", "default_value": "default_value", "link_status": "normal", "secure": true, "immutable": false, "hidden": true, "required": true, "options": ["options"], "min_value": 9, "max_value": 9, "min_length": 10, "max_length": 10, "matches": "matches", "position": 8, "group_by": "group_by", "source": "source"}, "link": "link"}], "outputs": [{"name": "name", "value": "value", "use_default": false, "metadata": {"type": "boolean", "aliases": ["aliases"], "description": "description", "cloud_data_type": "cloud_data_type", "default_value": "default_value", "link_status": "normal", "secure": true, "immutable": false, "hidden": true, "required": true, "options": ["options"], "min_value": 9, "max_value": 9, "min_length": 10, "max_length": 10, "matches": "matches", "position": 8, "group_by": "group_by", "source": "source"}, "link": "link"}], "settings": [{"name": "name", "value": "value", "use_default": false, "metadata": {"type": "boolean", "aliases": ["aliases"], "description": "description", "cloud_data_type": "cloud_data_type", "default_value": "default_value", "link_status": "normal", "secure": true, "immutable": false, "hidden": true, "required": true, "options": ["options"], "min_value": 9, "max_value": 9, "min_length": 10, "max_length": 10, "matches": "matches", "position": 8, "group_by": "group_by", "source": "source"}, "link": "link"}], "last_job": {"command_object": "workspace", "command_object_name": "command_object_name", "command_object_id": "command_object_id", "command_name": "workspace_plan", "job_id": "job_id", "job_status": "job_pending"}, "updated_at": "2019-01-01T12:00:00.000Z"}], "updated_at": "2019-01-01T12:00:00.000Z"}}, "bastion": {"name": "name", "host": "host"}, "log_summary": {"job_id": "job_id", "job_type": "repo_download_job", "log_start_at": "2019-01-01T12:00:00.000Z", "log_analyzed_till": "2019-01-01T12:00:00.000Z", "elapsed_time": 12, "log_errors": [{"error_code": "error_code", "error_msg": "error_msg", "error_count": 11}], "repo_download_job": {"scanned_file_count": 18, "quarantined_file_count": 22, "detected_filetype": "detected_filetype", "inputs_count": "inputs_count", "outputs_count": "outputs_count"}, "workspace_job": {"resources_add": 13, "resources_modify": 16, "resources_destroy": 17}, "flow_job": {"workitems_completed": 19, "workitems_pending": 17, "workitems_failed": 16, "workitems": [{"workspace_id": "workspace_id", "job_id": "job_id", "resources_add": 13, "resources_modify": 16, "resources_destroy": 17, "log_url": "log_url"}]}, "action_job": {"target_count": 12, "task_count": 10, "play_count": 10, "recap": {"target": ["target"], "ok": 2, "changed": 7, "failed": 6, "skipped": 7, "unreachable": 11}}, "system_job": {"target_count": 12, "success": 7, "failed": 6}}, "log_store_url": "log_store_url", "state_store_url": "state_store_url", "results_url": "results_url", "updated_at": "2019-01-01T12:00:00.000Z", "job_runner_id": "job_runner_id", "agent": {"id": "id", "name": "name", "assignment_policy_id": "assignment_policy_id"}}'
        responses.add(
            responses.POST,
            url,
            body=mock_response,
            content_type='application/json',
            status=201,
        )

        # Construct a dict representation of a VariableMetadata model
        variable_metadata_model = {}
        variable_metadata_model['type'] = 'boolean'
        variable_metadata_model['aliases'] = ['testString']
        variable_metadata_model['description'] = 'testString'
        variable_metadata_model['cloud_data_type'] = 'testString'
        variable_metadata_model['default_value'] = 'testString'
        variable_metadata_model['link_status'] = 'normal'
        variable_metadata_model['secure'] = True
        variable_metadata_model['immutable'] = True
        variable_metadata_model['hidden'] = True
        variable_metadata_model['required'] = True
        variable_metadata_model['options'] = ['testString']
        variable_metadata_model['min_value'] = 38
        variable_metadata_model['max_value'] = 38
        variable_metadata_model['min_length'] = 38
        variable_metadata_model['max_length'] = 38
        variable_metadata_model['matches'] = 'testString'
        variable_metadata_model['position'] = 38
        variable_metadata_model['group_by'] = 'testString'
        variable_metadata_model['source'] = 'testString'

        # Construct a dict representation of a VariableData model
        variable_data_model = {}
        variable_data_model['name'] = 'testString'
        variable_data_model['value'] = 'testString'
        variable_data_model['use_default'] = True
        variable_data_model['metadata'] = variable_metadata_model

        # Construct a dict representation of a JobStatusWorkitem model
        job_status_workitem_model = {}
        job_status_workitem_model['workspace_id'] = 'testString'
        job_status_workitem_model['workspace_name'] = 'testString'
        job_status_workitem_model['job_id'] = 'testString'
        job_status_workitem_model['status_code'] = 'job_pending'
        job_status_workitem_model['status_message'] = 'testString'
        job_status_workitem_model['updated_at'] = '2019-01-01T12:00:00Z'

        # Construct a dict representation of a JobStatusFlow model
        job_status_flow_model = {}
        job_status_flow_model['flow_id'] = 'testString'
        job_status_flow_model['flow_name'] = 'testString'
        job_status_flow_model['status_code'] = 'job_pending'
        job_status_flow_model['status_message'] = 'testString'
        job_status_flow_model['workitems'] = [job_status_workitem_model]
        job_status_flow_model['updated_at'] = '2019-01-01T12:00:00Z'

        # Construct a dict representation of a JobStatusTemplate model
        job_status_template_model = {}
        job_status_template_model['template_id'] = 'testString'
        job_status_template_model['template_name'] = 'testString'
        job_status_template_model['flow_index'] = 38
        job_status_template_model['status_code'] = 'job_pending'
        job_status_template_model['status_message'] = 'testString'
        job_status_template_model['updated_at'] = '2019-01-01T12:00:00Z'

        # Construct a dict representation of a JobStatusWorkspace model
        job_status_workspace_model = {}
        job_status_workspace_model['workspace_name'] = 'testString'
        job_status_workspace_model['status_code'] = 'job_pending'
        job_status_workspace_model['status_message'] = 'testString'
        job_status_workspace_model['flow_status'] = job_status_flow_model
        job_status_workspace_model['template_status'] = [job_status_template_model]
        job_status_workspace_model['updated_at'] = '2019-01-01T12:00:00Z'

        # Construct a dict representation of a JobStatusAction model
        job_status_action_model = {}
        job_status_action_model['action_name'] = 'testString'
        job_status_action_model['status_code'] = 'job_pending'
        job_status_action_model['status_message'] = 'testString'
        job_status_action_model['bastion_status_code'] = 'none'
        job_status_action_model['bastion_status_message'] = 'testString'
        job_status_action_model['targets_status_code'] = 'none'
        job_status_action_model['targets_status_message'] = 'testString'
        job_status_action_model['updated_at'] = '2019-01-01T12:00:00Z'

        # Construct a dict representation of a JobStatusSchematicsResources model
        job_status_schematics_resources_model = {}
        job_status_schematics_resources_model['status_code'] = 'job_pending'
        job_status_schematics_resources_model['status_message'] = 'testString'
        job_status_schematics_resources_model['schematics_resource_id'] = 'testString'
        job_status_schematics_resources_model['updated_at'] = '2019-01-01T12:00:00Z'

        # Construct a dict representation of a JobStatusSystem model
        job_status_system_model = {}
        job_status_system_model['system_status_message'] = 'testString'
        job_status_system_model['system_status_code'] = 'job_pending'
        job_status_system_model['schematics_resource_status'] = [job_status_schematics_resources_model]
        job_status_system_model['updated_at'] = '2019-01-01T12:00:00Z'

        # Construct a dict representation of a JobStatus model
        job_status_model = {}
        job_status_model['position_in_queue'] = 72.5
        job_status_model['total_in_queue'] = 72.5
        job_status_model['workspace_job_status'] = job_status_workspace_model
        job_status_model['action_job_status'] = job_status_action_model
        job_status_model['system_job_status'] = job_status_system_model
        job_status_model['flow_job_status'] = job_status_flow_model

        # Construct a dict representation of a CartOrderData model
        cart_order_data_model = {}
        cart_order_data_model['name'] = 'testString'
        cart_order_data_model['value'] = 'testString'
        cart_order_data_model['type'] = 'testString'
        cart_order_data_model['usage_kind'] = ['servicetags']

        # Construct a dict representation of a JobDataTemplate model
        job_data_template_model = {}
        job_data_template_model['template_id'] = 'testString'
        job_data_template_model['template_name'] = 'testString'
        job_data_template_model['flow_index'] = 38
        job_data_template_model['inputs'] = [variable_data_model]
        job_data_template_model['outputs'] = [variable_data_model]
        job_data_template_model['settings'] = [variable_data_model]
        job_data_template_model['updated_at'] = '2019-01-01T12:00:00Z'

        # Construct a dict representation of a JobDataWorkspace model
        job_data_workspace_model = {}
        job_data_workspace_model['workspace_name'] = 'testString'
        job_data_workspace_model['flow_id'] = 'testString'
        job_data_workspace_model['flow_name'] = 'testString'
        job_data_workspace_model['inputs'] = [variable_data_model]
        job_data_workspace_model['outputs'] = [variable_data_model]
        job_data_workspace_model['settings'] = [variable_data_model]
        job_data_workspace_model['template_data'] = [job_data_template_model]
        job_data_workspace_model['updated_at'] = '2019-01-01T12:00:00Z'

        # Construct a dict representation of a InventoryResourceRecord model
        inventory_resource_record_model = {}
        inventory_resource_record_model['name'] = 'testString'
        inventory_resource_record_model['description'] = 'testString'
        inventory_resource_record_model['location'] = 'us-south'
        inventory_resource_record_model['resource_group'] = 'testString'
        inventory_resource_record_model['inventories_ini'] = 'testString'
        inventory_resource_record_model['resource_queries'] = ['testString']

        # Construct a dict representation of a JobDataAction model
        job_data_action_model = {}
        job_data_action_model['action_name'] = 'testString'
        job_data_action_model['inputs'] = [variable_data_model]
        job_data_action_model['outputs'] = [variable_data_model]
        job_data_action_model['settings'] = [variable_data_model]
        job_data_action_model['updated_at'] = '2019-01-01T12:00:00Z'
        job_data_action_model['inventory_record'] = inventory_resource_record_model
        job_data_action_model['materialized_inventory'] = 'testString'

        # Construct a dict representation of a JobDataSystem model
        job_data_system_model = {}
        job_data_system_model['key_id'] = 'testString'
        job_data_system_model['schematics_resource_id'] = ['testString']
        job_data_system_model['updated_at'] = '2019-01-01T12:00:00Z'

        # Construct a dict representation of a GitSource model
        git_source_model = {}
        git_source_model['computed_git_repo_url'] = 'testString'
        git_source_model['git_repo_url'] = 'testString'
        git_source_model['git_token'] = 'testString'
        git_source_model['git_repo_folder'] = 'testString'
        git_source_model['git_release'] = 'testString'
        git_source_model['git_branch'] = 'testString'

        # Construct a dict representation of a CatalogSource model
        catalog_source_model = {}
        catalog_source_model['catalog_name'] = 'testString'
        catalog_source_model['catalog_id'] = 'testString'
        catalog_source_model['offering_name'] = 'testString'
        catalog_source_model['offering_version'] = 'testString'
        catalog_source_model['offering_kind'] = 'testString'
        catalog_source_model['offering_target_kind'] = 'testString'
        catalog_source_model['offering_id'] = 'testString'
        catalog_source_model['offering_version_id'] = 'testString'
        catalog_source_model['offering_version_flavour_name'] = 'testString'
        catalog_source_model['offering_repo_url'] = 'testString'
        catalog_source_model['offering_provisioner_working_directory'] = 'testString'
        catalog_source_model['dry_run'] = True
        catalog_source_model['owning_account'] = 'testString'
        catalog_source_model['item_icon_url'] = 'testString'
        catalog_source_model['item_id'] = 'testString'
        catalog_source_model['item_name'] = 'testString'
        catalog_source_model['item_readme_url'] = 'testString'
        catalog_source_model['item_url'] = 'testString'
        catalog_source_model['launch_url'] = 'testString'

        # Construct a dict representation of a ExternalSource model
        external_source_model = {}
        external_source_model['source_type'] = 'local'
        external_source_model['git'] = git_source_model
        external_source_model['catalog'] = catalog_source_model

        # Construct a dict representation of a JobDataWorkItemLastJob model
        job_data_work_item_last_job_model = {}
        job_data_work_item_last_job_model['command_object'] = 'workspace'
        job_data_work_item_last_job_model['command_object_name'] = 'testString'
        job_data_work_item_last_job_model['command_object_id'] = 'testString'
        job_data_work_item_last_job_model['command_name'] = 'workspace_plan'
        job_data_work_item_last_job_model['job_id'] = 'testString'
        job_data_work_item_last_job_model['job_status'] = 'job_pending'

        # Construct a dict representation of a JobDataWorkItem model
        job_data_work_item_model = {}
        job_data_work_item_model['command_object_id'] = 'testString'
        job_data_work_item_model['command_object_name'] = 'testString'
        job_data_work_item_model['layers'] = 'testString'
        job_data_work_item_model['source_type'] = 'local'
        job_data_work_item_model['source'] = external_source_model
        job_data_work_item_model['inputs'] = [variable_data_model]
        job_data_work_item_model['outputs'] = [variable_data_model]
        job_data_work_item_model['settings'] = [variable_data_model]
        job_data_work_item_model['last_job'] = job_data_work_item_last_job_model
        job_data_work_item_model['updated_at'] = '2019-01-01T12:00:00Z'

        # Construct a dict representation of a JobDataFlow model
        job_data_flow_model = {}
        job_data_flow_model['flow_id'] = 'testString'
        job_data_flow_model['flow_name'] = 'testString'
        job_data_flow_model['workitems'] = [job_data_work_item_model]
        job_data_flow_model['updated_at'] = '2019-01-01T12:00:00Z'

        # Construct a dict representation of a JobData model
        job_data_model = {}
        job_data_model['job_type'] = 'repo_download_job'
        job_data_model['workspace_job_data'] = job_data_workspace_model
        job_data_model['action_job_data'] = job_data_action_model
        job_data_model['system_job_data'] = job_data_system_model
        job_data_model['flow_job_data'] = job_data_flow_model

        # Construct a dict representation of a BastionResourceDefinition model
        bastion_resource_definition_model = {}
        bastion_resource_definition_model['name'] = 'testString'
        bastion_resource_definition_model['host'] = 'testString'

        # Construct a dict representation of a JobLogSummaryRepoDownloadJob model
        job_log_summary_repo_download_job_model = {}

        # Construct a dict representation of a JobLogSummaryWorkspaceJob model
        job_log_summary_workspace_job_model = {}

        # Construct a dict representation of a JobLogSummaryWorkitems model
        job_log_summary_workitems_model = {}
        job_log_summary_workitems_model['workspace_id'] = 'testString'
        job_log_summary_workitems_model['job_id'] = 'testString'
        job_log_summary_workitems_model['log_url'] = 'testString'

        # Construct a dict representation of a JobLogSummaryFlowJob model
        job_log_summary_flow_job_model = {}
        job_log_summary_flow_job_model['workitems'] = [job_log_summary_workitems_model]

        # Construct a dict representation of a JobLogSummaryActionJobRecap model
        job_log_summary_action_job_recap_model = {}
        job_log_summary_action_job_recap_model['target'] = ['testString']
        job_log_summary_action_job_recap_model['ok'] = 72.5
        job_log_summary_action_job_recap_model['changed'] = 72.5
        job_log_summary_action_job_recap_model['failed'] = 72.5
        job_log_summary_action_job_recap_model['skipped'] = 72.5
        job_log_summary_action_job_recap_model['unreachable'] = 72.5

        # Construct a dict representation of a JobLogSummaryActionJob model
        job_log_summary_action_job_model = {}
        job_log_summary_action_job_model['recap'] = job_log_summary_action_job_recap_model

        # Construct a dict representation of a JobLogSummarySystemJob model
        job_log_summary_system_job_model = {}
        job_log_summary_system_job_model['success'] = 72.5
        job_log_summary_system_job_model['failed'] = 72.5

        # Construct a dict representation of a JobLogSummary model
        job_log_summary_model = {}
        job_log_summary_model['job_type'] = 'repo_download_job'
        job_log_summary_model['repo_download_job'] = job_log_summary_repo_download_job_model
        job_log_summary_model['workspace_job'] = job_log_summary_workspace_job_model
        job_log_summary_model['flow_job'] = job_log_summary_flow_job_model
        job_log_summary_model['action_job'] = job_log_summary_action_job_model
        job_log_summary_model['system_job'] = job_log_summary_system_job_model

        # Construct a dict representation of a AgentInfo model
        agent_info_model = {}
        agent_info_model['id'] = 'testString'
        agent_info_model['name'] = 'testString'
        agent_info_model['assignment_policy_id'] = 'testString'

        # Set up parameter values
        refresh_token = 'testString'
        command_object = 'workspace'
        command_object_id = 'testString'
        command_name = 'workspace_plan'
        command_parameter = 'testString'
        command_options = ['testString']
        inputs = [variable_data_model]
        settings = [variable_data_model]
        tags = ['testString']
        location = 'us-south'
        status = job_status_model
        cart_order_data = [cart_order_data_model]
        data = job_data_model
        bastion = bastion_resource_definition_model
        log_summary = job_log_summary_model
        agent = agent_info_model

        # Pass in all but one required param and check for a ValueError
        req_param_dict = {
            "refresh_token": refresh_token,
        }
        for param in req_param_dict.keys():
            req_copy = {key: val if key is not param else None for (key, val) in req_param_dict.items()}
            with pytest.raises(ValueError):
                _service.create_job(**req_copy)

    def test_create_job_value_error_with_retries(self):
        # Enable retries and run test_create_job_value_error.
        _service.enable_retries()
        self.test_create_job_value_error()

        # Disable retries and run test_create_job_value_error.
        _service.disable_retries()
        self.test_create_job_value_error()


class TestGetJob:
    """
    Test Class for get_job
    """

    @responses.activate
    def test_get_job_all_params(self):
        """
        get_job()
        """
        # Set up mock
        url = preprocess_url('/v2/jobs/testString')
        mock_response = '{"command_object": "workspace", "command_object_id": "command_object_id", "command_name": "workspace_plan", "command_parameter": "command_parameter", "command_options": ["command_options"], "inputs": [{"name": "name", "value": "value", "use_default": false, "metadata": {"type": "boolean", "aliases": ["aliases"], "description": "description", "cloud_data_type": "cloud_data_type", "default_value": "default_value", "link_status": "normal", "secure": true, "immutable": false, "hidden": true, "required": true, "options": ["options"], "min_value": 9, "max_value": 9, "min_length": 10, "max_length": 10, "matches": "matches", "position": 8, "group_by": "group_by", "source": "source"}, "link": "link"}], "settings": [{"name": "name", "value": "value", "use_default": false, "metadata": {"type": "boolean", "aliases": ["aliases"], "description": "description", "cloud_data_type": "cloud_data_type", "default_value": "default_value", "link_status": "normal", "secure": true, "immutable": false, "hidden": true, "required": true, "options": ["options"], "min_value": 9, "max_value": 9, "min_length": 10, "max_length": 10, "matches": "matches", "position": 8, "group_by": "group_by", "source": "source"}, "link": "link"}], "tags": ["tags"], "id": "id", "name": "name", "description": "description", "location": "us-south", "resource_group": "resource_group", "submitted_at": "2019-01-01T12:00:00.000Z", "submitted_by": "submitted_by", "start_at": "2019-01-01T12:00:00.000Z", "end_at": "2019-01-01T12:00:00.000Z", "duration": "duration", "status": {"position_in_queue": 17, "total_in_queue": 14, "workspace_job_status": {"workspace_name": "workspace_name", "status_code": "job_pending", "status_message": "status_message", "flow_status": {"flow_id": "flow_id", "flow_name": "flow_name", "status_code": "job_pending", "status_message": "status_message", "workitems": [{"workspace_id": "workspace_id", "workspace_name": "workspace_name", "job_id": "job_id", "status_code": "job_pending", "status_message": "status_message", "updated_at": "2019-01-01T12:00:00.000Z"}], "updated_at": "2019-01-01T12:00:00.000Z"}, "template_status": [{"template_id": "template_id", "template_name": "template_name", "flow_index": 10, "status_code": "job_pending", "status_message": "status_message", "updated_at": "2019-01-01T12:00:00.000Z"}], "updated_at": "2019-01-01T12:00:00.000Z", "commands": [{"name": "name", "outcome": "outcome"}]}, "action_job_status": {"action_name": "action_name", "status_code": "job_pending", "status_message": "status_message", "bastion_status_code": "none", "bastion_status_message": "bastion_status_message", "targets_status_code": "none", "targets_status_message": "targets_status_message", "updated_at": "2019-01-01T12:00:00.000Z"}, "system_job_status": {"system_status_message": "system_status_message", "system_status_code": "job_pending", "schematics_resource_status": [{"status_code": "job_pending", "status_message": "status_message", "schematics_resource_id": "schematics_resource_id", "updated_at": "2019-01-01T12:00:00.000Z"}], "updated_at": "2019-01-01T12:00:00.000Z"}, "flow_job_status": {"flow_id": "flow_id", "flow_name": "flow_name", "status_code": "job_pending", "status_message": "status_message", "workitems": [{"workspace_id": "workspace_id", "workspace_name": "workspace_name", "job_id": "job_id", "status_code": "job_pending", "status_message": "status_message", "updated_at": "2019-01-01T12:00:00.000Z"}], "updated_at": "2019-01-01T12:00:00.000Z"}}, "cart_order_data": [{"name": "name", "value": "value", "type": "type", "usage_kind": ["servicetags"]}], "data": {"job_type": "repo_download_job", "workspace_job_data": {"workspace_name": "workspace_name", "flow_id": "flow_id", "flow_name": "flow_name", "inputs": [{"name": "name", "value": "value", "use_default": false, "metadata": {"type": "boolean", "aliases": ["aliases"], "description": "description", "cloud_data_type": "cloud_data_type", "default_value": "default_value", "link_status": "normal", "secure": true, "immutable": false, "hidden": true, "required": true, "options": ["options"], "min_value": 9, "max_value": 9, "min_length": 10, "max_length": 10, "matches": "matches", "position": 8, "group_by": "group_by", "source": "source"}, "link": "link"}], "outputs": [{"name": "name", "value": "value", "use_default": false, "metadata": {"type": "boolean", "aliases": ["aliases"], "description": "description", "cloud_data_type": "cloud_data_type", "default_value": "default_value", "link_status": "normal", "secure": true, "immutable": false, "hidden": true, "required": true, "options": ["options"], "min_value": 9, "max_value": 9, "min_length": 10, "max_length": 10, "matches": "matches", "position": 8, "group_by": "group_by", "source": "source"}, "link": "link"}], "settings": [{"name": "name", "value": "value", "use_default": false, "metadata": {"type": "boolean", "aliases": ["aliases"], "description": "description", "cloud_data_type": "cloud_data_type", "default_value": "default_value", "link_status": "normal", "secure": true, "immutable": false, "hidden": true, "required": true, "options": ["options"], "min_value": 9, "max_value": 9, "min_length": 10, "max_length": 10, "matches": "matches", "position": 8, "group_by": "group_by", "source": "source"}, "link": "link"}], "template_data": [{"template_id": "template_id", "template_name": "template_name", "flow_index": 10, "inputs": [{"name": "name", "value": "value", "use_default": false, "metadata": {"type": "boolean", "aliases": ["aliases"], "description": "description", "cloud_data_type": "cloud_data_type", "default_value": "default_value", "link_status": "normal", "secure": true, "immutable": false, "hidden": true, "required": true, "options": ["options"], "min_value": 9, "max_value": 9, "min_length": 10, "max_length": 10, "matches": "matches", "position": 8, "group_by": "group_by", "source": "source"}, "link": "link"}], "outputs": [{"name": "name", "value": "value", "use_default": false, "metadata": {"type": "boolean", "aliases": ["aliases"], "description": "description", "cloud_data_type": "cloud_data_type", "default_value": "default_value", "link_status": "normal", "secure": true, "immutable": false, "hidden": true, "required": true, "options": ["options"], "min_value": 9, "max_value": 9, "min_length": 10, "max_length": 10, "matches": "matches", "position": 8, "group_by": "group_by", "source": "source"}, "link": "link"}], "settings": [{"name": "name", "value": "value", "use_default": false, "metadata": {"type": "boolean", "aliases": ["aliases"], "description": "description", "cloud_data_type": "cloud_data_type", "default_value": "default_value", "link_status": "normal", "secure": true, "immutable": false, "hidden": true, "required": true, "options": ["options"], "min_value": 9, "max_value": 9, "min_length": 10, "max_length": 10, "matches": "matches", "position": 8, "group_by": "group_by", "source": "source"}, "link": "link"}], "updated_at": "2019-01-01T12:00:00.000Z"}], "updated_at": "2019-01-01T12:00:00.000Z"}, "action_job_data": {"action_name": "action_name", "inputs": [{"name": "name", "value": "value", "use_default": false, "metadata": {"type": "boolean", "aliases": ["aliases"], "description": "description", "cloud_data_type": "cloud_data_type", "default_value": "default_value", "link_status": "normal", "secure": true, "immutable": false, "hidden": true, "required": true, "options": ["options"], "min_value": 9, "max_value": 9, "min_length": 10, "max_length": 10, "matches": "matches", "position": 8, "group_by": "group_by", "source": "source"}, "link": "link"}], "outputs": [{"name": "name", "value": "value", "use_default": false, "metadata": {"type": "boolean", "aliases": ["aliases"], "description": "description", "cloud_data_type": "cloud_data_type", "default_value": "default_value", "link_status": "normal", "secure": true, "immutable": false, "hidden": true, "required": true, "options": ["options"], "min_value": 9, "max_value": 9, "min_length": 10, "max_length": 10, "matches": "matches", "position": 8, "group_by": "group_by", "source": "source"}, "link": "link"}], "settings": [{"name": "name", "value": "value", "use_default": false, "metadata": {"type": "boolean", "aliases": ["aliases"], "description": "description", "cloud_data_type": "cloud_data_type", "default_value": "default_value", "link_status": "normal", "secure": true, "immutable": false, "hidden": true, "required": true, "options": ["options"], "min_value": 9, "max_value": 9, "min_length": 10, "max_length": 10, "matches": "matches", "position": 8, "group_by": "group_by", "source": "source"}, "link": "link"}], "updated_at": "2019-01-01T12:00:00.000Z", "inventory_record": {"name": "name", "id": "id", "description": "description", "location": "us-south", "resource_group": "resource_group", "created_at": "2019-01-01T12:00:00.000Z", "created_by": "created_by", "updated_at": "2019-01-01T12:00:00.000Z", "updated_by": "updated_by", "inventories_ini": "inventories_ini", "resource_queries": ["resource_queries"]}, "materialized_inventory": "materialized_inventory"}, "system_job_data": {"key_id": "key_id", "schematics_resource_id": ["schematics_resource_id"], "updated_at": "2019-01-01T12:00:00.000Z"}, "flow_job_data": {"flow_id": "flow_id", "flow_name": "flow_name", "workitems": [{"command_object_id": "command_object_id", "command_object_name": "command_object_name", "layers": "layers", "source_type": "local", "source": {"source_type": "local", "git": {"computed_git_repo_url": "computed_git_repo_url", "git_repo_url": "git_repo_url", "git_token": "git_token", "git_repo_folder": "git_repo_folder", "git_release": "git_release", "git_branch": "git_branch", "git_commit": "git_commit", "git_commit_timestamp": "git_commit_timestamp"}, "catalog": {"catalog_name": "catalog_name", "catalog_id": "catalog_id", "offering_name": "offering_name", "offering_version": "offering_version", "offering_kind": "offering_kind", "offering_target_kind": "offering_target_kind", "offering_id": "offering_id", "offering_version_id": "offering_version_id", "offering_version_flavour_name": "offering_version_flavour_name", "offering_repo_url": "offering_repo_url", "offering_provisioner_working_directory": "offering_provisioner_working_directory", "dry_run": false, "owning_account": "owning_account", "item_icon_url": "item_icon_url", "item_id": "item_id", "item_name": "item_name", "item_readme_url": "item_readme_url", "item_url": "item_url", "launch_url": "launch_url"}}, "inputs": [{"name": "name", "value": "value", "use_default": false, "metadata": {"type": "boolean", "aliases": ["aliases"], "description": "description", "cloud_data_type": "cloud_data_type", "default_value": "default_value", "link_status": "normal", "secure": true, "immutable": false, "hidden": true, "required": true, "options": ["options"], "min_value": 9, "max_value": 9, "min_length": 10, "max_length": 10, "matches": "matches", "position": 8, "group_by": "group_by", "source": "source"}, "link": "link"}], "outputs": [{"name": "name", "value": "value", "use_default": false, "metadata": {"type": "boolean", "aliases": ["aliases"], "description": "description", "cloud_data_type": "cloud_data_type", "default_value": "default_value", "link_status": "normal", "secure": true, "immutable": false, "hidden": true, "required": true, "options": ["options"], "min_value": 9, "max_value": 9, "min_length": 10, "max_length": 10, "matches": "matches", "position": 8, "group_by": "group_by", "source": "source"}, "link": "link"}], "settings": [{"name": "name", "value": "value", "use_default": false, "metadata": {"type": "boolean", "aliases": ["aliases"], "description": "description", "cloud_data_type": "cloud_data_type", "default_value": "default_value", "link_status": "normal", "secure": true, "immutable": false, "hidden": true, "required": true, "options": ["options"], "min_value": 9, "max_value": 9, "min_length": 10, "max_length": 10, "matches": "matches", "position": 8, "group_by": "group_by", "source": "source"}, "link": "link"}], "last_job": {"command_object": "workspace", "command_object_name": "command_object_name", "command_object_id": "command_object_id", "command_name": "workspace_plan", "job_id": "job_id", "job_status": "job_pending"}, "updated_at": "2019-01-01T12:00:00.000Z"}], "updated_at": "2019-01-01T12:00:00.000Z"}}, "bastion": {"name": "name", "host": "host"}, "log_summary": {"job_id": "job_id", "job_type": "repo_download_job", "log_start_at": "2019-01-01T12:00:00.000Z", "log_analyzed_till": "2019-01-01T12:00:00.000Z", "elapsed_time": 12, "log_errors": [{"error_code": "error_code", "error_msg": "error_msg", "error_count": 11}], "repo_download_job": {"scanned_file_count": 18, "quarantined_file_count": 22, "detected_filetype": "detected_filetype", "inputs_count": "inputs_count", "outputs_count": "outputs_count"}, "workspace_job": {"resources_add": 13, "resources_modify": 16, "resources_destroy": 17}, "flow_job": {"workitems_completed": 19, "workitems_pending": 17, "workitems_failed": 16, "workitems": [{"workspace_id": "workspace_id", "job_id": "job_id", "resources_add": 13, "resources_modify": 16, "resources_destroy": 17, "log_url": "log_url"}]}, "action_job": {"target_count": 12, "task_count": 10, "play_count": 10, "recap": {"target": ["target"], "ok": 2, "changed": 7, "failed": 6, "skipped": 7, "unreachable": 11}}, "system_job": {"target_count": 12, "success": 7, "failed": 6}}, "log_store_url": "log_store_url", "state_store_url": "state_store_url", "results_url": "results_url", "updated_at": "2019-01-01T12:00:00.000Z", "job_runner_id": "job_runner_id", "agent": {"id": "id", "name": "name", "assignment_policy_id": "assignment_policy_id"}}'
        responses.add(
            responses.GET,
            url,
            body=mock_response,
            content_type='application/json',
            status=200,
        )

        # Set up parameter values
        job_id = 'testString'
        profile = 'summary'

        # Invoke method
        response = _service.get_job(
            job_id,
            profile=profile,
            headers={},
        )

        # Check for correct operation
        assert len(responses.calls) == 1
        assert response.status_code == 200
        # Validate query params
        query_string = responses.calls[0].request.url.split('?', 1)[1]
        query_string = urllib.parse.unquote_plus(query_string)
        assert 'profile={}'.format(profile) in query_string

    def test_get_job_all_params_with_retries(self):
        # Enable retries and run test_get_job_all_params.
        _service.enable_retries()
        self.test_get_job_all_params()

        # Disable retries and run test_get_job_all_params.
        _service.disable_retries()
        self.test_get_job_all_params()

    @responses.activate
    def test_get_job_required_params(self):
        """
        test_get_job_required_params()
        """
        # Set up mock
        url = preprocess_url('/v2/jobs/testString')
        mock_response = '{"command_object": "workspace", "command_object_id": "command_object_id", "command_name": "workspace_plan", "command_parameter": "command_parameter", "command_options": ["command_options"], "inputs": [{"name": "name", "value": "value", "use_default": false, "metadata": {"type": "boolean", "aliases": ["aliases"], "description": "description", "cloud_data_type": "cloud_data_type", "default_value": "default_value", "link_status": "normal", "secure": true, "immutable": false, "hidden": true, "required": true, "options": ["options"], "min_value": 9, "max_value": 9, "min_length": 10, "max_length": 10, "matches": "matches", "position": 8, "group_by": "group_by", "source": "source"}, "link": "link"}], "settings": [{"name": "name", "value": "value", "use_default": false, "metadata": {"type": "boolean", "aliases": ["aliases"], "description": "description", "cloud_data_type": "cloud_data_type", "default_value": "default_value", "link_status": "normal", "secure": true, "immutable": false, "hidden": true, "required": true, "options": ["options"], "min_value": 9, "max_value": 9, "min_length": 10, "max_length": 10, "matches": "matches", "position": 8, "group_by": "group_by", "source": "source"}, "link": "link"}], "tags": ["tags"], "id": "id", "name": "name", "description": "description", "location": "us-south", "resource_group": "resource_group", "submitted_at": "2019-01-01T12:00:00.000Z", "submitted_by": "submitted_by", "start_at": "2019-01-01T12:00:00.000Z", "end_at": "2019-01-01T12:00:00.000Z", "duration": "duration", "status": {"position_in_queue": 17, "total_in_queue": 14, "workspace_job_status": {"workspace_name": "workspace_name", "status_code": "job_pending", "status_message": "status_message", "flow_status": {"flow_id": "flow_id", "flow_name": "flow_name", "status_code": "job_pending", "status_message": "status_message", "workitems": [{"workspace_id": "workspace_id", "workspace_name": "workspace_name", "job_id": "job_id", "status_code": "job_pending", "status_message": "status_message", "updated_at": "2019-01-01T12:00:00.000Z"}], "updated_at": "2019-01-01T12:00:00.000Z"}, "template_status": [{"template_id": "template_id", "template_name": "template_name", "flow_index": 10, "status_code": "job_pending", "status_message": "status_message", "updated_at": "2019-01-01T12:00:00.000Z"}], "updated_at": "2019-01-01T12:00:00.000Z", "commands": [{"name": "name", "outcome": "outcome"}]}, "action_job_status": {"action_name": "action_name", "status_code": "job_pending", "status_message": "status_message", "bastion_status_code": "none", "bastion_status_message": "bastion_status_message", "targets_status_code": "none", "targets_status_message": "targets_status_message", "updated_at": "2019-01-01T12:00:00.000Z"}, "system_job_status": {"system_status_message": "system_status_message", "system_status_code": "job_pending", "schematics_resource_status": [{"status_code": "job_pending", "status_message": "status_message", "schematics_resource_id": "schematics_resource_id", "updated_at": "2019-01-01T12:00:00.000Z"}], "updated_at": "2019-01-01T12:00:00.000Z"}, "flow_job_status": {"flow_id": "flow_id", "flow_name": "flow_name", "status_code": "job_pending", "status_message": "status_message", "workitems": [{"workspace_id": "workspace_id", "workspace_name": "workspace_name", "job_id": "job_id", "status_code": "job_pending", "status_message": "status_message", "updated_at": "2019-01-01T12:00:00.000Z"}], "updated_at": "2019-01-01T12:00:00.000Z"}}, "cart_order_data": [{"name": "name", "value": "value", "type": "type", "usage_kind": ["servicetags"]}], "data": {"job_type": "repo_download_job", "workspace_job_data": {"workspace_name": "workspace_name", "flow_id": "flow_id", "flow_name": "flow_name", "inputs": [{"name": "name", "value": "value", "use_default": false, "metadata": {"type": "boolean", "aliases": ["aliases"], "description": "description", "cloud_data_type": "cloud_data_type", "default_value": "default_value", "link_status": "normal", "secure": true, "immutable": false, "hidden": true, "required": true, "options": ["options"], "min_value": 9, "max_value": 9, "min_length": 10, "max_length": 10, "matches": "matches", "position": 8, "group_by": "group_by", "source": "source"}, "link": "link"}], "outputs": [{"name": "name", "value": "value", "use_default": false, "metadata": {"type": "boolean", "aliases": ["aliases"], "description": "description", "cloud_data_type": "cloud_data_type", "default_value": "default_value", "link_status": "normal", "secure": true, "immutable": false, "hidden": true, "required": true, "options": ["options"], "min_value": 9, "max_value": 9, "min_length": 10, "max_length": 10, "matches": "matches", "position": 8, "group_by": "group_by", "source": "source"}, "link": "link"}], "settings": [{"name": "name", "value": "value", "use_default": false, "metadata": {"type": "boolean", "aliases": ["aliases"], "description": "description", "cloud_data_type": "cloud_data_type", "default_value": "default_value", "link_status": "normal", "secure": true, "immutable": false, "hidden": true, "required": true, "options": ["options"], "min_value": 9, "max_value": 9, "min_length": 10, "max_length": 10, "matches": "matches", "position": 8, "group_by": "group_by", "source": "source"}, "link": "link"}], "template_data": [{"template_id": "template_id", "template_name": "template_name", "flow_index": 10, "inputs": [{"name": "name", "value": "value", "use_default": false, "metadata": {"type": "boolean", "aliases": ["aliases"], "description": "description", "cloud_data_type": "cloud_data_type", "default_value": "default_value", "link_status": "normal", "secure": true, "immutable": false, "hidden": true, "required": true, "options": ["options"], "min_value": 9, "max_value": 9, "min_length": 10, "max_length": 10, "matches": "matches", "position": 8, "group_by": "group_by", "source": "source"}, "link": "link"}], "outputs": [{"name": "name", "value": "value", "use_default": false, "metadata": {"type": "boolean", "aliases": ["aliases"], "description": "description", "cloud_data_type": "cloud_data_type", "default_value": "default_value", "link_status": "normal", "secure": true, "immutable": false, "hidden": true, "required": true, "options": ["options"], "min_value": 9, "max_value": 9, "min_length": 10, "max_length": 10, "matches": "matches", "position": 8, "group_by": "group_by", "source": "source"}, "link": "link"}], "settings": [{"name": "name", "value": "value", "use_default": false, "metadata": {"type": "boolean", "aliases": ["aliases"], "description": "description", "cloud_data_type": "cloud_data_type", "default_value": "default_value", "link_status": "normal", "secure": true, "immutable": false, "hidden": true, "required": true, "options": ["options"], "min_value": 9, "max_value": 9, "min_length": 10, "max_length": 10, "matches": "matches", "position": 8, "group_by": "group_by", "source": "source"}, "link": "link"}], "updated_at": "2019-01-01T12:00:00.000Z"}], "updated_at": "2019-01-01T12:00:00.000Z"}, "action_job_data": {"action_name": "action_name", "inputs": [{"name": "name", "value": "value", "use_default": false, "metadata": {"type": "boolean", "aliases": ["aliases"], "description": "description", "cloud_data_type": "cloud_data_type", "default_value": "default_value", "link_status": "normal", "secure": true, "immutable": false, "hidden": true, "required": true, "options": ["options"], "min_value": 9, "max_value": 9, "min_length": 10, "max_length": 10, "matches": "matches", "position": 8, "group_by": "group_by", "source": "source"}, "link": "link"}], "outputs": [{"name": "name", "value": "value", "use_default": false, "metadata": {"type": "boolean", "aliases": ["aliases"], "description": "description", "cloud_data_type": "cloud_data_type", "default_value": "default_value", "link_status": "normal", "secure": true, "immutable": false, "hidden": true, "required": true, "options": ["options"], "min_value": 9, "max_value": 9, "min_length": 10, "max_length": 10, "matches": "matches", "position": 8, "group_by": "group_by", "source": "source"}, "link": "link"}], "settings": [{"name": "name", "value": "value", "use_default": false, "metadata": {"type": "boolean", "aliases": ["aliases"], "description": "description", "cloud_data_type": "cloud_data_type", "default_value": "default_value", "link_status": "normal", "secure": true, "immutable": false, "hidden": true, "required": true, "options": ["options"], "min_value": 9, "max_value": 9, "min_length": 10, "max_length": 10, "matches": "matches", "position": 8, "group_by": "group_by", "source": "source"}, "link": "link"}], "updated_at": "2019-01-01T12:00:00.000Z", "inventory_record": {"name": "name", "id": "id", "description": "description", "location": "us-south", "resource_group": "resource_group", "created_at": "2019-01-01T12:00:00.000Z", "created_by": "created_by", "updated_at": "2019-01-01T12:00:00.000Z", "updated_by": "updated_by", "inventories_ini": "inventories_ini", "resource_queries": ["resource_queries"]}, "materialized_inventory": "materialized_inventory"}, "system_job_data": {"key_id": "key_id", "schematics_resource_id": ["schematics_resource_id"], "updated_at": "2019-01-01T12:00:00.000Z"}, "flow_job_data": {"flow_id": "flow_id", "flow_name": "flow_name", "workitems": [{"command_object_id": "command_object_id", "command_object_name": "command_object_name", "layers": "layers", "source_type": "local", "source": {"source_type": "local", "git": {"computed_git_repo_url": "computed_git_repo_url", "git_repo_url": "git_repo_url", "git_token": "git_token", "git_repo_folder": "git_repo_folder", "git_release": "git_release", "git_branch": "git_branch", "git_commit": "git_commit", "git_commit_timestamp": "git_commit_timestamp"}, "catalog": {"catalog_name": "catalog_name", "catalog_id": "catalog_id", "offering_name": "offering_name", "offering_version": "offering_version", "offering_kind": "offering_kind", "offering_target_kind": "offering_target_kind", "offering_id": "offering_id", "offering_version_id": "offering_version_id", "offering_version_flavour_name": "offering_version_flavour_name", "offering_repo_url": "offering_repo_url", "offering_provisioner_working_directory": "offering_provisioner_working_directory", "dry_run": false, "owning_account": "owning_account", "item_icon_url": "item_icon_url", "item_id": "item_id", "item_name": "item_name", "item_readme_url": "item_readme_url", "item_url": "item_url", "launch_url": "launch_url"}}, "inputs": [{"name": "name", "value": "value", "use_default": false, "metadata": {"type": "boolean", "aliases": ["aliases"], "description": "description", "cloud_data_type": "cloud_data_type", "default_value": "default_value", "link_status": "normal", "secure": true, "immutable": false, "hidden": true, "required": true, "options": ["options"], "min_value": 9, "max_value": 9, "min_length": 10, "max_length": 10, "matches": "matches", "position": 8, "group_by": "group_by", "source": "source"}, "link": "link"}], "outputs": [{"name": "name", "value": "value", "use_default": false, "metadata": {"type": "boolean", "aliases": ["aliases"], "description": "description", "cloud_data_type": "cloud_data_type", "default_value": "default_value", "link_status": "normal", "secure": true, "immutable": false, "hidden": true, "required": true, "options": ["options"], "min_value": 9, "max_value": 9, "min_length": 10, "max_length": 10, "matches": "matches", "position": 8, "group_by": "group_by", "source": "source"}, "link": "link"}], "settings": [{"name": "name", "value": "value", "use_default": false, "metadata": {"type": "boolean", "aliases": ["aliases"], "description": "description", "cloud_data_type": "cloud_data_type", "default_value": "default_value", "link_status": "normal", "secure": true, "immutable": false, "hidden": true, "required": true, "options": ["options"], "min_value": 9, "max_value": 9, "min_length": 10, "max_length": 10, "matches": "matches", "position": 8, "group_by": "group_by", "source": "source"}, "link": "link"}], "last_job": {"command_object": "workspace", "command_object_name": "command_object_name", "command_object_id": "command_object_id", "command_name": "workspace_plan", "job_id": "job_id", "job_status": "job_pending"}, "updated_at": "2019-01-01T12:00:00.000Z"}], "updated_at": "2019-01-01T12:00:00.000Z"}}, "bastion": {"name": "name", "host": "host"}, "log_summary": {"job_id": "job_id", "job_type": "repo_download_job", "log_start_at": "2019-01-01T12:00:00.000Z", "log_analyzed_till": "2019-01-01T12:00:00.000Z", "elapsed_time": 12, "log_errors": [{"error_code": "error_code", "error_msg": "error_msg", "error_count": 11}], "repo_download_job": {"scanned_file_count": 18, "quarantined_file_count": 22, "detected_filetype": "detected_filetype", "inputs_count": "inputs_count", "outputs_count": "outputs_count"}, "workspace_job": {"resources_add": 13, "resources_modify": 16, "resources_destroy": 17}, "flow_job": {"workitems_completed": 19, "workitems_pending": 17, "workitems_failed": 16, "workitems": [{"workspace_id": "workspace_id", "job_id": "job_id", "resources_add": 13, "resources_modify": 16, "resources_destroy": 17, "log_url": "log_url"}]}, "action_job": {"target_count": 12, "task_count": 10, "play_count": 10, "recap": {"target": ["target"], "ok": 2, "changed": 7, "failed": 6, "skipped": 7, "unreachable": 11}}, "system_job": {"target_count": 12, "success": 7, "failed": 6}}, "log_store_url": "log_store_url", "state_store_url": "state_store_url", "results_url": "results_url", "updated_at": "2019-01-01T12:00:00.000Z", "job_runner_id": "job_runner_id", "agent": {"id": "id", "name": "name", "assignment_policy_id": "assignment_policy_id"}}'
        responses.add(
            responses.GET,
            url,
            body=mock_response,
            content_type='application/json',
            status=200,
        )

        # Set up parameter values
        job_id = 'testString'

        # Invoke method
        response = _service.get_job(
            job_id,
            headers={},
        )

        # Check for correct operation
        assert len(responses.calls) == 1
        assert response.status_code == 200

    def test_get_job_required_params_with_retries(self):
        # Enable retries and run test_get_job_required_params.
        _service.enable_retries()
        self.test_get_job_required_params()

        # Disable retries and run test_get_job_required_params.
        _service.disable_retries()
        self.test_get_job_required_params()

    @responses.activate
    def test_get_job_value_error(self):
        """
        test_get_job_value_error()
        """
        # Set up mock
        url = preprocess_url('/v2/jobs/testString')
        mock_response = '{"command_object": "workspace", "command_object_id": "command_object_id", "command_name": "workspace_plan", "command_parameter": "command_parameter", "command_options": ["command_options"], "inputs": [{"name": "name", "value": "value", "use_default": false, "metadata": {"type": "boolean", "aliases": ["aliases"], "description": "description", "cloud_data_type": "cloud_data_type", "default_value": "default_value", "link_status": "normal", "secure": true, "immutable": false, "hidden": true, "required": true, "options": ["options"], "min_value": 9, "max_value": 9, "min_length": 10, "max_length": 10, "matches": "matches", "position": 8, "group_by": "group_by", "source": "source"}, "link": "link"}], "settings": [{"name": "name", "value": "value", "use_default": false, "metadata": {"type": "boolean", "aliases": ["aliases"], "description": "description", "cloud_data_type": "cloud_data_type", "default_value": "default_value", "link_status": "normal", "secure": true, "immutable": false, "hidden": true, "required": true, "options": ["options"], "min_value": 9, "max_value": 9, "min_length": 10, "max_length": 10, "matches": "matches", "position": 8, "group_by": "group_by", "source": "source"}, "link": "link"}], "tags": ["tags"], "id": "id", "name": "name", "description": "description", "location": "us-south", "resource_group": "resource_group", "submitted_at": "2019-01-01T12:00:00.000Z", "submitted_by": "submitted_by", "start_at": "2019-01-01T12:00:00.000Z", "end_at": "2019-01-01T12:00:00.000Z", "duration": "duration", "status": {"position_in_queue": 17, "total_in_queue": 14, "workspace_job_status": {"workspace_name": "workspace_name", "status_code": "job_pending", "status_message": "status_message", "flow_status": {"flow_id": "flow_id", "flow_name": "flow_name", "status_code": "job_pending", "status_message": "status_message", "workitems": [{"workspace_id": "workspace_id", "workspace_name": "workspace_name", "job_id": "job_id", "status_code": "job_pending", "status_message": "status_message", "updated_at": "2019-01-01T12:00:00.000Z"}], "updated_at": "2019-01-01T12:00:00.000Z"}, "template_status": [{"template_id": "template_id", "template_name": "template_name", "flow_index": 10, "status_code": "job_pending", "status_message": "status_message", "updated_at": "2019-01-01T12:00:00.000Z"}], "updated_at": "2019-01-01T12:00:00.000Z", "commands": [{"name": "name", "outcome": "outcome"}]}, "action_job_status": {"action_name": "action_name", "status_code": "job_pending", "status_message": "status_message", "bastion_status_code": "none", "bastion_status_message": "bastion_status_message", "targets_status_code": "none", "targets_status_message": "targets_status_message", "updated_at": "2019-01-01T12:00:00.000Z"}, "system_job_status": {"system_status_message": "system_status_message", "system_status_code": "job_pending", "schematics_resource_status": [{"status_code": "job_pending", "status_message": "status_message", "schematics_resource_id": "schematics_resource_id", "updated_at": "2019-01-01T12:00:00.000Z"}], "updated_at": "2019-01-01T12:00:00.000Z"}, "flow_job_status": {"flow_id": "flow_id", "flow_name": "flow_name", "status_code": "job_pending", "status_message": "status_message", "workitems": [{"workspace_id": "workspace_id", "workspace_name": "workspace_name", "job_id": "job_id", "status_code": "job_pending", "status_message": "status_message", "updated_at": "2019-01-01T12:00:00.000Z"}], "updated_at": "2019-01-01T12:00:00.000Z"}}, "cart_order_data": [{"name": "name", "value": "value", "type": "type", "usage_kind": ["servicetags"]}], "data": {"job_type": "repo_download_job", "workspace_job_data": {"workspace_name": "workspace_name", "flow_id": "flow_id", "flow_name": "flow_name", "inputs": [{"name": "name", "value": "value", "use_default": false, "metadata": {"type": "boolean", "aliases": ["aliases"], "description": "description", "cloud_data_type": "cloud_data_type", "default_value": "default_value", "link_status": "normal", "secure": true, "immutable": false, "hidden": true, "required": true, "options": ["options"], "min_value": 9, "max_value": 9, "min_length": 10, "max_length": 10, "matches": "matches", "position": 8, "group_by": "group_by", "source": "source"}, "link": "link"}], "outputs": [{"name": "name", "value": "value", "use_default": false, "metadata": {"type": "boolean", "aliases": ["aliases"], "description": "description", "cloud_data_type": "cloud_data_type", "default_value": "default_value", "link_status": "normal", "secure": true, "immutable": false, "hidden": true, "required": true, "options": ["options"], "min_value": 9, "max_value": 9, "min_length": 10, "max_length": 10, "matches": "matches", "position": 8, "group_by": "group_by", "source": "source"}, "link": "link"}], "settings": [{"name": "name", "value": "value", "use_default": false, "metadata": {"type": "boolean", "aliases": ["aliases"], "description": "description", "cloud_data_type": "cloud_data_type", "default_value": "default_value", "link_status": "normal", "secure": true, "immutable": false, "hidden": true, "required": true, "options": ["options"], "min_value": 9, "max_value": 9, "min_length": 10, "max_length": 10, "matches": "matches", "position": 8, "group_by": "group_by", "source": "source"}, "link": "link"}], "template_data": [{"template_id": "template_id", "template_name": "template_name", "flow_index": 10, "inputs": [{"name": "name", "value": "value", "use_default": false, "metadata": {"type": "boolean", "aliases": ["aliases"], "description": "description", "cloud_data_type": "cloud_data_type", "default_value": "default_value", "link_status": "normal", "secure": true, "immutable": false, "hidden": true, "required": true, "options": ["options"], "min_value": 9, "max_value": 9, "min_length": 10, "max_length": 10, "matches": "matches", "position": 8, "group_by": "group_by", "source": "source"}, "link": "link"}], "outputs": [{"name": "name", "value": "value", "use_default": false, "metadata": {"type": "boolean", "aliases": ["aliases"], "description": "description", "cloud_data_type": "cloud_data_type", "default_value": "default_value", "link_status": "normal", "secure": true, "immutable": false, "hidden": true, "required": true, "options": ["options"], "min_value": 9, "max_value": 9, "min_length": 10, "max_length": 10, "matches": "matches", "position": 8, "group_by": "group_by", "source": "source"}, "link": "link"}], "settings": [{"name": "name", "value": "value", "use_default": false, "metadata": {"type": "boolean", "aliases": ["aliases"], "description": "description", "cloud_data_type": "cloud_data_type", "default_value": "default_value", "link_status": "normal", "secure": true, "immutable": false, "hidden": true, "required": true, "options": ["options"], "min_value": 9, "max_value": 9, "min_length": 10, "max_length": 10, "matches": "matches", "position": 8, "group_by": "group_by", "source": "source"}, "link": "link"}], "updated_at": "2019-01-01T12:00:00.000Z"}], "updated_at": "2019-01-01T12:00:00.000Z"}, "action_job_data": {"action_name": "action_name", "inputs": [{"name": "name", "value": "value", "use_default": false, "metadata": {"type": "boolean", "aliases": ["aliases"], "description": "description", "cloud_data_type": "cloud_data_type", "default_value": "default_value", "link_status": "normal", "secure": true, "immutable": false, "hidden": true, "required": true, "options": ["options"], "min_value": 9, "max_value": 9, "min_length": 10, "max_length": 10, "matches": "matches", "position": 8, "group_by": "group_by", "source": "source"}, "link": "link"}], "outputs": [{"name": "name", "value": "value", "use_default": false, "metadata": {"type": "boolean", "aliases": ["aliases"], "description": "description", "cloud_data_type": "cloud_data_type", "default_value": "default_value", "link_status": "normal", "secure": true, "immutable": false, "hidden": true, "required": true, "options": ["options"], "min_value": 9, "max_value": 9, "min_length": 10, "max_length": 10, "matches": "matches", "position": 8, "group_by": "group_by", "source": "source"}, "link": "link"}], "settings": [{"name": "name", "value": "value", "use_default": false, "metadata": {"type": "boolean", "aliases": ["aliases"], "description": "description", "cloud_data_type": "cloud_data_type", "default_value": "default_value", "link_status": "normal", "secure": true, "immutable": false, "hidden": true, "required": true, "options": ["options"], "min_value": 9, "max_value": 9, "min_length": 10, "max_length": 10, "matches": "matches", "position": 8, "group_by": "group_by", "source": "source"}, "link": "link"}], "updated_at": "2019-01-01T12:00:00.000Z", "inventory_record": {"name": "name", "id": "id", "description": "description", "location": "us-south", "resource_group": "resource_group", "created_at": "2019-01-01T12:00:00.000Z", "created_by": "created_by", "updated_at": "2019-01-01T12:00:00.000Z", "updated_by": "updated_by", "inventories_ini": "inventories_ini", "resource_queries": ["resource_queries"]}, "materialized_inventory": "materialized_inventory"}, "system_job_data": {"key_id": "key_id", "schematics_resource_id": ["schematics_resource_id"], "updated_at": "2019-01-01T12:00:00.000Z"}, "flow_job_data": {"flow_id": "flow_id", "flow_name": "flow_name", "workitems": [{"command_object_id": "command_object_id", "command_object_name": "command_object_name", "layers": "layers", "source_type": "local", "source": {"source_type": "local", "git": {"computed_git_repo_url": "computed_git_repo_url", "git_repo_url": "git_repo_url", "git_token": "git_token", "git_repo_folder": "git_repo_folder", "git_release": "git_release", "git_branch": "git_branch", "git_commit": "git_commit", "git_commit_timestamp": "git_commit_timestamp"}, "catalog": {"catalog_name": "catalog_name", "catalog_id": "catalog_id", "offering_name": "offering_name", "offering_version": "offering_version", "offering_kind": "offering_kind", "offering_target_kind": "offering_target_kind", "offering_id": "offering_id", "offering_version_id": "offering_version_id", "offering_version_flavour_name": "offering_version_flavour_name", "offering_repo_url": "offering_repo_url", "offering_provisioner_working_directory": "offering_provisioner_working_directory", "dry_run": false, "owning_account": "owning_account", "item_icon_url": "item_icon_url", "item_id": "item_id", "item_name": "item_name", "item_readme_url": "item_readme_url", "item_url": "item_url", "launch_url": "launch_url"}}, "inputs": [{"name": "name", "value": "value", "use_default": false, "metadata": {"type": "boolean", "aliases": ["aliases"], "description": "description", "cloud_data_type": "cloud_data_type", "default_value": "default_value", "link_status": "normal", "secure": true, "immutable": false, "hidden": true, "required": true, "options": ["options"], "min_value": 9, "max_value": 9, "min_length": 10, "max_length": 10, "matches": "matches", "position": 8, "group_by": "group_by", "source": "source"}, "link": "link"}], "outputs": [{"name": "name", "value": "value", "use_default": false, "metadata": {"type": "boolean", "aliases": ["aliases"], "description": "description", "cloud_data_type": "cloud_data_type", "default_value": "default_value", "link_status": "normal", "secure": true, "immutable": false, "hidden": true, "required": true, "options": ["options"], "min_value": 9, "max_value": 9, "min_length": 10, "max_length": 10, "matches": "matches", "position": 8, "group_by": "group_by", "source": "source"}, "link": "link"}], "settings": [{"name": "name", "value": "value", "use_default": false, "metadata": {"type": "boolean", "aliases": ["aliases"], "description": "description", "cloud_data_type": "cloud_data_type", "default_value": "default_value", "link_status": "normal", "secure": true, "immutable": false, "hidden": true, "required": true, "options": ["options"], "min_value": 9, "max_value": 9, "min_length": 10, "max_length": 10, "matches": "matches", "position": 8, "group_by": "group_by", "source": "source"}, "link": "link"}], "last_job": {"command_object": "workspace", "command_object_name": "command_object_name", "command_object_id": "command_object_id", "command_name": "workspace_plan", "job_id": "job_id", "job_status": "job_pending"}, "updated_at": "2019-01-01T12:00:00.000Z"}], "updated_at": "2019-01-01T12:00:00.000Z"}}, "bastion": {"name": "name", "host": "host"}, "log_summary": {"job_id": "job_id", "job_type": "repo_download_job", "log_start_at": "2019-01-01T12:00:00.000Z", "log_analyzed_till": "2019-01-01T12:00:00.000Z", "elapsed_time": 12, "log_errors": [{"error_code": "error_code", "error_msg": "error_msg", "error_count": 11}], "repo_download_job": {"scanned_file_count": 18, "quarantined_file_count": 22, "detected_filetype": "detected_filetype", "inputs_count": "inputs_count", "outputs_count": "outputs_count"}, "workspace_job": {"resources_add": 13, "resources_modify": 16, "resources_destroy": 17}, "flow_job": {"workitems_completed": 19, "workitems_pending": 17, "workitems_failed": 16, "workitems": [{"workspace_id": "workspace_id", "job_id": "job_id", "resources_add": 13, "resources_modify": 16, "resources_destroy": 17, "log_url": "log_url"}]}, "action_job": {"target_count": 12, "task_count": 10, "play_count": 10, "recap": {"target": ["target"], "ok": 2, "changed": 7, "failed": 6, "skipped": 7, "unreachable": 11}}, "system_job": {"target_count": 12, "success": 7, "failed": 6}}, "log_store_url": "log_store_url", "state_store_url": "state_store_url", "results_url": "results_url", "updated_at": "2019-01-01T12:00:00.000Z", "job_runner_id": "job_runner_id", "agent": {"id": "id", "name": "name", "assignment_policy_id": "assignment_policy_id"}}'
        responses.add(
            responses.GET,
            url,
            body=mock_response,
            content_type='application/json',
            status=200,
        )

        # Set up parameter values
        job_id = 'testString'

        # Pass in all but one required param and check for a ValueError
        req_param_dict = {
            "job_id": job_id,
        }
        for param in req_param_dict.keys():
            req_copy = {key: val if key is not param else None for (key, val) in req_param_dict.items()}
            with pytest.raises(ValueError):
                _service.get_job(**req_copy)

    def test_get_job_value_error_with_retries(self):
        # Enable retries and run test_get_job_value_error.
        _service.enable_retries()
        self.test_get_job_value_error()

        # Disable retries and run test_get_job_value_error.
        _service.disable_retries()
        self.test_get_job_value_error()


class TestUpdateJob:
    """
    Test Class for update_job
    """

    @responses.activate
    def test_update_job_all_params(self):
        """
        update_job()
        """
        # Set up mock
        url = preprocess_url('/v2/jobs/testString')
        mock_response = '{"command_object": "workspace", "command_object_id": "command_object_id", "command_name": "workspace_plan", "command_parameter": "command_parameter", "command_options": ["command_options"], "inputs": [{"name": "name", "value": "value", "use_default": false, "metadata": {"type": "boolean", "aliases": ["aliases"], "description": "description", "cloud_data_type": "cloud_data_type", "default_value": "default_value", "link_status": "normal", "secure": true, "immutable": false, "hidden": true, "required": true, "options": ["options"], "min_value": 9, "max_value": 9, "min_length": 10, "max_length": 10, "matches": "matches", "position": 8, "group_by": "group_by", "source": "source"}, "link": "link"}], "settings": [{"name": "name", "value": "value", "use_default": false, "metadata": {"type": "boolean", "aliases": ["aliases"], "description": "description", "cloud_data_type": "cloud_data_type", "default_value": "default_value", "link_status": "normal", "secure": true, "immutable": false, "hidden": true, "required": true, "options": ["options"], "min_value": 9, "max_value": 9, "min_length": 10, "max_length": 10, "matches": "matches", "position": 8, "group_by": "group_by", "source": "source"}, "link": "link"}], "tags": ["tags"], "id": "id", "name": "name", "description": "description", "location": "us-south", "resource_group": "resource_group", "submitted_at": "2019-01-01T12:00:00.000Z", "submitted_by": "submitted_by", "start_at": "2019-01-01T12:00:00.000Z", "end_at": "2019-01-01T12:00:00.000Z", "duration": "duration", "status": {"position_in_queue": 17, "total_in_queue": 14, "workspace_job_status": {"workspace_name": "workspace_name", "status_code": "job_pending", "status_message": "status_message", "flow_status": {"flow_id": "flow_id", "flow_name": "flow_name", "status_code": "job_pending", "status_message": "status_message", "workitems": [{"workspace_id": "workspace_id", "workspace_name": "workspace_name", "job_id": "job_id", "status_code": "job_pending", "status_message": "status_message", "updated_at": "2019-01-01T12:00:00.000Z"}], "updated_at": "2019-01-01T12:00:00.000Z"}, "template_status": [{"template_id": "template_id", "template_name": "template_name", "flow_index": 10, "status_code": "job_pending", "status_message": "status_message", "updated_at": "2019-01-01T12:00:00.000Z"}], "updated_at": "2019-01-01T12:00:00.000Z", "commands": [{"name": "name", "outcome": "outcome"}]}, "action_job_status": {"action_name": "action_name", "status_code": "job_pending", "status_message": "status_message", "bastion_status_code": "none", "bastion_status_message": "bastion_status_message", "targets_status_code": "none", "targets_status_message": "targets_status_message", "updated_at": "2019-01-01T12:00:00.000Z"}, "system_job_status": {"system_status_message": "system_status_message", "system_status_code": "job_pending", "schematics_resource_status": [{"status_code": "job_pending", "status_message": "status_message", "schematics_resource_id": "schematics_resource_id", "updated_at": "2019-01-01T12:00:00.000Z"}], "updated_at": "2019-01-01T12:00:00.000Z"}, "flow_job_status": {"flow_id": "flow_id", "flow_name": "flow_name", "status_code": "job_pending", "status_message": "status_message", "workitems": [{"workspace_id": "workspace_id", "workspace_name": "workspace_name", "job_id": "job_id", "status_code": "job_pending", "status_message": "status_message", "updated_at": "2019-01-01T12:00:00.000Z"}], "updated_at": "2019-01-01T12:00:00.000Z"}}, "cart_order_data": [{"name": "name", "value": "value", "type": "type", "usage_kind": ["servicetags"]}], "data": {"job_type": "repo_download_job", "workspace_job_data": {"workspace_name": "workspace_name", "flow_id": "flow_id", "flow_name": "flow_name", "inputs": [{"name": "name", "value": "value", "use_default": false, "metadata": {"type": "boolean", "aliases": ["aliases"], "description": "description", "cloud_data_type": "cloud_data_type", "default_value": "default_value", "link_status": "normal", "secure": true, "immutable": false, "hidden": true, "required": true, "options": ["options"], "min_value": 9, "max_value": 9, "min_length": 10, "max_length": 10, "matches": "matches", "position": 8, "group_by": "group_by", "source": "source"}, "link": "link"}], "outputs": [{"name": "name", "value": "value", "use_default": false, "metadata": {"type": "boolean", "aliases": ["aliases"], "description": "description", "cloud_data_type": "cloud_data_type", "default_value": "default_value", "link_status": "normal", "secure": true, "immutable": false, "hidden": true, "required": true, "options": ["options"], "min_value": 9, "max_value": 9, "min_length": 10, "max_length": 10, "matches": "matches", "position": 8, "group_by": "group_by", "source": "source"}, "link": "link"}], "settings": [{"name": "name", "value": "value", "use_default": false, "metadata": {"type": "boolean", "aliases": ["aliases"], "description": "description", "cloud_data_type": "cloud_data_type", "default_value": "default_value", "link_status": "normal", "secure": true, "immutable": false, "hidden": true, "required": true, "options": ["options"], "min_value": 9, "max_value": 9, "min_length": 10, "max_length": 10, "matches": "matches", "position": 8, "group_by": "group_by", "source": "source"}, "link": "link"}], "template_data": [{"template_id": "template_id", "template_name": "template_name", "flow_index": 10, "inputs": [{"name": "name", "value": "value", "use_default": false, "metadata": {"type": "boolean", "aliases": ["aliases"], "description": "description", "cloud_data_type": "cloud_data_type", "default_value": "default_value", "link_status": "normal", "secure": true, "immutable": false, "hidden": true, "required": true, "options": ["options"], "min_value": 9, "max_value": 9, "min_length": 10, "max_length": 10, "matches": "matches", "position": 8, "group_by": "group_by", "source": "source"}, "link": "link"}], "outputs": [{"name": "name", "value": "value", "use_default": false, "metadata": {"type": "boolean", "aliases": ["aliases"], "description": "description", "cloud_data_type": "cloud_data_type", "default_value": "default_value", "link_status": "normal", "secure": true, "immutable": false, "hidden": true, "required": true, "options": ["options"], "min_value": 9, "max_value": 9, "min_length": 10, "max_length": 10, "matches": "matches", "position": 8, "group_by": "group_by", "source": "source"}, "link": "link"}], "settings": [{"name": "name", "value": "value", "use_default": false, "metadata": {"type": "boolean", "aliases": ["aliases"], "description": "description", "cloud_data_type": "cloud_data_type", "default_value": "default_value", "link_status": "normal", "secure": true, "immutable": false, "hidden": true, "required": true, "options": ["options"], "min_value": 9, "max_value": 9, "min_length": 10, "max_length": 10, "matches": "matches", "position": 8, "group_by": "group_by", "source": "source"}, "link": "link"}], "updated_at": "2019-01-01T12:00:00.000Z"}], "updated_at": "2019-01-01T12:00:00.000Z"}, "action_job_data": {"action_name": "action_name", "inputs": [{"name": "name", "value": "value", "use_default": false, "metadata": {"type": "boolean", "aliases": ["aliases"], "description": "description", "cloud_data_type": "cloud_data_type", "default_value": "default_value", "link_status": "normal", "secure": true, "immutable": false, "hidden": true, "required": true, "options": ["options"], "min_value": 9, "max_value": 9, "min_length": 10, "max_length": 10, "matches": "matches", "position": 8, "group_by": "group_by", "source": "source"}, "link": "link"}], "outputs": [{"name": "name", "value": "value", "use_default": false, "metadata": {"type": "boolean", "aliases": ["aliases"], "description": "description", "cloud_data_type": "cloud_data_type", "default_value": "default_value", "link_status": "normal", "secure": true, "immutable": false, "hidden": true, "required": true, "options": ["options"], "min_value": 9, "max_value": 9, "min_length": 10, "max_length": 10, "matches": "matches", "position": 8, "group_by": "group_by", "source": "source"}, "link": "link"}], "settings": [{"name": "name", "value": "value", "use_default": false, "metadata": {"type": "boolean", "aliases": ["aliases"], "description": "description", "cloud_data_type": "cloud_data_type", "default_value": "default_value", "link_status": "normal", "secure": true, "immutable": false, "hidden": true, "required": true, "options": ["options"], "min_value": 9, "max_value": 9, "min_length": 10, "max_length": 10, "matches": "matches", "position": 8, "group_by": "group_by", "source": "source"}, "link": "link"}], "updated_at": "2019-01-01T12:00:00.000Z", "inventory_record": {"name": "name", "id": "id", "description": "description", "location": "us-south", "resource_group": "resource_group", "created_at": "2019-01-01T12:00:00.000Z", "created_by": "created_by", "updated_at": "2019-01-01T12:00:00.000Z", "updated_by": "updated_by", "inventories_ini": "inventories_ini", "resource_queries": ["resource_queries"]}, "materialized_inventory": "materialized_inventory"}, "system_job_data": {"key_id": "key_id", "schematics_resource_id": ["schematics_resource_id"], "updated_at": "2019-01-01T12:00:00.000Z"}, "flow_job_data": {"flow_id": "flow_id", "flow_name": "flow_name", "workitems": [{"command_object_id": "command_object_id", "command_object_name": "command_object_name", "layers": "layers", "source_type": "local", "source": {"source_type": "local", "git": {"computed_git_repo_url": "computed_git_repo_url", "git_repo_url": "git_repo_url", "git_token": "git_token", "git_repo_folder": "git_repo_folder", "git_release": "git_release", "git_branch": "git_branch", "git_commit": "git_commit", "git_commit_timestamp": "git_commit_timestamp"}, "catalog": {"catalog_name": "catalog_name", "catalog_id": "catalog_id", "offering_name": "offering_name", "offering_version": "offering_version", "offering_kind": "offering_kind", "offering_target_kind": "offering_target_kind", "offering_id": "offering_id", "offering_version_id": "offering_version_id", "offering_version_flavour_name": "offering_version_flavour_name", "offering_repo_url": "offering_repo_url", "offering_provisioner_working_directory": "offering_provisioner_working_directory", "dry_run": false, "owning_account": "owning_account", "item_icon_url": "item_icon_url", "item_id": "item_id", "item_name": "item_name", "item_readme_url": "item_readme_url", "item_url": "item_url", "launch_url": "launch_url"}}, "inputs": [{"name": "name", "value": "value", "use_default": false, "metadata": {"type": "boolean", "aliases": ["aliases"], "description": "description", "cloud_data_type": "cloud_data_type", "default_value": "default_value", "link_status": "normal", "secure": true, "immutable": false, "hidden": true, "required": true, "options": ["options"], "min_value": 9, "max_value": 9, "min_length": 10, "max_length": 10, "matches": "matches", "position": 8, "group_by": "group_by", "source": "source"}, "link": "link"}], "outputs": [{"name": "name", "value": "value", "use_default": false, "metadata": {"type": "boolean", "aliases": ["aliases"], "description": "description", "cloud_data_type": "cloud_data_type", "default_value": "default_value", "link_status": "normal", "secure": true, "immutable": false, "hidden": true, "required": true, "options": ["options"], "min_value": 9, "max_value": 9, "min_length": 10, "max_length": 10, "matches": "matches", "position": 8, "group_by": "group_by", "source": "source"}, "link": "link"}], "settings": [{"name": "name", "value": "value", "use_default": false, "metadata": {"type": "boolean", "aliases": ["aliases"], "description": "description", "cloud_data_type": "cloud_data_type", "default_value": "default_value", "link_status": "normal", "secure": true, "immutable": false, "hidden": true, "required": true, "options": ["options"], "min_value": 9, "max_value": 9, "min_length": 10, "max_length": 10, "matches": "matches", "position": 8, "group_by": "group_by", "source": "source"}, "link": "link"}], "last_job": {"command_object": "workspace", "command_object_name": "command_object_name", "command_object_id": "command_object_id", "command_name": "workspace_plan", "job_id": "job_id", "job_status": "job_pending"}, "updated_at": "2019-01-01T12:00:00.000Z"}], "updated_at": "2019-01-01T12:00:00.000Z"}}, "bastion": {"name": "name", "host": "host"}, "log_summary": {"job_id": "job_id", "job_type": "repo_download_job", "log_start_at": "2019-01-01T12:00:00.000Z", "log_analyzed_till": "2019-01-01T12:00:00.000Z", "elapsed_time": 12, "log_errors": [{"error_code": "error_code", "error_msg": "error_msg", "error_count": 11}], "repo_download_job": {"scanned_file_count": 18, "quarantined_file_count": 22, "detected_filetype": "detected_filetype", "inputs_count": "inputs_count", "outputs_count": "outputs_count"}, "workspace_job": {"resources_add": 13, "resources_modify": 16, "resources_destroy": 17}, "flow_job": {"workitems_completed": 19, "workitems_pending": 17, "workitems_failed": 16, "workitems": [{"workspace_id": "workspace_id", "job_id": "job_id", "resources_add": 13, "resources_modify": 16, "resources_destroy": 17, "log_url": "log_url"}]}, "action_job": {"target_count": 12, "task_count": 10, "play_count": 10, "recap": {"target": ["target"], "ok": 2, "changed": 7, "failed": 6, "skipped": 7, "unreachable": 11}}, "system_job": {"target_count": 12, "success": 7, "failed": 6}}, "log_store_url": "log_store_url", "state_store_url": "state_store_url", "results_url": "results_url", "updated_at": "2019-01-01T12:00:00.000Z", "job_runner_id": "job_runner_id", "agent": {"id": "id", "name": "name", "assignment_policy_id": "assignment_policy_id"}}'
        responses.add(
            responses.PUT,
            url,
            body=mock_response,
            content_type='application/json',
            status=200,
        )

        # Construct a dict representation of a VariableMetadata model
        variable_metadata_model = {}
        variable_metadata_model['type'] = 'boolean'
        variable_metadata_model['aliases'] = ['testString']
        variable_metadata_model['description'] = 'testString'
        variable_metadata_model['cloud_data_type'] = 'testString'
        variable_metadata_model['default_value'] = 'testString'
        variable_metadata_model['link_status'] = 'normal'
        variable_metadata_model['secure'] = True
        variable_metadata_model['immutable'] = True
        variable_metadata_model['hidden'] = True
        variable_metadata_model['required'] = True
        variable_metadata_model['options'] = ['testString']
        variable_metadata_model['min_value'] = 38
        variable_metadata_model['max_value'] = 38
        variable_metadata_model['min_length'] = 38
        variable_metadata_model['max_length'] = 38
        variable_metadata_model['matches'] = 'testString'
        variable_metadata_model['position'] = 38
        variable_metadata_model['group_by'] = 'testString'
        variable_metadata_model['source'] = 'testString'

        # Construct a dict representation of a VariableData model
        variable_data_model = {}
        variable_data_model['name'] = 'testString'
        variable_data_model['value'] = 'testString'
        variable_data_model['use_default'] = True
        variable_data_model['metadata'] = variable_metadata_model

        # Construct a dict representation of a JobStatusWorkitem model
        job_status_workitem_model = {}
        job_status_workitem_model['workspace_id'] = 'testString'
        job_status_workitem_model['workspace_name'] = 'testString'
        job_status_workitem_model['job_id'] = 'testString'
        job_status_workitem_model['status_code'] = 'job_pending'
        job_status_workitem_model['status_message'] = 'testString'
        job_status_workitem_model['updated_at'] = '2019-01-01T12:00:00Z'

        # Construct a dict representation of a JobStatusFlow model
        job_status_flow_model = {}
        job_status_flow_model['flow_id'] = 'testString'
        job_status_flow_model['flow_name'] = 'testString'
        job_status_flow_model['status_code'] = 'job_pending'
        job_status_flow_model['status_message'] = 'testString'
        job_status_flow_model['workitems'] = [job_status_workitem_model]
        job_status_flow_model['updated_at'] = '2019-01-01T12:00:00Z'

        # Construct a dict representation of a JobStatusTemplate model
        job_status_template_model = {}
        job_status_template_model['template_id'] = 'testString'
        job_status_template_model['template_name'] = 'testString'
        job_status_template_model['flow_index'] = 38
        job_status_template_model['status_code'] = 'job_pending'
        job_status_template_model['status_message'] = 'testString'
        job_status_template_model['updated_at'] = '2019-01-01T12:00:00Z'

        # Construct a dict representation of a JobStatusWorkspace model
        job_status_workspace_model = {}
        job_status_workspace_model['workspace_name'] = 'testString'
        job_status_workspace_model['status_code'] = 'job_pending'
        job_status_workspace_model['status_message'] = 'testString'
        job_status_workspace_model['flow_status'] = job_status_flow_model
        job_status_workspace_model['template_status'] = [job_status_template_model]
        job_status_workspace_model['updated_at'] = '2019-01-01T12:00:00Z'

        # Construct a dict representation of a JobStatusAction model
        job_status_action_model = {}
        job_status_action_model['action_name'] = 'testString'
        job_status_action_model['status_code'] = 'job_pending'
        job_status_action_model['status_message'] = 'testString'
        job_status_action_model['bastion_status_code'] = 'none'
        job_status_action_model['bastion_status_message'] = 'testString'
        job_status_action_model['targets_status_code'] = 'none'
        job_status_action_model['targets_status_message'] = 'testString'
        job_status_action_model['updated_at'] = '2019-01-01T12:00:00Z'

        # Construct a dict representation of a JobStatusSchematicsResources model
        job_status_schematics_resources_model = {}
        job_status_schematics_resources_model['status_code'] = 'job_pending'
        job_status_schematics_resources_model['status_message'] = 'testString'
        job_status_schematics_resources_model['schematics_resource_id'] = 'testString'
        job_status_schematics_resources_model['updated_at'] = '2019-01-01T12:00:00Z'

        # Construct a dict representation of a JobStatusSystem model
        job_status_system_model = {}
        job_status_system_model['system_status_message'] = 'testString'
        job_status_system_model['system_status_code'] = 'job_pending'
        job_status_system_model['schematics_resource_status'] = [job_status_schematics_resources_model]
        job_status_system_model['updated_at'] = '2019-01-01T12:00:00Z'

        # Construct a dict representation of a JobStatus model
        job_status_model = {}
        job_status_model['position_in_queue'] = 72.5
        job_status_model['total_in_queue'] = 72.5
        job_status_model['workspace_job_status'] = job_status_workspace_model
        job_status_model['action_job_status'] = job_status_action_model
        job_status_model['system_job_status'] = job_status_system_model
        job_status_model['flow_job_status'] = job_status_flow_model

        # Construct a dict representation of a CartOrderData model
        cart_order_data_model = {}
        cart_order_data_model['name'] = 'testString'
        cart_order_data_model['value'] = 'testString'
        cart_order_data_model['type'] = 'testString'
        cart_order_data_model['usage_kind'] = ['servicetags']

        # Construct a dict representation of a JobDataTemplate model
        job_data_template_model = {}
        job_data_template_model['template_id'] = 'testString'
        job_data_template_model['template_name'] = 'testString'
        job_data_template_model['flow_index'] = 38
        job_data_template_model['inputs'] = [variable_data_model]
        job_data_template_model['outputs'] = [variable_data_model]
        job_data_template_model['settings'] = [variable_data_model]
        job_data_template_model['updated_at'] = '2019-01-01T12:00:00Z'

        # Construct a dict representation of a JobDataWorkspace model
        job_data_workspace_model = {}
        job_data_workspace_model['workspace_name'] = 'testString'
        job_data_workspace_model['flow_id'] = 'testString'
        job_data_workspace_model['flow_name'] = 'testString'
        job_data_workspace_model['inputs'] = [variable_data_model]
        job_data_workspace_model['outputs'] = [variable_data_model]
        job_data_workspace_model['settings'] = [variable_data_model]
        job_data_workspace_model['template_data'] = [job_data_template_model]
        job_data_workspace_model['updated_at'] = '2019-01-01T12:00:00Z'

        # Construct a dict representation of a InventoryResourceRecord model
        inventory_resource_record_model = {}
        inventory_resource_record_model['name'] = 'testString'
        inventory_resource_record_model['description'] = 'testString'
        inventory_resource_record_model['location'] = 'us-south'
        inventory_resource_record_model['resource_group'] = 'testString'
        inventory_resource_record_model['inventories_ini'] = 'testString'
        inventory_resource_record_model['resource_queries'] = ['testString']

        # Construct a dict representation of a JobDataAction model
        job_data_action_model = {}
        job_data_action_model['action_name'] = 'testString'
        job_data_action_model['inputs'] = [variable_data_model]
        job_data_action_model['outputs'] = [variable_data_model]
        job_data_action_model['settings'] = [variable_data_model]
        job_data_action_model['updated_at'] = '2019-01-01T12:00:00Z'
        job_data_action_model['inventory_record'] = inventory_resource_record_model
        job_data_action_model['materialized_inventory'] = 'testString'

        # Construct a dict representation of a JobDataSystem model
        job_data_system_model = {}
        job_data_system_model['key_id'] = 'testString'
        job_data_system_model['schematics_resource_id'] = ['testString']
        job_data_system_model['updated_at'] = '2019-01-01T12:00:00Z'

        # Construct a dict representation of a GitSource model
        git_source_model = {}
        git_source_model['computed_git_repo_url'] = 'testString'
        git_source_model['git_repo_url'] = 'testString'
        git_source_model['git_token'] = 'testString'
        git_source_model['git_repo_folder'] = 'testString'
        git_source_model['git_release'] = 'testString'
        git_source_model['git_branch'] = 'testString'

        # Construct a dict representation of a CatalogSource model
        catalog_source_model = {}
        catalog_source_model['catalog_name'] = 'testString'
        catalog_source_model['catalog_id'] = 'testString'
        catalog_source_model['offering_name'] = 'testString'
        catalog_source_model['offering_version'] = 'testString'
        catalog_source_model['offering_kind'] = 'testString'
        catalog_source_model['offering_target_kind'] = 'testString'
        catalog_source_model['offering_id'] = 'testString'
        catalog_source_model['offering_version_id'] = 'testString'
        catalog_source_model['offering_version_flavour_name'] = 'testString'
        catalog_source_model['offering_repo_url'] = 'testString'
        catalog_source_model['offering_provisioner_working_directory'] = 'testString'
        catalog_source_model['dry_run'] = True
        catalog_source_model['owning_account'] = 'testString'
        catalog_source_model['item_icon_url'] = 'testString'
        catalog_source_model['item_id'] = 'testString'
        catalog_source_model['item_name'] = 'testString'
        catalog_source_model['item_readme_url'] = 'testString'
        catalog_source_model['item_url'] = 'testString'
        catalog_source_model['launch_url'] = 'testString'

        # Construct a dict representation of a ExternalSource model
        external_source_model = {}
        external_source_model['source_type'] = 'local'
        external_source_model['git'] = git_source_model
        external_source_model['catalog'] = catalog_source_model

        # Construct a dict representation of a JobDataWorkItemLastJob model
        job_data_work_item_last_job_model = {}
        job_data_work_item_last_job_model['command_object'] = 'workspace'
        job_data_work_item_last_job_model['command_object_name'] = 'testString'
        job_data_work_item_last_job_model['command_object_id'] = 'testString'
        job_data_work_item_last_job_model['command_name'] = 'workspace_plan'
        job_data_work_item_last_job_model['job_id'] = 'testString'
        job_data_work_item_last_job_model['job_status'] = 'job_pending'

        # Construct a dict representation of a JobDataWorkItem model
        job_data_work_item_model = {}
        job_data_work_item_model['command_object_id'] = 'testString'
        job_data_work_item_model['command_object_name'] = 'testString'
        job_data_work_item_model['layers'] = 'testString'
        job_data_work_item_model['source_type'] = 'local'
        job_data_work_item_model['source'] = external_source_model
        job_data_work_item_model['inputs'] = [variable_data_model]
        job_data_work_item_model['outputs'] = [variable_data_model]
        job_data_work_item_model['settings'] = [variable_data_model]
        job_data_work_item_model['last_job'] = job_data_work_item_last_job_model
        job_data_work_item_model['updated_at'] = '2019-01-01T12:00:00Z'

        # Construct a dict representation of a JobDataFlow model
        job_data_flow_model = {}
        job_data_flow_model['flow_id'] = 'testString'
        job_data_flow_model['flow_name'] = 'testString'
        job_data_flow_model['workitems'] = [job_data_work_item_model]
        job_data_flow_model['updated_at'] = '2019-01-01T12:00:00Z'

        # Construct a dict representation of a JobData model
        job_data_model = {}
        job_data_model['job_type'] = 'repo_download_job'
        job_data_model['workspace_job_data'] = job_data_workspace_model
        job_data_model['action_job_data'] = job_data_action_model
        job_data_model['system_job_data'] = job_data_system_model
        job_data_model['flow_job_data'] = job_data_flow_model

        # Construct a dict representation of a BastionResourceDefinition model
        bastion_resource_definition_model = {}
        bastion_resource_definition_model['name'] = 'testString'
        bastion_resource_definition_model['host'] = 'testString'

        # Construct a dict representation of a JobLogSummaryRepoDownloadJob model
        job_log_summary_repo_download_job_model = {}

        # Construct a dict representation of a JobLogSummaryWorkspaceJob model
        job_log_summary_workspace_job_model = {}

        # Construct a dict representation of a JobLogSummaryWorkitems model
        job_log_summary_workitems_model = {}
        job_log_summary_workitems_model['workspace_id'] = 'testString'
        job_log_summary_workitems_model['job_id'] = 'testString'
        job_log_summary_workitems_model['log_url'] = 'testString'

        # Construct a dict representation of a JobLogSummaryFlowJob model
        job_log_summary_flow_job_model = {}
        job_log_summary_flow_job_model['workitems'] = [job_log_summary_workitems_model]

        # Construct a dict representation of a JobLogSummaryActionJobRecap model
        job_log_summary_action_job_recap_model = {}
        job_log_summary_action_job_recap_model['target'] = ['testString']
        job_log_summary_action_job_recap_model['ok'] = 72.5
        job_log_summary_action_job_recap_model['changed'] = 72.5
        job_log_summary_action_job_recap_model['failed'] = 72.5
        job_log_summary_action_job_recap_model['skipped'] = 72.5
        job_log_summary_action_job_recap_model['unreachable'] = 72.5

        # Construct a dict representation of a JobLogSummaryActionJob model
        job_log_summary_action_job_model = {}
        job_log_summary_action_job_model['recap'] = job_log_summary_action_job_recap_model

        # Construct a dict representation of a JobLogSummarySystemJob model
        job_log_summary_system_job_model = {}
        job_log_summary_system_job_model['success'] = 72.5
        job_log_summary_system_job_model['failed'] = 72.5

        # Construct a dict representation of a JobLogSummary model
        job_log_summary_model = {}
        job_log_summary_model['job_type'] = 'repo_download_job'
        job_log_summary_model['repo_download_job'] = job_log_summary_repo_download_job_model
        job_log_summary_model['workspace_job'] = job_log_summary_workspace_job_model
        job_log_summary_model['flow_job'] = job_log_summary_flow_job_model
        job_log_summary_model['action_job'] = job_log_summary_action_job_model
        job_log_summary_model['system_job'] = job_log_summary_system_job_model

        # Construct a dict representation of a AgentInfo model
        agent_info_model = {}
        agent_info_model['id'] = 'testString'
        agent_info_model['name'] = 'testString'
        agent_info_model['assignment_policy_id'] = 'testString'

        # Set up parameter values
        job_id = 'testString'
        refresh_token = 'testString'
        command_object = 'workspace'
        command_object_id = 'testString'
        command_name = 'workspace_plan'
        command_parameter = 'testString'
        command_options = ['testString']
        inputs = [variable_data_model]
        settings = [variable_data_model]
        tags = ['testString']
        location = 'us-south'
        status = job_status_model
        cart_order_data = [cart_order_data_model]
        data = job_data_model
        bastion = bastion_resource_definition_model
        log_summary = job_log_summary_model
        agent = agent_info_model

        # Invoke method
        response = _service.update_job(
            job_id,
            refresh_token,
            command_object=command_object,
            command_object_id=command_object_id,
            command_name=command_name,
            command_parameter=command_parameter,
            command_options=command_options,
            inputs=inputs,
            settings=settings,
            tags=tags,
            location=location,
            status=status,
            cart_order_data=cart_order_data,
            data=data,
            bastion=bastion,
            log_summary=log_summary,
            agent=agent,
            headers={},
        )

        # Check for correct operation
        assert len(responses.calls) == 1
        assert response.status_code == 200
        # Validate body params
        req_body = json.loads(str(responses.calls[0].request.body, 'utf-8'))
        assert req_body['command_object'] == 'workspace'
        assert req_body['command_object_id'] == 'testString'
        assert req_body['command_name'] == 'workspace_plan'
        assert req_body['command_parameter'] == 'testString'
        assert req_body['command_options'] == ['testString']
        assert req_body['inputs'] == [variable_data_model]
        assert req_body['settings'] == [variable_data_model]
        assert req_body['tags'] == ['testString']
        assert req_body['location'] == 'us-south'
        assert req_body['status'] == job_status_model
        assert req_body['cart_order_data'] == [cart_order_data_model]
        assert req_body['data'] == job_data_model
        assert req_body['bastion'] == bastion_resource_definition_model
        assert req_body['log_summary'] == job_log_summary_model
        assert req_body['agent'] == agent_info_model

    def test_update_job_all_params_with_retries(self):
        # Enable retries and run test_update_job_all_params.
        _service.enable_retries()
        self.test_update_job_all_params()

        # Disable retries and run test_update_job_all_params.
        _service.disable_retries()
        self.test_update_job_all_params()

    @responses.activate
    def test_update_job_value_error(self):
        """
        test_update_job_value_error()
        """
        # Set up mock
        url = preprocess_url('/v2/jobs/testString')
        mock_response = '{"command_object": "workspace", "command_object_id": "command_object_id", "command_name": "workspace_plan", "command_parameter": "command_parameter", "command_options": ["command_options"], "inputs": [{"name": "name", "value": "value", "use_default": false, "metadata": {"type": "boolean", "aliases": ["aliases"], "description": "description", "cloud_data_type": "cloud_data_type", "default_value": "default_value", "link_status": "normal", "secure": true, "immutable": false, "hidden": true, "required": true, "options": ["options"], "min_value": 9, "max_value": 9, "min_length": 10, "max_length": 10, "matches": "matches", "position": 8, "group_by": "group_by", "source": "source"}, "link": "link"}], "settings": [{"name": "name", "value": "value", "use_default": false, "metadata": {"type": "boolean", "aliases": ["aliases"], "description": "description", "cloud_data_type": "cloud_data_type", "default_value": "default_value", "link_status": "normal", "secure": true, "immutable": false, "hidden": true, "required": true, "options": ["options"], "min_value": 9, "max_value": 9, "min_length": 10, "max_length": 10, "matches": "matches", "position": 8, "group_by": "group_by", "source": "source"}, "link": "link"}], "tags": ["tags"], "id": "id", "name": "name", "description": "description", "location": "us-south", "resource_group": "resource_group", "submitted_at": "2019-01-01T12:00:00.000Z", "submitted_by": "submitted_by", "start_at": "2019-01-01T12:00:00.000Z", "end_at": "2019-01-01T12:00:00.000Z", "duration": "duration", "status": {"position_in_queue": 17, "total_in_queue": 14, "workspace_job_status": {"workspace_name": "workspace_name", "status_code": "job_pending", "status_message": "status_message", "flow_status": {"flow_id": "flow_id", "flow_name": "flow_name", "status_code": "job_pending", "status_message": "status_message", "workitems": [{"workspace_id": "workspace_id", "workspace_name": "workspace_name", "job_id": "job_id", "status_code": "job_pending", "status_message": "status_message", "updated_at": "2019-01-01T12:00:00.000Z"}], "updated_at": "2019-01-01T12:00:00.000Z"}, "template_status": [{"template_id": "template_id", "template_name": "template_name", "flow_index": 10, "status_code": "job_pending", "status_message": "status_message", "updated_at": "2019-01-01T12:00:00.000Z"}], "updated_at": "2019-01-01T12:00:00.000Z", "commands": [{"name": "name", "outcome": "outcome"}]}, "action_job_status": {"action_name": "action_name", "status_code": "job_pending", "status_message": "status_message", "bastion_status_code": "none", "bastion_status_message": "bastion_status_message", "targets_status_code": "none", "targets_status_message": "targets_status_message", "updated_at": "2019-01-01T12:00:00.000Z"}, "system_job_status": {"system_status_message": "system_status_message", "system_status_code": "job_pending", "schematics_resource_status": [{"status_code": "job_pending", "status_message": "status_message", "schematics_resource_id": "schematics_resource_id", "updated_at": "2019-01-01T12:00:00.000Z"}], "updated_at": "2019-01-01T12:00:00.000Z"}, "flow_job_status": {"flow_id": "flow_id", "flow_name": "flow_name", "status_code": "job_pending", "status_message": "status_message", "workitems": [{"workspace_id": "workspace_id", "workspace_name": "workspace_name", "job_id": "job_id", "status_code": "job_pending", "status_message": "status_message", "updated_at": "2019-01-01T12:00:00.000Z"}], "updated_at": "2019-01-01T12:00:00.000Z"}}, "cart_order_data": [{"name": "name", "value": "value", "type": "type", "usage_kind": ["servicetags"]}], "data": {"job_type": "repo_download_job", "workspace_job_data": {"workspace_name": "workspace_name", "flow_id": "flow_id", "flow_name": "flow_name", "inputs": [{"name": "name", "value": "value", "use_default": false, "metadata": {"type": "boolean", "aliases": ["aliases"], "description": "description", "cloud_data_type": "cloud_data_type", "default_value": "default_value", "link_status": "normal", "secure": true, "immutable": false, "hidden": true, "required": true, "options": ["options"], "min_value": 9, "max_value": 9, "min_length": 10, "max_length": 10, "matches": "matches", "position": 8, "group_by": "group_by", "source": "source"}, "link": "link"}], "outputs": [{"name": "name", "value": "value", "use_default": false, "metadata": {"type": "boolean", "aliases": ["aliases"], "description": "description", "cloud_data_type": "cloud_data_type", "default_value": "default_value", "link_status": "normal", "secure": true, "immutable": false, "hidden": true, "required": true, "options": ["options"], "min_value": 9, "max_value": 9, "min_length": 10, "max_length": 10, "matches": "matches", "position": 8, "group_by": "group_by", "source": "source"}, "link": "link"}], "settings": [{"name": "name", "value": "value", "use_default": false, "metadata": {"type": "boolean", "aliases": ["aliases"], "description": "description", "cloud_data_type": "cloud_data_type", "default_value": "default_value", "link_status": "normal", "secure": true, "immutable": false, "hidden": true, "required": true, "options": ["options"], "min_value": 9, "max_value": 9, "min_length": 10, "max_length": 10, "matches": "matches", "position": 8, "group_by": "group_by", "source": "source"}, "link": "link"}], "template_data": [{"template_id": "template_id", "template_name": "template_name", "flow_index": 10, "inputs": [{"name": "name", "value": "value", "use_default": false, "metadata": {"type": "boolean", "aliases": ["aliases"], "description": "description", "cloud_data_type": "cloud_data_type", "default_value": "default_value", "link_status": "normal", "secure": true, "immutable": false, "hidden": true, "required": true, "options": ["options"], "min_value": 9, "max_value": 9, "min_length": 10, "max_length": 10, "matches": "matches", "position": 8, "group_by": "group_by", "source": "source"}, "link": "link"}], "outputs": [{"name": "name", "value": "value", "use_default": false, "metadata": {"type": "boolean", "aliases": ["aliases"], "description": "description", "cloud_data_type": "cloud_data_type", "default_value": "default_value", "link_status": "normal", "secure": true, "immutable": false, "hidden": true, "required": true, "options": ["options"], "min_value": 9, "max_value": 9, "min_length": 10, "max_length": 10, "matches": "matches", "position": 8, "group_by": "group_by", "source": "source"}, "link": "link"}], "settings": [{"name": "name", "value": "value", "use_default": false, "metadata": {"type": "boolean", "aliases": ["aliases"], "description": "description", "cloud_data_type": "cloud_data_type", "default_value": "default_value", "link_status": "normal", "secure": true, "immutable": false, "hidden": true, "required": true, "options": ["options"], "min_value": 9, "max_value": 9, "min_length": 10, "max_length": 10, "matches": "matches", "position": 8, "group_by": "group_by", "source": "source"}, "link": "link"}], "updated_at": "2019-01-01T12:00:00.000Z"}], "updated_at": "2019-01-01T12:00:00.000Z"}, "action_job_data": {"action_name": "action_name", "inputs": [{"name": "name", "value": "value", "use_default": false, "metadata": {"type": "boolean", "aliases": ["aliases"], "description": "description", "cloud_data_type": "cloud_data_type", "default_value": "default_value", "link_status": "normal", "secure": true, "immutable": false, "hidden": true, "required": true, "options": ["options"], "min_value": 9, "max_value": 9, "min_length": 10, "max_length": 10, "matches": "matches", "position": 8, "group_by": "group_by", "source": "source"}, "link": "link"}], "outputs": [{"name": "name", "value": "value", "use_default": false, "metadata": {"type": "boolean", "aliases": ["aliases"], "description": "description", "cloud_data_type": "cloud_data_type", "default_value": "default_value", "link_status": "normal", "secure": true, "immutable": false, "hidden": true, "required": true, "options": ["options"], "min_value": 9, "max_value": 9, "min_length": 10, "max_length": 10, "matches": "matches", "position": 8, "group_by": "group_by", "source": "source"}, "link": "link"}], "settings": [{"name": "name", "value": "value", "use_default": false, "metadata": {"type": "boolean", "aliases": ["aliases"], "description": "description", "cloud_data_type": "cloud_data_type", "default_value": "default_value", "link_status": "normal", "secure": true, "immutable": false, "hidden": true, "required": true, "options": ["options"], "min_value": 9, "max_value": 9, "min_length": 10, "max_length": 10, "matches": "matches", "position": 8, "group_by": "group_by", "source": "source"}, "link": "link"}], "updated_at": "2019-01-01T12:00:00.000Z", "inventory_record": {"name": "name", "id": "id", "description": "description", "location": "us-south", "resource_group": "resource_group", "created_at": "2019-01-01T12:00:00.000Z", "created_by": "created_by", "updated_at": "2019-01-01T12:00:00.000Z", "updated_by": "updated_by", "inventories_ini": "inventories_ini", "resource_queries": ["resource_queries"]}, "materialized_inventory": "materialized_inventory"}, "system_job_data": {"key_id": "key_id", "schematics_resource_id": ["schematics_resource_id"], "updated_at": "2019-01-01T12:00:00.000Z"}, "flow_job_data": {"flow_id": "flow_id", "flow_name": "flow_name", "workitems": [{"command_object_id": "command_object_id", "command_object_name": "command_object_name", "layers": "layers", "source_type": "local", "source": {"source_type": "local", "git": {"computed_git_repo_url": "computed_git_repo_url", "git_repo_url": "git_repo_url", "git_token": "git_token", "git_repo_folder": "git_repo_folder", "git_release": "git_release", "git_branch": "git_branch", "git_commit": "git_commit", "git_commit_timestamp": "git_commit_timestamp"}, "catalog": {"catalog_name": "catalog_name", "catalog_id": "catalog_id", "offering_name": "offering_name", "offering_version": "offering_version", "offering_kind": "offering_kind", "offering_target_kind": "offering_target_kind", "offering_id": "offering_id", "offering_version_id": "offering_version_id", "offering_version_flavour_name": "offering_version_flavour_name", "offering_repo_url": "offering_repo_url", "offering_provisioner_working_directory": "offering_provisioner_working_directory", "dry_run": false, "owning_account": "owning_account", "item_icon_url": "item_icon_url", "item_id": "item_id", "item_name": "item_name", "item_readme_url": "item_readme_url", "item_url": "item_url", "launch_url": "launch_url"}}, "inputs": [{"name": "name", "value": "value", "use_default": false, "metadata": {"type": "boolean", "aliases": ["aliases"], "description": "description", "cloud_data_type": "cloud_data_type", "default_value": "default_value", "link_status": "normal", "secure": true, "immutable": false, "hidden": true, "required": true, "options": ["options"], "min_value": 9, "max_value": 9, "min_length": 10, "max_length": 10, "matches": "matches", "position": 8, "group_by": "group_by", "source": "source"}, "link": "link"}], "outputs": [{"name": "name", "value": "value", "use_default": false, "metadata": {"type": "boolean", "aliases": ["aliases"], "description": "description", "cloud_data_type": "cloud_data_type", "default_value": "default_value", "link_status": "normal", "secure": true, "immutable": false, "hidden": true, "required": true, "options": ["options"], "min_value": 9, "max_value": 9, "min_length": 10, "max_length": 10, "matches": "matches", "position": 8, "group_by": "group_by", "source": "source"}, "link": "link"}], "settings": [{"name": "name", "value": "value", "use_default": false, "metadata": {"type": "boolean", "aliases": ["aliases"], "description": "description", "cloud_data_type": "cloud_data_type", "default_value": "default_value", "link_status": "normal", "secure": true, "immutable": false, "hidden": true, "required": true, "options": ["options"], "min_value": 9, "max_value": 9, "min_length": 10, "max_length": 10, "matches": "matches", "position": 8, "group_by": "group_by", "source": "source"}, "link": "link"}], "last_job": {"command_object": "workspace", "command_object_name": "command_object_name", "command_object_id": "command_object_id", "command_name": "workspace_plan", "job_id": "job_id", "job_status": "job_pending"}, "updated_at": "2019-01-01T12:00:00.000Z"}], "updated_at": "2019-01-01T12:00:00.000Z"}}, "bastion": {"name": "name", "host": "host"}, "log_summary": {"job_id": "job_id", "job_type": "repo_download_job", "log_start_at": "2019-01-01T12:00:00.000Z", "log_analyzed_till": "2019-01-01T12:00:00.000Z", "elapsed_time": 12, "log_errors": [{"error_code": "error_code", "error_msg": "error_msg", "error_count": 11}], "repo_download_job": {"scanned_file_count": 18, "quarantined_file_count": 22, "detected_filetype": "detected_filetype", "inputs_count": "inputs_count", "outputs_count": "outputs_count"}, "workspace_job": {"resources_add": 13, "resources_modify": 16, "resources_destroy": 17}, "flow_job": {"workitems_completed": 19, "workitems_pending": 17, "workitems_failed": 16, "workitems": [{"workspace_id": "workspace_id", "job_id": "job_id", "resources_add": 13, "resources_modify": 16, "resources_destroy": 17, "log_url": "log_url"}]}, "action_job": {"target_count": 12, "task_count": 10, "play_count": 10, "recap": {"target": ["target"], "ok": 2, "changed": 7, "failed": 6, "skipped": 7, "unreachable": 11}}, "system_job": {"target_count": 12, "success": 7, "failed": 6}}, "log_store_url": "log_store_url", "state_store_url": "state_store_url", "results_url": "results_url", "updated_at": "2019-01-01T12:00:00.000Z", "job_runner_id": "job_runner_id", "agent": {"id": "id", "name": "name", "assignment_policy_id": "assignment_policy_id"}}'
        responses.add(
            responses.PUT,
            url,
            body=mock_response,
            content_type='application/json',
            status=200,
        )

        # Construct a dict representation of a VariableMetadata model
        variable_metadata_model = {}
        variable_metadata_model['type'] = 'boolean'
        variable_metadata_model['aliases'] = ['testString']
        variable_metadata_model['description'] = 'testString'
        variable_metadata_model['cloud_data_type'] = 'testString'
        variable_metadata_model['default_value'] = 'testString'
        variable_metadata_model['link_status'] = 'normal'
        variable_metadata_model['secure'] = True
        variable_metadata_model['immutable'] = True
        variable_metadata_model['hidden'] = True
        variable_metadata_model['required'] = True
        variable_metadata_model['options'] = ['testString']
        variable_metadata_model['min_value'] = 38
        variable_metadata_model['max_value'] = 38
        variable_metadata_model['min_length'] = 38
        variable_metadata_model['max_length'] = 38
        variable_metadata_model['matches'] = 'testString'
        variable_metadata_model['position'] = 38
        variable_metadata_model['group_by'] = 'testString'
        variable_metadata_model['source'] = 'testString'

        # Construct a dict representation of a VariableData model
        variable_data_model = {}
        variable_data_model['name'] = 'testString'
        variable_data_model['value'] = 'testString'
        variable_data_model['use_default'] = True
        variable_data_model['metadata'] = variable_metadata_model

        # Construct a dict representation of a JobStatusWorkitem model
        job_status_workitem_model = {}
        job_status_workitem_model['workspace_id'] = 'testString'
        job_status_workitem_model['workspace_name'] = 'testString'
        job_status_workitem_model['job_id'] = 'testString'
        job_status_workitem_model['status_code'] = 'job_pending'
        job_status_workitem_model['status_message'] = 'testString'
        job_status_workitem_model['updated_at'] = '2019-01-01T12:00:00Z'

        # Construct a dict representation of a JobStatusFlow model
        job_status_flow_model = {}
        job_status_flow_model['flow_id'] = 'testString'
        job_status_flow_model['flow_name'] = 'testString'
        job_status_flow_model['status_code'] = 'job_pending'
        job_status_flow_model['status_message'] = 'testString'
        job_status_flow_model['workitems'] = [job_status_workitem_model]
        job_status_flow_model['updated_at'] = '2019-01-01T12:00:00Z'

        # Construct a dict representation of a JobStatusTemplate model
        job_status_template_model = {}
        job_status_template_model['template_id'] = 'testString'
        job_status_template_model['template_name'] = 'testString'
        job_status_template_model['flow_index'] = 38
        job_status_template_model['status_code'] = 'job_pending'
        job_status_template_model['status_message'] = 'testString'
        job_status_template_model['updated_at'] = '2019-01-01T12:00:00Z'

        # Construct a dict representation of a JobStatusWorkspace model
        job_status_workspace_model = {}
        job_status_workspace_model['workspace_name'] = 'testString'
        job_status_workspace_model['status_code'] = 'job_pending'
        job_status_workspace_model['status_message'] = 'testString'
        job_status_workspace_model['flow_status'] = job_status_flow_model
        job_status_workspace_model['template_status'] = [job_status_template_model]
        job_status_workspace_model['updated_at'] = '2019-01-01T12:00:00Z'

        # Construct a dict representation of a JobStatusAction model
        job_status_action_model = {}
        job_status_action_model['action_name'] = 'testString'
        job_status_action_model['status_code'] = 'job_pending'
        job_status_action_model['status_message'] = 'testString'
        job_status_action_model['bastion_status_code'] = 'none'
        job_status_action_model['bastion_status_message'] = 'testString'
        job_status_action_model['targets_status_code'] = 'none'
        job_status_action_model['targets_status_message'] = 'testString'
        job_status_action_model['updated_at'] = '2019-01-01T12:00:00Z'

        # Construct a dict representation of a JobStatusSchematicsResources model
        job_status_schematics_resources_model = {}
        job_status_schematics_resources_model['status_code'] = 'job_pending'
        job_status_schematics_resources_model['status_message'] = 'testString'
        job_status_schematics_resources_model['schematics_resource_id'] = 'testString'
        job_status_schematics_resources_model['updated_at'] = '2019-01-01T12:00:00Z'

        # Construct a dict representation of a JobStatusSystem model
        job_status_system_model = {}
        job_status_system_model['system_status_message'] = 'testString'
        job_status_system_model['system_status_code'] = 'job_pending'
        job_status_system_model['schematics_resource_status'] = [job_status_schematics_resources_model]
        job_status_system_model['updated_at'] = '2019-01-01T12:00:00Z'

        # Construct a dict representation of a JobStatus model
        job_status_model = {}
        job_status_model['position_in_queue'] = 72.5
        job_status_model['total_in_queue'] = 72.5
        job_status_model['workspace_job_status'] = job_status_workspace_model
        job_status_model['action_job_status'] = job_status_action_model
        job_status_model['system_job_status'] = job_status_system_model
        job_status_model['flow_job_status'] = job_status_flow_model

        # Construct a dict representation of a CartOrderData model
        cart_order_data_model = {}
        cart_order_data_model['name'] = 'testString'
        cart_order_data_model['value'] = 'testString'
        cart_order_data_model['type'] = 'testString'
        cart_order_data_model['usage_kind'] = ['servicetags']

        # Construct a dict representation of a JobDataTemplate model
        job_data_template_model = {}
        job_data_template_model['template_id'] = 'testString'
        job_data_template_model['template_name'] = 'testString'
        job_data_template_model['flow_index'] = 38
        job_data_template_model['inputs'] = [variable_data_model]
        job_data_template_model['outputs'] = [variable_data_model]
        job_data_template_model['settings'] = [variable_data_model]
        job_data_template_model['updated_at'] = '2019-01-01T12:00:00Z'

        # Construct a dict representation of a JobDataWorkspace model
        job_data_workspace_model = {}
        job_data_workspace_model['workspace_name'] = 'testString'
        job_data_workspace_model['flow_id'] = 'testString'
        job_data_workspace_model['flow_name'] = 'testString'
        job_data_workspace_model['inputs'] = [variable_data_model]
        job_data_workspace_model['outputs'] = [variable_data_model]
        job_data_workspace_model['settings'] = [variable_data_model]
        job_data_workspace_model['template_data'] = [job_data_template_model]
        job_data_workspace_model['updated_at'] = '2019-01-01T12:00:00Z'

        # Construct a dict representation of a InventoryResourceRecord model
        inventory_resource_record_model = {}
        inventory_resource_record_model['name'] = 'testString'
        inventory_resource_record_model['description'] = 'testString'
        inventory_resource_record_model['location'] = 'us-south'
        inventory_resource_record_model['resource_group'] = 'testString'
        inventory_resource_record_model['inventories_ini'] = 'testString'
        inventory_resource_record_model['resource_queries'] = ['testString']

        # Construct a dict representation of a JobDataAction model
        job_data_action_model = {}
        job_data_action_model['action_name'] = 'testString'
        job_data_action_model['inputs'] = [variable_data_model]
        job_data_action_model['outputs'] = [variable_data_model]
        job_data_action_model['settings'] = [variable_data_model]
        job_data_action_model['updated_at'] = '2019-01-01T12:00:00Z'
        job_data_action_model['inventory_record'] = inventory_resource_record_model
        job_data_action_model['materialized_inventory'] = 'testString'

        # Construct a dict representation of a JobDataSystem model
        job_data_system_model = {}
        job_data_system_model['key_id'] = 'testString'
        job_data_system_model['schematics_resource_id'] = ['testString']
        job_data_system_model['updated_at'] = '2019-01-01T12:00:00Z'

        # Construct a dict representation of a GitSource model
        git_source_model = {}
        git_source_model['computed_git_repo_url'] = 'testString'
        git_source_model['git_repo_url'] = 'testString'
        git_source_model['git_token'] = 'testString'
        git_source_model['git_repo_folder'] = 'testString'
        git_source_model['git_release'] = 'testString'
        git_source_model['git_branch'] = 'testString'

        # Construct a dict representation of a CatalogSource model
        catalog_source_model = {}
        catalog_source_model['catalog_name'] = 'testString'
        catalog_source_model['catalog_id'] = 'testString'
        catalog_source_model['offering_name'] = 'testString'
        catalog_source_model['offering_version'] = 'testString'
        catalog_source_model['offering_kind'] = 'testString'
        catalog_source_model['offering_target_kind'] = 'testString'
        catalog_source_model['offering_id'] = 'testString'
        catalog_source_model['offering_version_id'] = 'testString'
        catalog_source_model['offering_version_flavour_name'] = 'testString'
        catalog_source_model['offering_repo_url'] = 'testString'
        catalog_source_model['offering_provisioner_working_directory'] = 'testString'
        catalog_source_model['dry_run'] = True
        catalog_source_model['owning_account'] = 'testString'
        catalog_source_model['item_icon_url'] = 'testString'
        catalog_source_model['item_id'] = 'testString'
        catalog_source_model['item_name'] = 'testString'
        catalog_source_model['item_readme_url'] = 'testString'
        catalog_source_model['item_url'] = 'testString'
        catalog_source_model['launch_url'] = 'testString'

        # Construct a dict representation of a ExternalSource model
        external_source_model = {}
        external_source_model['source_type'] = 'local'
        external_source_model['git'] = git_source_model
        external_source_model['catalog'] = catalog_source_model

        # Construct a dict representation of a JobDataWorkItemLastJob model
        job_data_work_item_last_job_model = {}
        job_data_work_item_last_job_model['command_object'] = 'workspace'
        job_data_work_item_last_job_model['command_object_name'] = 'testString'
        job_data_work_item_last_job_model['command_object_id'] = 'testString'
        job_data_work_item_last_job_model['command_name'] = 'workspace_plan'
        job_data_work_item_last_job_model['job_id'] = 'testString'
        job_data_work_item_last_job_model['job_status'] = 'job_pending'

        # Construct a dict representation of a JobDataWorkItem model
        job_data_work_item_model = {}
        job_data_work_item_model['command_object_id'] = 'testString'
        job_data_work_item_model['command_object_name'] = 'testString'
        job_data_work_item_model['layers'] = 'testString'
        job_data_work_item_model['source_type'] = 'local'
        job_data_work_item_model['source'] = external_source_model
        job_data_work_item_model['inputs'] = [variable_data_model]
        job_data_work_item_model['outputs'] = [variable_data_model]
        job_data_work_item_model['settings'] = [variable_data_model]
        job_data_work_item_model['last_job'] = job_data_work_item_last_job_model
        job_data_work_item_model['updated_at'] = '2019-01-01T12:00:00Z'

        # Construct a dict representation of a JobDataFlow model
        job_data_flow_model = {}
        job_data_flow_model['flow_id'] = 'testString'
        job_data_flow_model['flow_name'] = 'testString'
        job_data_flow_model['workitems'] = [job_data_work_item_model]
        job_data_flow_model['updated_at'] = '2019-01-01T12:00:00Z'

        # Construct a dict representation of a JobData model
        job_data_model = {}
        job_data_model['job_type'] = 'repo_download_job'
        job_data_model['workspace_job_data'] = job_data_workspace_model
        job_data_model['action_job_data'] = job_data_action_model
        job_data_model['system_job_data'] = job_data_system_model
        job_data_model['flow_job_data'] = job_data_flow_model

        # Construct a dict representation of a BastionResourceDefinition model
        bastion_resource_definition_model = {}
        bastion_resource_definition_model['name'] = 'testString'
        bastion_resource_definition_model['host'] = 'testString'

        # Construct a dict representation of a JobLogSummaryRepoDownloadJob model
        job_log_summary_repo_download_job_model = {}

        # Construct a dict representation of a JobLogSummaryWorkspaceJob model
        job_log_summary_workspace_job_model = {}

        # Construct a dict representation of a JobLogSummaryWorkitems model
        job_log_summary_workitems_model = {}
        job_log_summary_workitems_model['workspace_id'] = 'testString'
        job_log_summary_workitems_model['job_id'] = 'testString'
        job_log_summary_workitems_model['log_url'] = 'testString'

        # Construct a dict representation of a JobLogSummaryFlowJob model
        job_log_summary_flow_job_model = {}
        job_log_summary_flow_job_model['workitems'] = [job_log_summary_workitems_model]

        # Construct a dict representation of a JobLogSummaryActionJobRecap model
        job_log_summary_action_job_recap_model = {}
        job_log_summary_action_job_recap_model['target'] = ['testString']
        job_log_summary_action_job_recap_model['ok'] = 72.5
        job_log_summary_action_job_recap_model['changed'] = 72.5
        job_log_summary_action_job_recap_model['failed'] = 72.5
        job_log_summary_action_job_recap_model['skipped'] = 72.5
        job_log_summary_action_job_recap_model['unreachable'] = 72.5

        # Construct a dict representation of a JobLogSummaryActionJob model
        job_log_summary_action_job_model = {}
        job_log_summary_action_job_model['recap'] = job_log_summary_action_job_recap_model

        # Construct a dict representation of a JobLogSummarySystemJob model
        job_log_summary_system_job_model = {}
        job_log_summary_system_job_model['success'] = 72.5
        job_log_summary_system_job_model['failed'] = 72.5

        # Construct a dict representation of a JobLogSummary model
        job_log_summary_model = {}
        job_log_summary_model['job_type'] = 'repo_download_job'
        job_log_summary_model['repo_download_job'] = job_log_summary_repo_download_job_model
        job_log_summary_model['workspace_job'] = job_log_summary_workspace_job_model
        job_log_summary_model['flow_job'] = job_log_summary_flow_job_model
        job_log_summary_model['action_job'] = job_log_summary_action_job_model
        job_log_summary_model['system_job'] = job_log_summary_system_job_model

        # Construct a dict representation of a AgentInfo model
        agent_info_model = {}
        agent_info_model['id'] = 'testString'
        agent_info_model['name'] = 'testString'
        agent_info_model['assignment_policy_id'] = 'testString'

        # Set up parameter values
        job_id = 'testString'
        refresh_token = 'testString'
        command_object = 'workspace'
        command_object_id = 'testString'
        command_name = 'workspace_plan'
        command_parameter = 'testString'
        command_options = ['testString']
        inputs = [variable_data_model]
        settings = [variable_data_model]
        tags = ['testString']
        location = 'us-south'
        status = job_status_model
        cart_order_data = [cart_order_data_model]
        data = job_data_model
        bastion = bastion_resource_definition_model
        log_summary = job_log_summary_model
        agent = agent_info_model

        # Pass in all but one required param and check for a ValueError
        req_param_dict = {
            "job_id": job_id,
            "refresh_token": refresh_token,
        }
        for param in req_param_dict.keys():
            req_copy = {key: val if key is not param else None for (key, val) in req_param_dict.items()}
            with pytest.raises(ValueError):
                _service.update_job(**req_copy)

    def test_update_job_value_error_with_retries(self):
        # Enable retries and run test_update_job_value_error.
        _service.enable_retries()
        self.test_update_job_value_error()

        # Disable retries and run test_update_job_value_error.
        _service.disable_retries()
        self.test_update_job_value_error()


class TestDeleteJob:
    """
    Test Class for delete_job
    """

    @responses.activate
    def test_delete_job_all_params(self):
        """
        delete_job()
        """
        # Set up mock
        url = preprocess_url('/v2/jobs/testString')
        responses.add(
            responses.DELETE,
            url,
            status=204,
        )

        # Set up parameter values
        job_id = 'testString'
        refresh_token = 'testString'
        force = True
        propagate = True

        # Invoke method
        response = _service.delete_job(
            job_id,
            refresh_token,
            force=force,
            propagate=propagate,
            headers={},
        )

        # Check for correct operation
        assert len(responses.calls) == 1
        assert response.status_code == 204

    def test_delete_job_all_params_with_retries(self):
        # Enable retries and run test_delete_job_all_params.
        _service.enable_retries()
        self.test_delete_job_all_params()

        # Disable retries and run test_delete_job_all_params.
        _service.disable_retries()
        self.test_delete_job_all_params()

    @responses.activate
    def test_delete_job_required_params(self):
        """
        test_delete_job_required_params()
        """
        # Set up mock
        url = preprocess_url('/v2/jobs/testString')
        responses.add(
            responses.DELETE,
            url,
            status=204,
        )

        # Set up parameter values
        job_id = 'testString'
        refresh_token = 'testString'

        # Invoke method
        response = _service.delete_job(
            job_id,
            refresh_token,
            headers={},
        )

        # Check for correct operation
        assert len(responses.calls) == 1
        assert response.status_code == 204

    def test_delete_job_required_params_with_retries(self):
        # Enable retries and run test_delete_job_required_params.
        _service.enable_retries()
        self.test_delete_job_required_params()

        # Disable retries and run test_delete_job_required_params.
        _service.disable_retries()
        self.test_delete_job_required_params()

    @responses.activate
    def test_delete_job_value_error(self):
        """
        test_delete_job_value_error()
        """
        # Set up mock
        url = preprocess_url('/v2/jobs/testString')
        responses.add(
            responses.DELETE,
            url,
            status=204,
        )

        # Set up parameter values
        job_id = 'testString'
        refresh_token = 'testString'

        # Pass in all but one required param and check for a ValueError
        req_param_dict = {
            "job_id": job_id,
            "refresh_token": refresh_token,
        }
        for param in req_param_dict.keys():
            req_copy = {key: val if key is not param else None for (key, val) in req_param_dict.items()}
            with pytest.raises(ValueError):
                _service.delete_job(**req_copy)

    def test_delete_job_value_error_with_retries(self):
        # Enable retries and run test_delete_job_value_error.
        _service.enable_retries()
        self.test_delete_job_value_error()

        # Disable retries and run test_delete_job_value_error.
        _service.disable_retries()
        self.test_delete_job_value_error()


class TestListJobLogs:
    """
    Test Class for list_job_logs
    """

    @responses.activate
    def test_list_job_logs_all_params(self):
        """
        list_job_logs()
        """
        # Set up mock
        url = preprocess_url('/v2/jobs/testString/logs')
        mock_response = '{"job_id": "job_id", "job_name": "job_name", "log_summary": {"job_id": "job_id", "job_type": "repo_download_job", "log_start_at": "2019-01-01T12:00:00.000Z", "log_analyzed_till": "2019-01-01T12:00:00.000Z", "elapsed_time": 12, "log_errors": [{"error_code": "error_code", "error_msg": "error_msg", "error_count": 11}], "repo_download_job": {"scanned_file_count": 18, "quarantined_file_count": 22, "detected_filetype": "detected_filetype", "inputs_count": "inputs_count", "outputs_count": "outputs_count"}, "workspace_job": {"resources_add": 13, "resources_modify": 16, "resources_destroy": 17}, "flow_job": {"workitems_completed": 19, "workitems_pending": 17, "workitems_failed": 16, "workitems": [{"workspace_id": "workspace_id", "job_id": "job_id", "resources_add": 13, "resources_modify": 16, "resources_destroy": 17, "log_url": "log_url"}]}, "action_job": {"target_count": 12, "task_count": 10, "play_count": 10, "recap": {"target": ["target"], "ok": 2, "changed": 7, "failed": 6, "skipped": 7, "unreachable": 11}}, "system_job": {"target_count": 12, "success": 7, "failed": 6}}, "format": "json", "details": "VGhpcyBpcyBhIG1vY2sgYnl0ZSBhcnJheSB2YWx1ZS4=", "updated_at": "2019-01-01T12:00:00.000Z"}'
        responses.add(
            responses.GET,
            url,
            body=mock_response,
            content_type='application/json',
            status=200,
        )

        # Set up parameter values
        job_id = 'testString'

        # Invoke method
        response = _service.list_job_logs(
            job_id,
            headers={},
        )

        # Check for correct operation
        assert len(responses.calls) == 1
        assert response.status_code == 200

    def test_list_job_logs_all_params_with_retries(self):
        # Enable retries and run test_list_job_logs_all_params.
        _service.enable_retries()
        self.test_list_job_logs_all_params()

        # Disable retries and run test_list_job_logs_all_params.
        _service.disable_retries()
        self.test_list_job_logs_all_params()

    @responses.activate
    def test_list_job_logs_value_error(self):
        """
        test_list_job_logs_value_error()
        """
        # Set up mock
        url = preprocess_url('/v2/jobs/testString/logs')
        mock_response = '{"job_id": "job_id", "job_name": "job_name", "log_summary": {"job_id": "job_id", "job_type": "repo_download_job", "log_start_at": "2019-01-01T12:00:00.000Z", "log_analyzed_till": "2019-01-01T12:00:00.000Z", "elapsed_time": 12, "log_errors": [{"error_code": "error_code", "error_msg": "error_msg", "error_count": 11}], "repo_download_job": {"scanned_file_count": 18, "quarantined_file_count": 22, "detected_filetype": "detected_filetype", "inputs_count": "inputs_count", "outputs_count": "outputs_count"}, "workspace_job": {"resources_add": 13, "resources_modify": 16, "resources_destroy": 17}, "flow_job": {"workitems_completed": 19, "workitems_pending": 17, "workitems_failed": 16, "workitems": [{"workspace_id": "workspace_id", "job_id": "job_id", "resources_add": 13, "resources_modify": 16, "resources_destroy": 17, "log_url": "log_url"}]}, "action_job": {"target_count": 12, "task_count": 10, "play_count": 10, "recap": {"target": ["target"], "ok": 2, "changed": 7, "failed": 6, "skipped": 7, "unreachable": 11}}, "system_job": {"target_count": 12, "success": 7, "failed": 6}}, "format": "json", "details": "VGhpcyBpcyBhIG1vY2sgYnl0ZSBhcnJheSB2YWx1ZS4=", "updated_at": "2019-01-01T12:00:00.000Z"}'
        responses.add(
            responses.GET,
            url,
            body=mock_response,
            content_type='application/json',
            status=200,
        )

        # Set up parameter values
        job_id = 'testString'

        # Pass in all but one required param and check for a ValueError
        req_param_dict = {
            "job_id": job_id,
        }
        for param in req_param_dict.keys():
            req_copy = {key: val if key is not param else None for (key, val) in req_param_dict.items()}
            with pytest.raises(ValueError):
                _service.list_job_logs(**req_copy)

    def test_list_job_logs_value_error_with_retries(self):
        # Enable retries and run test_list_job_logs_value_error.
        _service.enable_retries()
        self.test_list_job_logs_value_error()

        # Disable retries and run test_list_job_logs_value_error.
        _service.disable_retries()
        self.test_list_job_logs_value_error()


class TestGetJobFiles:
    """
    Test Class for get_job_files
    """

    @responses.activate
    def test_get_job_files_all_params(self):
        """
        get_job_files()
        """
        # Set up mock
        url = preprocess_url('/v2/jobs/testString/files')
        mock_response = '{"job_id": "job_id", "job_name": "job_name", "summary": [{"name": "name", "type": "number", "value": "value"}], "file_type": "state_file", "file_content": "file_content", "additional_files": [{"file_name": "file_name", "file_content": "file_content"}], "updated_at": "2019-01-01T12:00:00.000Z"}'
        responses.add(
            responses.GET,
            url,
            body=mock_response,
            content_type='application/json',
            status=200,
        )

        # Set up parameter values
        job_id = 'testString'
        file_type = 'template_repo'

        # Invoke method
        response = _service.get_job_files(
            job_id,
            file_type,
            headers={},
        )

        # Check for correct operation
        assert len(responses.calls) == 1
        assert response.status_code == 200
        # Validate query params
        query_string = responses.calls[0].request.url.split('?', 1)[1]
        query_string = urllib.parse.unquote_plus(query_string)
        assert 'file_type={}'.format(file_type) in query_string

    def test_get_job_files_all_params_with_retries(self):
        # Enable retries and run test_get_job_files_all_params.
        _service.enable_retries()
        self.test_get_job_files_all_params()

        # Disable retries and run test_get_job_files_all_params.
        _service.disable_retries()
        self.test_get_job_files_all_params()

    @responses.activate
    def test_get_job_files_value_error(self):
        """
        test_get_job_files_value_error()
        """
        # Set up mock
        url = preprocess_url('/v2/jobs/testString/files')
        mock_response = '{"job_id": "job_id", "job_name": "job_name", "summary": [{"name": "name", "type": "number", "value": "value"}], "file_type": "state_file", "file_content": "file_content", "additional_files": [{"file_name": "file_name", "file_content": "file_content"}], "updated_at": "2019-01-01T12:00:00.000Z"}'
        responses.add(
            responses.GET,
            url,
            body=mock_response,
            content_type='application/json',
            status=200,
        )

        # Set up parameter values
        job_id = 'testString'
        file_type = 'template_repo'

        # Pass in all but one required param and check for a ValueError
        req_param_dict = {
            "job_id": job_id,
            "file_type": file_type,
        }
        for param in req_param_dict.keys():
            req_copy = {key: val if key is not param else None for (key, val) in req_param_dict.items()}
            with pytest.raises(ValueError):
                _service.get_job_files(**req_copy)

    def test_get_job_files_value_error_with_retries(self):
        # Enable retries and run test_get_job_files_value_error.
        _service.enable_retries()
        self.test_get_job_files_value_error()

        # Disable retries and run test_get_job_files_value_error.
        _service.disable_retries()
        self.test_get_job_files_value_error()


# endregion
##############################################################################
# End of Service: Jobs
##############################################################################

##############################################################################
# Start of Service: BulkJobs
##############################################################################
# region


class TestNewInstance:
    """
    Test Class for new_instance
    """

    def test_new_instance(self):
        """
        new_instance()
        """
        os.environ['TEST_SERVICE_AUTH_TYPE'] = 'noAuth'

        service = SchematicsV1.new_instance(
            service_name='TEST_SERVICE',
        )

        assert service is not None
        assert isinstance(service, SchematicsV1)

    def test_new_instance_without_authenticator(self):
        """
        new_instance_without_authenticator()
        """
        with pytest.raises(ValueError, match='authenticator must be provided'):
            service = SchematicsV1.new_instance(
                service_name='TEST_SERVICE_NOT_FOUND',
            )


class TestCreateWorkspaceDeletionJob:
    """
    Test Class for create_workspace_deletion_job
    """

    @responses.activate
    def test_create_workspace_deletion_job_all_params(self):
        """
        create_workspace_deletion_job()
        """
        # Set up mock
        url = preprocess_url('/v1/workspace_jobs')
        mock_response = '{"job": "job", "job_id": "job_id"}'
        responses.add(
            responses.POST,
            url,
            body=mock_response,
            content_type='application/json',
            status=200,
        )

        # Set up parameter values
        refresh_token = 'testString'
        job = 'testString'
        version = 'testString'
        workspaces = ['testString']

        # Invoke method
        response = _service.create_workspace_deletion_job(
            refresh_token,
            job=job,
            version=version,
            workspaces=workspaces,
            headers={},
        )

        # Check for correct operation
        assert len(responses.calls) == 1
        assert response.status_code == 200
        # Validate body params
        req_body = json.loads(str(responses.calls[0].request.body, 'utf-8'))
        assert req_body['job'] == 'testString'
        assert req_body['version'] == 'testString'
        assert req_body['workspaces'] == ['testString']

    def test_create_workspace_deletion_job_all_params_with_retries(self):
        # Enable retries and run test_create_workspace_deletion_job_all_params.
        _service.enable_retries()
        self.test_create_workspace_deletion_job_all_params()

        # Disable retries and run test_create_workspace_deletion_job_all_params.
        _service.disable_retries()
        self.test_create_workspace_deletion_job_all_params()

    @responses.activate
    def test_create_workspace_deletion_job_value_error(self):
        """
        test_create_workspace_deletion_job_value_error()
        """
        # Set up mock
        url = preprocess_url('/v1/workspace_jobs')
        mock_response = '{"job": "job", "job_id": "job_id"}'
        responses.add(
            responses.POST,
            url,
            body=mock_response,
            content_type='application/json',
            status=200,
        )

        # Set up parameter values
        refresh_token = 'testString'
        job = 'testString'
        version = 'testString'
        workspaces = ['testString']

        # Pass in all but one required param and check for a ValueError
        req_param_dict = {
            "refresh_token": refresh_token,
        }
        for param in req_param_dict.keys():
            req_copy = {key: val if key is not param else None for (key, val) in req_param_dict.items()}
            with pytest.raises(ValueError):
                _service.create_workspace_deletion_job(**req_copy)

    def test_create_workspace_deletion_job_value_error_with_retries(self):
        # Enable retries and run test_create_workspace_deletion_job_value_error.
        _service.enable_retries()
        self.test_create_workspace_deletion_job_value_error()

        # Disable retries and run test_create_workspace_deletion_job_value_error.
        _service.disable_retries()
        self.test_create_workspace_deletion_job_value_error()


class TestGetWorkspaceDeletionJobStatus:
    """
    Test Class for get_workspace_deletion_job_status
    """

    @responses.activate
    def test_get_workspace_deletion_job_status_all_params(self):
        """
        get_workspace_deletion_job_status()
        """
        # Set up mock
        url = preprocess_url('/v1/workspace_jobs/testString/status')
        mock_response = '{"job_status": {"failed": ["failed"], "in_progress": ["in_progress"], "success": ["success"], "last_updated_on": "2019-01-01T12:00:00.000Z"}}'
        responses.add(
            responses.GET,
            url,
            body=mock_response,
            content_type='application/json',
            status=200,
        )

        # Set up parameter values
        wj_id = 'testString'

        # Invoke method
        response = _service.get_workspace_deletion_job_status(
            wj_id,
            headers={},
        )

        # Check for correct operation
        assert len(responses.calls) == 1
        assert response.status_code == 200

    def test_get_workspace_deletion_job_status_all_params_with_retries(self):
        # Enable retries and run test_get_workspace_deletion_job_status_all_params.
        _service.enable_retries()
        self.test_get_workspace_deletion_job_status_all_params()

        # Disable retries and run test_get_workspace_deletion_job_status_all_params.
        _service.disable_retries()
        self.test_get_workspace_deletion_job_status_all_params()

    @responses.activate
    def test_get_workspace_deletion_job_status_value_error(self):
        """
        test_get_workspace_deletion_job_status_value_error()
        """
        # Set up mock
        url = preprocess_url('/v1/workspace_jobs/testString/status')
        mock_response = '{"job_status": {"failed": ["failed"], "in_progress": ["in_progress"], "success": ["success"], "last_updated_on": "2019-01-01T12:00:00.000Z"}}'
        responses.add(
            responses.GET,
            url,
            body=mock_response,
            content_type='application/json',
            status=200,
        )

        # Set up parameter values
        wj_id = 'testString'

        # Pass in all but one required param and check for a ValueError
        req_param_dict = {
            "wj_id": wj_id,
        }
        for param in req_param_dict.keys():
            req_copy = {key: val if key is not param else None for (key, val) in req_param_dict.items()}
            with pytest.raises(ValueError):
                _service.get_workspace_deletion_job_status(**req_copy)

    def test_get_workspace_deletion_job_status_value_error_with_retries(self):
        # Enable retries and run test_get_workspace_deletion_job_status_value_error.
        _service.enable_retries()
        self.test_get_workspace_deletion_job_status_value_error()

        # Disable retries and run test_get_workspace_deletion_job_status_value_error.
        _service.disable_retries()
        self.test_get_workspace_deletion_job_status_value_error()


# endregion
##############################################################################
# End of Service: BulkJobs
##############################################################################

##############################################################################
# Start of Service: Inventory
##############################################################################
# region


class TestNewInstance:
    """
    Test Class for new_instance
    """

    def test_new_instance(self):
        """
        new_instance()
        """
        os.environ['TEST_SERVICE_AUTH_TYPE'] = 'noAuth'

        service = SchematicsV1.new_instance(
            service_name='TEST_SERVICE',
        )

        assert service is not None
        assert isinstance(service, SchematicsV1)

    def test_new_instance_without_authenticator(self):
        """
        new_instance_without_authenticator()
        """
        with pytest.raises(ValueError, match='authenticator must be provided'):
            service = SchematicsV1.new_instance(
                service_name='TEST_SERVICE_NOT_FOUND',
            )


class TestListInventories:
    """
    Test Class for list_inventories
    """

    @responses.activate
    def test_list_inventories_all_params(self):
        """
        list_inventories()
        """
        # Set up mock
        url = preprocess_url('/v2/inventories')
        mock_response = '{"total_count": 11, "limit": 5, "offset": 6, "inventories": [{"name": "name", "id": "id", "description": "description", "location": "us-south", "resource_group": "resource_group", "created_at": "2019-01-01T12:00:00.000Z", "created_by": "created_by", "updated_at": "2019-01-01T12:00:00.000Z", "updated_by": "updated_by", "inventories_ini": "inventories_ini", "resource_queries": ["resource_queries"]}]}'
        responses.add(
            responses.GET,
            url,
            body=mock_response,
            content_type='application/json',
            status=200,
        )

        # Set up parameter values
        offset = 0
        limit = 100
        sort = 'testString'
        profile = 'ids'

        # Invoke method
        response = _service.list_inventories(
            offset=offset,
            limit=limit,
            sort=sort,
            profile=profile,
            headers={},
        )

        # Check for correct operation
        assert len(responses.calls) == 1
        assert response.status_code == 200
        # Validate query params
        query_string = responses.calls[0].request.url.split('?', 1)[1]
        query_string = urllib.parse.unquote_plus(query_string)
        assert 'offset={}'.format(offset) in query_string
        assert 'limit={}'.format(limit) in query_string
        assert 'sort={}'.format(sort) in query_string
        assert 'profile={}'.format(profile) in query_string

    def test_list_inventories_all_params_with_retries(self):
        # Enable retries and run test_list_inventories_all_params.
        _service.enable_retries()
        self.test_list_inventories_all_params()

        # Disable retries and run test_list_inventories_all_params.
        _service.disable_retries()
        self.test_list_inventories_all_params()

    @responses.activate
    def test_list_inventories_required_params(self):
        """
        test_list_inventories_required_params()
        """
        # Set up mock
        url = preprocess_url('/v2/inventories')
        mock_response = '{"total_count": 11, "limit": 5, "offset": 6, "inventories": [{"name": "name", "id": "id", "description": "description", "location": "us-south", "resource_group": "resource_group", "created_at": "2019-01-01T12:00:00.000Z", "created_by": "created_by", "updated_at": "2019-01-01T12:00:00.000Z", "updated_by": "updated_by", "inventories_ini": "inventories_ini", "resource_queries": ["resource_queries"]}]}'
        responses.add(
            responses.GET,
            url,
            body=mock_response,
            content_type='application/json',
            status=200,
        )

        # Invoke method
        response = _service.list_inventories()

        # Check for correct operation
        assert len(responses.calls) == 1
        assert response.status_code == 200

    def test_list_inventories_required_params_with_retries(self):
        # Enable retries and run test_list_inventories_required_params.
        _service.enable_retries()
        self.test_list_inventories_required_params()

        # Disable retries and run test_list_inventories_required_params.
        _service.disable_retries()
        self.test_list_inventories_required_params()


class TestCreateInventory:
    """
    Test Class for create_inventory
    """

    @responses.activate
    def test_create_inventory_all_params(self):
        """
        create_inventory()
        """
        # Set up mock
        url = preprocess_url('/v2/inventories')
        mock_response = '{"name": "name", "id": "id", "description": "description", "location": "us-south", "resource_group": "resource_group", "created_at": "2019-01-01T12:00:00.000Z", "created_by": "created_by", "updated_at": "2019-01-01T12:00:00.000Z", "updated_by": "updated_by", "inventories_ini": "inventories_ini", "resource_queries": ["resource_queries"]}'
        responses.add(
            responses.POST,
            url,
            body=mock_response,
            content_type='application/json',
            status=200,
        )

        # Set up parameter values
        name = 'testString'
        description = 'testString'
        location = 'us-south'
        resource_group = 'testString'
        inventories_ini = 'testString'
        resource_queries = ['testString']

        # Invoke method
        response = _service.create_inventory(
            name=name,
            description=description,
            location=location,
            resource_group=resource_group,
            inventories_ini=inventories_ini,
            resource_queries=resource_queries,
            headers={},
        )

        # Check for correct operation
        assert len(responses.calls) == 1
        assert response.status_code == 200
        # Validate body params
        req_body = json.loads(str(responses.calls[0].request.body, 'utf-8'))
        assert req_body['name'] == 'testString'
        assert req_body['description'] == 'testString'
        assert req_body['location'] == 'us-south'
        assert req_body['resource_group'] == 'testString'
        assert req_body['inventories_ini'] == 'testString'
        assert req_body['resource_queries'] == ['testString']

    def test_create_inventory_all_params_with_retries(self):
        # Enable retries and run test_create_inventory_all_params.
        _service.enable_retries()
        self.test_create_inventory_all_params()

        # Disable retries and run test_create_inventory_all_params.
        _service.disable_retries()
        self.test_create_inventory_all_params()


class TestGetInventory:
    """
    Test Class for get_inventory
    """

    @responses.activate
    def test_get_inventory_all_params(self):
        """
        get_inventory()
        """
        # Set up mock
        url = preprocess_url('/v2/inventories/testString')
        mock_response = '{"name": "name", "id": "id", "description": "description", "location": "us-south", "resource_group": "resource_group", "created_at": "2019-01-01T12:00:00.000Z", "created_by": "created_by", "updated_at": "2019-01-01T12:00:00.000Z", "updated_by": "updated_by", "inventories_ini": "inventories_ini", "resource_queries": ["resource_queries"]}'
        responses.add(
            responses.GET,
            url,
            body=mock_response,
            content_type='application/json',
            status=200,
        )

        # Set up parameter values
        inventory_id = 'testString'
        profile = 'summary'

        # Invoke method
        response = _service.get_inventory(
            inventory_id,
            profile=profile,
            headers={},
        )

        # Check for correct operation
        assert len(responses.calls) == 1
        assert response.status_code == 200
        # Validate query params
        query_string = responses.calls[0].request.url.split('?', 1)[1]
        query_string = urllib.parse.unquote_plus(query_string)
        assert 'profile={}'.format(profile) in query_string

    def test_get_inventory_all_params_with_retries(self):
        # Enable retries and run test_get_inventory_all_params.
        _service.enable_retries()
        self.test_get_inventory_all_params()

        # Disable retries and run test_get_inventory_all_params.
        _service.disable_retries()
        self.test_get_inventory_all_params()

    @responses.activate
    def test_get_inventory_required_params(self):
        """
        test_get_inventory_required_params()
        """
        # Set up mock
        url = preprocess_url('/v2/inventories/testString')
        mock_response = '{"name": "name", "id": "id", "description": "description", "location": "us-south", "resource_group": "resource_group", "created_at": "2019-01-01T12:00:00.000Z", "created_by": "created_by", "updated_at": "2019-01-01T12:00:00.000Z", "updated_by": "updated_by", "inventories_ini": "inventories_ini", "resource_queries": ["resource_queries"]}'
        responses.add(
            responses.GET,
            url,
            body=mock_response,
            content_type='application/json',
            status=200,
        )

        # Set up parameter values
        inventory_id = 'testString'

        # Invoke method
        response = _service.get_inventory(
            inventory_id,
            headers={},
        )

        # Check for correct operation
        assert len(responses.calls) == 1
        assert response.status_code == 200

    def test_get_inventory_required_params_with_retries(self):
        # Enable retries and run test_get_inventory_required_params.
        _service.enable_retries()
        self.test_get_inventory_required_params()

        # Disable retries and run test_get_inventory_required_params.
        _service.disable_retries()
        self.test_get_inventory_required_params()

    @responses.activate
    def test_get_inventory_value_error(self):
        """
        test_get_inventory_value_error()
        """
        # Set up mock
        url = preprocess_url('/v2/inventories/testString')
        mock_response = '{"name": "name", "id": "id", "description": "description", "location": "us-south", "resource_group": "resource_group", "created_at": "2019-01-01T12:00:00.000Z", "created_by": "created_by", "updated_at": "2019-01-01T12:00:00.000Z", "updated_by": "updated_by", "inventories_ini": "inventories_ini", "resource_queries": ["resource_queries"]}'
        responses.add(
            responses.GET,
            url,
            body=mock_response,
            content_type='application/json',
            status=200,
        )

        # Set up parameter values
        inventory_id = 'testString'

        # Pass in all but one required param and check for a ValueError
        req_param_dict = {
            "inventory_id": inventory_id,
        }
        for param in req_param_dict.keys():
            req_copy = {key: val if key is not param else None for (key, val) in req_param_dict.items()}
            with pytest.raises(ValueError):
                _service.get_inventory(**req_copy)

    def test_get_inventory_value_error_with_retries(self):
        # Enable retries and run test_get_inventory_value_error.
        _service.enable_retries()
        self.test_get_inventory_value_error()

        # Disable retries and run test_get_inventory_value_error.
        _service.disable_retries()
        self.test_get_inventory_value_error()


class TestReplaceInventory:
    """
    Test Class for replace_inventory
    """

    @responses.activate
    def test_replace_inventory_all_params(self):
        """
        replace_inventory()
        """
        # Set up mock
        url = preprocess_url('/v2/inventories/testString')
        mock_response = '{"name": "name", "id": "id", "description": "description", "location": "us-south", "resource_group": "resource_group", "created_at": "2019-01-01T12:00:00.000Z", "created_by": "created_by", "updated_at": "2019-01-01T12:00:00.000Z", "updated_by": "updated_by", "inventories_ini": "inventories_ini", "resource_queries": ["resource_queries"]}'
        responses.add(
            responses.PUT,
            url,
            body=mock_response,
            content_type='application/json',
            status=200,
        )

        # Set up parameter values
        inventory_id = 'testString'
        name = 'testString'
        description = 'testString'
        location = 'us-south'
        resource_group = 'testString'
        inventories_ini = 'testString'
        resource_queries = ['testString']

        # Invoke method
        response = _service.replace_inventory(
            inventory_id,
            name=name,
            description=description,
            location=location,
            resource_group=resource_group,
            inventories_ini=inventories_ini,
            resource_queries=resource_queries,
            headers={},
        )

        # Check for correct operation
        assert len(responses.calls) == 1
        assert response.status_code == 200
        # Validate body params
        req_body = json.loads(str(responses.calls[0].request.body, 'utf-8'))
        assert req_body['name'] == 'testString'
        assert req_body['description'] == 'testString'
        assert req_body['location'] == 'us-south'
        assert req_body['resource_group'] == 'testString'
        assert req_body['inventories_ini'] == 'testString'
        assert req_body['resource_queries'] == ['testString']

    def test_replace_inventory_all_params_with_retries(self):
        # Enable retries and run test_replace_inventory_all_params.
        _service.enable_retries()
        self.test_replace_inventory_all_params()

        # Disable retries and run test_replace_inventory_all_params.
        _service.disable_retries()
        self.test_replace_inventory_all_params()

    @responses.activate
    def test_replace_inventory_value_error(self):
        """
        test_replace_inventory_value_error()
        """
        # Set up mock
        url = preprocess_url('/v2/inventories/testString')
        mock_response = '{"name": "name", "id": "id", "description": "description", "location": "us-south", "resource_group": "resource_group", "created_at": "2019-01-01T12:00:00.000Z", "created_by": "created_by", "updated_at": "2019-01-01T12:00:00.000Z", "updated_by": "updated_by", "inventories_ini": "inventories_ini", "resource_queries": ["resource_queries"]}'
        responses.add(
            responses.PUT,
            url,
            body=mock_response,
            content_type='application/json',
            status=200,
        )

        # Set up parameter values
        inventory_id = 'testString'
        name = 'testString'
        description = 'testString'
        location = 'us-south'
        resource_group = 'testString'
        inventories_ini = 'testString'
        resource_queries = ['testString']

        # Pass in all but one required param and check for a ValueError
        req_param_dict = {
            "inventory_id": inventory_id,
        }
        for param in req_param_dict.keys():
            req_copy = {key: val if key is not param else None for (key, val) in req_param_dict.items()}
            with pytest.raises(ValueError):
                _service.replace_inventory(**req_copy)

    def test_replace_inventory_value_error_with_retries(self):
        # Enable retries and run test_replace_inventory_value_error.
        _service.enable_retries()
        self.test_replace_inventory_value_error()

        # Disable retries and run test_replace_inventory_value_error.
        _service.disable_retries()
        self.test_replace_inventory_value_error()


class TestDeleteInventory:
    """
    Test Class for delete_inventory
    """

    @responses.activate
    def test_delete_inventory_all_params(self):
        """
        delete_inventory()
        """
        # Set up mock
        url = preprocess_url('/v2/inventories/testString')
        responses.add(
            responses.DELETE,
            url,
            status=204,
        )

        # Set up parameter values
        inventory_id = 'testString'
        force = True
        propagate = True

        # Invoke method
        response = _service.delete_inventory(
            inventory_id,
            force=force,
            propagate=propagate,
            headers={},
        )

        # Check for correct operation
        assert len(responses.calls) == 1
        assert response.status_code == 204

    def test_delete_inventory_all_params_with_retries(self):
        # Enable retries and run test_delete_inventory_all_params.
        _service.enable_retries()
        self.test_delete_inventory_all_params()

        # Disable retries and run test_delete_inventory_all_params.
        _service.disable_retries()
        self.test_delete_inventory_all_params()

    @responses.activate
    def test_delete_inventory_required_params(self):
        """
        test_delete_inventory_required_params()
        """
        # Set up mock
        url = preprocess_url('/v2/inventories/testString')
        responses.add(
            responses.DELETE,
            url,
            status=204,
        )

        # Set up parameter values
        inventory_id = 'testString'

        # Invoke method
        response = _service.delete_inventory(
            inventory_id,
            headers={},
        )

        # Check for correct operation
        assert len(responses.calls) == 1
        assert response.status_code == 204

    def test_delete_inventory_required_params_with_retries(self):
        # Enable retries and run test_delete_inventory_required_params.
        _service.enable_retries()
        self.test_delete_inventory_required_params()

        # Disable retries and run test_delete_inventory_required_params.
        _service.disable_retries()
        self.test_delete_inventory_required_params()

    @responses.activate
    def test_delete_inventory_value_error(self):
        """
        test_delete_inventory_value_error()
        """
        # Set up mock
        url = preprocess_url('/v2/inventories/testString')
        responses.add(
            responses.DELETE,
            url,
            status=204,
        )

        # Set up parameter values
        inventory_id = 'testString'

        # Pass in all but one required param and check for a ValueError
        req_param_dict = {
            "inventory_id": inventory_id,
        }
        for param in req_param_dict.keys():
            req_copy = {key: val if key is not param else None for (key, val) in req_param_dict.items()}
            with pytest.raises(ValueError):
                _service.delete_inventory(**req_copy)

    def test_delete_inventory_value_error_with_retries(self):
        # Enable retries and run test_delete_inventory_value_error.
        _service.enable_retries()
        self.test_delete_inventory_value_error()

        # Disable retries and run test_delete_inventory_value_error.
        _service.disable_retries()
        self.test_delete_inventory_value_error()


class TestListResourceQuery:
    """
    Test Class for list_resource_query
    """

    @responses.activate
    def test_list_resource_query_all_params(self):
        """
        list_resource_query()
        """
        # Set up mock
        url = preprocess_url('/v2/resources_query')
        mock_response = '{"total_count": 11, "limit": 5, "offset": 6, "resource_queries": [{"type": "vsi", "name": "name", "id": "id", "created_at": "2019-01-01T12:00:00.000Z", "created_by": "created_by", "updated_at": "2019-01-01T12:00:00.000Z", "updated_by": "updated_by", "queries": [{"query_type": "workspaces", "query_condition": [{"name": "name", "value": "value", "description": "description"}], "query_select": ["query_select"]}]}]}'
        responses.add(
            responses.GET,
            url,
            body=mock_response,
            content_type='application/json',
            status=200,
        )

        # Set up parameter values
        offset = 0
        limit = 100
        sort = 'testString'
        profile = 'ids'

        # Invoke method
        response = _service.list_resource_query(
            offset=offset,
            limit=limit,
            sort=sort,
            profile=profile,
            headers={},
        )

        # Check for correct operation
        assert len(responses.calls) == 1
        assert response.status_code == 200
        # Validate query params
        query_string = responses.calls[0].request.url.split('?', 1)[1]
        query_string = urllib.parse.unquote_plus(query_string)
        assert 'offset={}'.format(offset) in query_string
        assert 'limit={}'.format(limit) in query_string
        assert 'sort={}'.format(sort) in query_string
        assert 'profile={}'.format(profile) in query_string

    def test_list_resource_query_all_params_with_retries(self):
        # Enable retries and run test_list_resource_query_all_params.
        _service.enable_retries()
        self.test_list_resource_query_all_params()

        # Disable retries and run test_list_resource_query_all_params.
        _service.disable_retries()
        self.test_list_resource_query_all_params()

    @responses.activate
    def test_list_resource_query_required_params(self):
        """
        test_list_resource_query_required_params()
        """
        # Set up mock
        url = preprocess_url('/v2/resources_query')
        mock_response = '{"total_count": 11, "limit": 5, "offset": 6, "resource_queries": [{"type": "vsi", "name": "name", "id": "id", "created_at": "2019-01-01T12:00:00.000Z", "created_by": "created_by", "updated_at": "2019-01-01T12:00:00.000Z", "updated_by": "updated_by", "queries": [{"query_type": "workspaces", "query_condition": [{"name": "name", "value": "value", "description": "description"}], "query_select": ["query_select"]}]}]}'
        responses.add(
            responses.GET,
            url,
            body=mock_response,
            content_type='application/json',
            status=200,
        )

        # Invoke method
        response = _service.list_resource_query()

        # Check for correct operation
        assert len(responses.calls) == 1
        assert response.status_code == 200

    def test_list_resource_query_required_params_with_retries(self):
        # Enable retries and run test_list_resource_query_required_params.
        _service.enable_retries()
        self.test_list_resource_query_required_params()

        # Disable retries and run test_list_resource_query_required_params.
        _service.disable_retries()
        self.test_list_resource_query_required_params()


class TestCreateResourceQuery:
    """
    Test Class for create_resource_query
    """

    @responses.activate
    def test_create_resource_query_all_params(self):
        """
        create_resource_query()
        """
        # Set up mock
        url = preprocess_url('/v2/resources_query')
        mock_response = '{"type": "vsi", "name": "name", "id": "id", "created_at": "2019-01-01T12:00:00.000Z", "created_by": "created_by", "updated_at": "2019-01-01T12:00:00.000Z", "updated_by": "updated_by", "queries": [{"query_type": "workspaces", "query_condition": [{"name": "name", "value": "value", "description": "description"}], "query_select": ["query_select"]}]}'
        responses.add(
            responses.POST,
            url,
            body=mock_response,
            content_type='application/json',
            status=200,
        )

        # Construct a dict representation of a ResourceQueryParam model
        resource_query_param_model = {}
        resource_query_param_model['name'] = 'testString'
        resource_query_param_model['value'] = 'testString'
        resource_query_param_model['description'] = 'testString'

        # Construct a dict representation of a ResourceQuery model
        resource_query_model = {}
        resource_query_model['query_type'] = 'workspaces'
        resource_query_model['query_condition'] = [resource_query_param_model]
        resource_query_model['query_select'] = ['testString']

        # Set up parameter values
        type = 'vsi'
        name = 'testString'
        queries = [resource_query_model]

        # Invoke method
        response = _service.create_resource_query(
            type=type,
            name=name,
            queries=queries,
            headers={},
        )

        # Check for correct operation
        assert len(responses.calls) == 1
        assert response.status_code == 200
        # Validate body params
        req_body = json.loads(str(responses.calls[0].request.body, 'utf-8'))
        assert req_body['type'] == 'vsi'
        assert req_body['name'] == 'testString'
        assert req_body['queries'] == [resource_query_model]

    def test_create_resource_query_all_params_with_retries(self):
        # Enable retries and run test_create_resource_query_all_params.
        _service.enable_retries()
        self.test_create_resource_query_all_params()

        # Disable retries and run test_create_resource_query_all_params.
        _service.disable_retries()
        self.test_create_resource_query_all_params()


class TestGetResourcesQuery:
    """
    Test Class for get_resources_query
    """

    @responses.activate
    def test_get_resources_query_all_params(self):
        """
        get_resources_query()
        """
        # Set up mock
        url = preprocess_url('/v2/resources_query/testString')
        mock_response = '{"type": "vsi", "name": "name", "id": "id", "created_at": "2019-01-01T12:00:00.000Z", "created_by": "created_by", "updated_at": "2019-01-01T12:00:00.000Z", "updated_by": "updated_by", "queries": [{"query_type": "workspaces", "query_condition": [{"name": "name", "value": "value", "description": "description"}], "query_select": ["query_select"]}]}'
        responses.add(
            responses.GET,
            url,
            body=mock_response,
            content_type='application/json',
            status=200,
        )

        # Set up parameter values
        query_id = 'testString'

        # Invoke method
        response = _service.get_resources_query(
            query_id,
            headers={},
        )

        # Check for correct operation
        assert len(responses.calls) == 1
        assert response.status_code == 200

    def test_get_resources_query_all_params_with_retries(self):
        # Enable retries and run test_get_resources_query_all_params.
        _service.enable_retries()
        self.test_get_resources_query_all_params()

        # Disable retries and run test_get_resources_query_all_params.
        _service.disable_retries()
        self.test_get_resources_query_all_params()

    @responses.activate
    def test_get_resources_query_value_error(self):
        """
        test_get_resources_query_value_error()
        """
        # Set up mock
        url = preprocess_url('/v2/resources_query/testString')
        mock_response = '{"type": "vsi", "name": "name", "id": "id", "created_at": "2019-01-01T12:00:00.000Z", "created_by": "created_by", "updated_at": "2019-01-01T12:00:00.000Z", "updated_by": "updated_by", "queries": [{"query_type": "workspaces", "query_condition": [{"name": "name", "value": "value", "description": "description"}], "query_select": ["query_select"]}]}'
        responses.add(
            responses.GET,
            url,
            body=mock_response,
            content_type='application/json',
            status=200,
        )

        # Set up parameter values
        query_id = 'testString'

        # Pass in all but one required param and check for a ValueError
        req_param_dict = {
            "query_id": query_id,
        }
        for param in req_param_dict.keys():
            req_copy = {key: val if key is not param else None for (key, val) in req_param_dict.items()}
            with pytest.raises(ValueError):
                _service.get_resources_query(**req_copy)

    def test_get_resources_query_value_error_with_retries(self):
        # Enable retries and run test_get_resources_query_value_error.
        _service.enable_retries()
        self.test_get_resources_query_value_error()

        # Disable retries and run test_get_resources_query_value_error.
        _service.disable_retries()
        self.test_get_resources_query_value_error()


class TestReplaceResourcesQuery:
    """
    Test Class for replace_resources_query
    """

    @responses.activate
    def test_replace_resources_query_all_params(self):
        """
        replace_resources_query()
        """
        # Set up mock
        url = preprocess_url('/v2/resources_query/testString')
        mock_response = '{"type": "vsi", "name": "name", "id": "id", "created_at": "2019-01-01T12:00:00.000Z", "created_by": "created_by", "updated_at": "2019-01-01T12:00:00.000Z", "updated_by": "updated_by", "queries": [{"query_type": "workspaces", "query_condition": [{"name": "name", "value": "value", "description": "description"}], "query_select": ["query_select"]}]}'
        responses.add(
            responses.PUT,
            url,
            body=mock_response,
            content_type='application/json',
            status=200,
        )

        # Construct a dict representation of a ResourceQueryParam model
        resource_query_param_model = {}
        resource_query_param_model['name'] = 'testString'
        resource_query_param_model['value'] = 'testString'
        resource_query_param_model['description'] = 'testString'

        # Construct a dict representation of a ResourceQuery model
        resource_query_model = {}
        resource_query_model['query_type'] = 'workspaces'
        resource_query_model['query_condition'] = [resource_query_param_model]
        resource_query_model['query_select'] = ['testString']

        # Set up parameter values
        query_id = 'testString'
        type = 'vsi'
        name = 'testString'
        queries = [resource_query_model]

        # Invoke method
        response = _service.replace_resources_query(
            query_id,
            type=type,
            name=name,
            queries=queries,
            headers={},
        )

        # Check for correct operation
        assert len(responses.calls) == 1
        assert response.status_code == 200
        # Validate body params
        req_body = json.loads(str(responses.calls[0].request.body, 'utf-8'))
        assert req_body['type'] == 'vsi'
        assert req_body['name'] == 'testString'
        assert req_body['queries'] == [resource_query_model]

    def test_replace_resources_query_all_params_with_retries(self):
        # Enable retries and run test_replace_resources_query_all_params.
        _service.enable_retries()
        self.test_replace_resources_query_all_params()

        # Disable retries and run test_replace_resources_query_all_params.
        _service.disable_retries()
        self.test_replace_resources_query_all_params()

    @responses.activate
    def test_replace_resources_query_value_error(self):
        """
        test_replace_resources_query_value_error()
        """
        # Set up mock
        url = preprocess_url('/v2/resources_query/testString')
        mock_response = '{"type": "vsi", "name": "name", "id": "id", "created_at": "2019-01-01T12:00:00.000Z", "created_by": "created_by", "updated_at": "2019-01-01T12:00:00.000Z", "updated_by": "updated_by", "queries": [{"query_type": "workspaces", "query_condition": [{"name": "name", "value": "value", "description": "description"}], "query_select": ["query_select"]}]}'
        responses.add(
            responses.PUT,
            url,
            body=mock_response,
            content_type='application/json',
            status=200,
        )

        # Construct a dict representation of a ResourceQueryParam model
        resource_query_param_model = {}
        resource_query_param_model['name'] = 'testString'
        resource_query_param_model['value'] = 'testString'
        resource_query_param_model['description'] = 'testString'

        # Construct a dict representation of a ResourceQuery model
        resource_query_model = {}
        resource_query_model['query_type'] = 'workspaces'
        resource_query_model['query_condition'] = [resource_query_param_model]
        resource_query_model['query_select'] = ['testString']

        # Set up parameter values
        query_id = 'testString'
        type = 'vsi'
        name = 'testString'
        queries = [resource_query_model]

        # Pass in all but one required param and check for a ValueError
        req_param_dict = {
            "query_id": query_id,
        }
        for param in req_param_dict.keys():
            req_copy = {key: val if key is not param else None for (key, val) in req_param_dict.items()}
            with pytest.raises(ValueError):
                _service.replace_resources_query(**req_copy)

    def test_replace_resources_query_value_error_with_retries(self):
        # Enable retries and run test_replace_resources_query_value_error.
        _service.enable_retries()
        self.test_replace_resources_query_value_error()

        # Disable retries and run test_replace_resources_query_value_error.
        _service.disable_retries()
        self.test_replace_resources_query_value_error()


class TestExecuteResourceQuery:
    """
    Test Class for execute_resource_query
    """

    @responses.activate
    def test_execute_resource_query_all_params(self):
        """
        execute_resource_query()
        """
        # Set up mock
        url = preprocess_url('/v2/resources_query/testString')
        mock_response = '{"response": [{"query_type": "workspaces", "query_condition": [{"name": "name", "value": "value", "description": "description"}], "query_select": ["query_select"], "query_output": [{"name": "name", "value": "value"}]}]}'
        responses.add(
            responses.POST,
            url,
            body=mock_response,
            content_type='application/json',
            status=200,
        )

        # Set up parameter values
        query_id = 'testString'

        # Invoke method
        response = _service.execute_resource_query(
            query_id,
            headers={},
        )

        # Check for correct operation
        assert len(responses.calls) == 1
        assert response.status_code == 200

    def test_execute_resource_query_all_params_with_retries(self):
        # Enable retries and run test_execute_resource_query_all_params.
        _service.enable_retries()
        self.test_execute_resource_query_all_params()

        # Disable retries and run test_execute_resource_query_all_params.
        _service.disable_retries()
        self.test_execute_resource_query_all_params()

    @responses.activate
    def test_execute_resource_query_value_error(self):
        """
        test_execute_resource_query_value_error()
        """
        # Set up mock
        url = preprocess_url('/v2/resources_query/testString')
        mock_response = '{"response": [{"query_type": "workspaces", "query_condition": [{"name": "name", "value": "value", "description": "description"}], "query_select": ["query_select"], "query_output": [{"name": "name", "value": "value"}]}]}'
        responses.add(
            responses.POST,
            url,
            body=mock_response,
            content_type='application/json',
            status=200,
        )

        # Set up parameter values
        query_id = 'testString'

        # Pass in all but one required param and check for a ValueError
        req_param_dict = {
            "query_id": query_id,
        }
        for param in req_param_dict.keys():
            req_copy = {key: val if key is not param else None for (key, val) in req_param_dict.items()}
            with pytest.raises(ValueError):
                _service.execute_resource_query(**req_copy)

    def test_execute_resource_query_value_error_with_retries(self):
        # Enable retries and run test_execute_resource_query_value_error.
        _service.enable_retries()
        self.test_execute_resource_query_value_error()

        # Disable retries and run test_execute_resource_query_value_error.
        _service.disable_retries()
        self.test_execute_resource_query_value_error()


class TestDeleteResourcesQuery:
    """
    Test Class for delete_resources_query
    """

    @responses.activate
    def test_delete_resources_query_all_params(self):
        """
        delete_resources_query()
        """
        # Set up mock
        url = preprocess_url('/v2/resources_query/testString')
        responses.add(
            responses.DELETE,
            url,
            status=204,
        )

        # Set up parameter values
        query_id = 'testString'
        force = True
        propagate = True

        # Invoke method
        response = _service.delete_resources_query(
            query_id,
            force=force,
            propagate=propagate,
            headers={},
        )

        # Check for correct operation
        assert len(responses.calls) == 1
        assert response.status_code == 204

    def test_delete_resources_query_all_params_with_retries(self):
        # Enable retries and run test_delete_resources_query_all_params.
        _service.enable_retries()
        self.test_delete_resources_query_all_params()

        # Disable retries and run test_delete_resources_query_all_params.
        _service.disable_retries()
        self.test_delete_resources_query_all_params()

    @responses.activate
    def test_delete_resources_query_required_params(self):
        """
        test_delete_resources_query_required_params()
        """
        # Set up mock
        url = preprocess_url('/v2/resources_query/testString')
        responses.add(
            responses.DELETE,
            url,
            status=204,
        )

        # Set up parameter values
        query_id = 'testString'

        # Invoke method
        response = _service.delete_resources_query(
            query_id,
            headers={},
        )

        # Check for correct operation
        assert len(responses.calls) == 1
        assert response.status_code == 204

    def test_delete_resources_query_required_params_with_retries(self):
        # Enable retries and run test_delete_resources_query_required_params.
        _service.enable_retries()
        self.test_delete_resources_query_required_params()

        # Disable retries and run test_delete_resources_query_required_params.
        _service.disable_retries()
        self.test_delete_resources_query_required_params()

    @responses.activate
    def test_delete_resources_query_value_error(self):
        """
        test_delete_resources_query_value_error()
        """
        # Set up mock
        url = preprocess_url('/v2/resources_query/testString')
        responses.add(
            responses.DELETE,
            url,
            status=204,
        )

        # Set up parameter values
        query_id = 'testString'

        # Pass in all but one required param and check for a ValueError
        req_param_dict = {
            "query_id": query_id,
        }
        for param in req_param_dict.keys():
            req_copy = {key: val if key is not param else None for (key, val) in req_param_dict.items()}
            with pytest.raises(ValueError):
                _service.delete_resources_query(**req_copy)

    def test_delete_resources_query_value_error_with_retries(self):
        # Enable retries and run test_delete_resources_query_value_error.
        _service.enable_retries()
        self.test_delete_resources_query_value_error()

        # Disable retries and run test_delete_resources_query_value_error.
        _service.disable_retries()
        self.test_delete_resources_query_value_error()


# endregion
##############################################################################
# End of Service: Inventory
##############################################################################

##############################################################################
# Start of Service: Agent
##############################################################################
# region


class TestNewInstance:
    """
    Test Class for new_instance
    """

    def test_new_instance(self):
        """
        new_instance()
        """
        os.environ['TEST_SERVICE_AUTH_TYPE'] = 'noAuth'

        service = SchematicsV1.new_instance(
            service_name='TEST_SERVICE',
        )

        assert service is not None
        assert isinstance(service, SchematicsV1)

    def test_new_instance_without_authenticator(self):
        """
        new_instance_without_authenticator()
        """
        with pytest.raises(ValueError, match='authenticator must be provided'):
            service = SchematicsV1.new_instance(
                service_name='TEST_SERVICE_NOT_FOUND',
            )


class TestListAgent:
    """
    Test Class for list_agent
    """

    @responses.activate
    def test_list_agent_all_params(self):
        """
        list_agent()
        """
        # Set up mock
        url = preprocess_url('/v2/settings/agents')
        mock_response = '{"total_count": 11, "limit": 5, "offset": 6, "agents": [{"name": "MyDevAgent", "description": "Register agent", "resource_group": "resource_group", "tags": ["tags"], "agent_location": "us-south", "location": "us-south", "profile_id": "profile_id", "agent_crn": "agent_crn", "id": "id", "registered_at": "2019-01-01T12:00:00.000Z", "registered_by": "registered_by", "updated_at": "2019-01-01T12:00:00.000Z", "updated_by": "updated_by", "user_state": {"state": "enable", "set_by": "set_by", "set_at": "2019-01-01T12:00:00.000Z"}, "connection_state": {"state": "Connected", "checked_at": "2019-01-01T12:00:00.000Z"}, "system_state": {"state": "error", "message": "message"}}]}'
        responses.add(
            responses.GET,
            url,
            body=mock_response,
            content_type='application/json',
            status=200,
        )

        # Set up parameter values
        offset = 0
        limit = 100
        profile = 'summary'
        filter = 'all'

        # Invoke method
        response = _service.list_agent(
            offset=offset,
            limit=limit,
            profile=profile,
            filter=filter,
            headers={},
        )

        # Check for correct operation
        assert len(responses.calls) == 1
        assert response.status_code == 200
        # Validate query params
        query_string = responses.calls[0].request.url.split('?', 1)[1]
        query_string = urllib.parse.unquote_plus(query_string)
        assert 'offset={}'.format(offset) in query_string
        assert 'limit={}'.format(limit) in query_string
        assert 'profile={}'.format(profile) in query_string
        assert 'filter={}'.format(filter) in query_string

    def test_list_agent_all_params_with_retries(self):
        # Enable retries and run test_list_agent_all_params.
        _service.enable_retries()
        self.test_list_agent_all_params()

        # Disable retries and run test_list_agent_all_params.
        _service.disable_retries()
        self.test_list_agent_all_params()

    @responses.activate
    def test_list_agent_required_params(self):
        """
        test_list_agent_required_params()
        """
        # Set up mock
        url = preprocess_url('/v2/settings/agents')
        mock_response = '{"total_count": 11, "limit": 5, "offset": 6, "agents": [{"name": "MyDevAgent", "description": "Register agent", "resource_group": "resource_group", "tags": ["tags"], "agent_location": "us-south", "location": "us-south", "profile_id": "profile_id", "agent_crn": "agent_crn", "id": "id", "registered_at": "2019-01-01T12:00:00.000Z", "registered_by": "registered_by", "updated_at": "2019-01-01T12:00:00.000Z", "updated_by": "updated_by", "user_state": {"state": "enable", "set_by": "set_by", "set_at": "2019-01-01T12:00:00.000Z"}, "connection_state": {"state": "Connected", "checked_at": "2019-01-01T12:00:00.000Z"}, "system_state": {"state": "error", "message": "message"}}]}'
        responses.add(
            responses.GET,
            url,
            body=mock_response,
            content_type='application/json',
            status=200,
        )

        # Invoke method
        response = _service.list_agent()

        # Check for correct operation
        assert len(responses.calls) == 1
        assert response.status_code == 200

    def test_list_agent_required_params_with_retries(self):
        # Enable retries and run test_list_agent_required_params.
        _service.enable_retries()
        self.test_list_agent_required_params()

        # Disable retries and run test_list_agent_required_params.
        _service.disable_retries()
        self.test_list_agent_required_params()


class TestRegisterAgent:
    """
    Test Class for register_agent
    """

    @responses.activate
    def test_register_agent_all_params(self):
        """
        register_agent()
        """
        # Set up mock
        url = preprocess_url('/v2/settings/agents')
        mock_response = '{"name": "MyDevAgent", "description": "Register agent", "resource_group": "resource_group", "tags": ["tags"], "agent_location": "us-south", "location": "us-south", "profile_id": "profile_id", "agent_crn": "agent_crn", "id": "id", "registered_at": "2019-01-01T12:00:00.000Z", "registered_by": "registered_by", "updated_at": "2019-01-01T12:00:00.000Z", "updated_by": "updated_by", "user_state": {"state": "enable", "set_by": "set_by", "set_at": "2019-01-01T12:00:00.000Z"}, "connection_state": {"state": "Connected", "checked_at": "2019-01-01T12:00:00.000Z"}, "system_state": {"state": "error", "message": "message"}}'
        responses.add(
            responses.POST,
            url,
            body=mock_response,
            content_type='application/json',
            status=201,
        )

        # Construct a dict representation of a AgentUserState model
        agent_user_state_model = {}
        agent_user_state_model['state'] = 'enable'

        # Set up parameter values
        name = 'MyDevAgent'
        agent_location = 'us-south'
        location = 'us-south'
        profile_id = 'testString'
        description = 'Register agent'
        resource_group = 'testString'
        tags = ['testString']
        user_state = agent_user_state_model

        # Invoke method
        response = _service.register_agent(
            name,
            agent_location,
            location,
            profile_id,
            description=description,
            resource_group=resource_group,
            tags=tags,
            user_state=user_state,
            headers={},
        )

        # Check for correct operation
        assert len(responses.calls) == 1
        assert response.status_code == 201
        # Validate body params
        req_body = json.loads(str(responses.calls[0].request.body, 'utf-8'))
        assert req_body['name'] == 'MyDevAgent'
        assert req_body['agent_location'] == 'us-south'
        assert req_body['location'] == 'us-south'
        assert req_body['profile_id'] == 'testString'
        assert req_body['description'] == 'Register agent'
        assert req_body['resource_group'] == 'testString'
        assert req_body['tags'] == ['testString']
        assert req_body['user_state'] == agent_user_state_model

    def test_register_agent_all_params_with_retries(self):
        # Enable retries and run test_register_agent_all_params.
        _service.enable_retries()
        self.test_register_agent_all_params()

        # Disable retries and run test_register_agent_all_params.
        _service.disable_retries()
        self.test_register_agent_all_params()

    @responses.activate
    def test_register_agent_value_error(self):
        """
        test_register_agent_value_error()
        """
        # Set up mock
        url = preprocess_url('/v2/settings/agents')
        mock_response = '{"name": "MyDevAgent", "description": "Register agent", "resource_group": "resource_group", "tags": ["tags"], "agent_location": "us-south", "location": "us-south", "profile_id": "profile_id", "agent_crn": "agent_crn", "id": "id", "registered_at": "2019-01-01T12:00:00.000Z", "registered_by": "registered_by", "updated_at": "2019-01-01T12:00:00.000Z", "updated_by": "updated_by", "user_state": {"state": "enable", "set_by": "set_by", "set_at": "2019-01-01T12:00:00.000Z"}, "connection_state": {"state": "Connected", "checked_at": "2019-01-01T12:00:00.000Z"}, "system_state": {"state": "error", "message": "message"}}'
        responses.add(
            responses.POST,
            url,
            body=mock_response,
            content_type='application/json',
            status=201,
        )

        # Construct a dict representation of a AgentUserState model
        agent_user_state_model = {}
        agent_user_state_model['state'] = 'enable'

        # Set up parameter values
        name = 'MyDevAgent'
        agent_location = 'us-south'
        location = 'us-south'
        profile_id = 'testString'
        description = 'Register agent'
        resource_group = 'testString'
        tags = ['testString']
        user_state = agent_user_state_model

        # Pass in all but one required param and check for a ValueError
        req_param_dict = {
            "name": name,
            "agent_location": agent_location,
            "location": location,
            "profile_id": profile_id,
        }
        for param in req_param_dict.keys():
            req_copy = {key: val if key is not param else None for (key, val) in req_param_dict.items()}
            with pytest.raises(ValueError):
                _service.register_agent(**req_copy)

    def test_register_agent_value_error_with_retries(self):
        # Enable retries and run test_register_agent_value_error.
        _service.enable_retries()
        self.test_register_agent_value_error()

        # Disable retries and run test_register_agent_value_error.
        _service.disable_retries()
        self.test_register_agent_value_error()


class TestGetAgent:
    """
    Test Class for get_agent
    """

    @responses.activate
    def test_get_agent_all_params(self):
        """
        get_agent()
        """
        # Set up mock
        url = preprocess_url('/v2/settings/agents/testString')
        mock_response = '{"name": "MyDevAgent", "description": "Register agent", "resource_group": "resource_group", "tags": ["tags"], "agent_location": "us-south", "location": "us-south", "profile_id": "profile_id", "agent_crn": "agent_crn", "id": "id", "registered_at": "2019-01-01T12:00:00.000Z", "registered_by": "registered_by", "updated_at": "2019-01-01T12:00:00.000Z", "updated_by": "updated_by", "user_state": {"state": "enable", "set_by": "set_by", "set_at": "2019-01-01T12:00:00.000Z"}, "connection_state": {"state": "Connected", "checked_at": "2019-01-01T12:00:00.000Z"}, "system_state": {"state": "error", "message": "message"}}'
        responses.add(
            responses.GET,
            url,
            body=mock_response,
            content_type='application/json',
            status=200,
        )

        # Set up parameter values
        agent_id = 'testString'
        profile = 'summary'

        # Invoke method
        response = _service.get_agent(
            agent_id,
            profile=profile,
            headers={},
        )

        # Check for correct operation
        assert len(responses.calls) == 1
        assert response.status_code == 200
        # Validate query params
        query_string = responses.calls[0].request.url.split('?', 1)[1]
        query_string = urllib.parse.unquote_plus(query_string)
        assert 'profile={}'.format(profile) in query_string

    def test_get_agent_all_params_with_retries(self):
        # Enable retries and run test_get_agent_all_params.
        _service.enable_retries()
        self.test_get_agent_all_params()

        # Disable retries and run test_get_agent_all_params.
        _service.disable_retries()
        self.test_get_agent_all_params()

    @responses.activate
    def test_get_agent_required_params(self):
        """
        test_get_agent_required_params()
        """
        # Set up mock
        url = preprocess_url('/v2/settings/agents/testString')
        mock_response = '{"name": "MyDevAgent", "description": "Register agent", "resource_group": "resource_group", "tags": ["tags"], "agent_location": "us-south", "location": "us-south", "profile_id": "profile_id", "agent_crn": "agent_crn", "id": "id", "registered_at": "2019-01-01T12:00:00.000Z", "registered_by": "registered_by", "updated_at": "2019-01-01T12:00:00.000Z", "updated_by": "updated_by", "user_state": {"state": "enable", "set_by": "set_by", "set_at": "2019-01-01T12:00:00.000Z"}, "connection_state": {"state": "Connected", "checked_at": "2019-01-01T12:00:00.000Z"}, "system_state": {"state": "error", "message": "message"}}'
        responses.add(
            responses.GET,
            url,
            body=mock_response,
            content_type='application/json',
            status=200,
        )

        # Set up parameter values
        agent_id = 'testString'

        # Invoke method
        response = _service.get_agent(
            agent_id,
            headers={},
        )

        # Check for correct operation
        assert len(responses.calls) == 1
        assert response.status_code == 200

    def test_get_agent_required_params_with_retries(self):
        # Enable retries and run test_get_agent_required_params.
        _service.enable_retries()
        self.test_get_agent_required_params()

        # Disable retries and run test_get_agent_required_params.
        _service.disable_retries()
        self.test_get_agent_required_params()

    @responses.activate
    def test_get_agent_value_error(self):
        """
        test_get_agent_value_error()
        """
        # Set up mock
        url = preprocess_url('/v2/settings/agents/testString')
        mock_response = '{"name": "MyDevAgent", "description": "Register agent", "resource_group": "resource_group", "tags": ["tags"], "agent_location": "us-south", "location": "us-south", "profile_id": "profile_id", "agent_crn": "agent_crn", "id": "id", "registered_at": "2019-01-01T12:00:00.000Z", "registered_by": "registered_by", "updated_at": "2019-01-01T12:00:00.000Z", "updated_by": "updated_by", "user_state": {"state": "enable", "set_by": "set_by", "set_at": "2019-01-01T12:00:00.000Z"}, "connection_state": {"state": "Connected", "checked_at": "2019-01-01T12:00:00.000Z"}, "system_state": {"state": "error", "message": "message"}}'
        responses.add(
            responses.GET,
            url,
            body=mock_response,
            content_type='application/json',
            status=200,
        )

        # Set up parameter values
        agent_id = 'testString'

        # Pass in all but one required param and check for a ValueError
        req_param_dict = {
            "agent_id": agent_id,
        }
        for param in req_param_dict.keys():
            req_copy = {key: val if key is not param else None for (key, val) in req_param_dict.items()}
            with pytest.raises(ValueError):
                _service.get_agent(**req_copy)

    def test_get_agent_value_error_with_retries(self):
        # Enable retries and run test_get_agent_value_error.
        _service.enable_retries()
        self.test_get_agent_value_error()

        # Disable retries and run test_get_agent_value_error.
        _service.disable_retries()
        self.test_get_agent_value_error()


class TestDeleteAgent:
    """
    Test Class for delete_agent
    """

    @responses.activate
    def test_delete_agent_all_params(self):
        """
        delete_agent()
        """
        # Set up mock
        url = preprocess_url('/v2/settings/agents/testString')
        responses.add(
            responses.DELETE,
            url,
            status=204,
        )

        # Set up parameter values
        agent_id = 'testString'

        # Invoke method
        response = _service.delete_agent(
            agent_id,
            headers={},
        )

        # Check for correct operation
        assert len(responses.calls) == 1
        assert response.status_code == 204

    def test_delete_agent_all_params_with_retries(self):
        # Enable retries and run test_delete_agent_all_params.
        _service.enable_retries()
        self.test_delete_agent_all_params()

        # Disable retries and run test_delete_agent_all_params.
        _service.disable_retries()
        self.test_delete_agent_all_params()

    @responses.activate
    def test_delete_agent_value_error(self):
        """
        test_delete_agent_value_error()
        """
        # Set up mock
        url = preprocess_url('/v2/settings/agents/testString')
        responses.add(
            responses.DELETE,
            url,
            status=204,
        )

        # Set up parameter values
        agent_id = 'testString'

        # Pass in all but one required param and check for a ValueError
        req_param_dict = {
            "agent_id": agent_id,
        }
        for param in req_param_dict.keys():
            req_copy = {key: val if key is not param else None for (key, val) in req_param_dict.items()}
            with pytest.raises(ValueError):
                _service.delete_agent(**req_copy)

    def test_delete_agent_value_error_with_retries(self):
        # Enable retries and run test_delete_agent_value_error.
        _service.enable_retries()
        self.test_delete_agent_value_error()

        # Disable retries and run test_delete_agent_value_error.
        _service.disable_retries()
        self.test_delete_agent_value_error()


class TestUpdateAgentRegistration:
    """
    Test Class for update_agent_registration
    """

    @responses.activate
    def test_update_agent_registration_all_params(self):
        """
        update_agent_registration()
        """
        # Set up mock
        url = preprocess_url('/v2/settings/agents/testString')
        mock_response = '{"name": "MyDevAgent", "description": "Register agent", "resource_group": "resource_group", "tags": ["tags"], "agent_location": "us-south", "location": "us-south", "profile_id": "profile_id", "agent_crn": "agent_crn", "id": "id", "registered_at": "2019-01-01T12:00:00.000Z", "registered_by": "registered_by", "updated_at": "2019-01-01T12:00:00.000Z", "updated_by": "updated_by", "user_state": {"state": "enable", "set_by": "set_by", "set_at": "2019-01-01T12:00:00.000Z"}, "connection_state": {"state": "Connected", "checked_at": "2019-01-01T12:00:00.000Z"}, "system_state": {"state": "error", "message": "message"}}'
        responses.add(
            responses.PATCH,
            url,
            body=mock_response,
            content_type='application/json',
            status=201,
        )

        # Construct a dict representation of a AgentUserState model
        agent_user_state_model = {}
        agent_user_state_model['state'] = 'enable'

        # Set up parameter values
        agent_id = 'testString'
        name = 'MyDevAgent'
        agent_location = 'us-south'
        location = 'us-south'
        profile_id = 'testString'
        description = 'Register agent'
        resource_group = 'testString'
        tags = ['testString']
        user_state = agent_user_state_model

        # Invoke method
        response = _service.update_agent_registration(
            agent_id,
            name,
            agent_location,
            location,
            profile_id,
            description=description,
            resource_group=resource_group,
            tags=tags,
            user_state=user_state,
            headers={},
        )

        # Check for correct operation
        assert len(responses.calls) == 1
        assert response.status_code == 201
        # Validate body params
        req_body = json.loads(str(responses.calls[0].request.body, 'utf-8'))
        assert req_body['name'] == 'MyDevAgent'
        assert req_body['agent_location'] == 'us-south'
        assert req_body['location'] == 'us-south'
        assert req_body['profile_id'] == 'testString'
        assert req_body['description'] == 'Register agent'
        assert req_body['resource_group'] == 'testString'
        assert req_body['tags'] == ['testString']
        assert req_body['user_state'] == agent_user_state_model

    def test_update_agent_registration_all_params_with_retries(self):
        # Enable retries and run test_update_agent_registration_all_params.
        _service.enable_retries()
        self.test_update_agent_registration_all_params()

        # Disable retries and run test_update_agent_registration_all_params.
        _service.disable_retries()
        self.test_update_agent_registration_all_params()

    @responses.activate
    def test_update_agent_registration_value_error(self):
        """
        test_update_agent_registration_value_error()
        """
        # Set up mock
        url = preprocess_url('/v2/settings/agents/testString')
        mock_response = '{"name": "MyDevAgent", "description": "Register agent", "resource_group": "resource_group", "tags": ["tags"], "agent_location": "us-south", "location": "us-south", "profile_id": "profile_id", "agent_crn": "agent_crn", "id": "id", "registered_at": "2019-01-01T12:00:00.000Z", "registered_by": "registered_by", "updated_at": "2019-01-01T12:00:00.000Z", "updated_by": "updated_by", "user_state": {"state": "enable", "set_by": "set_by", "set_at": "2019-01-01T12:00:00.000Z"}, "connection_state": {"state": "Connected", "checked_at": "2019-01-01T12:00:00.000Z"}, "system_state": {"state": "error", "message": "message"}}'
        responses.add(
            responses.PATCH,
            url,
            body=mock_response,
            content_type='application/json',
            status=201,
        )

        # Construct a dict representation of a AgentUserState model
        agent_user_state_model = {}
        agent_user_state_model['state'] = 'enable'

        # Set up parameter values
        agent_id = 'testString'
        name = 'MyDevAgent'
        agent_location = 'us-south'
        location = 'us-south'
        profile_id = 'testString'
        description = 'Register agent'
        resource_group = 'testString'
        tags = ['testString']
        user_state = agent_user_state_model

        # Pass in all but one required param and check for a ValueError
        req_param_dict = {
            "agent_id": agent_id,
            "name": name,
            "agent_location": agent_location,
            "location": location,
            "profile_id": profile_id,
        }
        for param in req_param_dict.keys():
            req_copy = {key: val if key is not param else None for (key, val) in req_param_dict.items()}
            with pytest.raises(ValueError):
                _service.update_agent_registration(**req_copy)

    def test_update_agent_registration_value_error_with_retries(self):
        # Enable retries and run test_update_agent_registration_value_error.
        _service.enable_retries()
        self.test_update_agent_registration_value_error()

        # Disable retries and run test_update_agent_registration_value_error.
        _service.disable_retries()
        self.test_update_agent_registration_value_error()


class TestListAgentData:
    """
    Test Class for list_agent_data
    """

    @responses.activate
    def test_list_agent_data_all_params(self):
        """
        list_agent_data()
        """
        # Set up mock
        url = preprocess_url('/v2/agents')
        mock_response = '{"total_count": 11, "limit": 5, "offset": 6, "agents": [{"name": "MyDevAgent", "description": "Register agent", "resource_group": "resource_group", "tags": ["tags"], "version": "v1.0.0", "schematics_location": "us-south", "agent_location": "us-south", "agent_metadata": [{"name": "purpose", "value": ["value"]}], "user_state": {"state": "enable", "set_by": "set_by", "set_at": "2019-01-01T12:00:00.000Z"}, "agent_crn": "agent_crn", "id": "id", "created_at": "2019-01-01T12:00:00.000Z", "creation_by": "creation_by", "updated_at": "2019-01-01T12:00:00.000Z", "updated_by": "updated_by", "system_state": {"status_code": "error", "status_message": "status_message"}, "agent_kpi": {"availability_indicator": "available", "lifecycle_indicator": "consistent", "percent_usage_indicator": "percent_usage_indicator"}}]}'
        responses.add(
            responses.GET,
            url,
            body=mock_response,
            content_type='application/json',
            status=200,
        )

        # Set up parameter values
        offset = 0
        limit = 100
        profile = 'summary'
        filter = 'all'

        # Invoke method
        response = _service.list_agent_data(
            offset=offset,
            limit=limit,
            profile=profile,
            filter=filter,
            headers={},
        )

        # Check for correct operation
        assert len(responses.calls) == 1
        assert response.status_code == 200
        # Validate query params
        query_string = responses.calls[0].request.url.split('?', 1)[1]
        query_string = urllib.parse.unquote_plus(query_string)
        assert 'offset={}'.format(offset) in query_string
        assert 'limit={}'.format(limit) in query_string
        assert 'profile={}'.format(profile) in query_string
        assert 'filter={}'.format(filter) in query_string

    def test_list_agent_data_all_params_with_retries(self):
        # Enable retries and run test_list_agent_data_all_params.
        _service.enable_retries()
        self.test_list_agent_data_all_params()

        # Disable retries and run test_list_agent_data_all_params.
        _service.disable_retries()
        self.test_list_agent_data_all_params()

    @responses.activate
    def test_list_agent_data_required_params(self):
        """
        test_list_agent_data_required_params()
        """
        # Set up mock
        url = preprocess_url('/v2/agents')
        mock_response = '{"total_count": 11, "limit": 5, "offset": 6, "agents": [{"name": "MyDevAgent", "description": "Register agent", "resource_group": "resource_group", "tags": ["tags"], "version": "v1.0.0", "schematics_location": "us-south", "agent_location": "us-south", "agent_metadata": [{"name": "purpose", "value": ["value"]}], "user_state": {"state": "enable", "set_by": "set_by", "set_at": "2019-01-01T12:00:00.000Z"}, "agent_crn": "agent_crn", "id": "id", "created_at": "2019-01-01T12:00:00.000Z", "creation_by": "creation_by", "updated_at": "2019-01-01T12:00:00.000Z", "updated_by": "updated_by", "system_state": {"status_code": "error", "status_message": "status_message"}, "agent_kpi": {"availability_indicator": "available", "lifecycle_indicator": "consistent", "percent_usage_indicator": "percent_usage_indicator"}}]}'
        responses.add(
            responses.GET,
            url,
            body=mock_response,
            content_type='application/json',
            status=200,
        )

        # Invoke method
        response = _service.list_agent_data()

        # Check for correct operation
        assert len(responses.calls) == 1
        assert response.status_code == 200

    def test_list_agent_data_required_params_with_retries(self):
        # Enable retries and run test_list_agent_data_required_params.
        _service.enable_retries()
        self.test_list_agent_data_required_params()

        # Disable retries and run test_list_agent_data_required_params.
        _service.disable_retries()
        self.test_list_agent_data_required_params()


class TestCreateAgentData:
    """
    Test Class for create_agent_data
    """

    @responses.activate
    def test_create_agent_data_all_params(self):
        """
        create_agent_data()
        """
        # Set up mock
        url = preprocess_url('/v2/agents')
        mock_response = '{"name": "MyDevAgent", "description": "Create Agent", "resource_group": "Default", "tags": ["tags"], "version": "v1.0.0", "schematics_location": "us-south", "agent_location": "us-south", "agent_infrastructure": {"infra_type": "ibm_kubernetes", "cluster_id": "cluster_id", "cluster_resource_group": "cluster_resource_group", "cos_instance_name": "cos_instance_name", "cos_bucket_name": "cos_bucket_name", "cos_bucket_region": "cos_bucket_region"}, "agent_metadata": [{"name": "purpose", "value": ["value"]}], "agent_inputs": [{"name": "name", "value": "value", "use_default": false, "metadata": {"type": "boolean", "aliases": ["aliases"], "description": "description", "cloud_data_type": "cloud_data_type", "default_value": "default_value", "link_status": "normal", "secure": true, "immutable": false, "hidden": true, "required": true, "options": ["options"], "min_value": 9, "max_value": 9, "min_length": 10, "max_length": 10, "matches": "matches", "position": 8, "group_by": "group_by", "source": "source"}, "link": "link"}], "user_state": {"state": "enable", "set_by": "set_by", "set_at": "2019-01-01T12:00:00.000Z"}, "agent_crn": "agent_crn", "id": "id", "created_at": "2019-01-01T12:00:00.000Z", "creation_by": "creation_by", "updated_at": "2019-01-01T12:00:00.000Z", "updated_by": "updated_by", "system_state": {"status_code": "error", "status_message": "status_message"}, "agent_kpi": {"availability_indicator": "available", "lifecycle_indicator": "consistent", "percent_usage_indicator": "percent_usage_indicator", "application_indicators": ["anyValue"], "infra_indicators": ["anyValue"]}, "recent_prs_job": {"agent_id": "agent_id", "job_id": "job_id", "updated_at": "2019-01-01T12:00:00.000Z", "updated_by": "updated_by", "agent_version": "v1.0.0", "status_code": "job_pending", "status_message": "status_message", "log_url": "log_url"}, "recent_deploy_job": {"agent_id": "agent_id", "job_id": "job_id", "updated_at": "2019-01-01T12:00:00.000Z", "updated_by": "updated_by", "is_redeployed": false, "agent_version": "v1.0.0", "status_code": "job_pending", "status_message": "status_message", "log_url": "log_url"}, "recent_health_job": {"agent_id": "agent_id", "job_id": "job_id", "updated_at": "2019-01-01T12:00:00.000Z", "updated_by": "updated_by", "agent_version": "v1.0.0", "status_code": "job_pending", "status_message": "status_message", "log_url": "log_url"}, "recent_destroy_job": {"agent_id": "agent_id", "job_id": "job_id", "updated_at": "2019-01-01T12:00:00.000Z", "updated_by": "updated_by", "agent_version": "v1.0.0", "status_code": "job_pending", "status_message": "status_message", "log_url": "log_url"}, "encryption": {"crn": "crn", "scheme": "scheme"}}'
        responses.add(
            responses.POST,
            url,
            body=mock_response,
            content_type='application/json',
            status=201,
        )

        # Construct a dict representation of a AgentInfrastructure model
        agent_infrastructure_model = {}
        agent_infrastructure_model['infra_type'] = 'ibm_kubernetes'
        agent_infrastructure_model['cluster_id'] = 'testString'
        agent_infrastructure_model['cluster_resource_group'] = 'testString'
        agent_infrastructure_model['cos_instance_name'] = 'testString'
        agent_infrastructure_model['cos_bucket_name'] = 'testString'
        agent_infrastructure_model['cos_bucket_region'] = 'testString'

        # Construct a dict representation of a AgentMetadataInfo model
        agent_metadata_info_model = {}
        agent_metadata_info_model['name'] = 'purpose'
        agent_metadata_info_model['value'] = ['git', 'terraform', 'ansible']

        # Construct a dict representation of a VariableMetadata model
        variable_metadata_model = {}
        variable_metadata_model['type'] = 'boolean'
        variable_metadata_model['aliases'] = ['testString']
        variable_metadata_model['description'] = 'testString'
        variable_metadata_model['cloud_data_type'] = 'testString'
        variable_metadata_model['default_value'] = 'testString'
        variable_metadata_model['link_status'] = 'normal'
        variable_metadata_model['secure'] = True
        variable_metadata_model['immutable'] = True
        variable_metadata_model['hidden'] = True
        variable_metadata_model['required'] = True
        variable_metadata_model['options'] = ['testString']
        variable_metadata_model['min_value'] = 38
        variable_metadata_model['max_value'] = 38
        variable_metadata_model['min_length'] = 38
        variable_metadata_model['max_length'] = 38
        variable_metadata_model['matches'] = 'testString'
        variable_metadata_model['position'] = 38
        variable_metadata_model['group_by'] = 'testString'
        variable_metadata_model['source'] = 'testString'

        # Construct a dict representation of a VariableData model
        variable_data_model = {}
        variable_data_model['name'] = 'testString'
        variable_data_model['value'] = 'testString'
        variable_data_model['use_default'] = True
        variable_data_model['metadata'] = variable_metadata_model

        # Construct a dict representation of a AgentUserState model
        agent_user_state_model = {}
        agent_user_state_model['state'] = 'enable'

        # Construct a dict representation of a AgentKPIData model
        agent_kpi_data_model = {}
        agent_kpi_data_model['availability_indicator'] = 'available'
        agent_kpi_data_model['lifecycle_indicator'] = 'consistent'
        agent_kpi_data_model['percent_usage_indicator'] = 'testString'
        agent_kpi_data_model['application_indicators'] = ['testString']
        agent_kpi_data_model['infra_indicators'] = ['testString']

        # Set up parameter values
        name = 'MyDevAgent'
        resource_group = 'Default'
        version = 'v1.0.0'
        schematics_location = 'us-south'
        agent_location = 'us-south'
        agent_infrastructure = agent_infrastructure_model
        description = 'Create Agent'
        tags = ['testString']
        agent_metadata = [agent_metadata_info_model]
        agent_inputs = [variable_data_model]
        user_state = agent_user_state_model
        agent_kpi = agent_kpi_data_model

        # Invoke method
        response = _service.create_agent_data(
            name,
            resource_group,
            version,
            schematics_location,
            agent_location,
            agent_infrastructure,
            description=description,
            tags=tags,
            agent_metadata=agent_metadata,
            agent_inputs=agent_inputs,
            user_state=user_state,
            agent_kpi=agent_kpi,
            headers={},
        )

        # Check for correct operation
        assert len(responses.calls) == 1
        assert response.status_code == 201
        # Validate body params
        req_body = json.loads(str(responses.calls[0].request.body, 'utf-8'))
        assert req_body['name'] == 'MyDevAgent'
        assert req_body['resource_group'] == 'Default'
        assert req_body['version'] == 'v1.0.0'
        assert req_body['schematics_location'] == 'us-south'
        assert req_body['agent_location'] == 'us-south'
        assert req_body['agent_infrastructure'] == agent_infrastructure_model
        assert req_body['description'] == 'Create Agent'
        assert req_body['tags'] == ['testString']
        assert req_body['agent_metadata'] == [agent_metadata_info_model]
        assert req_body['agent_inputs'] == [variable_data_model]
        assert req_body['user_state'] == agent_user_state_model
        assert req_body['agent_kpi'] == agent_kpi_data_model

    def test_create_agent_data_all_params_with_retries(self):
        # Enable retries and run test_create_agent_data_all_params.
        _service.enable_retries()
        self.test_create_agent_data_all_params()

        # Disable retries and run test_create_agent_data_all_params.
        _service.disable_retries()
        self.test_create_agent_data_all_params()

    @responses.activate
    def test_create_agent_data_value_error(self):
        """
        test_create_agent_data_value_error()
        """
        # Set up mock
        url = preprocess_url('/v2/agents')
        mock_response = '{"name": "MyDevAgent", "description": "Create Agent", "resource_group": "Default", "tags": ["tags"], "version": "v1.0.0", "schematics_location": "us-south", "agent_location": "us-south", "agent_infrastructure": {"infra_type": "ibm_kubernetes", "cluster_id": "cluster_id", "cluster_resource_group": "cluster_resource_group", "cos_instance_name": "cos_instance_name", "cos_bucket_name": "cos_bucket_name", "cos_bucket_region": "cos_bucket_region"}, "agent_metadata": [{"name": "purpose", "value": ["value"]}], "agent_inputs": [{"name": "name", "value": "value", "use_default": false, "metadata": {"type": "boolean", "aliases": ["aliases"], "description": "description", "cloud_data_type": "cloud_data_type", "default_value": "default_value", "link_status": "normal", "secure": true, "immutable": false, "hidden": true, "required": true, "options": ["options"], "min_value": 9, "max_value": 9, "min_length": 10, "max_length": 10, "matches": "matches", "position": 8, "group_by": "group_by", "source": "source"}, "link": "link"}], "user_state": {"state": "enable", "set_by": "set_by", "set_at": "2019-01-01T12:00:00.000Z"}, "agent_crn": "agent_crn", "id": "id", "created_at": "2019-01-01T12:00:00.000Z", "creation_by": "creation_by", "updated_at": "2019-01-01T12:00:00.000Z", "updated_by": "updated_by", "system_state": {"status_code": "error", "status_message": "status_message"}, "agent_kpi": {"availability_indicator": "available", "lifecycle_indicator": "consistent", "percent_usage_indicator": "percent_usage_indicator", "application_indicators": ["anyValue"], "infra_indicators": ["anyValue"]}, "recent_prs_job": {"agent_id": "agent_id", "job_id": "job_id", "updated_at": "2019-01-01T12:00:00.000Z", "updated_by": "updated_by", "agent_version": "v1.0.0", "status_code": "job_pending", "status_message": "status_message", "log_url": "log_url"}, "recent_deploy_job": {"agent_id": "agent_id", "job_id": "job_id", "updated_at": "2019-01-01T12:00:00.000Z", "updated_by": "updated_by", "is_redeployed": false, "agent_version": "v1.0.0", "status_code": "job_pending", "status_message": "status_message", "log_url": "log_url"}, "recent_health_job": {"agent_id": "agent_id", "job_id": "job_id", "updated_at": "2019-01-01T12:00:00.000Z", "updated_by": "updated_by", "agent_version": "v1.0.0", "status_code": "job_pending", "status_message": "status_message", "log_url": "log_url"}, "recent_destroy_job": {"agent_id": "agent_id", "job_id": "job_id", "updated_at": "2019-01-01T12:00:00.000Z", "updated_by": "updated_by", "agent_version": "v1.0.0", "status_code": "job_pending", "status_message": "status_message", "log_url": "log_url"}, "encryption": {"crn": "crn", "scheme": "scheme"}}'
        responses.add(
            responses.POST,
            url,
            body=mock_response,
            content_type='application/json',
            status=201,
        )

        # Construct a dict representation of a AgentInfrastructure model
        agent_infrastructure_model = {}
        agent_infrastructure_model['infra_type'] = 'ibm_kubernetes'
        agent_infrastructure_model['cluster_id'] = 'testString'
        agent_infrastructure_model['cluster_resource_group'] = 'testString'
        agent_infrastructure_model['cos_instance_name'] = 'testString'
        agent_infrastructure_model['cos_bucket_name'] = 'testString'
        agent_infrastructure_model['cos_bucket_region'] = 'testString'

        # Construct a dict representation of a AgentMetadataInfo model
        agent_metadata_info_model = {}
        agent_metadata_info_model['name'] = 'purpose'
        agent_metadata_info_model['value'] = ['git', 'terraform', 'ansible']

        # Construct a dict representation of a VariableMetadata model
        variable_metadata_model = {}
        variable_metadata_model['type'] = 'boolean'
        variable_metadata_model['aliases'] = ['testString']
        variable_metadata_model['description'] = 'testString'
        variable_metadata_model['cloud_data_type'] = 'testString'
        variable_metadata_model['default_value'] = 'testString'
        variable_metadata_model['link_status'] = 'normal'
        variable_metadata_model['secure'] = True
        variable_metadata_model['immutable'] = True
        variable_metadata_model['hidden'] = True
        variable_metadata_model['required'] = True
        variable_metadata_model['options'] = ['testString']
        variable_metadata_model['min_value'] = 38
        variable_metadata_model['max_value'] = 38
        variable_metadata_model['min_length'] = 38
        variable_metadata_model['max_length'] = 38
        variable_metadata_model['matches'] = 'testString'
        variable_metadata_model['position'] = 38
        variable_metadata_model['group_by'] = 'testString'
        variable_metadata_model['source'] = 'testString'

        # Construct a dict representation of a VariableData model
        variable_data_model = {}
        variable_data_model['name'] = 'testString'
        variable_data_model['value'] = 'testString'
        variable_data_model['use_default'] = True
        variable_data_model['metadata'] = variable_metadata_model

        # Construct a dict representation of a AgentUserState model
        agent_user_state_model = {}
        agent_user_state_model['state'] = 'enable'

        # Construct a dict representation of a AgentKPIData model
        agent_kpi_data_model = {}
        agent_kpi_data_model['availability_indicator'] = 'available'
        agent_kpi_data_model['lifecycle_indicator'] = 'consistent'
        agent_kpi_data_model['percent_usage_indicator'] = 'testString'
        agent_kpi_data_model['application_indicators'] = ['testString']
        agent_kpi_data_model['infra_indicators'] = ['testString']

        # Set up parameter values
        name = 'MyDevAgent'
        resource_group = 'Default'
        version = 'v1.0.0'
        schematics_location = 'us-south'
        agent_location = 'us-south'
        agent_infrastructure = agent_infrastructure_model
        description = 'Create Agent'
        tags = ['testString']
        agent_metadata = [agent_metadata_info_model]
        agent_inputs = [variable_data_model]
        user_state = agent_user_state_model
        agent_kpi = agent_kpi_data_model

        # Pass in all but one required param and check for a ValueError
        req_param_dict = {
            "name": name,
            "resource_group": resource_group,
            "version": version,
            "schematics_location": schematics_location,
            "agent_location": agent_location,
            "agent_infrastructure": agent_infrastructure,
        }
        for param in req_param_dict.keys():
            req_copy = {key: val if key is not param else None for (key, val) in req_param_dict.items()}
            with pytest.raises(ValueError):
                _service.create_agent_data(**req_copy)

    def test_create_agent_data_value_error_with_retries(self):
        # Enable retries and run test_create_agent_data_value_error.
        _service.enable_retries()
        self.test_create_agent_data_value_error()

        # Disable retries and run test_create_agent_data_value_error.
        _service.disable_retries()
        self.test_create_agent_data_value_error()


class TestGetAgentData:
    """
    Test Class for get_agent_data
    """

    @responses.activate
    def test_get_agent_data_all_params(self):
        """
        get_agent_data()
        """
        # Set up mock
        url = preprocess_url('/v2/agents/testString')
        mock_response = '{"name": "MyDevAgent", "description": "Create Agent", "resource_group": "Default", "tags": ["tags"], "version": "v1.0.0", "schematics_location": "us-south", "agent_location": "us-south", "agent_infrastructure": {"infra_type": "ibm_kubernetes", "cluster_id": "cluster_id", "cluster_resource_group": "cluster_resource_group", "cos_instance_name": "cos_instance_name", "cos_bucket_name": "cos_bucket_name", "cos_bucket_region": "cos_bucket_region"}, "agent_metadata": [{"name": "purpose", "value": ["value"]}], "agent_inputs": [{"name": "name", "value": "value", "use_default": false, "metadata": {"type": "boolean", "aliases": ["aliases"], "description": "description", "cloud_data_type": "cloud_data_type", "default_value": "default_value", "link_status": "normal", "secure": true, "immutable": false, "hidden": true, "required": true, "options": ["options"], "min_value": 9, "max_value": 9, "min_length": 10, "max_length": 10, "matches": "matches", "position": 8, "group_by": "group_by", "source": "source"}, "link": "link"}], "user_state": {"state": "enable", "set_by": "set_by", "set_at": "2019-01-01T12:00:00.000Z"}, "agent_crn": "agent_crn", "id": "id", "created_at": "2019-01-01T12:00:00.000Z", "creation_by": "creation_by", "updated_at": "2019-01-01T12:00:00.000Z", "updated_by": "updated_by", "system_state": {"status_code": "error", "status_message": "status_message"}, "agent_kpi": {"availability_indicator": "available", "lifecycle_indicator": "consistent", "percent_usage_indicator": "percent_usage_indicator", "application_indicators": ["anyValue"], "infra_indicators": ["anyValue"]}, "recent_prs_job": {"agent_id": "agent_id", "job_id": "job_id", "updated_at": "2019-01-01T12:00:00.000Z", "updated_by": "updated_by", "agent_version": "v1.0.0", "status_code": "job_pending", "status_message": "status_message", "log_url": "log_url"}, "recent_deploy_job": {"agent_id": "agent_id", "job_id": "job_id", "updated_at": "2019-01-01T12:00:00.000Z", "updated_by": "updated_by", "is_redeployed": false, "agent_version": "v1.0.0", "status_code": "job_pending", "status_message": "status_message", "log_url": "log_url"}, "recent_health_job": {"agent_id": "agent_id", "job_id": "job_id", "updated_at": "2019-01-01T12:00:00.000Z", "updated_by": "updated_by", "agent_version": "v1.0.0", "status_code": "job_pending", "status_message": "status_message", "log_url": "log_url"}, "recent_destroy_job": {"agent_id": "agent_id", "job_id": "job_id", "updated_at": "2019-01-01T12:00:00.000Z", "updated_by": "updated_by", "agent_version": "v1.0.0", "status_code": "job_pending", "status_message": "status_message", "log_url": "log_url"}, "encryption": {"crn": "crn", "scheme": "scheme"}}'
        responses.add(
            responses.GET,
            url,
            body=mock_response,
            content_type='application/json',
            status=200,
        )

        # Set up parameter values
        agent_id = 'testString'
        profile = 'summary'

        # Invoke method
        response = _service.get_agent_data(
            agent_id,
            profile=profile,
            headers={},
        )

        # Check for correct operation
        assert len(responses.calls) == 1
        assert response.status_code == 200
        # Validate query params
        query_string = responses.calls[0].request.url.split('?', 1)[1]
        query_string = urllib.parse.unquote_plus(query_string)
        assert 'profile={}'.format(profile) in query_string

    def test_get_agent_data_all_params_with_retries(self):
        # Enable retries and run test_get_agent_data_all_params.
        _service.enable_retries()
        self.test_get_agent_data_all_params()

        # Disable retries and run test_get_agent_data_all_params.
        _service.disable_retries()
        self.test_get_agent_data_all_params()

    @responses.activate
    def test_get_agent_data_required_params(self):
        """
        test_get_agent_data_required_params()
        """
        # Set up mock
        url = preprocess_url('/v2/agents/testString')
        mock_response = '{"name": "MyDevAgent", "description": "Create Agent", "resource_group": "Default", "tags": ["tags"], "version": "v1.0.0", "schematics_location": "us-south", "agent_location": "us-south", "agent_infrastructure": {"infra_type": "ibm_kubernetes", "cluster_id": "cluster_id", "cluster_resource_group": "cluster_resource_group", "cos_instance_name": "cos_instance_name", "cos_bucket_name": "cos_bucket_name", "cos_bucket_region": "cos_bucket_region"}, "agent_metadata": [{"name": "purpose", "value": ["value"]}], "agent_inputs": [{"name": "name", "value": "value", "use_default": false, "metadata": {"type": "boolean", "aliases": ["aliases"], "description": "description", "cloud_data_type": "cloud_data_type", "default_value": "default_value", "link_status": "normal", "secure": true, "immutable": false, "hidden": true, "required": true, "options": ["options"], "min_value": 9, "max_value": 9, "min_length": 10, "max_length": 10, "matches": "matches", "position": 8, "group_by": "group_by", "source": "source"}, "link": "link"}], "user_state": {"state": "enable", "set_by": "set_by", "set_at": "2019-01-01T12:00:00.000Z"}, "agent_crn": "agent_crn", "id": "id", "created_at": "2019-01-01T12:00:00.000Z", "creation_by": "creation_by", "updated_at": "2019-01-01T12:00:00.000Z", "updated_by": "updated_by", "system_state": {"status_code": "error", "status_message": "status_message"}, "agent_kpi": {"availability_indicator": "available", "lifecycle_indicator": "consistent", "percent_usage_indicator": "percent_usage_indicator", "application_indicators": ["anyValue"], "infra_indicators": ["anyValue"]}, "recent_prs_job": {"agent_id": "agent_id", "job_id": "job_id", "updated_at": "2019-01-01T12:00:00.000Z", "updated_by": "updated_by", "agent_version": "v1.0.0", "status_code": "job_pending", "status_message": "status_message", "log_url": "log_url"}, "recent_deploy_job": {"agent_id": "agent_id", "job_id": "job_id", "updated_at": "2019-01-01T12:00:00.000Z", "updated_by": "updated_by", "is_redeployed": false, "agent_version": "v1.0.0", "status_code": "job_pending", "status_message": "status_message", "log_url": "log_url"}, "recent_health_job": {"agent_id": "agent_id", "job_id": "job_id", "updated_at": "2019-01-01T12:00:00.000Z", "updated_by": "updated_by", "agent_version": "v1.0.0", "status_code": "job_pending", "status_message": "status_message", "log_url": "log_url"}, "recent_destroy_job": {"agent_id": "agent_id", "job_id": "job_id", "updated_at": "2019-01-01T12:00:00.000Z", "updated_by": "updated_by", "agent_version": "v1.0.0", "status_code": "job_pending", "status_message": "status_message", "log_url": "log_url"}, "encryption": {"crn": "crn", "scheme": "scheme"}}'
        responses.add(
            responses.GET,
            url,
            body=mock_response,
            content_type='application/json',
            status=200,
        )

        # Set up parameter values
        agent_id = 'testString'

        # Invoke method
        response = _service.get_agent_data(
            agent_id,
            headers={},
        )

        # Check for correct operation
        assert len(responses.calls) == 1
        assert response.status_code == 200

    def test_get_agent_data_required_params_with_retries(self):
        # Enable retries and run test_get_agent_data_required_params.
        _service.enable_retries()
        self.test_get_agent_data_required_params()

        # Disable retries and run test_get_agent_data_required_params.
        _service.disable_retries()
        self.test_get_agent_data_required_params()

    @responses.activate
    def test_get_agent_data_value_error(self):
        """
        test_get_agent_data_value_error()
        """
        # Set up mock
        url = preprocess_url('/v2/agents/testString')
        mock_response = '{"name": "MyDevAgent", "description": "Create Agent", "resource_group": "Default", "tags": ["tags"], "version": "v1.0.0", "schematics_location": "us-south", "agent_location": "us-south", "agent_infrastructure": {"infra_type": "ibm_kubernetes", "cluster_id": "cluster_id", "cluster_resource_group": "cluster_resource_group", "cos_instance_name": "cos_instance_name", "cos_bucket_name": "cos_bucket_name", "cos_bucket_region": "cos_bucket_region"}, "agent_metadata": [{"name": "purpose", "value": ["value"]}], "agent_inputs": [{"name": "name", "value": "value", "use_default": false, "metadata": {"type": "boolean", "aliases": ["aliases"], "description": "description", "cloud_data_type": "cloud_data_type", "default_value": "default_value", "link_status": "normal", "secure": true, "immutable": false, "hidden": true, "required": true, "options": ["options"], "min_value": 9, "max_value": 9, "min_length": 10, "max_length": 10, "matches": "matches", "position": 8, "group_by": "group_by", "source": "source"}, "link": "link"}], "user_state": {"state": "enable", "set_by": "set_by", "set_at": "2019-01-01T12:00:00.000Z"}, "agent_crn": "agent_crn", "id": "id", "created_at": "2019-01-01T12:00:00.000Z", "creation_by": "creation_by", "updated_at": "2019-01-01T12:00:00.000Z", "updated_by": "updated_by", "system_state": {"status_code": "error", "status_message": "status_message"}, "agent_kpi": {"availability_indicator": "available", "lifecycle_indicator": "consistent", "percent_usage_indicator": "percent_usage_indicator", "application_indicators": ["anyValue"], "infra_indicators": ["anyValue"]}, "recent_prs_job": {"agent_id": "agent_id", "job_id": "job_id", "updated_at": "2019-01-01T12:00:00.000Z", "updated_by": "updated_by", "agent_version": "v1.0.0", "status_code": "job_pending", "status_message": "status_message", "log_url": "log_url"}, "recent_deploy_job": {"agent_id": "agent_id", "job_id": "job_id", "updated_at": "2019-01-01T12:00:00.000Z", "updated_by": "updated_by", "is_redeployed": false, "agent_version": "v1.0.0", "status_code": "job_pending", "status_message": "status_message", "log_url": "log_url"}, "recent_health_job": {"agent_id": "agent_id", "job_id": "job_id", "updated_at": "2019-01-01T12:00:00.000Z", "updated_by": "updated_by", "agent_version": "v1.0.0", "status_code": "job_pending", "status_message": "status_message", "log_url": "log_url"}, "recent_destroy_job": {"agent_id": "agent_id", "job_id": "job_id", "updated_at": "2019-01-01T12:00:00.000Z", "updated_by": "updated_by", "agent_version": "v1.0.0", "status_code": "job_pending", "status_message": "status_message", "log_url": "log_url"}, "encryption": {"crn": "crn", "scheme": "scheme"}}'
        responses.add(
            responses.GET,
            url,
            body=mock_response,
            content_type='application/json',
            status=200,
        )

        # Set up parameter values
        agent_id = 'testString'

        # Pass in all but one required param and check for a ValueError
        req_param_dict = {
            "agent_id": agent_id,
        }
        for param in req_param_dict.keys():
            req_copy = {key: val if key is not param else None for (key, val) in req_param_dict.items()}
            with pytest.raises(ValueError):
                _service.get_agent_data(**req_copy)

    def test_get_agent_data_value_error_with_retries(self):
        # Enable retries and run test_get_agent_data_value_error.
        _service.enable_retries()
        self.test_get_agent_data_value_error()

        # Disable retries and run test_get_agent_data_value_error.
        _service.disable_retries()
        self.test_get_agent_data_value_error()


class TestUpdateAgentData:
    """
    Test Class for update_agent_data
    """

    @responses.activate
    def test_update_agent_data_all_params(self):
        """
        update_agent_data()
        """
        # Set up mock
        url = preprocess_url('/v2/agents/testString')
        mock_response = '{"name": "MyDevAgent", "description": "Create Agent", "resource_group": "Default", "tags": ["tags"], "version": "v1.0.0", "schematics_location": "us-south", "agent_location": "us-south", "agent_infrastructure": {"infra_type": "ibm_kubernetes", "cluster_id": "cluster_id", "cluster_resource_group": "cluster_resource_group", "cos_instance_name": "cos_instance_name", "cos_bucket_name": "cos_bucket_name", "cos_bucket_region": "cos_bucket_region"}, "agent_metadata": [{"name": "purpose", "value": ["value"]}], "agent_inputs": [{"name": "name", "value": "value", "use_default": false, "metadata": {"type": "boolean", "aliases": ["aliases"], "description": "description", "cloud_data_type": "cloud_data_type", "default_value": "default_value", "link_status": "normal", "secure": true, "immutable": false, "hidden": true, "required": true, "options": ["options"], "min_value": 9, "max_value": 9, "min_length": 10, "max_length": 10, "matches": "matches", "position": 8, "group_by": "group_by", "source": "source"}, "link": "link"}], "user_state": {"state": "enable", "set_by": "set_by", "set_at": "2019-01-01T12:00:00.000Z"}, "agent_crn": "agent_crn", "id": "id", "created_at": "2019-01-01T12:00:00.000Z", "creation_by": "creation_by", "updated_at": "2019-01-01T12:00:00.000Z", "updated_by": "updated_by", "system_state": {"status_code": "error", "status_message": "status_message"}, "agent_kpi": {"availability_indicator": "available", "lifecycle_indicator": "consistent", "percent_usage_indicator": "percent_usage_indicator", "application_indicators": ["anyValue"], "infra_indicators": ["anyValue"]}, "recent_prs_job": {"agent_id": "agent_id", "job_id": "job_id", "updated_at": "2019-01-01T12:00:00.000Z", "updated_by": "updated_by", "agent_version": "v1.0.0", "status_code": "job_pending", "status_message": "status_message", "log_url": "log_url"}, "recent_deploy_job": {"agent_id": "agent_id", "job_id": "job_id", "updated_at": "2019-01-01T12:00:00.000Z", "updated_by": "updated_by", "is_redeployed": false, "agent_version": "v1.0.0", "status_code": "job_pending", "status_message": "status_message", "log_url": "log_url"}, "recent_health_job": {"agent_id": "agent_id", "job_id": "job_id", "updated_at": "2019-01-01T12:00:00.000Z", "updated_by": "updated_by", "agent_version": "v1.0.0", "status_code": "job_pending", "status_message": "status_message", "log_url": "log_url"}, "recent_destroy_job": {"agent_id": "agent_id", "job_id": "job_id", "updated_at": "2019-01-01T12:00:00.000Z", "updated_by": "updated_by", "agent_version": "v1.0.0", "status_code": "job_pending", "status_message": "status_message", "log_url": "log_url"}, "encryption": {"crn": "crn", "scheme": "scheme"}}'
        responses.add(
            responses.PUT,
            url,
            body=mock_response,
            content_type='application/json',
            status=201,
        )

        # Construct a dict representation of a AgentInfrastructure model
        agent_infrastructure_model = {}
        agent_infrastructure_model['infra_type'] = 'ibm_kubernetes'
        agent_infrastructure_model['cluster_id'] = 'testString'
        agent_infrastructure_model['cluster_resource_group'] = 'testString'
        agent_infrastructure_model['cos_instance_name'] = 'testString'
        agent_infrastructure_model['cos_bucket_name'] = 'testString'
        agent_infrastructure_model['cos_bucket_region'] = 'testString'

        # Construct a dict representation of a AgentMetadataInfo model
        agent_metadata_info_model = {}
        agent_metadata_info_model['name'] = 'purpose'
        agent_metadata_info_model['value'] = ['git', 'terraform', 'ansible']

        # Construct a dict representation of a VariableMetadata model
        variable_metadata_model = {}
        variable_metadata_model['type'] = 'boolean'
        variable_metadata_model['aliases'] = ['testString']
        variable_metadata_model['description'] = 'testString'
        variable_metadata_model['cloud_data_type'] = 'testString'
        variable_metadata_model['default_value'] = 'testString'
        variable_metadata_model['link_status'] = 'normal'
        variable_metadata_model['secure'] = True
        variable_metadata_model['immutable'] = True
        variable_metadata_model['hidden'] = True
        variable_metadata_model['required'] = True
        variable_metadata_model['options'] = ['testString']
        variable_metadata_model['min_value'] = 38
        variable_metadata_model['max_value'] = 38
        variable_metadata_model['min_length'] = 38
        variable_metadata_model['max_length'] = 38
        variable_metadata_model['matches'] = 'testString'
        variable_metadata_model['position'] = 38
        variable_metadata_model['group_by'] = 'testString'
        variable_metadata_model['source'] = 'testString'

        # Construct a dict representation of a VariableData model
        variable_data_model = {}
        variable_data_model['name'] = 'testString'
        variable_data_model['value'] = 'testString'
        variable_data_model['use_default'] = True
        variable_data_model['metadata'] = variable_metadata_model

        # Construct a dict representation of a AgentUserState model
        agent_user_state_model = {}
        agent_user_state_model['state'] = 'enable'

        # Construct a dict representation of a AgentKPIData model
        agent_kpi_data_model = {}
        agent_kpi_data_model['availability_indicator'] = 'available'
        agent_kpi_data_model['lifecycle_indicator'] = 'consistent'
        agent_kpi_data_model['percent_usage_indicator'] = 'testString'
        agent_kpi_data_model['application_indicators'] = ['testString']
        agent_kpi_data_model['infra_indicators'] = ['testString']

        # Set up parameter values
        agent_id = 'testString'
        name = 'MyDevAgent'
        resource_group = 'Default'
        version = 'v1.0.0'
        schematics_location = 'us-south'
        agent_location = 'us-south'
        agent_infrastructure = agent_infrastructure_model
        description = 'Create Agent'
        tags = ['testString']
        agent_metadata = [agent_metadata_info_model]
        agent_inputs = [variable_data_model]
        user_state = agent_user_state_model
        agent_kpi = agent_kpi_data_model
        refresh_token = 'testString'

        # Invoke method
        response = _service.update_agent_data(
            agent_id,
            name,
            resource_group,
            version,
            schematics_location,
            agent_location,
            agent_infrastructure,
            description=description,
            tags=tags,
            agent_metadata=agent_metadata,
            agent_inputs=agent_inputs,
            user_state=user_state,
            agent_kpi=agent_kpi,
            refresh_token=refresh_token,
            headers={},
        )

        # Check for correct operation
        assert len(responses.calls) == 1
        assert response.status_code == 201
        # Validate body params
        req_body = json.loads(str(responses.calls[0].request.body, 'utf-8'))
        assert req_body['name'] == 'MyDevAgent'
        assert req_body['resource_group'] == 'Default'
        assert req_body['version'] == 'v1.0.0'
        assert req_body['schematics_location'] == 'us-south'
        assert req_body['agent_location'] == 'us-south'
        assert req_body['agent_infrastructure'] == agent_infrastructure_model
        assert req_body['description'] == 'Create Agent'
        assert req_body['tags'] == ['testString']
        assert req_body['agent_metadata'] == [agent_metadata_info_model]
        assert req_body['agent_inputs'] == [variable_data_model]
        assert req_body['user_state'] == agent_user_state_model
        assert req_body['agent_kpi'] == agent_kpi_data_model

    def test_update_agent_data_all_params_with_retries(self):
        # Enable retries and run test_update_agent_data_all_params.
        _service.enable_retries()
        self.test_update_agent_data_all_params()

        # Disable retries and run test_update_agent_data_all_params.
        _service.disable_retries()
        self.test_update_agent_data_all_params()

    @responses.activate
    def test_update_agent_data_required_params(self):
        """
        test_update_agent_data_required_params()
        """
        # Set up mock
        url = preprocess_url('/v2/agents/testString')
        mock_response = '{"name": "MyDevAgent", "description": "Create Agent", "resource_group": "Default", "tags": ["tags"], "version": "v1.0.0", "schematics_location": "us-south", "agent_location": "us-south", "agent_infrastructure": {"infra_type": "ibm_kubernetes", "cluster_id": "cluster_id", "cluster_resource_group": "cluster_resource_group", "cos_instance_name": "cos_instance_name", "cos_bucket_name": "cos_bucket_name", "cos_bucket_region": "cos_bucket_region"}, "agent_metadata": [{"name": "purpose", "value": ["value"]}], "agent_inputs": [{"name": "name", "value": "value", "use_default": false, "metadata": {"type": "boolean", "aliases": ["aliases"], "description": "description", "cloud_data_type": "cloud_data_type", "default_value": "default_value", "link_status": "normal", "secure": true, "immutable": false, "hidden": true, "required": true, "options": ["options"], "min_value": 9, "max_value": 9, "min_length": 10, "max_length": 10, "matches": "matches", "position": 8, "group_by": "group_by", "source": "source"}, "link": "link"}], "user_state": {"state": "enable", "set_by": "set_by", "set_at": "2019-01-01T12:00:00.000Z"}, "agent_crn": "agent_crn", "id": "id", "created_at": "2019-01-01T12:00:00.000Z", "creation_by": "creation_by", "updated_at": "2019-01-01T12:00:00.000Z", "updated_by": "updated_by", "system_state": {"status_code": "error", "status_message": "status_message"}, "agent_kpi": {"availability_indicator": "available", "lifecycle_indicator": "consistent", "percent_usage_indicator": "percent_usage_indicator", "application_indicators": ["anyValue"], "infra_indicators": ["anyValue"]}, "recent_prs_job": {"agent_id": "agent_id", "job_id": "job_id", "updated_at": "2019-01-01T12:00:00.000Z", "updated_by": "updated_by", "agent_version": "v1.0.0", "status_code": "job_pending", "status_message": "status_message", "log_url": "log_url"}, "recent_deploy_job": {"agent_id": "agent_id", "job_id": "job_id", "updated_at": "2019-01-01T12:00:00.000Z", "updated_by": "updated_by", "is_redeployed": false, "agent_version": "v1.0.0", "status_code": "job_pending", "status_message": "status_message", "log_url": "log_url"}, "recent_health_job": {"agent_id": "agent_id", "job_id": "job_id", "updated_at": "2019-01-01T12:00:00.000Z", "updated_by": "updated_by", "agent_version": "v1.0.0", "status_code": "job_pending", "status_message": "status_message", "log_url": "log_url"}, "recent_destroy_job": {"agent_id": "agent_id", "job_id": "job_id", "updated_at": "2019-01-01T12:00:00.000Z", "updated_by": "updated_by", "agent_version": "v1.0.0", "status_code": "job_pending", "status_message": "status_message", "log_url": "log_url"}, "encryption": {"crn": "crn", "scheme": "scheme"}}'
        responses.add(
            responses.PUT,
            url,
            body=mock_response,
            content_type='application/json',
            status=201,
        )

        # Construct a dict representation of a AgentInfrastructure model
        agent_infrastructure_model = {}
        agent_infrastructure_model['infra_type'] = 'ibm_kubernetes'
        agent_infrastructure_model['cluster_id'] = 'testString'
        agent_infrastructure_model['cluster_resource_group'] = 'testString'
        agent_infrastructure_model['cos_instance_name'] = 'testString'
        agent_infrastructure_model['cos_bucket_name'] = 'testString'
        agent_infrastructure_model['cos_bucket_region'] = 'testString'

        # Construct a dict representation of a AgentMetadataInfo model
        agent_metadata_info_model = {}
        agent_metadata_info_model['name'] = 'purpose'
        agent_metadata_info_model['value'] = ['git', 'terraform', 'ansible']

        # Construct a dict representation of a VariableMetadata model
        variable_metadata_model = {}
        variable_metadata_model['type'] = 'boolean'
        variable_metadata_model['aliases'] = ['testString']
        variable_metadata_model['description'] = 'testString'
        variable_metadata_model['cloud_data_type'] = 'testString'
        variable_metadata_model['default_value'] = 'testString'
        variable_metadata_model['link_status'] = 'normal'
        variable_metadata_model['secure'] = True
        variable_metadata_model['immutable'] = True
        variable_metadata_model['hidden'] = True
        variable_metadata_model['required'] = True
        variable_metadata_model['options'] = ['testString']
        variable_metadata_model['min_value'] = 38
        variable_metadata_model['max_value'] = 38
        variable_metadata_model['min_length'] = 38
        variable_metadata_model['max_length'] = 38
        variable_metadata_model['matches'] = 'testString'
        variable_metadata_model['position'] = 38
        variable_metadata_model['group_by'] = 'testString'
        variable_metadata_model['source'] = 'testString'

        # Construct a dict representation of a VariableData model
        variable_data_model = {}
        variable_data_model['name'] = 'testString'
        variable_data_model['value'] = 'testString'
        variable_data_model['use_default'] = True
        variable_data_model['metadata'] = variable_metadata_model

        # Construct a dict representation of a AgentUserState model
        agent_user_state_model = {}
        agent_user_state_model['state'] = 'enable'

        # Construct a dict representation of a AgentKPIData model
        agent_kpi_data_model = {}
        agent_kpi_data_model['availability_indicator'] = 'available'
        agent_kpi_data_model['lifecycle_indicator'] = 'consistent'
        agent_kpi_data_model['percent_usage_indicator'] = 'testString'
        agent_kpi_data_model['application_indicators'] = ['testString']
        agent_kpi_data_model['infra_indicators'] = ['testString']

        # Set up parameter values
        agent_id = 'testString'
        name = 'MyDevAgent'
        resource_group = 'Default'
        version = 'v1.0.0'
        schematics_location = 'us-south'
        agent_location = 'us-south'
        agent_infrastructure = agent_infrastructure_model
        description = 'Create Agent'
        tags = ['testString']
        agent_metadata = [agent_metadata_info_model]
        agent_inputs = [variable_data_model]
        user_state = agent_user_state_model
        agent_kpi = agent_kpi_data_model

        # Invoke method
        response = _service.update_agent_data(
            agent_id,
            name,
            resource_group,
            version,
            schematics_location,
            agent_location,
            agent_infrastructure,
            description=description,
            tags=tags,
            agent_metadata=agent_metadata,
            agent_inputs=agent_inputs,
            user_state=user_state,
            agent_kpi=agent_kpi,
            headers={},
        )

        # Check for correct operation
        assert len(responses.calls) == 1
        assert response.status_code == 201
        # Validate body params
        req_body = json.loads(str(responses.calls[0].request.body, 'utf-8'))
        assert req_body['name'] == 'MyDevAgent'
        assert req_body['resource_group'] == 'Default'
        assert req_body['version'] == 'v1.0.0'
        assert req_body['schematics_location'] == 'us-south'
        assert req_body['agent_location'] == 'us-south'
        assert req_body['agent_infrastructure'] == agent_infrastructure_model
        assert req_body['description'] == 'Create Agent'
        assert req_body['tags'] == ['testString']
        assert req_body['agent_metadata'] == [agent_metadata_info_model]
        assert req_body['agent_inputs'] == [variable_data_model]
        assert req_body['user_state'] == agent_user_state_model
        assert req_body['agent_kpi'] == agent_kpi_data_model

    def test_update_agent_data_required_params_with_retries(self):
        # Enable retries and run test_update_agent_data_required_params.
        _service.enable_retries()
        self.test_update_agent_data_required_params()

        # Disable retries and run test_update_agent_data_required_params.
        _service.disable_retries()
        self.test_update_agent_data_required_params()

    @responses.activate
    def test_update_agent_data_value_error(self):
        """
        test_update_agent_data_value_error()
        """
        # Set up mock
        url = preprocess_url('/v2/agents/testString')
        mock_response = '{"name": "MyDevAgent", "description": "Create Agent", "resource_group": "Default", "tags": ["tags"], "version": "v1.0.0", "schematics_location": "us-south", "agent_location": "us-south", "agent_infrastructure": {"infra_type": "ibm_kubernetes", "cluster_id": "cluster_id", "cluster_resource_group": "cluster_resource_group", "cos_instance_name": "cos_instance_name", "cos_bucket_name": "cos_bucket_name", "cos_bucket_region": "cos_bucket_region"}, "agent_metadata": [{"name": "purpose", "value": ["value"]}], "agent_inputs": [{"name": "name", "value": "value", "use_default": false, "metadata": {"type": "boolean", "aliases": ["aliases"], "description": "description", "cloud_data_type": "cloud_data_type", "default_value": "default_value", "link_status": "normal", "secure": true, "immutable": false, "hidden": true, "required": true, "options": ["options"], "min_value": 9, "max_value": 9, "min_length": 10, "max_length": 10, "matches": "matches", "position": 8, "group_by": "group_by", "source": "source"}, "link": "link"}], "user_state": {"state": "enable", "set_by": "set_by", "set_at": "2019-01-01T12:00:00.000Z"}, "agent_crn": "agent_crn", "id": "id", "created_at": "2019-01-01T12:00:00.000Z", "creation_by": "creation_by", "updated_at": "2019-01-01T12:00:00.000Z", "updated_by": "updated_by", "system_state": {"status_code": "error", "status_message": "status_message"}, "agent_kpi": {"availability_indicator": "available", "lifecycle_indicator": "consistent", "percent_usage_indicator": "percent_usage_indicator", "application_indicators": ["anyValue"], "infra_indicators": ["anyValue"]}, "recent_prs_job": {"agent_id": "agent_id", "job_id": "job_id", "updated_at": "2019-01-01T12:00:00.000Z", "updated_by": "updated_by", "agent_version": "v1.0.0", "status_code": "job_pending", "status_message": "status_message", "log_url": "log_url"}, "recent_deploy_job": {"agent_id": "agent_id", "job_id": "job_id", "updated_at": "2019-01-01T12:00:00.000Z", "updated_by": "updated_by", "is_redeployed": false, "agent_version": "v1.0.0", "status_code": "job_pending", "status_message": "status_message", "log_url": "log_url"}, "recent_health_job": {"agent_id": "agent_id", "job_id": "job_id", "updated_at": "2019-01-01T12:00:00.000Z", "updated_by": "updated_by", "agent_version": "v1.0.0", "status_code": "job_pending", "status_message": "status_message", "log_url": "log_url"}, "recent_destroy_job": {"agent_id": "agent_id", "job_id": "job_id", "updated_at": "2019-01-01T12:00:00.000Z", "updated_by": "updated_by", "agent_version": "v1.0.0", "status_code": "job_pending", "status_message": "status_message", "log_url": "log_url"}, "encryption": {"crn": "crn", "scheme": "scheme"}}'
        responses.add(
            responses.PUT,
            url,
            body=mock_response,
            content_type='application/json',
            status=201,
        )

        # Construct a dict representation of a AgentInfrastructure model
        agent_infrastructure_model = {}
        agent_infrastructure_model['infra_type'] = 'ibm_kubernetes'
        agent_infrastructure_model['cluster_id'] = 'testString'
        agent_infrastructure_model['cluster_resource_group'] = 'testString'
        agent_infrastructure_model['cos_instance_name'] = 'testString'
        agent_infrastructure_model['cos_bucket_name'] = 'testString'
        agent_infrastructure_model['cos_bucket_region'] = 'testString'

        # Construct a dict representation of a AgentMetadataInfo model
        agent_metadata_info_model = {}
        agent_metadata_info_model['name'] = 'purpose'
        agent_metadata_info_model['value'] = ['git', 'terraform', 'ansible']

        # Construct a dict representation of a VariableMetadata model
        variable_metadata_model = {}
        variable_metadata_model['type'] = 'boolean'
        variable_metadata_model['aliases'] = ['testString']
        variable_metadata_model['description'] = 'testString'
        variable_metadata_model['cloud_data_type'] = 'testString'
        variable_metadata_model['default_value'] = 'testString'
        variable_metadata_model['link_status'] = 'normal'
        variable_metadata_model['secure'] = True
        variable_metadata_model['immutable'] = True
        variable_metadata_model['hidden'] = True
        variable_metadata_model['required'] = True
        variable_metadata_model['options'] = ['testString']
        variable_metadata_model['min_value'] = 38
        variable_metadata_model['max_value'] = 38
        variable_metadata_model['min_length'] = 38
        variable_metadata_model['max_length'] = 38
        variable_metadata_model['matches'] = 'testString'
        variable_metadata_model['position'] = 38
        variable_metadata_model['group_by'] = 'testString'
        variable_metadata_model['source'] = 'testString'

        # Construct a dict representation of a VariableData model
        variable_data_model = {}
        variable_data_model['name'] = 'testString'
        variable_data_model['value'] = 'testString'
        variable_data_model['use_default'] = True
        variable_data_model['metadata'] = variable_metadata_model

        # Construct a dict representation of a AgentUserState model
        agent_user_state_model = {}
        agent_user_state_model['state'] = 'enable'

        # Construct a dict representation of a AgentKPIData model
        agent_kpi_data_model = {}
        agent_kpi_data_model['availability_indicator'] = 'available'
        agent_kpi_data_model['lifecycle_indicator'] = 'consistent'
        agent_kpi_data_model['percent_usage_indicator'] = 'testString'
        agent_kpi_data_model['application_indicators'] = ['testString']
        agent_kpi_data_model['infra_indicators'] = ['testString']

        # Set up parameter values
        agent_id = 'testString'
        name = 'MyDevAgent'
        resource_group = 'Default'
        version = 'v1.0.0'
        schematics_location = 'us-south'
        agent_location = 'us-south'
        agent_infrastructure = agent_infrastructure_model
        description = 'Create Agent'
        tags = ['testString']
        agent_metadata = [agent_metadata_info_model]
        agent_inputs = [variable_data_model]
        user_state = agent_user_state_model
        agent_kpi = agent_kpi_data_model

        # Pass in all but one required param and check for a ValueError
        req_param_dict = {
            "agent_id": agent_id,
            "name": name,
            "resource_group": resource_group,
            "version": version,
            "schematics_location": schematics_location,
            "agent_location": agent_location,
            "agent_infrastructure": agent_infrastructure,
        }
        for param in req_param_dict.keys():
            req_copy = {key: val if key is not param else None for (key, val) in req_param_dict.items()}
            with pytest.raises(ValueError):
                _service.update_agent_data(**req_copy)

    def test_update_agent_data_value_error_with_retries(self):
        # Enable retries and run test_update_agent_data_value_error.
        _service.enable_retries()
        self.test_update_agent_data_value_error()

        # Disable retries and run test_update_agent_data_value_error.
        _service.disable_retries()
        self.test_update_agent_data_value_error()


class TestDeleteAgentData:
    """
    Test Class for delete_agent_data
    """

    @responses.activate
    def test_delete_agent_data_all_params(self):
        """
        delete_agent_data()
        """
        # Set up mock
        url = preprocess_url('/v2/agents/testString')
        responses.add(
            responses.DELETE,
            url,
            status=204,
        )

        # Set up parameter values
        agent_id = 'testString'
        force = True

        # Invoke method
        response = _service.delete_agent_data(
            agent_id,
            force=force,
            headers={},
        )

        # Check for correct operation
        assert len(responses.calls) == 1
        assert response.status_code == 204
        # Validate query params
        query_string = responses.calls[0].request.url.split('?', 1)[1]
        query_string = urllib.parse.unquote_plus(query_string)
        assert 'force={}'.format('true' if force else 'false') in query_string

    def test_delete_agent_data_all_params_with_retries(self):
        # Enable retries and run test_delete_agent_data_all_params.
        _service.enable_retries()
        self.test_delete_agent_data_all_params()

        # Disable retries and run test_delete_agent_data_all_params.
        _service.disable_retries()
        self.test_delete_agent_data_all_params()

    @responses.activate
    def test_delete_agent_data_required_params(self):
        """
        test_delete_agent_data_required_params()
        """
        # Set up mock
        url = preprocess_url('/v2/agents/testString')
        responses.add(
            responses.DELETE,
            url,
            status=204,
        )

        # Set up parameter values
        agent_id = 'testString'

        # Invoke method
        response = _service.delete_agent_data(
            agent_id,
            headers={},
        )

        # Check for correct operation
        assert len(responses.calls) == 1
        assert response.status_code == 204

    def test_delete_agent_data_required_params_with_retries(self):
        # Enable retries and run test_delete_agent_data_required_params.
        _service.enable_retries()
        self.test_delete_agent_data_required_params()

        # Disable retries and run test_delete_agent_data_required_params.
        _service.disable_retries()
        self.test_delete_agent_data_required_params()

    @responses.activate
    def test_delete_agent_data_value_error(self):
        """
        test_delete_agent_data_value_error()
        """
        # Set up mock
        url = preprocess_url('/v2/agents/testString')
        responses.add(
            responses.DELETE,
            url,
            status=204,
        )

        # Set up parameter values
        agent_id = 'testString'

        # Pass in all but one required param and check for a ValueError
        req_param_dict = {
            "agent_id": agent_id,
        }
        for param in req_param_dict.keys():
            req_copy = {key: val if key is not param else None for (key, val) in req_param_dict.items()}
            with pytest.raises(ValueError):
                _service.delete_agent_data(**req_copy)

    def test_delete_agent_data_value_error_with_retries(self):
        # Enable retries and run test_delete_agent_data_value_error.
        _service.enable_retries()
        self.test_delete_agent_data_value_error()

        # Disable retries and run test_delete_agent_data_value_error.
        _service.disable_retries()
        self.test_delete_agent_data_value_error()


class TestGetAgentVersions:
    """
    Test Class for get_agent_versions
    """

    @responses.activate
    def test_get_agent_versions_all_params(self):
        """
        get_agent_versions()
        """
        # Set up mock
        url = preprocess_url('/v2/agents/versions')
        mock_response = (
            '{"supported_agent_versions": [{"display_name": "display_name", "agent_version": "agent_version"}]}'
        )
        responses.add(
            responses.GET,
            url,
            body=mock_response,
            content_type='application/json',
            status=200,
        )

        # Invoke method
        response = _service.get_agent_versions()

        # Check for correct operation
        assert len(responses.calls) == 1
        assert response.status_code == 200

    def test_get_agent_versions_all_params_with_retries(self):
        # Enable retries and run test_get_agent_versions_all_params.
        _service.enable_retries()
        self.test_get_agent_versions_all_params()

        # Disable retries and run test_get_agent_versions_all_params.
        _service.disable_retries()
        self.test_get_agent_versions_all_params()


class TestGetPrsAgentJob:
    """
    Test Class for get_prs_agent_job
    """

    @responses.activate
    def test_get_prs_agent_job_all_params(self):
        """
        get_prs_agent_job()
        """
        # Set up mock
        url = preprocess_url('/v2/agents/testString/prs')
        mock_response = '{"agent_id": "agent_id", "job_id": "job_id", "updated_at": "2019-01-01T12:00:00.000Z", "updated_by": "updated_by", "agent_version": "v1.0.0", "status_code": "job_pending", "status_message": "status_message", "log_url": "log_url"}'
        responses.add(
            responses.GET,
            url,
            body=mock_response,
            content_type='application/json',
            status=202,
        )

        # Set up parameter values
        agent_id = 'testString'

        # Invoke method
        response = _service.get_prs_agent_job(
            agent_id,
            headers={},
        )

        # Check for correct operation
        assert len(responses.calls) == 1
        assert response.status_code == 202

    def test_get_prs_agent_job_all_params_with_retries(self):
        # Enable retries and run test_get_prs_agent_job_all_params.
        _service.enable_retries()
        self.test_get_prs_agent_job_all_params()

        # Disable retries and run test_get_prs_agent_job_all_params.
        _service.disable_retries()
        self.test_get_prs_agent_job_all_params()

    @responses.activate
    def test_get_prs_agent_job_value_error(self):
        """
        test_get_prs_agent_job_value_error()
        """
        # Set up mock
        url = preprocess_url('/v2/agents/testString/prs')
        mock_response = '{"agent_id": "agent_id", "job_id": "job_id", "updated_at": "2019-01-01T12:00:00.000Z", "updated_by": "updated_by", "agent_version": "v1.0.0", "status_code": "job_pending", "status_message": "status_message", "log_url": "log_url"}'
        responses.add(
            responses.GET,
            url,
            body=mock_response,
            content_type='application/json',
            status=202,
        )

        # Set up parameter values
        agent_id = 'testString'

        # Pass in all but one required param and check for a ValueError
        req_param_dict = {
            "agent_id": agent_id,
        }
        for param in req_param_dict.keys():
            req_copy = {key: val if key is not param else None for (key, val) in req_param_dict.items()}
            with pytest.raises(ValueError):
                _service.get_prs_agent_job(**req_copy)

    def test_get_prs_agent_job_value_error_with_retries(self):
        # Enable retries and run test_get_prs_agent_job_value_error.
        _service.enable_retries()
        self.test_get_prs_agent_job_value_error()

        # Disable retries and run test_get_prs_agent_job_value_error.
        _service.disable_retries()
        self.test_get_prs_agent_job_value_error()


class TestPrsAgentJob:
    """
    Test Class for prs_agent_job
    """

    @responses.activate
    def test_prs_agent_job_all_params(self):
        """
        prs_agent_job()
        """
        # Set up mock
        url = preprocess_url('/v2/agents/testString/prs')
        mock_response = '{"agent_id": "agent_id", "job_id": "job_id", "updated_at": "2019-01-01T12:00:00.000Z", "updated_by": "updated_by", "agent_version": "v1.0.0", "status_code": "job_pending", "status_message": "status_message", "log_url": "log_url"}'
        responses.add(
            responses.PUT,
            url,
            body=mock_response,
            content_type='application/json',
            status=202,
        )

        # Set up parameter values
        agent_id = 'testString'
        force = True

        # Invoke method
        response = _service.prs_agent_job(
            agent_id,
            force=force,
            headers={},
        )

        # Check for correct operation
        assert len(responses.calls) == 1
        assert response.status_code == 202
        # Validate query params
        query_string = responses.calls[0].request.url.split('?', 1)[1]
        query_string = urllib.parse.unquote_plus(query_string)
        assert 'force={}'.format('true' if force else 'false') in query_string

    def test_prs_agent_job_all_params_with_retries(self):
        # Enable retries and run test_prs_agent_job_all_params.
        _service.enable_retries()
        self.test_prs_agent_job_all_params()

        # Disable retries and run test_prs_agent_job_all_params.
        _service.disable_retries()
        self.test_prs_agent_job_all_params()

    @responses.activate
    def test_prs_agent_job_required_params(self):
        """
        test_prs_agent_job_required_params()
        """
        # Set up mock
        url = preprocess_url('/v2/agents/testString/prs')
        mock_response = '{"agent_id": "agent_id", "job_id": "job_id", "updated_at": "2019-01-01T12:00:00.000Z", "updated_by": "updated_by", "agent_version": "v1.0.0", "status_code": "job_pending", "status_message": "status_message", "log_url": "log_url"}'
        responses.add(
            responses.PUT,
            url,
            body=mock_response,
            content_type='application/json',
            status=202,
        )

        # Set up parameter values
        agent_id = 'testString'

        # Invoke method
        response = _service.prs_agent_job(
            agent_id,
            headers={},
        )

        # Check for correct operation
        assert len(responses.calls) == 1
        assert response.status_code == 202

    def test_prs_agent_job_required_params_with_retries(self):
        # Enable retries and run test_prs_agent_job_required_params.
        _service.enable_retries()
        self.test_prs_agent_job_required_params()

        # Disable retries and run test_prs_agent_job_required_params.
        _service.disable_retries()
        self.test_prs_agent_job_required_params()

    @responses.activate
    def test_prs_agent_job_value_error(self):
        """
        test_prs_agent_job_value_error()
        """
        # Set up mock
        url = preprocess_url('/v2/agents/testString/prs')
        mock_response = '{"agent_id": "agent_id", "job_id": "job_id", "updated_at": "2019-01-01T12:00:00.000Z", "updated_by": "updated_by", "agent_version": "v1.0.0", "status_code": "job_pending", "status_message": "status_message", "log_url": "log_url"}'
        responses.add(
            responses.PUT,
            url,
            body=mock_response,
            content_type='application/json',
            status=202,
        )

        # Set up parameter values
        agent_id = 'testString'

        # Pass in all but one required param and check for a ValueError
        req_param_dict = {
            "agent_id": agent_id,
        }
        for param in req_param_dict.keys():
            req_copy = {key: val if key is not param else None for (key, val) in req_param_dict.items()}
            with pytest.raises(ValueError):
                _service.prs_agent_job(**req_copy)

    def test_prs_agent_job_value_error_with_retries(self):
        # Enable retries and run test_prs_agent_job_value_error.
        _service.enable_retries()
        self.test_prs_agent_job_value_error()

        # Disable retries and run test_prs_agent_job_value_error.
        _service.disable_retries()
        self.test_prs_agent_job_value_error()


class TestGetHealthCheckAgentJob:
    """
    Test Class for get_health_check_agent_job
    """

    @responses.activate
    def test_get_health_check_agent_job_all_params(self):
        """
        get_health_check_agent_job()
        """
        # Set up mock
        url = preprocess_url('/v2/agents/testString/health')
        mock_response = '{"agent_id": "agent_id", "job_id": "job_id", "updated_at": "2019-01-01T12:00:00.000Z", "updated_by": "updated_by", "agent_version": "v1.0.0", "status_code": "job_pending", "status_message": "status_message", "log_url": "log_url"}'
        responses.add(
            responses.GET,
            url,
            body=mock_response,
            content_type='application/json',
            status=202,
        )

        # Set up parameter values
        agent_id = 'testString'

        # Invoke method
        response = _service.get_health_check_agent_job(
            agent_id,
            headers={},
        )

        # Check for correct operation
        assert len(responses.calls) == 1
        assert response.status_code == 202

    def test_get_health_check_agent_job_all_params_with_retries(self):
        # Enable retries and run test_get_health_check_agent_job_all_params.
        _service.enable_retries()
        self.test_get_health_check_agent_job_all_params()

        # Disable retries and run test_get_health_check_agent_job_all_params.
        _service.disable_retries()
        self.test_get_health_check_agent_job_all_params()

    @responses.activate
    def test_get_health_check_agent_job_value_error(self):
        """
        test_get_health_check_agent_job_value_error()
        """
        # Set up mock
        url = preprocess_url('/v2/agents/testString/health')
        mock_response = '{"agent_id": "agent_id", "job_id": "job_id", "updated_at": "2019-01-01T12:00:00.000Z", "updated_by": "updated_by", "agent_version": "v1.0.0", "status_code": "job_pending", "status_message": "status_message", "log_url": "log_url"}'
        responses.add(
            responses.GET,
            url,
            body=mock_response,
            content_type='application/json',
            status=202,
        )

        # Set up parameter values
        agent_id = 'testString'

        # Pass in all but one required param and check for a ValueError
        req_param_dict = {
            "agent_id": agent_id,
        }
        for param in req_param_dict.keys():
            req_copy = {key: val if key is not param else None for (key, val) in req_param_dict.items()}
            with pytest.raises(ValueError):
                _service.get_health_check_agent_job(**req_copy)

    def test_get_health_check_agent_job_value_error_with_retries(self):
        # Enable retries and run test_get_health_check_agent_job_value_error.
        _service.enable_retries()
        self.test_get_health_check_agent_job_value_error()

        # Disable retries and run test_get_health_check_agent_job_value_error.
        _service.disable_retries()
        self.test_get_health_check_agent_job_value_error()


class TestHealthCheckAgentJob:
    """
    Test Class for health_check_agent_job
    """

    @responses.activate
    def test_health_check_agent_job_all_params(self):
        """
        health_check_agent_job()
        """
        # Set up mock
        url = preprocess_url('/v2/agents/testString/health')
        mock_response = '{"agent_id": "agent_id", "job_id": "job_id", "updated_at": "2019-01-01T12:00:00.000Z", "updated_by": "updated_by", "agent_version": "v1.0.0", "status_code": "job_pending", "status_message": "status_message", "log_url": "log_url"}'
        responses.add(
            responses.PUT,
            url,
            body=mock_response,
            content_type='application/json',
            status=202,
        )

        # Set up parameter values
        agent_id = 'testString'
        force = True

        # Invoke method
        response = _service.health_check_agent_job(
            agent_id,
            force=force,
            headers={},
        )

        # Check for correct operation
        assert len(responses.calls) == 1
        assert response.status_code == 202
        # Validate query params
        query_string = responses.calls[0].request.url.split('?', 1)[1]
        query_string = urllib.parse.unquote_plus(query_string)
        assert 'force={}'.format('true' if force else 'false') in query_string

    def test_health_check_agent_job_all_params_with_retries(self):
        # Enable retries and run test_health_check_agent_job_all_params.
        _service.enable_retries()
        self.test_health_check_agent_job_all_params()

        # Disable retries and run test_health_check_agent_job_all_params.
        _service.disable_retries()
        self.test_health_check_agent_job_all_params()

    @responses.activate
    def test_health_check_agent_job_required_params(self):
        """
        test_health_check_agent_job_required_params()
        """
        # Set up mock
        url = preprocess_url('/v2/agents/testString/health')
        mock_response = '{"agent_id": "agent_id", "job_id": "job_id", "updated_at": "2019-01-01T12:00:00.000Z", "updated_by": "updated_by", "agent_version": "v1.0.0", "status_code": "job_pending", "status_message": "status_message", "log_url": "log_url"}'
        responses.add(
            responses.PUT,
            url,
            body=mock_response,
            content_type='application/json',
            status=202,
        )

        # Set up parameter values
        agent_id = 'testString'

        # Invoke method
        response = _service.health_check_agent_job(
            agent_id,
            headers={},
        )

        # Check for correct operation
        assert len(responses.calls) == 1
        assert response.status_code == 202

    def test_health_check_agent_job_required_params_with_retries(self):
        # Enable retries and run test_health_check_agent_job_required_params.
        _service.enable_retries()
        self.test_health_check_agent_job_required_params()

        # Disable retries and run test_health_check_agent_job_required_params.
        _service.disable_retries()
        self.test_health_check_agent_job_required_params()

    @responses.activate
    def test_health_check_agent_job_value_error(self):
        """
        test_health_check_agent_job_value_error()
        """
        # Set up mock
        url = preprocess_url('/v2/agents/testString/health')
        mock_response = '{"agent_id": "agent_id", "job_id": "job_id", "updated_at": "2019-01-01T12:00:00.000Z", "updated_by": "updated_by", "agent_version": "v1.0.0", "status_code": "job_pending", "status_message": "status_message", "log_url": "log_url"}'
        responses.add(
            responses.PUT,
            url,
            body=mock_response,
            content_type='application/json',
            status=202,
        )

        # Set up parameter values
        agent_id = 'testString'

        # Pass in all but one required param and check for a ValueError
        req_param_dict = {
            "agent_id": agent_id,
        }
        for param in req_param_dict.keys():
            req_copy = {key: val if key is not param else None for (key, val) in req_param_dict.items()}
            with pytest.raises(ValueError):
                _service.health_check_agent_job(**req_copy)

    def test_health_check_agent_job_value_error_with_retries(self):
        # Enable retries and run test_health_check_agent_job_value_error.
        _service.enable_retries()
        self.test_health_check_agent_job_value_error()

        # Disable retries and run test_health_check_agent_job_value_error.
        _service.disable_retries()
        self.test_health_check_agent_job_value_error()


class TestGetDeployAgentJob:
    """
    Test Class for get_deploy_agent_job
    """

    @responses.activate
    def test_get_deploy_agent_job_all_params(self):
        """
        get_deploy_agent_job()
        """
        # Set up mock
        url = preprocess_url('/v2/agents/testString/deploy')
        mock_response = '{"agent_id": "agent_id", "job_id": "job_id", "updated_at": "2019-01-01T12:00:00.000Z", "updated_by": "updated_by", "is_redeployed": false, "agent_version": "v1.0.0", "status_code": "job_pending", "status_message": "status_message", "log_url": "log_url"}'
        responses.add(
            responses.GET,
            url,
            body=mock_response,
            content_type='application/json',
            status=202,
        )

        # Set up parameter values
        agent_id = 'testString'

        # Invoke method
        response = _service.get_deploy_agent_job(
            agent_id,
            headers={},
        )

        # Check for correct operation
        assert len(responses.calls) == 1
        assert response.status_code == 202

    def test_get_deploy_agent_job_all_params_with_retries(self):
        # Enable retries and run test_get_deploy_agent_job_all_params.
        _service.enable_retries()
        self.test_get_deploy_agent_job_all_params()

        # Disable retries and run test_get_deploy_agent_job_all_params.
        _service.disable_retries()
        self.test_get_deploy_agent_job_all_params()

    @responses.activate
    def test_get_deploy_agent_job_value_error(self):
        """
        test_get_deploy_agent_job_value_error()
        """
        # Set up mock
        url = preprocess_url('/v2/agents/testString/deploy')
        mock_response = '{"agent_id": "agent_id", "job_id": "job_id", "updated_at": "2019-01-01T12:00:00.000Z", "updated_by": "updated_by", "is_redeployed": false, "agent_version": "v1.0.0", "status_code": "job_pending", "status_message": "status_message", "log_url": "log_url"}'
        responses.add(
            responses.GET,
            url,
            body=mock_response,
            content_type='application/json',
            status=202,
        )

        # Set up parameter values
        agent_id = 'testString'

        # Pass in all but one required param and check for a ValueError
        req_param_dict = {
            "agent_id": agent_id,
        }
        for param in req_param_dict.keys():
            req_copy = {key: val if key is not param else None for (key, val) in req_param_dict.items()}
            with pytest.raises(ValueError):
                _service.get_deploy_agent_job(**req_copy)

    def test_get_deploy_agent_job_value_error_with_retries(self):
        # Enable retries and run test_get_deploy_agent_job_value_error.
        _service.enable_retries()
        self.test_get_deploy_agent_job_value_error()

        # Disable retries and run test_get_deploy_agent_job_value_error.
        _service.disable_retries()
        self.test_get_deploy_agent_job_value_error()


class TestDeployAgentJob:
    """
    Test Class for deploy_agent_job
    """

    @responses.activate
    def test_deploy_agent_job_all_params(self):
        """
        deploy_agent_job()
        """
        # Set up mock
        url = preprocess_url('/v2/agents/testString/deploy')
        mock_response = '{"agent_id": "agent_id", "job_id": "job_id", "updated_at": "2019-01-01T12:00:00.000Z", "updated_by": "updated_by", "is_redeployed": false, "agent_version": "v1.0.0", "status_code": "job_pending", "status_message": "status_message", "log_url": "log_url"}'
        responses.add(
            responses.PUT,
            url,
            body=mock_response,
            content_type='application/json',
            status=202,
        )

        # Set up parameter values
        agent_id = 'testString'
        force = True

        # Invoke method
        response = _service.deploy_agent_job(
            agent_id,
            force=force,
            headers={},
        )

        # Check for correct operation
        assert len(responses.calls) == 1
        assert response.status_code == 202
        # Validate query params
        query_string = responses.calls[0].request.url.split('?', 1)[1]
        query_string = urllib.parse.unquote_plus(query_string)
        assert 'force={}'.format('true' if force else 'false') in query_string

    def test_deploy_agent_job_all_params_with_retries(self):
        # Enable retries and run test_deploy_agent_job_all_params.
        _service.enable_retries()
        self.test_deploy_agent_job_all_params()

        # Disable retries and run test_deploy_agent_job_all_params.
        _service.disable_retries()
        self.test_deploy_agent_job_all_params()

    @responses.activate
    def test_deploy_agent_job_required_params(self):
        """
        test_deploy_agent_job_required_params()
        """
        # Set up mock
        url = preprocess_url('/v2/agents/testString/deploy')
        mock_response = '{"agent_id": "agent_id", "job_id": "job_id", "updated_at": "2019-01-01T12:00:00.000Z", "updated_by": "updated_by", "is_redeployed": false, "agent_version": "v1.0.0", "status_code": "job_pending", "status_message": "status_message", "log_url": "log_url"}'
        responses.add(
            responses.PUT,
            url,
            body=mock_response,
            content_type='application/json',
            status=202,
        )

        # Set up parameter values
        agent_id = 'testString'

        # Invoke method
        response = _service.deploy_agent_job(
            agent_id,
            headers={},
        )

        # Check for correct operation
        assert len(responses.calls) == 1
        assert response.status_code == 202

    def test_deploy_agent_job_required_params_with_retries(self):
        # Enable retries and run test_deploy_agent_job_required_params.
        _service.enable_retries()
        self.test_deploy_agent_job_required_params()

        # Disable retries and run test_deploy_agent_job_required_params.
        _service.disable_retries()
        self.test_deploy_agent_job_required_params()

    @responses.activate
    def test_deploy_agent_job_value_error(self):
        """
        test_deploy_agent_job_value_error()
        """
        # Set up mock
        url = preprocess_url('/v2/agents/testString/deploy')
        mock_response = '{"agent_id": "agent_id", "job_id": "job_id", "updated_at": "2019-01-01T12:00:00.000Z", "updated_by": "updated_by", "is_redeployed": false, "agent_version": "v1.0.0", "status_code": "job_pending", "status_message": "status_message", "log_url": "log_url"}'
        responses.add(
            responses.PUT,
            url,
            body=mock_response,
            content_type='application/json',
            status=202,
        )

        # Set up parameter values
        agent_id = 'testString'

        # Pass in all but one required param and check for a ValueError
        req_param_dict = {
            "agent_id": agent_id,
        }
        for param in req_param_dict.keys():
            req_copy = {key: val if key is not param else None for (key, val) in req_param_dict.items()}
            with pytest.raises(ValueError):
                _service.deploy_agent_job(**req_copy)

    def test_deploy_agent_job_value_error_with_retries(self):
        # Enable retries and run test_deploy_agent_job_value_error.
        _service.enable_retries()
        self.test_deploy_agent_job_value_error()

        # Disable retries and run test_deploy_agent_job_value_error.
        _service.disable_retries()
        self.test_deploy_agent_job_value_error()


class TestDeleteAgentResources:
    """
    Test Class for delete_agent_resources
    """

    @responses.activate
    def test_delete_agent_resources_all_params(self):
        """
        delete_agent_resources()
        """
        # Set up mock
        url = preprocess_url('/v2/agents/testString/resources')
        responses.add(
            responses.DELETE,
            url,
            status=202,
        )

        # Set up parameter values
        agent_id = 'testString'
        refresh_token = 'testString'

        # Invoke method
        response = _service.delete_agent_resources(
            agent_id,
            refresh_token,
            headers={},
        )

        # Check for correct operation
        assert len(responses.calls) == 1
        assert response.status_code == 202

    def test_delete_agent_resources_all_params_with_retries(self):
        # Enable retries and run test_delete_agent_resources_all_params.
        _service.enable_retries()
        self.test_delete_agent_resources_all_params()

        # Disable retries and run test_delete_agent_resources_all_params.
        _service.disable_retries()
        self.test_delete_agent_resources_all_params()

    @responses.activate
    def test_delete_agent_resources_value_error(self):
        """
        test_delete_agent_resources_value_error()
        """
        # Set up mock
        url = preprocess_url('/v2/agents/testString/resources')
        responses.add(
            responses.DELETE,
            url,
            status=202,
        )

        # Set up parameter values
        agent_id = 'testString'
        refresh_token = 'testString'

        # Pass in all but one required param and check for a ValueError
        req_param_dict = {
            "agent_id": agent_id,
            "refresh_token": refresh_token,
        }
        for param in req_param_dict.keys():
            req_copy = {key: val if key is not param else None for (key, val) in req_param_dict.items()}
            with pytest.raises(ValueError):
                _service.delete_agent_resources(**req_copy)

    def test_delete_agent_resources_value_error_with_retries(self):
        # Enable retries and run test_delete_agent_resources_value_error.
        _service.enable_retries()
        self.test_delete_agent_resources_value_error()

        # Disable retries and run test_delete_agent_resources_value_error.
        _service.disable_retries()
        self.test_delete_agent_resources_value_error()


# endregion
##############################################################################
# End of Service: Agent
##############################################################################

##############################################################################
# Start of Service: SettingsKms
##############################################################################
# region


class TestNewInstance:
    """
    Test Class for new_instance
    """

    def test_new_instance(self):
        """
        new_instance()
        """
        os.environ['TEST_SERVICE_AUTH_TYPE'] = 'noAuth'

        service = SchematicsV1.new_instance(
            service_name='TEST_SERVICE',
        )

        assert service is not None
        assert isinstance(service, SchematicsV1)

    def test_new_instance_without_authenticator(self):
        """
        new_instance_without_authenticator()
        """
        with pytest.raises(ValueError, match='authenticator must be provided'):
            service = SchematicsV1.new_instance(
                service_name='TEST_SERVICE_NOT_FOUND',
            )


class TestGetKmsSettings:
    """
    Test Class for get_kms_settings
    """

    @responses.activate
    def test_get_kms_settings_all_params(self):
        """
        get_kms_settings()
        """
        # Set up mock
        url = preprocess_url('/v2/settings/kms')
        mock_response = '{"location": "location", "encryption_scheme": "encryption_scheme", "resource_group": "resource_group", "primary_crk": {"kms_name": "kms_name", "kms_private_endpoint": "kms_private_endpoint", "key_crn": "key_crn"}, "secondary_crk": {"kms_name": "kms_name", "kms_private_endpoint": "kms_private_endpoint", "key_crn": "key_crn"}}'
        responses.add(
            responses.GET,
            url,
            body=mock_response,
            content_type='application/json',
            status=200,
        )

        # Set up parameter values
        location = 'testString'

        # Invoke method
        response = _service.get_kms_settings(
            location,
            headers={},
        )

        # Check for correct operation
        assert len(responses.calls) == 1
        assert response.status_code == 200
        # Validate query params
        query_string = responses.calls[0].request.url.split('?', 1)[1]
        query_string = urllib.parse.unquote_plus(query_string)
        assert 'location={}'.format(location) in query_string

    def test_get_kms_settings_all_params_with_retries(self):
        # Enable retries and run test_get_kms_settings_all_params.
        _service.enable_retries()
        self.test_get_kms_settings_all_params()

        # Disable retries and run test_get_kms_settings_all_params.
        _service.disable_retries()
        self.test_get_kms_settings_all_params()

    @responses.activate
    def test_get_kms_settings_value_error(self):
        """
        test_get_kms_settings_value_error()
        """
        # Set up mock
        url = preprocess_url('/v2/settings/kms')
        mock_response = '{"location": "location", "encryption_scheme": "encryption_scheme", "resource_group": "resource_group", "primary_crk": {"kms_name": "kms_name", "kms_private_endpoint": "kms_private_endpoint", "key_crn": "key_crn"}, "secondary_crk": {"kms_name": "kms_name", "kms_private_endpoint": "kms_private_endpoint", "key_crn": "key_crn"}}'
        responses.add(
            responses.GET,
            url,
            body=mock_response,
            content_type='application/json',
            status=200,
        )

        # Set up parameter values
        location = 'testString'

        # Pass in all but one required param and check for a ValueError
        req_param_dict = {
            "location": location,
        }
        for param in req_param_dict.keys():
            req_copy = {key: val if key is not param else None for (key, val) in req_param_dict.items()}
            with pytest.raises(ValueError):
                _service.get_kms_settings(**req_copy)

    def test_get_kms_settings_value_error_with_retries(self):
        # Enable retries and run test_get_kms_settings_value_error.
        _service.enable_retries()
        self.test_get_kms_settings_value_error()

        # Disable retries and run test_get_kms_settings_value_error.
        _service.disable_retries()
        self.test_get_kms_settings_value_error()


class TestUpdateKmsSettings:
    """
    Test Class for update_kms_settings
    """

    @responses.activate
    def test_update_kms_settings_all_params(self):
        """
        update_kms_settings()
        """
        # Set up mock
        url = preprocess_url('/v2/settings/kms')
        mock_response = '{"location": "location", "encryption_scheme": "encryption_scheme", "resource_group": "resource_group", "primary_crk": {"kms_name": "kms_name", "kms_private_endpoint": "kms_private_endpoint", "key_crn": "key_crn"}, "secondary_crk": {"kms_name": "kms_name", "kms_private_endpoint": "kms_private_endpoint", "key_crn": "key_crn"}}'
        responses.add(
            responses.PUT,
            url,
            body=mock_response,
            content_type='application/json',
            status=200,
        )

        # Construct a dict representation of a KMSSettingsPrimaryCrk model
        kms_settings_primary_crk_model = {}
        kms_settings_primary_crk_model['kms_name'] = 'testString'
        kms_settings_primary_crk_model['kms_private_endpoint'] = 'testString'
        kms_settings_primary_crk_model['key_crn'] = 'testString'

        # Construct a dict representation of a KMSSettingsSecondaryCrk model
        kms_settings_secondary_crk_model = {}
        kms_settings_secondary_crk_model['kms_name'] = 'testString'
        kms_settings_secondary_crk_model['kms_private_endpoint'] = 'testString'
        kms_settings_secondary_crk_model['key_crn'] = 'testString'

        # Set up parameter values
        location = 'testString'
        encryption_scheme = 'testString'
        resource_group = 'testString'
        primary_crk = kms_settings_primary_crk_model
        secondary_crk = kms_settings_secondary_crk_model

        # Invoke method
        response = _service.update_kms_settings(
            location=location,
            encryption_scheme=encryption_scheme,
            resource_group=resource_group,
            primary_crk=primary_crk,
            secondary_crk=secondary_crk,
            headers={},
        )

        # Check for correct operation
        assert len(responses.calls) == 1
        assert response.status_code == 200
        # Validate body params
        req_body = json.loads(str(responses.calls[0].request.body, 'utf-8'))
        assert req_body['location'] == 'testString'
        assert req_body['encryption_scheme'] == 'testString'
        assert req_body['resource_group'] == 'testString'
        assert req_body['primary_crk'] == kms_settings_primary_crk_model
        assert req_body['secondary_crk'] == kms_settings_secondary_crk_model

    def test_update_kms_settings_all_params_with_retries(self):
        # Enable retries and run test_update_kms_settings_all_params.
        _service.enable_retries()
        self.test_update_kms_settings_all_params()

        # Disable retries and run test_update_kms_settings_all_params.
        _service.disable_retries()
        self.test_update_kms_settings_all_params()


class TestListKms:
    """
    Test Class for list_kms
    """

    @responses.activate
    def test_list_kms_all_params(self):
        """
        list_kms()
        """
        # Set up mock
        url = preprocess_url('/v2/settings/kms_instances')
        mock_response = '{"total_count": 11, "limit": 5, "offset": 6, "kms_instances": [{"location": "location", "encryption_scheme": "encryption_scheme", "resource_group": "resource_group", "kms_crn": "kms_crn", "kms_name": "kms_name", "kms_private_endpoint": "kms_private_endpoint", "kms_public_endpoint": "kms_public_endpoint", "keys": [{"name": "name", "crn": "crn", "error": "error"}]}]}'
        responses.add(
            responses.GET,
            url,
            body=mock_response,
            content_type='application/json',
            status=200,
        )

        # Set up parameter values
        encryption_scheme = 'testString'
        location = 'testString'
        resource_group = 'testString'
        limit = 100
        sort = 'testString'

        # Invoke method
        response = _service.list_kms(
            encryption_scheme,
            location,
            resource_group=resource_group,
            limit=limit,
            sort=sort,
            headers={},
        )

        # Check for correct operation
        assert len(responses.calls) == 1
        assert response.status_code == 200
        # Validate query params
        query_string = responses.calls[0].request.url.split('?', 1)[1]
        query_string = urllib.parse.unquote_plus(query_string)
        assert 'encryption_scheme={}'.format(encryption_scheme) in query_string
        assert 'location={}'.format(location) in query_string
        assert 'resource_group={}'.format(resource_group) in query_string
        assert 'limit={}'.format(limit) in query_string
        assert 'sort={}'.format(sort) in query_string

    def test_list_kms_all_params_with_retries(self):
        # Enable retries and run test_list_kms_all_params.
        _service.enable_retries()
        self.test_list_kms_all_params()

        # Disable retries and run test_list_kms_all_params.
        _service.disable_retries()
        self.test_list_kms_all_params()

    @responses.activate
    def test_list_kms_required_params(self):
        """
        test_list_kms_required_params()
        """
        # Set up mock
        url = preprocess_url('/v2/settings/kms_instances')
        mock_response = '{"total_count": 11, "limit": 5, "offset": 6, "kms_instances": [{"location": "location", "encryption_scheme": "encryption_scheme", "resource_group": "resource_group", "kms_crn": "kms_crn", "kms_name": "kms_name", "kms_private_endpoint": "kms_private_endpoint", "kms_public_endpoint": "kms_public_endpoint", "keys": [{"name": "name", "crn": "crn", "error": "error"}]}]}'
        responses.add(
            responses.GET,
            url,
            body=mock_response,
            content_type='application/json',
            status=200,
        )

        # Set up parameter values
        encryption_scheme = 'testString'
        location = 'testString'

        # Invoke method
        response = _service.list_kms(
            encryption_scheme,
            location,
            headers={},
        )

        # Check for correct operation
        assert len(responses.calls) == 1
        assert response.status_code == 200
        # Validate query params
        query_string = responses.calls[0].request.url.split('?', 1)[1]
        query_string = urllib.parse.unquote_plus(query_string)
        assert 'encryption_scheme={}'.format(encryption_scheme) in query_string
        assert 'location={}'.format(location) in query_string

    def test_list_kms_required_params_with_retries(self):
        # Enable retries and run test_list_kms_required_params.
        _service.enable_retries()
        self.test_list_kms_required_params()

        # Disable retries and run test_list_kms_required_params.
        _service.disable_retries()
        self.test_list_kms_required_params()

    @responses.activate
    def test_list_kms_value_error(self):
        """
        test_list_kms_value_error()
        """
        # Set up mock
        url = preprocess_url('/v2/settings/kms_instances')
        mock_response = '{"total_count": 11, "limit": 5, "offset": 6, "kms_instances": [{"location": "location", "encryption_scheme": "encryption_scheme", "resource_group": "resource_group", "kms_crn": "kms_crn", "kms_name": "kms_name", "kms_private_endpoint": "kms_private_endpoint", "kms_public_endpoint": "kms_public_endpoint", "keys": [{"name": "name", "crn": "crn", "error": "error"}]}]}'
        responses.add(
            responses.GET,
            url,
            body=mock_response,
            content_type='application/json',
            status=200,
        )

        # Set up parameter values
        encryption_scheme = 'testString'
        location = 'testString'

        # Pass in all but one required param and check for a ValueError
        req_param_dict = {
            "encryption_scheme": encryption_scheme,
            "location": location,
        }
        for param in req_param_dict.keys():
            req_copy = {key: val if key is not param else None for (key, val) in req_param_dict.items()}
            with pytest.raises(ValueError):
                _service.list_kms(**req_copy)

    def test_list_kms_value_error_with_retries(self):
        # Enable retries and run test_list_kms_value_error.
        _service.enable_retries()
        self.test_list_kms_value_error()

        # Disable retries and run test_list_kms_value_error.
        _service.disable_retries()
        self.test_list_kms_value_error()


# endregion
##############################################################################
# End of Service: SettingsKms
##############################################################################

##############################################################################
# Start of Service: Policy
##############################################################################
# region


class TestNewInstance:
    """
    Test Class for new_instance
    """

    def test_new_instance(self):
        """
        new_instance()
        """
        os.environ['TEST_SERVICE_AUTH_TYPE'] = 'noAuth'

        service = SchematicsV1.new_instance(
            service_name='TEST_SERVICE',
        )

        assert service is not None
        assert isinstance(service, SchematicsV1)

    def test_new_instance_without_authenticator(self):
        """
        new_instance_without_authenticator()
        """
        with pytest.raises(ValueError, match='authenticator must be provided'):
            service = SchematicsV1.new_instance(
                service_name='TEST_SERVICE_NOT_FOUND',
            )


class TestListPolicy:
    """
    Test Class for list_policy
    """

    @responses.activate
    def test_list_policy_all_params(self):
        """
        list_policy()
        """
        # Set up mock
        url = preprocess_url('/v2/settings/policies')
        mock_response = '{"total_count": 11, "limit": 5, "offset": 6, "policies": [{"name": "Agent1-DevWS", "id": "id", "crn": "crn", "account": "account", "description": "Policy for job execution of secured workspaces on agent1", "resource_group": "Default", "tags": ["tags"], "location": "us-south", "state": {"state": "draft", "set_by": "set_by", "set_at": "2019-01-01T12:00:00.000Z"}, "policy_kind": "agent_assignment_policy", "created_at": "2019-01-01T12:00:00.000Z", "created_by": "created_by", "updated_at": "2019-01-01T12:00:00.000Z", "updated_by": "updated_by"}]}'
        responses.add(
            responses.GET,
            url,
            body=mock_response,
            content_type='application/json',
            status=200,
        )

        # Set up parameter values
        offset = 0
        limit = 100
        profile = 'summary'

        # Invoke method
        response = _service.list_policy(
            offset=offset,
            limit=limit,
            profile=profile,
            headers={},
        )

        # Check for correct operation
        assert len(responses.calls) == 1
        assert response.status_code == 200
        # Validate query params
        query_string = responses.calls[0].request.url.split('?', 1)[1]
        query_string = urllib.parse.unquote_plus(query_string)
        assert 'offset={}'.format(offset) in query_string
        assert 'limit={}'.format(limit) in query_string
        assert 'profile={}'.format(profile) in query_string

    def test_list_policy_all_params_with_retries(self):
        # Enable retries and run test_list_policy_all_params.
        _service.enable_retries()
        self.test_list_policy_all_params()

        # Disable retries and run test_list_policy_all_params.
        _service.disable_retries()
        self.test_list_policy_all_params()

    @responses.activate
    def test_list_policy_required_params(self):
        """
        test_list_policy_required_params()
        """
        # Set up mock
        url = preprocess_url('/v2/settings/policies')
        mock_response = '{"total_count": 11, "limit": 5, "offset": 6, "policies": [{"name": "Agent1-DevWS", "id": "id", "crn": "crn", "account": "account", "description": "Policy for job execution of secured workspaces on agent1", "resource_group": "Default", "tags": ["tags"], "location": "us-south", "state": {"state": "draft", "set_by": "set_by", "set_at": "2019-01-01T12:00:00.000Z"}, "policy_kind": "agent_assignment_policy", "created_at": "2019-01-01T12:00:00.000Z", "created_by": "created_by", "updated_at": "2019-01-01T12:00:00.000Z", "updated_by": "updated_by"}]}'
        responses.add(
            responses.GET,
            url,
            body=mock_response,
            content_type='application/json',
            status=200,
        )

        # Invoke method
        response = _service.list_policy()

        # Check for correct operation
        assert len(responses.calls) == 1
        assert response.status_code == 200

    def test_list_policy_required_params_with_retries(self):
        # Enable retries and run test_list_policy_required_params.
        _service.enable_retries()
        self.test_list_policy_required_params()

        # Disable retries and run test_list_policy_required_params.
        _service.disable_retries()
        self.test_list_policy_required_params()


class TestCreatePolicy:
    """
    Test Class for create_policy
    """

    @responses.activate
    def test_create_policy_all_params(self):
        """
        create_policy()
        """
        # Set up mock
        url = preprocess_url('/v2/settings/policies')
        mock_response = '{"name": "Agent1-DevWS", "description": "Policy for job execution of secured workspaces on agent1", "resource_group": "Default", "tags": ["tags"], "location": "us-south", "state": {"state": "draft", "set_by": "set_by", "set_at": "2019-01-01T12:00:00.000Z"}, "kind": "agent_assignment_policy", "target": {"selector_kind": "ids", "selector_ids": ["selector_ids"], "selector_scope": [{"kind": "workspace", "tags": ["tags"], "resource_groups": ["resource_groups"], "locations": ["us-south"]}]}, "parameter": {"agent_assignment_policy_parameter": {"selector_kind": "ids", "selector_ids": ["selector_ids"], "selector_scope": [{"kind": "workspace", "tags": ["tags"], "resource_groups": ["resource_groups"], "locations": ["us-south"]}]}}, "id": "id", "crn": "crn", "account": "account", "scoped_resources": [{"kind": "workspace", "id": "id"}], "created_at": "2019-01-01T12:00:00.000Z", "created_by": "created_by", "updated_at": "2019-01-01T12:00:00.000Z"}'
        responses.add(
            responses.POST,
            url,
            body=mock_response,
            content_type='application/json',
            status=201,
        )

        # Construct a dict representation of a UserState model
        user_state_model = {}
        user_state_model['state'] = 'draft'
        user_state_model['set_by'] = 'testString'
        user_state_model['set_at'] = '2019-01-01T12:00:00Z'

        # Construct a dict representation of a PolicyObjectSelector model
        policy_object_selector_model = {}
        policy_object_selector_model['kind'] = 'workspace'
        policy_object_selector_model['tags'] = ['testString']
        policy_object_selector_model['resource_groups'] = ['testString']
        policy_object_selector_model['locations'] = ['us-south']

        # Construct a dict representation of a PolicyObjects model
        policy_objects_model = {}
        policy_objects_model['selector_kind'] = 'ids'
        policy_objects_model['selector_ids'] = ['testString']
        policy_objects_model['selector_scope'] = [policy_object_selector_model]

        # Construct a dict representation of a AgentAssignmentPolicyParameter model
        agent_assignment_policy_parameter_model = {}
        agent_assignment_policy_parameter_model['selector_kind'] = 'ids'
        agent_assignment_policy_parameter_model['selector_ids'] = ['testString']
        agent_assignment_policy_parameter_model['selector_scope'] = [policy_object_selector_model]

        # Construct a dict representation of a PolicyParameter model
        policy_parameter_model = {}
        policy_parameter_model['agent_assignment_policy_parameter'] = agent_assignment_policy_parameter_model

        # Construct a dict representation of a ScopedResource model
        scoped_resource_model = {}
        scoped_resource_model['kind'] = 'workspace'
        scoped_resource_model['id'] = 'testString'

        # Set up parameter values
        name = 'Agent1-DevWS'
        description = 'Policy for job execution of secured workspaces on agent1'
        resource_group = 'Default'
        tags = ['policy:secured-job']
        location = 'us-south'
        state = user_state_model
        kind = 'agent_assignment_policy'
        target = policy_objects_model
        parameter = policy_parameter_model
        scoped_resources = [scoped_resource_model]

        # Invoke method
        response = _service.create_policy(
            name=name,
            description=description,
            resource_group=resource_group,
            tags=tags,
            location=location,
            state=state,
            kind=kind,
            target=target,
            parameter=parameter,
            scoped_resources=scoped_resources,
            headers={},
        )

        # Check for correct operation
        assert len(responses.calls) == 1
        assert response.status_code == 201
        # Validate body params
        req_body = json.loads(str(responses.calls[0].request.body, 'utf-8'))
        assert req_body['name'] == 'Agent1-DevWS'
        assert req_body['description'] == 'Policy for job execution of secured workspaces on agent1'
        assert req_body['resource_group'] == 'Default'
        assert req_body['tags'] == ['policy:secured-job']
        assert req_body['location'] == 'us-south'
        assert req_body['state'] == user_state_model
        assert req_body['kind'] == 'agent_assignment_policy'
        assert req_body['target'] == policy_objects_model
        assert req_body['parameter'] == policy_parameter_model
        assert req_body['scoped_resources'] == [scoped_resource_model]

    def test_create_policy_all_params_with_retries(self):
        # Enable retries and run test_create_policy_all_params.
        _service.enable_retries()
        self.test_create_policy_all_params()

        # Disable retries and run test_create_policy_all_params.
        _service.disable_retries()
        self.test_create_policy_all_params()


class TestGetPolicy:
    """
    Test Class for get_policy
    """

    @responses.activate
    def test_get_policy_all_params(self):
        """
        get_policy()
        """
        # Set up mock
        url = preprocess_url('/v2/settings/policies/testString')
        mock_response = '{"name": "Agent1-DevWS", "description": "Policy for job execution of secured workspaces on agent1", "resource_group": "Default", "tags": ["tags"], "location": "us-south", "state": {"state": "draft", "set_by": "set_by", "set_at": "2019-01-01T12:00:00.000Z"}, "kind": "agent_assignment_policy", "target": {"selector_kind": "ids", "selector_ids": ["selector_ids"], "selector_scope": [{"kind": "workspace", "tags": ["tags"], "resource_groups": ["resource_groups"], "locations": ["us-south"]}]}, "parameter": {"agent_assignment_policy_parameter": {"selector_kind": "ids", "selector_ids": ["selector_ids"], "selector_scope": [{"kind": "workspace", "tags": ["tags"], "resource_groups": ["resource_groups"], "locations": ["us-south"]}]}}, "id": "id", "crn": "crn", "account": "account", "scoped_resources": [{"kind": "workspace", "id": "id"}], "created_at": "2019-01-01T12:00:00.000Z", "created_by": "created_by", "updated_at": "2019-01-01T12:00:00.000Z"}'
        responses.add(
            responses.GET,
            url,
            body=mock_response,
            content_type='application/json',
            status=200,
        )

        # Set up parameter values
        policy_id = 'testString'
        profile = 'summary'

        # Invoke method
        response = _service.get_policy(
            policy_id,
            profile=profile,
            headers={},
        )

        # Check for correct operation
        assert len(responses.calls) == 1
        assert response.status_code == 200
        # Validate query params
        query_string = responses.calls[0].request.url.split('?', 1)[1]
        query_string = urllib.parse.unquote_plus(query_string)
        assert 'profile={}'.format(profile) in query_string

    def test_get_policy_all_params_with_retries(self):
        # Enable retries and run test_get_policy_all_params.
        _service.enable_retries()
        self.test_get_policy_all_params()

        # Disable retries and run test_get_policy_all_params.
        _service.disable_retries()
        self.test_get_policy_all_params()

    @responses.activate
    def test_get_policy_required_params(self):
        """
        test_get_policy_required_params()
        """
        # Set up mock
        url = preprocess_url('/v2/settings/policies/testString')
        mock_response = '{"name": "Agent1-DevWS", "description": "Policy for job execution of secured workspaces on agent1", "resource_group": "Default", "tags": ["tags"], "location": "us-south", "state": {"state": "draft", "set_by": "set_by", "set_at": "2019-01-01T12:00:00.000Z"}, "kind": "agent_assignment_policy", "target": {"selector_kind": "ids", "selector_ids": ["selector_ids"], "selector_scope": [{"kind": "workspace", "tags": ["tags"], "resource_groups": ["resource_groups"], "locations": ["us-south"]}]}, "parameter": {"agent_assignment_policy_parameter": {"selector_kind": "ids", "selector_ids": ["selector_ids"], "selector_scope": [{"kind": "workspace", "tags": ["tags"], "resource_groups": ["resource_groups"], "locations": ["us-south"]}]}}, "id": "id", "crn": "crn", "account": "account", "scoped_resources": [{"kind": "workspace", "id": "id"}], "created_at": "2019-01-01T12:00:00.000Z", "created_by": "created_by", "updated_at": "2019-01-01T12:00:00.000Z"}'
        responses.add(
            responses.GET,
            url,
            body=mock_response,
            content_type='application/json',
            status=200,
        )

        # Set up parameter values
        policy_id = 'testString'

        # Invoke method
        response = _service.get_policy(
            policy_id,
            headers={},
        )

        # Check for correct operation
        assert len(responses.calls) == 1
        assert response.status_code == 200

    def test_get_policy_required_params_with_retries(self):
        # Enable retries and run test_get_policy_required_params.
        _service.enable_retries()
        self.test_get_policy_required_params()

        # Disable retries and run test_get_policy_required_params.
        _service.disable_retries()
        self.test_get_policy_required_params()

    @responses.activate
    def test_get_policy_value_error(self):
        """
        test_get_policy_value_error()
        """
        # Set up mock
        url = preprocess_url('/v2/settings/policies/testString')
        mock_response = '{"name": "Agent1-DevWS", "description": "Policy for job execution of secured workspaces on agent1", "resource_group": "Default", "tags": ["tags"], "location": "us-south", "state": {"state": "draft", "set_by": "set_by", "set_at": "2019-01-01T12:00:00.000Z"}, "kind": "agent_assignment_policy", "target": {"selector_kind": "ids", "selector_ids": ["selector_ids"], "selector_scope": [{"kind": "workspace", "tags": ["tags"], "resource_groups": ["resource_groups"], "locations": ["us-south"]}]}, "parameter": {"agent_assignment_policy_parameter": {"selector_kind": "ids", "selector_ids": ["selector_ids"], "selector_scope": [{"kind": "workspace", "tags": ["tags"], "resource_groups": ["resource_groups"], "locations": ["us-south"]}]}}, "id": "id", "crn": "crn", "account": "account", "scoped_resources": [{"kind": "workspace", "id": "id"}], "created_at": "2019-01-01T12:00:00.000Z", "created_by": "created_by", "updated_at": "2019-01-01T12:00:00.000Z"}'
        responses.add(
            responses.GET,
            url,
            body=mock_response,
            content_type='application/json',
            status=200,
        )

        # Set up parameter values
        policy_id = 'testString'

        # Pass in all but one required param and check for a ValueError
        req_param_dict = {
            "policy_id": policy_id,
        }
        for param in req_param_dict.keys():
            req_copy = {key: val if key is not param else None for (key, val) in req_param_dict.items()}
            with pytest.raises(ValueError):
                _service.get_policy(**req_copy)

    def test_get_policy_value_error_with_retries(self):
        # Enable retries and run test_get_policy_value_error.
        _service.enable_retries()
        self.test_get_policy_value_error()

        # Disable retries and run test_get_policy_value_error.
        _service.disable_retries()
        self.test_get_policy_value_error()


class TestDeletePolicy:
    """
    Test Class for delete_policy
    """

    @responses.activate
    def test_delete_policy_all_params(self):
        """
        delete_policy()
        """
        # Set up mock
        url = preprocess_url('/v2/settings/policies/testString')
        responses.add(
            responses.DELETE,
            url,
            status=204,
        )

        # Set up parameter values
        policy_id = 'testString'

        # Invoke method
        response = _service.delete_policy(
            policy_id,
            headers={},
        )

        # Check for correct operation
        assert len(responses.calls) == 1
        assert response.status_code == 204

    def test_delete_policy_all_params_with_retries(self):
        # Enable retries and run test_delete_policy_all_params.
        _service.enable_retries()
        self.test_delete_policy_all_params()

        # Disable retries and run test_delete_policy_all_params.
        _service.disable_retries()
        self.test_delete_policy_all_params()

    @responses.activate
    def test_delete_policy_value_error(self):
        """
        test_delete_policy_value_error()
        """
        # Set up mock
        url = preprocess_url('/v2/settings/policies/testString')
        responses.add(
            responses.DELETE,
            url,
            status=204,
        )

        # Set up parameter values
        policy_id = 'testString'

        # Pass in all but one required param and check for a ValueError
        req_param_dict = {
            "policy_id": policy_id,
        }
        for param in req_param_dict.keys():
            req_copy = {key: val if key is not param else None for (key, val) in req_param_dict.items()}
            with pytest.raises(ValueError):
                _service.delete_policy(**req_copy)

    def test_delete_policy_value_error_with_retries(self):
        # Enable retries and run test_delete_policy_value_error.
        _service.enable_retries()
        self.test_delete_policy_value_error()

        # Disable retries and run test_delete_policy_value_error.
        _service.disable_retries()
        self.test_delete_policy_value_error()


class TestUpdatePolicy:
    """
    Test Class for update_policy
    """

    @responses.activate
    def test_update_policy_all_params(self):
        """
        update_policy()
        """
        # Set up mock
        url = preprocess_url('/v2/settings/policies/testString')
        mock_response = '{"name": "Agent1-DevWS", "description": "Policy for job execution of secured workspaces on agent1", "resource_group": "Default", "tags": ["tags"], "location": "us-south", "state": {"state": "draft", "set_by": "set_by", "set_at": "2019-01-01T12:00:00.000Z"}, "kind": "agent_assignment_policy", "target": {"selector_kind": "ids", "selector_ids": ["selector_ids"], "selector_scope": [{"kind": "workspace", "tags": ["tags"], "resource_groups": ["resource_groups"], "locations": ["us-south"]}]}, "parameter": {"agent_assignment_policy_parameter": {"selector_kind": "ids", "selector_ids": ["selector_ids"], "selector_scope": [{"kind": "workspace", "tags": ["tags"], "resource_groups": ["resource_groups"], "locations": ["us-south"]}]}}, "id": "id", "crn": "crn", "account": "account", "scoped_resources": [{"kind": "workspace", "id": "id"}], "created_at": "2019-01-01T12:00:00.000Z", "created_by": "created_by", "updated_at": "2019-01-01T12:00:00.000Z"}'
        responses.add(
            responses.PATCH,
            url,
            body=mock_response,
            content_type='application/json',
            status=200,
        )

        # Construct a dict representation of a UserState model
        user_state_model = {}
        user_state_model['state'] = 'draft'
        user_state_model['set_by'] = 'testString'
        user_state_model['set_at'] = '2019-01-01T12:00:00Z'

        # Construct a dict representation of a PolicyObjectSelector model
        policy_object_selector_model = {}
        policy_object_selector_model['kind'] = 'workspace'
        policy_object_selector_model['tags'] = ['testString']
        policy_object_selector_model['resource_groups'] = ['testString']
        policy_object_selector_model['locations'] = ['us-south']

        # Construct a dict representation of a PolicyObjects model
        policy_objects_model = {}
        policy_objects_model['selector_kind'] = 'ids'
        policy_objects_model['selector_ids'] = ['testString']
        policy_objects_model['selector_scope'] = [policy_object_selector_model]

        # Construct a dict representation of a AgentAssignmentPolicyParameter model
        agent_assignment_policy_parameter_model = {}
        agent_assignment_policy_parameter_model['selector_kind'] = 'ids'
        agent_assignment_policy_parameter_model['selector_ids'] = ['testString']
        agent_assignment_policy_parameter_model['selector_scope'] = [policy_object_selector_model]

        # Construct a dict representation of a PolicyParameter model
        policy_parameter_model = {}
        policy_parameter_model['agent_assignment_policy_parameter'] = agent_assignment_policy_parameter_model

        # Construct a dict representation of a ScopedResource model
        scoped_resource_model = {}
        scoped_resource_model['kind'] = 'workspace'
        scoped_resource_model['id'] = 'testString'

        # Set up parameter values
        policy_id = 'testString'
        name = 'Agent1-DevWS'
        description = 'Policy for job execution of secured workspaces on agent1'
        resource_group = 'Default'
        tags = ['policy:secured-job']
        location = 'us-south'
        state = user_state_model
        kind = 'agent_assignment_policy'
        target = policy_objects_model
        parameter = policy_parameter_model
        scoped_resources = [scoped_resource_model]

        # Invoke method
        response = _service.update_policy(
            policy_id,
            name=name,
            description=description,
            resource_group=resource_group,
            tags=tags,
            location=location,
            state=state,
            kind=kind,
            target=target,
            parameter=parameter,
            scoped_resources=scoped_resources,
            headers={},
        )

        # Check for correct operation
        assert len(responses.calls) == 1
        assert response.status_code == 200
        # Validate body params
        req_body = json.loads(str(responses.calls[0].request.body, 'utf-8'))
        assert req_body['name'] == 'Agent1-DevWS'
        assert req_body['description'] == 'Policy for job execution of secured workspaces on agent1'
        assert req_body['resource_group'] == 'Default'
        assert req_body['tags'] == ['policy:secured-job']
        assert req_body['location'] == 'us-south'
        assert req_body['state'] == user_state_model
        assert req_body['kind'] == 'agent_assignment_policy'
        assert req_body['target'] == policy_objects_model
        assert req_body['parameter'] == policy_parameter_model
        assert req_body['scoped_resources'] == [scoped_resource_model]

    def test_update_policy_all_params_with_retries(self):
        # Enable retries and run test_update_policy_all_params.
        _service.enable_retries()
        self.test_update_policy_all_params()

        # Disable retries and run test_update_policy_all_params.
        _service.disable_retries()
        self.test_update_policy_all_params()

    @responses.activate
    def test_update_policy_value_error(self):
        """
        test_update_policy_value_error()
        """
        # Set up mock
        url = preprocess_url('/v2/settings/policies/testString')
        mock_response = '{"name": "Agent1-DevWS", "description": "Policy for job execution of secured workspaces on agent1", "resource_group": "Default", "tags": ["tags"], "location": "us-south", "state": {"state": "draft", "set_by": "set_by", "set_at": "2019-01-01T12:00:00.000Z"}, "kind": "agent_assignment_policy", "target": {"selector_kind": "ids", "selector_ids": ["selector_ids"], "selector_scope": [{"kind": "workspace", "tags": ["tags"], "resource_groups": ["resource_groups"], "locations": ["us-south"]}]}, "parameter": {"agent_assignment_policy_parameter": {"selector_kind": "ids", "selector_ids": ["selector_ids"], "selector_scope": [{"kind": "workspace", "tags": ["tags"], "resource_groups": ["resource_groups"], "locations": ["us-south"]}]}}, "id": "id", "crn": "crn", "account": "account", "scoped_resources": [{"kind": "workspace", "id": "id"}], "created_at": "2019-01-01T12:00:00.000Z", "created_by": "created_by", "updated_at": "2019-01-01T12:00:00.000Z"}'
        responses.add(
            responses.PATCH,
            url,
            body=mock_response,
            content_type='application/json',
            status=200,
        )

        # Construct a dict representation of a UserState model
        user_state_model = {}
        user_state_model['state'] = 'draft'
        user_state_model['set_by'] = 'testString'
        user_state_model['set_at'] = '2019-01-01T12:00:00Z'

        # Construct a dict representation of a PolicyObjectSelector model
        policy_object_selector_model = {}
        policy_object_selector_model['kind'] = 'workspace'
        policy_object_selector_model['tags'] = ['testString']
        policy_object_selector_model['resource_groups'] = ['testString']
        policy_object_selector_model['locations'] = ['us-south']

        # Construct a dict representation of a PolicyObjects model
        policy_objects_model = {}
        policy_objects_model['selector_kind'] = 'ids'
        policy_objects_model['selector_ids'] = ['testString']
        policy_objects_model['selector_scope'] = [policy_object_selector_model]

        # Construct a dict representation of a AgentAssignmentPolicyParameter model
        agent_assignment_policy_parameter_model = {}
        agent_assignment_policy_parameter_model['selector_kind'] = 'ids'
        agent_assignment_policy_parameter_model['selector_ids'] = ['testString']
        agent_assignment_policy_parameter_model['selector_scope'] = [policy_object_selector_model]

        # Construct a dict representation of a PolicyParameter model
        policy_parameter_model = {}
        policy_parameter_model['agent_assignment_policy_parameter'] = agent_assignment_policy_parameter_model

        # Construct a dict representation of a ScopedResource model
        scoped_resource_model = {}
        scoped_resource_model['kind'] = 'workspace'
        scoped_resource_model['id'] = 'testString'

        # Set up parameter values
        policy_id = 'testString'
        name = 'Agent1-DevWS'
        description = 'Policy for job execution of secured workspaces on agent1'
        resource_group = 'Default'
        tags = ['policy:secured-job']
        location = 'us-south'
        state = user_state_model
        kind = 'agent_assignment_policy'
        target = policy_objects_model
        parameter = policy_parameter_model
        scoped_resources = [scoped_resource_model]

        # Pass in all but one required param and check for a ValueError
        req_param_dict = {
            "policy_id": policy_id,
        }
        for param in req_param_dict.keys():
            req_copy = {key: val if key is not param else None for (key, val) in req_param_dict.items()}
            with pytest.raises(ValueError):
                _service.update_policy(**req_copy)

    def test_update_policy_value_error_with_retries(self):
        # Enable retries and run test_update_policy_value_error.
        _service.enable_retries()
        self.test_update_policy_value_error()

        # Disable retries and run test_update_policy_value_error.
        _service.disable_retries()
        self.test_update_policy_value_error()


# endregion
##############################################################################
# End of Service: Policy
##############################################################################


##############################################################################
# Start of Model Tests
##############################################################################
# region


class TestModel_Action:
    """
    Test Class for Action
    """

    def test_action_serialization(self):
        """
        Test serialization/deserialization for Action
        """

        # Construct dict forms of any model objects needed in order to build this model.

        user_state_model = {}  # UserState
        user_state_model['state'] = 'draft'
        user_state_model['set_by'] = 'testString'
        user_state_model['set_at'] = '2019-01-01T12:00:00Z'

        git_source_model = {}  # GitSource
        git_source_model['computed_git_repo_url'] = 'testString'
        git_source_model['git_repo_url'] = 'testString'
        git_source_model['git_token'] = 'testString'
        git_source_model['git_repo_folder'] = 'testString'
        git_source_model['git_release'] = 'testString'
        git_source_model['git_branch'] = 'testString'

        catalog_source_model = {}  # CatalogSource
        catalog_source_model['catalog_name'] = 'testString'
        catalog_source_model['catalog_id'] = 'testString'
        catalog_source_model['offering_name'] = 'testString'
        catalog_source_model['offering_version'] = 'testString'
        catalog_source_model['offering_kind'] = 'testString'
        catalog_source_model['offering_target_kind'] = 'testString'
        catalog_source_model['offering_id'] = 'testString'
        catalog_source_model['offering_version_id'] = 'testString'
        catalog_source_model['offering_version_flavour_name'] = 'testString'
        catalog_source_model['offering_repo_url'] = 'testString'
        catalog_source_model['offering_provisioner_working_directory'] = 'testString'
        catalog_source_model['dry_run'] = True
        catalog_source_model['owning_account'] = 'testString'
        catalog_source_model['item_icon_url'] = 'testString'
        catalog_source_model['item_id'] = 'testString'
        catalog_source_model['item_name'] = 'testString'
        catalog_source_model['item_readme_url'] = 'testString'
        catalog_source_model['item_url'] = 'testString'
        catalog_source_model['launch_url'] = 'testString'

        external_source_model = {}  # ExternalSource
        external_source_model['source_type'] = 'local'
        external_source_model['git'] = git_source_model
        external_source_model['catalog'] = catalog_source_model

        credential_variable_metadata_model = {}  # CredentialVariableMetadata
        credential_variable_metadata_model['type'] = 'string'
        credential_variable_metadata_model['aliases'] = ['testString']
        credential_variable_metadata_model['description'] = 'testString'
        credential_variable_metadata_model['cloud_data_type'] = 'testString'
        credential_variable_metadata_model['default_value'] = 'testString'
        credential_variable_metadata_model['link_status'] = 'normal'
        credential_variable_metadata_model['immutable'] = True
        credential_variable_metadata_model['hidden'] = True
        credential_variable_metadata_model['required'] = True
        credential_variable_metadata_model['position'] = 38
        credential_variable_metadata_model['group_by'] = 'testString'
        credential_variable_metadata_model['source'] = 'testString'

        credential_variable_data_model = {}  # CredentialVariableData
        credential_variable_data_model['name'] = 'testString'
        credential_variable_data_model['value'] = (
            '-----BEGIN OPENSSH PRIVATE KEY-----\\nXXXXXXXXXXXXX\\n-----END OPENSSH PRIVATE KEY-----\\n'
        )
        credential_variable_data_model['use_default'] = True
        credential_variable_data_model['metadata'] = credential_variable_metadata_model

        bastion_resource_definition_model = {}  # BastionResourceDefinition
        bastion_resource_definition_model['name'] = 'testString'
        bastion_resource_definition_model['host'] = 'testString'

        variable_metadata_model = {}  # VariableMetadata
        variable_metadata_model['type'] = 'boolean'
        variable_metadata_model['aliases'] = ['testString']
        variable_metadata_model['description'] = 'testString'
        variable_metadata_model['cloud_data_type'] = 'testString'
        variable_metadata_model['default_value'] = 'testString'
        variable_metadata_model['link_status'] = 'normal'
        variable_metadata_model['secure'] = True
        variable_metadata_model['immutable'] = True
        variable_metadata_model['hidden'] = True
        variable_metadata_model['required'] = True
        variable_metadata_model['options'] = ['testString']
        variable_metadata_model['min_value'] = 38
        variable_metadata_model['max_value'] = 38
        variable_metadata_model['min_length'] = 38
        variable_metadata_model['max_length'] = 38
        variable_metadata_model['matches'] = 'testString'
        variable_metadata_model['position'] = 38
        variable_metadata_model['group_by'] = 'testString'
        variable_metadata_model['source'] = 'testString'

        variable_data_model = {}  # VariableData
        variable_data_model['name'] = 'testString'
        variable_data_model['value'] = 'testString'
        variable_data_model['use_default'] = True
        variable_data_model['metadata'] = variable_metadata_model

        # Construct a json representation of a Action model
        action_model_json = {}
        action_model_json['name'] = 'Stop Action'
        action_model_json['description'] = (
            'The description of your action. The description can be up to 2048 characters long in size. **Example** you can use the description to stop the targets.'
        )
        action_model_json['location'] = 'us-south'
        action_model_json['resource_group'] = 'testString'
        action_model_json['bastion_connection_type'] = 'ssh'
        action_model_json['inventory_connection_type'] = 'ssh'
        action_model_json['tags'] = ['testString']
        action_model_json['user_state'] = user_state_model
        action_model_json['source_readme_url'] = 'testString'
        action_model_json['source'] = external_source_model
        action_model_json['source_type'] = 'local'
        action_model_json['command_parameter'] = 'testString'
        action_model_json['inventory'] = 'testString'
        action_model_json['credentials'] = [credential_variable_data_model]
        action_model_json['bastion'] = bastion_resource_definition_model
        action_model_json['bastion_credential'] = credential_variable_data_model
        action_model_json['targets_ini'] = 'testString'
        action_model_json['inputs'] = [variable_data_model]
        action_model_json['outputs'] = [variable_data_model]
        action_model_json['settings'] = [variable_data_model]

        # Construct a model instance of Action by calling from_dict on the json representation
        action_model = Action.from_dict(action_model_json)
        assert action_model != False

        # Construct a model instance of Action by calling from_dict on the json representation
        action_model_dict = Action.from_dict(action_model_json).__dict__
        action_model2 = Action(**action_model_dict)

        # Verify the model instances are equivalent
        assert action_model == action_model2

        # Convert model instance back to dict and verify no loss of data
        action_model_json2 = action_model.to_dict()
        assert action_model_json2 == action_model_json


class TestModel_ActionList:
    """
    Test Class for ActionList
    """

    def test_action_list_serialization(self):
        """
        Test serialization/deserialization for ActionList
        """

        # Construct dict forms of any model objects needed in order to build this model.

        user_state_model = {}  # UserState
        user_state_model['state'] = 'draft'
        user_state_model['set_by'] = 'testString'
        user_state_model['set_at'] = '2019-01-01T12:00:00Z'

        agent_info_model = {}  # AgentInfo
        agent_info_model['id'] = 'testString'
        agent_info_model['name'] = 'testString'
        agent_info_model['assignment_policy_id'] = 'testString'

        action_lite_model = {}  # ActionLite
        action_lite_model['name'] = 'Stop Action'
        action_lite_model['description'] = 'This Action can be used to Stop the targets'
        action_lite_model['location'] = 'us-south'
        action_lite_model['user_state'] = user_state_model
        action_lite_model['agent'] = agent_info_model

        # Construct a json representation of a ActionList model
        action_list_model_json = {}
        action_list_model_json['total_count'] = 26
        action_list_model_json['limit'] = 26
        action_list_model_json['offset'] = 26
        action_list_model_json['actions'] = [action_lite_model]

        # Construct a model instance of ActionList by calling from_dict on the json representation
        action_list_model = ActionList.from_dict(action_list_model_json)
        assert action_list_model != False

        # Construct a model instance of ActionList by calling from_dict on the json representation
        action_list_model_dict = ActionList.from_dict(action_list_model_json).__dict__
        action_list_model2 = ActionList(**action_list_model_dict)

        # Verify the model instances are equivalent
        assert action_list_model == action_list_model2

        # Convert model instance back to dict and verify no loss of data
        action_list_model_json2 = action_list_model.to_dict()
        assert action_list_model_json2 == action_list_model_json


class TestModel_ActionLite:
    """
    Test Class for ActionLite
    """

    def test_action_lite_serialization(self):
        """
        Test serialization/deserialization for ActionLite
        """

        # Construct dict forms of any model objects needed in order to build this model.

        user_state_model = {}  # UserState
        user_state_model['state'] = 'draft'
        user_state_model['set_by'] = 'testString'
        user_state_model['set_at'] = '2019-01-01T12:00:00Z'

        agent_info_model = {}  # AgentInfo
        agent_info_model['id'] = 'testString'
        agent_info_model['name'] = 'testString'
        agent_info_model['assignment_policy_id'] = 'testString'

        # Construct a json representation of a ActionLite model
        action_lite_model_json = {}
        action_lite_model_json['name'] = 'Stop Action'
        action_lite_model_json['description'] = 'This Action can be used to Stop the targets'
        action_lite_model_json['location'] = 'us-south'
        action_lite_model_json['user_state'] = user_state_model
        action_lite_model_json['agent'] = agent_info_model

        # Construct a model instance of ActionLite by calling from_dict on the json representation
        action_lite_model = ActionLite.from_dict(action_lite_model_json)
        assert action_lite_model != False

        # Construct a model instance of ActionLite by calling from_dict on the json representation
        action_lite_model_dict = ActionLite.from_dict(action_lite_model_json).__dict__
        action_lite_model2 = ActionLite(**action_lite_model_dict)

        # Verify the model instances are equivalent
        assert action_lite_model == action_lite_model2

        # Convert model instance back to dict and verify no loss of data
        action_lite_model_json2 = action_lite_model.to_dict()
        assert action_lite_model_json2 == action_lite_model_json


class TestModel_ActionLiteState:
    """
    Test Class for ActionLiteState
    """

    def test_action_lite_state_serialization(self):
        """
        Test serialization/deserialization for ActionLiteState
        """

        # Construct a json representation of a ActionLiteState model
        action_lite_state_model_json = {}
        action_lite_state_model_json['status_code'] = 'normal'
        action_lite_state_model_json['status_message'] = 'testString'

        # Construct a model instance of ActionLiteState by calling from_dict on the json representation
        action_lite_state_model = ActionLiteState.from_dict(action_lite_state_model_json)
        assert action_lite_state_model != False

        # Construct a model instance of ActionLiteState by calling from_dict on the json representation
        action_lite_state_model_dict = ActionLiteState.from_dict(action_lite_state_model_json).__dict__
        action_lite_state_model2 = ActionLiteState(**action_lite_state_model_dict)

        # Verify the model instances are equivalent
        assert action_lite_state_model == action_lite_state_model2

        # Convert model instance back to dict and verify no loss of data
        action_lite_state_model_json2 = action_lite_state_model.to_dict()
        assert action_lite_state_model_json2 == action_lite_state_model_json


class TestModel_ActionState:
    """
    Test Class for ActionState
    """

    def test_action_state_serialization(self):
        """
        Test serialization/deserialization for ActionState
        """

        # Construct a json representation of a ActionState model
        action_state_model_json = {}
        action_state_model_json['status_code'] = 'normal'
        action_state_model_json['status_job_id'] = 'testString'
        action_state_model_json['status_message'] = 'testString'

        # Construct a model instance of ActionState by calling from_dict on the json representation
        action_state_model = ActionState.from_dict(action_state_model_json)
        assert action_state_model != False

        # Construct a model instance of ActionState by calling from_dict on the json representation
        action_state_model_dict = ActionState.from_dict(action_state_model_json).__dict__
        action_state_model2 = ActionState(**action_state_model_dict)

        # Verify the model instances are equivalent
        assert action_state_model == action_state_model2

        # Convert model instance back to dict and verify no loss of data
        action_state_model_json2 = action_state_model.to_dict()
        assert action_state_model_json2 == action_state_model_json


class TestModel_Agent:
    """
    Test Class for Agent
    """

    def test_agent_serialization(self):
        """
        Test serialization/deserialization for Agent
        """

        # Construct dict forms of any model objects needed in order to build this model.

        agent_user_state_model = {}  # AgentUserState
        agent_user_state_model['state'] = 'enable'

        # Construct a json representation of a Agent model
        agent_model_json = {}
        agent_model_json['name'] = 'MyDevAgent'
        agent_model_json['description'] = 'Register agent'
        agent_model_json['resource_group'] = 'testString'
        agent_model_json['tags'] = ['testString']
        agent_model_json['agent_location'] = 'us-south'
        agent_model_json['location'] = 'us-south'
        agent_model_json['profile_id'] = 'testString'
        agent_model_json['user_state'] = agent_user_state_model

        # Construct a model instance of Agent by calling from_dict on the json representation
        agent_model = Agent.from_dict(agent_model_json)
        assert agent_model != False

        # Construct a model instance of Agent by calling from_dict on the json representation
        agent_model_dict = Agent.from_dict(agent_model_json).__dict__
        agent_model2 = Agent(**agent_model_dict)

        # Verify the model instances are equivalent
        assert agent_model == agent_model2

        # Convert model instance back to dict and verify no loss of data
        agent_model_json2 = agent_model.to_dict()
        assert agent_model_json2 == agent_model_json


class TestModel_AgentAssignmentPolicyParameter:
    """
    Test Class for AgentAssignmentPolicyParameter
    """

    def test_agent_assignment_policy_parameter_serialization(self):
        """
        Test serialization/deserialization for AgentAssignmentPolicyParameter
        """

        # Construct dict forms of any model objects needed in order to build this model.

        policy_object_selector_model = {}  # PolicyObjectSelector
        policy_object_selector_model['kind'] = 'workspace'
        policy_object_selector_model['tags'] = ['testString']
        policy_object_selector_model['resource_groups'] = ['testString']
        policy_object_selector_model['locations'] = ['us-south']

        # Construct a json representation of a AgentAssignmentPolicyParameter model
        agent_assignment_policy_parameter_model_json = {}
        agent_assignment_policy_parameter_model_json['selector_kind'] = 'ids'
        agent_assignment_policy_parameter_model_json['selector_ids'] = ['testString']
        agent_assignment_policy_parameter_model_json['selector_scope'] = [policy_object_selector_model]

        # Construct a model instance of AgentAssignmentPolicyParameter by calling from_dict on the json representation
        agent_assignment_policy_parameter_model = AgentAssignmentPolicyParameter.from_dict(
            agent_assignment_policy_parameter_model_json
        )
        assert agent_assignment_policy_parameter_model != False

        # Construct a model instance of AgentAssignmentPolicyParameter by calling from_dict on the json representation
        agent_assignment_policy_parameter_model_dict = AgentAssignmentPolicyParameter.from_dict(
            agent_assignment_policy_parameter_model_json
        ).__dict__
        agent_assignment_policy_parameter_model2 = AgentAssignmentPolicyParameter(
            **agent_assignment_policy_parameter_model_dict
        )

        # Verify the model instances are equivalent
        assert agent_assignment_policy_parameter_model == agent_assignment_policy_parameter_model2

        # Convert model instance back to dict and verify no loss of data
        agent_assignment_policy_parameter_model_json2 = agent_assignment_policy_parameter_model.to_dict()
        assert agent_assignment_policy_parameter_model_json2 == agent_assignment_policy_parameter_model_json


class TestModel_AgentData:
    """
    Test Class for AgentData
    """

    def test_agent_data_serialization(self):
        """
        Test serialization/deserialization for AgentData
        """

        # Construct dict forms of any model objects needed in order to build this model.

        agent_infrastructure_model = {}  # AgentInfrastructure
        agent_infrastructure_model['infra_type'] = 'ibm_kubernetes'
        agent_infrastructure_model['cluster_id'] = 'testString'
        agent_infrastructure_model['cluster_resource_group'] = 'testString'
        agent_infrastructure_model['cos_instance_name'] = 'testString'
        agent_infrastructure_model['cos_bucket_name'] = 'testString'
        agent_infrastructure_model['cos_bucket_region'] = 'testString'

        agent_metadata_info_model = {}  # AgentMetadataInfo
        agent_metadata_info_model['name'] = 'purpose'
        agent_metadata_info_model['value'] = ['git', 'terraform', 'ansible']

        variable_metadata_model = {}  # VariableMetadata
        variable_metadata_model['type'] = 'boolean'
        variable_metadata_model['aliases'] = ['testString']
        variable_metadata_model['description'] = 'testString'
        variable_metadata_model['cloud_data_type'] = 'testString'
        variable_metadata_model['default_value'] = 'testString'
        variable_metadata_model['link_status'] = 'normal'
        variable_metadata_model['secure'] = True
        variable_metadata_model['immutable'] = True
        variable_metadata_model['hidden'] = True
        variable_metadata_model['required'] = True
        variable_metadata_model['options'] = ['testString']
        variable_metadata_model['min_value'] = 38
        variable_metadata_model['max_value'] = 38
        variable_metadata_model['min_length'] = 38
        variable_metadata_model['max_length'] = 38
        variable_metadata_model['matches'] = 'testString'
        variable_metadata_model['position'] = 38
        variable_metadata_model['group_by'] = 'testString'
        variable_metadata_model['source'] = 'testString'

        variable_data_model = {}  # VariableData
        variable_data_model['name'] = 'testString'
        variable_data_model['value'] = 'testString'
        variable_data_model['use_default'] = True
        variable_data_model['metadata'] = variable_metadata_model

        agent_user_state_model = {}  # AgentUserState
        agent_user_state_model['state'] = 'enable'

        agent_kpi_data_model = {}  # AgentKPIData
        agent_kpi_data_model['availability_indicator'] = 'available'
        agent_kpi_data_model['lifecycle_indicator'] = 'consistent'
        agent_kpi_data_model['percent_usage_indicator'] = 'testString'
        agent_kpi_data_model['application_indicators'] = ['testString']
        agent_kpi_data_model['infra_indicators'] = ['testString']

        # Construct a json representation of a AgentData model
        agent_data_model_json = {}
        agent_data_model_json['name'] = 'MyDevAgent'
        agent_data_model_json['description'] = 'Create Agent'
        agent_data_model_json['resource_group'] = 'Default'
        agent_data_model_json['tags'] = ['testString']
        agent_data_model_json['version'] = 'v1.0.0'
        agent_data_model_json['schematics_location'] = 'us-south'
        agent_data_model_json['agent_location'] = 'us-south'
        agent_data_model_json['agent_infrastructure'] = agent_infrastructure_model
        agent_data_model_json['agent_metadata'] = [agent_metadata_info_model]
        agent_data_model_json['agent_inputs'] = [variable_data_model]
        agent_data_model_json['user_state'] = agent_user_state_model
        agent_data_model_json['agent_kpi'] = agent_kpi_data_model

        # Construct a model instance of AgentData by calling from_dict on the json representation
        agent_data_model = AgentData.from_dict(agent_data_model_json)
        assert agent_data_model != False

        # Construct a model instance of AgentData by calling from_dict on the json representation
        agent_data_model_dict = AgentData.from_dict(agent_data_model_json).__dict__
        agent_data_model2 = AgentData(**agent_data_model_dict)

        # Verify the model instances are equivalent
        assert agent_data_model == agent_data_model2

        # Convert model instance back to dict and verify no loss of data
        agent_data_model_json2 = agent_data_model.to_dict()
        assert agent_data_model_json2 == agent_data_model_json


class TestModel_AgentDataList:
    """
    Test Class for AgentDataList
    """

    def test_agent_data_list_serialization(self):
        """
        Test serialization/deserialization for AgentDataList
        """

        # Construct dict forms of any model objects needed in order to build this model.

        agent_metadata_info_model = {}  # AgentMetadataInfo
        agent_metadata_info_model['name'] = 'purpose'
        agent_metadata_info_model['value'] = ['git', 'terraform', 'ansible']

        agent_user_state_model = {}  # AgentUserState
        agent_user_state_model['state'] = 'enable'

        agent_kpi_data_lite_model = {}  # AgentKPIDataLite
        agent_kpi_data_lite_model['availability_indicator'] = 'available'
        agent_kpi_data_lite_model['lifecycle_indicator'] = 'consistent'
        agent_kpi_data_lite_model['percent_usage_indicator'] = 'testString'

        agent_data_lite_model = {}  # AgentDataLite
        agent_data_lite_model['name'] = 'MyDevAgent'
        agent_data_lite_model['description'] = 'Register agent'
        agent_data_lite_model['resource_group'] = 'testString'
        agent_data_lite_model['tags'] = ['testString']
        agent_data_lite_model['version'] = 'v1.0.0'
        agent_data_lite_model['schematics_location'] = 'us-south'
        agent_data_lite_model['agent_location'] = 'us-south'
        agent_data_lite_model['agent_metadata'] = [agent_metadata_info_model]
        agent_data_lite_model['user_state'] = agent_user_state_model
        agent_data_lite_model['agent_kpi'] = agent_kpi_data_lite_model

        # Construct a json representation of a AgentDataList model
        agent_data_list_model_json = {}
        agent_data_list_model_json['offset'] = 26
        agent_data_list_model_json['agents'] = [agent_data_lite_model]

        # Construct a model instance of AgentDataList by calling from_dict on the json representation
        agent_data_list_model = AgentDataList.from_dict(agent_data_list_model_json)
        assert agent_data_list_model != False

        # Construct a model instance of AgentDataList by calling from_dict on the json representation
        agent_data_list_model_dict = AgentDataList.from_dict(agent_data_list_model_json).__dict__
        agent_data_list_model2 = AgentDataList(**agent_data_list_model_dict)

        # Verify the model instances are equivalent
        assert agent_data_list_model == agent_data_list_model2

        # Convert model instance back to dict and verify no loss of data
        agent_data_list_model_json2 = agent_data_list_model.to_dict()
        assert agent_data_list_model_json2 == agent_data_list_model_json


class TestModel_AgentDataLite:
    """
    Test Class for AgentDataLite
    """

    def test_agent_data_lite_serialization(self):
        """
        Test serialization/deserialization for AgentDataLite
        """

        # Construct dict forms of any model objects needed in order to build this model.

        agent_metadata_info_model = {}  # AgentMetadataInfo
        agent_metadata_info_model['name'] = 'purpose'
        agent_metadata_info_model['value'] = ['git', 'terraform', 'ansible']

        agent_user_state_model = {}  # AgentUserState
        agent_user_state_model['state'] = 'enable'

        agent_kpi_data_lite_model = {}  # AgentKPIDataLite
        agent_kpi_data_lite_model['availability_indicator'] = 'available'
        agent_kpi_data_lite_model['lifecycle_indicator'] = 'consistent'
        agent_kpi_data_lite_model['percent_usage_indicator'] = 'testString'

        # Construct a json representation of a AgentDataLite model
        agent_data_lite_model_json = {}
        agent_data_lite_model_json['name'] = 'MyDevAgent'
        agent_data_lite_model_json['description'] = 'Register agent'
        agent_data_lite_model_json['resource_group'] = 'testString'
        agent_data_lite_model_json['tags'] = ['testString']
        agent_data_lite_model_json['version'] = 'v1.0.0'
        agent_data_lite_model_json['schematics_location'] = 'us-south'
        agent_data_lite_model_json['agent_location'] = 'us-south'
        agent_data_lite_model_json['agent_metadata'] = [agent_metadata_info_model]
        agent_data_lite_model_json['user_state'] = agent_user_state_model
        agent_data_lite_model_json['agent_kpi'] = agent_kpi_data_lite_model

        # Construct a model instance of AgentDataLite by calling from_dict on the json representation
        agent_data_lite_model = AgentDataLite.from_dict(agent_data_lite_model_json)
        assert agent_data_lite_model != False

        # Construct a model instance of AgentDataLite by calling from_dict on the json representation
        agent_data_lite_model_dict = AgentDataLite.from_dict(agent_data_lite_model_json).__dict__
        agent_data_lite_model2 = AgentDataLite(**agent_data_lite_model_dict)

        # Verify the model instances are equivalent
        assert agent_data_lite_model == agent_data_lite_model2

        # Convert model instance back to dict and verify no loss of data
        agent_data_lite_model_json2 = agent_data_lite_model.to_dict()
        assert agent_data_lite_model_json2 == agent_data_lite_model_json


class TestModel_AgentDataRecentDeployJob:
    """
    Test Class for AgentDataRecentDeployJob
    """

    def test_agent_data_recent_deploy_job_serialization(self):
        """
        Test serialization/deserialization for AgentDataRecentDeployJob
        """

        # Construct a json representation of a AgentDataRecentDeployJob model
        agent_data_recent_deploy_job_model_json = {}
        agent_data_recent_deploy_job_model_json['agent_id'] = 'testString'
        agent_data_recent_deploy_job_model_json['job_id'] = 'testString'
        agent_data_recent_deploy_job_model_json['is_redeployed'] = False
        agent_data_recent_deploy_job_model_json['status_code'] = 'job_pending'
        agent_data_recent_deploy_job_model_json['status_message'] = 'testString'
        agent_data_recent_deploy_job_model_json['log_url'] = 'testString'

        # Construct a model instance of AgentDataRecentDeployJob by calling from_dict on the json representation
        agent_data_recent_deploy_job_model = AgentDataRecentDeployJob.from_dict(agent_data_recent_deploy_job_model_json)
        assert agent_data_recent_deploy_job_model != False

        # Construct a model instance of AgentDataRecentDeployJob by calling from_dict on the json representation
        agent_data_recent_deploy_job_model_dict = AgentDataRecentDeployJob.from_dict(
            agent_data_recent_deploy_job_model_json
        ).__dict__
        agent_data_recent_deploy_job_model2 = AgentDataRecentDeployJob(**agent_data_recent_deploy_job_model_dict)

        # Verify the model instances are equivalent
        assert agent_data_recent_deploy_job_model == agent_data_recent_deploy_job_model2

        # Convert model instance back to dict and verify no loss of data
        agent_data_recent_deploy_job_model_json2 = agent_data_recent_deploy_job_model.to_dict()
        assert agent_data_recent_deploy_job_model_json2 == agent_data_recent_deploy_job_model_json


class TestModel_AgentDataRecentDestroyJob:
    """
    Test Class for AgentDataRecentDestroyJob
    """

    def test_agent_data_recent_destroy_job_serialization(self):
        """
        Test serialization/deserialization for AgentDataRecentDestroyJob
        """

        # Construct a json representation of a AgentDataRecentDestroyJob model
        agent_data_recent_destroy_job_model_json = {}
        agent_data_recent_destroy_job_model_json['agent_id'] = 'testString'
        agent_data_recent_destroy_job_model_json['job_id'] = 'testString'
        agent_data_recent_destroy_job_model_json['status_code'] = 'job_pending'
        agent_data_recent_destroy_job_model_json['status_message'] = 'testString'
        agent_data_recent_destroy_job_model_json['log_url'] = 'testString'

        # Construct a model instance of AgentDataRecentDestroyJob by calling from_dict on the json representation
        agent_data_recent_destroy_job_model = AgentDataRecentDestroyJob.from_dict(
            agent_data_recent_destroy_job_model_json
        )
        assert agent_data_recent_destroy_job_model != False

        # Construct a model instance of AgentDataRecentDestroyJob by calling from_dict on the json representation
        agent_data_recent_destroy_job_model_dict = AgentDataRecentDestroyJob.from_dict(
            agent_data_recent_destroy_job_model_json
        ).__dict__
        agent_data_recent_destroy_job_model2 = AgentDataRecentDestroyJob(**agent_data_recent_destroy_job_model_dict)

        # Verify the model instances are equivalent
        assert agent_data_recent_destroy_job_model == agent_data_recent_destroy_job_model2

        # Convert model instance back to dict and verify no loss of data
        agent_data_recent_destroy_job_model_json2 = agent_data_recent_destroy_job_model.to_dict()
        assert agent_data_recent_destroy_job_model_json2 == agent_data_recent_destroy_job_model_json


class TestModel_AgentDataRecentHealthJob:
    """
    Test Class for AgentDataRecentHealthJob
    """

    def test_agent_data_recent_health_job_serialization(self):
        """
        Test serialization/deserialization for AgentDataRecentHealthJob
        """

        # Construct a json representation of a AgentDataRecentHealthJob model
        agent_data_recent_health_job_model_json = {}
        agent_data_recent_health_job_model_json['agent_id'] = 'testString'
        agent_data_recent_health_job_model_json['job_id'] = 'testString'
        agent_data_recent_health_job_model_json['status_code'] = 'job_pending'
        agent_data_recent_health_job_model_json['status_message'] = 'testString'
        agent_data_recent_health_job_model_json['log_url'] = 'testString'

        # Construct a model instance of AgentDataRecentHealthJob by calling from_dict on the json representation
        agent_data_recent_health_job_model = AgentDataRecentHealthJob.from_dict(agent_data_recent_health_job_model_json)
        assert agent_data_recent_health_job_model != False

        # Construct a model instance of AgentDataRecentHealthJob by calling from_dict on the json representation
        agent_data_recent_health_job_model_dict = AgentDataRecentHealthJob.from_dict(
            agent_data_recent_health_job_model_json
        ).__dict__
        agent_data_recent_health_job_model2 = AgentDataRecentHealthJob(**agent_data_recent_health_job_model_dict)

        # Verify the model instances are equivalent
        assert agent_data_recent_health_job_model == agent_data_recent_health_job_model2

        # Convert model instance back to dict and verify no loss of data
        agent_data_recent_health_job_model_json2 = agent_data_recent_health_job_model.to_dict()
        assert agent_data_recent_health_job_model_json2 == agent_data_recent_health_job_model_json


class TestModel_AgentDataRecentPrsJob:
    """
    Test Class for AgentDataRecentPrsJob
    """

    def test_agent_data_recent_prs_job_serialization(self):
        """
        Test serialization/deserialization for AgentDataRecentPrsJob
        """

        # Construct a json representation of a AgentDataRecentPrsJob model
        agent_data_recent_prs_job_model_json = {}
        agent_data_recent_prs_job_model_json['agent_id'] = 'testString'
        agent_data_recent_prs_job_model_json['job_id'] = 'testString'
        agent_data_recent_prs_job_model_json['status_code'] = 'job_pending'
        agent_data_recent_prs_job_model_json['status_message'] = 'testString'
        agent_data_recent_prs_job_model_json['log_url'] = 'testString'

        # Construct a model instance of AgentDataRecentPrsJob by calling from_dict on the json representation
        agent_data_recent_prs_job_model = AgentDataRecentPrsJob.from_dict(agent_data_recent_prs_job_model_json)
        assert agent_data_recent_prs_job_model != False

        # Construct a model instance of AgentDataRecentPrsJob by calling from_dict on the json representation
        agent_data_recent_prs_job_model_dict = AgentDataRecentPrsJob.from_dict(
            agent_data_recent_prs_job_model_json
        ).__dict__
        agent_data_recent_prs_job_model2 = AgentDataRecentPrsJob(**agent_data_recent_prs_job_model_dict)

        # Verify the model instances are equivalent
        assert agent_data_recent_prs_job_model == agent_data_recent_prs_job_model2

        # Convert model instance back to dict and verify no loss of data
        agent_data_recent_prs_job_model_json2 = agent_data_recent_prs_job_model.to_dict()
        assert agent_data_recent_prs_job_model_json2 == agent_data_recent_prs_job_model_json


class TestModel_AgentDeployJob:
    """
    Test Class for AgentDeployJob
    """

    def test_agent_deploy_job_serialization(self):
        """
        Test serialization/deserialization for AgentDeployJob
        """

        # Construct a json representation of a AgentDeployJob model
        agent_deploy_job_model_json = {}
        agent_deploy_job_model_json['agent_id'] = 'testString'
        agent_deploy_job_model_json['job_id'] = 'testString'
        agent_deploy_job_model_json['is_redeployed'] = False
        agent_deploy_job_model_json['status_code'] = 'job_pending'
        agent_deploy_job_model_json['status_message'] = 'testString'
        agent_deploy_job_model_json['log_url'] = 'testString'

        # Construct a model instance of AgentDeployJob by calling from_dict on the json representation
        agent_deploy_job_model = AgentDeployJob.from_dict(agent_deploy_job_model_json)
        assert agent_deploy_job_model != False

        # Construct a model instance of AgentDeployJob by calling from_dict on the json representation
        agent_deploy_job_model_dict = AgentDeployJob.from_dict(agent_deploy_job_model_json).__dict__
        agent_deploy_job_model2 = AgentDeployJob(**agent_deploy_job_model_dict)

        # Verify the model instances are equivalent
        assert agent_deploy_job_model == agent_deploy_job_model2

        # Convert model instance back to dict and verify no loss of data
        agent_deploy_job_model_json2 = agent_deploy_job_model.to_dict()
        assert agent_deploy_job_model_json2 == agent_deploy_job_model_json


class TestModel_AgentHealthJob:
    """
    Test Class for AgentHealthJob
    """

    def test_agent_health_job_serialization(self):
        """
        Test serialization/deserialization for AgentHealthJob
        """

        # Construct a json representation of a AgentHealthJob model
        agent_health_job_model_json = {}
        agent_health_job_model_json['agent_id'] = 'testString'
        agent_health_job_model_json['job_id'] = 'testString'
        agent_health_job_model_json['status_code'] = 'job_pending'
        agent_health_job_model_json['status_message'] = 'testString'
        agent_health_job_model_json['log_url'] = 'testString'

        # Construct a model instance of AgentHealthJob by calling from_dict on the json representation
        agent_health_job_model = AgentHealthJob.from_dict(agent_health_job_model_json)
        assert agent_health_job_model != False

        # Construct a model instance of AgentHealthJob by calling from_dict on the json representation
        agent_health_job_model_dict = AgentHealthJob.from_dict(agent_health_job_model_json).__dict__
        agent_health_job_model2 = AgentHealthJob(**agent_health_job_model_dict)

        # Verify the model instances are equivalent
        assert agent_health_job_model == agent_health_job_model2

        # Convert model instance back to dict and verify no loss of data
        agent_health_job_model_json2 = agent_health_job_model.to_dict()
        assert agent_health_job_model_json2 == agent_health_job_model_json


class TestModel_AgentInfo:
    """
    Test Class for AgentInfo
    """

    def test_agent_info_serialization(self):
        """
        Test serialization/deserialization for AgentInfo
        """

        # Construct a json representation of a AgentInfo model
        agent_info_model_json = {}
        agent_info_model_json['id'] = 'testString'
        agent_info_model_json['name'] = 'testString'
        agent_info_model_json['assignment_policy_id'] = 'testString'

        # Construct a model instance of AgentInfo by calling from_dict on the json representation
        agent_info_model = AgentInfo.from_dict(agent_info_model_json)
        assert agent_info_model != False

        # Construct a model instance of AgentInfo by calling from_dict on the json representation
        agent_info_model_dict = AgentInfo.from_dict(agent_info_model_json).__dict__
        agent_info_model2 = AgentInfo(**agent_info_model_dict)

        # Verify the model instances are equivalent
        assert agent_info_model == agent_info_model2

        # Convert model instance back to dict and verify no loss of data
        agent_info_model_json2 = agent_info_model.to_dict()
        assert agent_info_model_json2 == agent_info_model_json


class TestModel_AgentInfrastructure:
    """
    Test Class for AgentInfrastructure
    """

    def test_agent_infrastructure_serialization(self):
        """
        Test serialization/deserialization for AgentInfrastructure
        """

        # Construct a json representation of a AgentInfrastructure model
        agent_infrastructure_model_json = {}
        agent_infrastructure_model_json['infra_type'] = 'ibm_kubernetes'
        agent_infrastructure_model_json['cluster_id'] = 'testString'
        agent_infrastructure_model_json['cluster_resource_group'] = 'testString'
        agent_infrastructure_model_json['cos_instance_name'] = 'testString'
        agent_infrastructure_model_json['cos_bucket_name'] = 'testString'
        agent_infrastructure_model_json['cos_bucket_region'] = 'testString'

        # Construct a model instance of AgentInfrastructure by calling from_dict on the json representation
        agent_infrastructure_model = AgentInfrastructure.from_dict(agent_infrastructure_model_json)
        assert agent_infrastructure_model != False

        # Construct a model instance of AgentInfrastructure by calling from_dict on the json representation
        agent_infrastructure_model_dict = AgentInfrastructure.from_dict(agent_infrastructure_model_json).__dict__
        agent_infrastructure_model2 = AgentInfrastructure(**agent_infrastructure_model_dict)

        # Verify the model instances are equivalent
        assert agent_infrastructure_model == agent_infrastructure_model2

        # Convert model instance back to dict and verify no loss of data
        agent_infrastructure_model_json2 = agent_infrastructure_model.to_dict()
        assert agent_infrastructure_model_json2 == agent_infrastructure_model_json


class TestModel_AgentKPIData:
    """
    Test Class for AgentKPIData
    """

    def test_agent_kpi_data_serialization(self):
        """
        Test serialization/deserialization for AgentKPIData
        """

        # Construct a json representation of a AgentKPIData model
        agent_kpi_data_model_json = {}
        agent_kpi_data_model_json['availability_indicator'] = 'available'
        agent_kpi_data_model_json['lifecycle_indicator'] = 'consistent'
        agent_kpi_data_model_json['percent_usage_indicator'] = 'testString'
        agent_kpi_data_model_json['application_indicators'] = ['testString']
        agent_kpi_data_model_json['infra_indicators'] = ['testString']

        # Construct a model instance of AgentKPIData by calling from_dict on the json representation
        agent_kpi_data_model = AgentKPIData.from_dict(agent_kpi_data_model_json)
        assert agent_kpi_data_model != False

        # Construct a model instance of AgentKPIData by calling from_dict on the json representation
        agent_kpi_data_model_dict = AgentKPIData.from_dict(agent_kpi_data_model_json).__dict__
        agent_kpi_data_model2 = AgentKPIData(**agent_kpi_data_model_dict)

        # Verify the model instances are equivalent
        assert agent_kpi_data_model == agent_kpi_data_model2

        # Convert model instance back to dict and verify no loss of data
        agent_kpi_data_model_json2 = agent_kpi_data_model.to_dict()
        assert agent_kpi_data_model_json2 == agent_kpi_data_model_json


class TestModel_AgentKPIDataLite:
    """
    Test Class for AgentKPIDataLite
    """

    def test_agent_kpi_data_lite_serialization(self):
        """
        Test serialization/deserialization for AgentKPIDataLite
        """

        # Construct a json representation of a AgentKPIDataLite model
        agent_kpi_data_lite_model_json = {}
        agent_kpi_data_lite_model_json['availability_indicator'] = 'available'
        agent_kpi_data_lite_model_json['lifecycle_indicator'] = 'consistent'
        agent_kpi_data_lite_model_json['percent_usage_indicator'] = 'testString'

        # Construct a model instance of AgentKPIDataLite by calling from_dict on the json representation
        agent_kpi_data_lite_model = AgentKPIDataLite.from_dict(agent_kpi_data_lite_model_json)
        assert agent_kpi_data_lite_model != False

        # Construct a model instance of AgentKPIDataLite by calling from_dict on the json representation
        agent_kpi_data_lite_model_dict = AgentKPIDataLite.from_dict(agent_kpi_data_lite_model_json).__dict__
        agent_kpi_data_lite_model2 = AgentKPIDataLite(**agent_kpi_data_lite_model_dict)

        # Verify the model instances are equivalent
        assert agent_kpi_data_lite_model == agent_kpi_data_lite_model2

        # Convert model instance back to dict and verify no loss of data
        agent_kpi_data_lite_model_json2 = agent_kpi_data_lite_model.to_dict()
        assert agent_kpi_data_lite_model_json2 == agent_kpi_data_lite_model_json


class TestModel_AgentList:
    """
    Test Class for AgentList
    """

    def test_agent_list_serialization(self):
        """
        Test serialization/deserialization for AgentList
        """

        # Construct dict forms of any model objects needed in order to build this model.

        agent_user_state_model = {}  # AgentUserState
        agent_user_state_model['state'] = 'enable'

        agent_model = {}  # Agent
        agent_model['name'] = 'MyDevAgent'
        agent_model['description'] = 'Register agent'
        agent_model['resource_group'] = 'testString'
        agent_model['tags'] = ['testString']
        agent_model['agent_location'] = 'us-south'
        agent_model['location'] = 'us-south'
        agent_model['profile_id'] = 'testString'
        agent_model['user_state'] = agent_user_state_model

        # Construct a json representation of a AgentList model
        agent_list_model_json = {}
        agent_list_model_json['offset'] = 26
        agent_list_model_json['agents'] = [agent_model]

        # Construct a model instance of AgentList by calling from_dict on the json representation
        agent_list_model = AgentList.from_dict(agent_list_model_json)
        assert agent_list_model != False

        # Construct a model instance of AgentList by calling from_dict on the json representation
        agent_list_model_dict = AgentList.from_dict(agent_list_model_json).__dict__
        agent_list_model2 = AgentList(**agent_list_model_dict)

        # Verify the model instances are equivalent
        assert agent_list_model == agent_list_model2

        # Convert model instance back to dict and verify no loss of data
        agent_list_model_json2 = agent_list_model.to_dict()
        assert agent_list_model_json2 == agent_list_model_json


class TestModel_AgentMetadataInfo:
    """
    Test Class for AgentMetadataInfo
    """

    def test_agent_metadata_info_serialization(self):
        """
        Test serialization/deserialization for AgentMetadataInfo
        """

        # Construct a json representation of a AgentMetadataInfo model
        agent_metadata_info_model_json = {}
        agent_metadata_info_model_json['name'] = 'purpose'
        agent_metadata_info_model_json['value'] = ['git', 'terraform', 'ansible']

        # Construct a model instance of AgentMetadataInfo by calling from_dict on the json representation
        agent_metadata_info_model = AgentMetadataInfo.from_dict(agent_metadata_info_model_json)
        assert agent_metadata_info_model != False

        # Construct a model instance of AgentMetadataInfo by calling from_dict on the json representation
        agent_metadata_info_model_dict = AgentMetadataInfo.from_dict(agent_metadata_info_model_json).__dict__
        agent_metadata_info_model2 = AgentMetadataInfo(**agent_metadata_info_model_dict)

        # Verify the model instances are equivalent
        assert agent_metadata_info_model == agent_metadata_info_model2

        # Convert model instance back to dict and verify no loss of data
        agent_metadata_info_model_json2 = agent_metadata_info_model.to_dict()
        assert agent_metadata_info_model_json2 == agent_metadata_info_model_json


class TestModel_AgentPRSJob:
    """
    Test Class for AgentPRSJob
    """

    def test_agent_prs_job_serialization(self):
        """
        Test serialization/deserialization for AgentPRSJob
        """

        # Construct a json representation of a AgentPRSJob model
        agent_prs_job_model_json = {}
        agent_prs_job_model_json['agent_id'] = 'testString'
        agent_prs_job_model_json['job_id'] = 'testString'
        agent_prs_job_model_json['status_code'] = 'job_pending'
        agent_prs_job_model_json['status_message'] = 'testString'
        agent_prs_job_model_json['log_url'] = 'testString'

        # Construct a model instance of AgentPRSJob by calling from_dict on the json representation
        agent_prs_job_model = AgentPRSJob.from_dict(agent_prs_job_model_json)
        assert agent_prs_job_model != False

        # Construct a model instance of AgentPRSJob by calling from_dict on the json representation
        agent_prs_job_model_dict = AgentPRSJob.from_dict(agent_prs_job_model_json).__dict__
        agent_prs_job_model2 = AgentPRSJob(**agent_prs_job_model_dict)

        # Verify the model instances are equivalent
        assert agent_prs_job_model == agent_prs_job_model2

        # Convert model instance back to dict and verify no loss of data
        agent_prs_job_model_json2 = agent_prs_job_model.to_dict()
        assert agent_prs_job_model_json2 == agent_prs_job_model_json


class TestModel_AgentSystemStatus:
    """
    Test Class for AgentSystemStatus
    """

    def test_agent_system_status_serialization(self):
        """
        Test serialization/deserialization for AgentSystemStatus
        """

        # Construct a json representation of a AgentSystemStatus model
        agent_system_status_model_json = {}
        agent_system_status_model_json['status_code'] = 'error'
        agent_system_status_model_json['status_message'] = 'testString'

        # Construct a model instance of AgentSystemStatus by calling from_dict on the json representation
        agent_system_status_model = AgentSystemStatus.from_dict(agent_system_status_model_json)
        assert agent_system_status_model != False

        # Construct a model instance of AgentSystemStatus by calling from_dict on the json representation
        agent_system_status_model_dict = AgentSystemStatus.from_dict(agent_system_status_model_json).__dict__
        agent_system_status_model2 = AgentSystemStatus(**agent_system_status_model_dict)

        # Verify the model instances are equivalent
        assert agent_system_status_model == agent_system_status_model2

        # Convert model instance back to dict and verify no loss of data
        agent_system_status_model_json2 = agent_system_status_model.to_dict()
        assert agent_system_status_model_json2 == agent_system_status_model_json


class TestModel_AgentUserState:
    """
    Test Class for AgentUserState
    """

    def test_agent_user_state_serialization(self):
        """
        Test serialization/deserialization for AgentUserState
        """

        # Construct a json representation of a AgentUserState model
        agent_user_state_model_json = {}
        agent_user_state_model_json['state'] = 'enable'

        # Construct a model instance of AgentUserState by calling from_dict on the json representation
        agent_user_state_model = AgentUserState.from_dict(agent_user_state_model_json)
        assert agent_user_state_model != False

        # Construct a model instance of AgentUserState by calling from_dict on the json representation
        agent_user_state_model_dict = AgentUserState.from_dict(agent_user_state_model_json).__dict__
        agent_user_state_model2 = AgentUserState(**agent_user_state_model_dict)

        # Verify the model instances are equivalent
        assert agent_user_state_model == agent_user_state_model2

        # Convert model instance back to dict and verify no loss of data
        agent_user_state_model_json2 = agent_user_state_model.to_dict()
        assert agent_user_state_model_json2 == agent_user_state_model_json


class TestModel_AgentVersionInfo:
    """
    Test Class for AgentVersionInfo
    """

    def test_agent_version_info_serialization(self):
        """
        Test serialization/deserialization for AgentVersionInfo
        """

        # Construct a json representation of a AgentVersionInfo model
        agent_version_info_model_json = {}
        agent_version_info_model_json['display_name'] = 'testString'
        agent_version_info_model_json['agent_version'] = 'testString'

        # Construct a model instance of AgentVersionInfo by calling from_dict on the json representation
        agent_version_info_model = AgentVersionInfo.from_dict(agent_version_info_model_json)
        assert agent_version_info_model != False

        # Construct a model instance of AgentVersionInfo by calling from_dict on the json representation
        agent_version_info_model_dict = AgentVersionInfo.from_dict(agent_version_info_model_json).__dict__
        agent_version_info_model2 = AgentVersionInfo(**agent_version_info_model_dict)

        # Verify the model instances are equivalent
        assert agent_version_info_model == agent_version_info_model2

        # Convert model instance back to dict and verify no loss of data
        agent_version_info_model_json2 = agent_version_info_model.to_dict()
        assert agent_version_info_model_json2 == agent_version_info_model_json


class TestModel_AgentVersions:
    """
    Test Class for AgentVersions
    """

    def test_agent_versions_serialization(self):
        """
        Test serialization/deserialization for AgentVersions
        """

        # Construct dict forms of any model objects needed in order to build this model.

        agent_version_info_model = {}  # AgentVersionInfo
        agent_version_info_model['display_name'] = 'testString'
        agent_version_info_model['agent_version'] = 'testString'

        # Construct a json representation of a AgentVersions model
        agent_versions_model_json = {}
        agent_versions_model_json['supported_agent_versions'] = [agent_version_info_model]

        # Construct a model instance of AgentVersions by calling from_dict on the json representation
        agent_versions_model = AgentVersions.from_dict(agent_versions_model_json)
        assert agent_versions_model != False

        # Construct a model instance of AgentVersions by calling from_dict on the json representation
        agent_versions_model_dict = AgentVersions.from_dict(agent_versions_model_json).__dict__
        agent_versions_model2 = AgentVersions(**agent_versions_model_dict)

        # Verify the model instances are equivalent
        assert agent_versions_model == agent_versions_model2

        # Convert model instance back to dict and verify no loss of data
        agent_versions_model_json2 = agent_versions_model.to_dict()
        assert agent_versions_model_json2 == agent_versions_model_json


class TestModel_AgentSystemState:
    """
    Test Class for AgentSystemState
    """

    def test_agent_system_state_serialization(self):
        """
        Test serialization/deserialization for AgentSystemState
        """

        # Construct a json representation of a AgentSystemState model
        agent_system_state_model_json = {}
        agent_system_state_model_json['state'] = 'error'
        agent_system_state_model_json['message'] = 'testString'

        # Construct a model instance of AgentSystemState by calling from_dict on the json representation
        agent_system_state_model = AgentSystemState.from_dict(agent_system_state_model_json)
        assert agent_system_state_model != False

        # Construct a model instance of AgentSystemState by calling from_dict on the json representation
        agent_system_state_model_dict = AgentSystemState.from_dict(agent_system_state_model_json).__dict__
        agent_system_state_model2 = AgentSystemState(**agent_system_state_model_dict)

        # Verify the model instances are equivalent
        assert agent_system_state_model == agent_system_state_model2

        # Convert model instance back to dict and verify no loss of data
        agent_system_state_model_json2 = agent_system_state_model.to_dict()
        assert agent_system_state_model_json2 == agent_system_state_model_json


class TestModel_BastionResourceDefinition:
    """
    Test Class for BastionResourceDefinition
    """

    def test_bastion_resource_definition_serialization(self):
        """
        Test serialization/deserialization for BastionResourceDefinition
        """

        # Construct a json representation of a BastionResourceDefinition model
        bastion_resource_definition_model_json = {}
        bastion_resource_definition_model_json['name'] = 'testString'
        bastion_resource_definition_model_json['host'] = 'testString'

        # Construct a model instance of BastionResourceDefinition by calling from_dict on the json representation
        bastion_resource_definition_model = BastionResourceDefinition.from_dict(bastion_resource_definition_model_json)
        assert bastion_resource_definition_model != False

        # Construct a model instance of BastionResourceDefinition by calling from_dict on the json representation
        bastion_resource_definition_model_dict = BastionResourceDefinition.from_dict(
            bastion_resource_definition_model_json
        ).__dict__
        bastion_resource_definition_model2 = BastionResourceDefinition(**bastion_resource_definition_model_dict)

        # Verify the model instances are equivalent
        assert bastion_resource_definition_model == bastion_resource_definition_model2

        # Convert model instance back to dict and verify no loss of data
        bastion_resource_definition_model_json2 = bastion_resource_definition_model.to_dict()
        assert bastion_resource_definition_model_json2 == bastion_resource_definition_model_json


class TestModel_CartOrderData:
    """
    Test Class for CartOrderData
    """

    def test_cart_order_data_serialization(self):
        """
        Test serialization/deserialization for CartOrderData
        """

        # Construct a json representation of a CartOrderData model
        cart_order_data_model_json = {}
        cart_order_data_model_json['name'] = 'testString'
        cart_order_data_model_json['value'] = 'testString'
        cart_order_data_model_json['type'] = 'testString'
        cart_order_data_model_json['usage_kind'] = ['servicetags']

        # Construct a model instance of CartOrderData by calling from_dict on the json representation
        cart_order_data_model = CartOrderData.from_dict(cart_order_data_model_json)
        assert cart_order_data_model != False

        # Construct a model instance of CartOrderData by calling from_dict on the json representation
        cart_order_data_model_dict = CartOrderData.from_dict(cart_order_data_model_json).__dict__
        cart_order_data_model2 = CartOrderData(**cart_order_data_model_dict)

        # Verify the model instances are equivalent
        assert cart_order_data_model == cart_order_data_model2

        # Convert model instance back to dict and verify no loss of data
        cart_order_data_model_json2 = cart_order_data_model.to_dict()
        assert cart_order_data_model_json2 == cart_order_data_model_json


class TestModel_CatalogRef:
    """
    Test Class for CatalogRef
    """

    def test_catalog_ref_serialization(self):
        """
        Test serialization/deserialization for CatalogRef
        """

        # Construct dict forms of any model objects needed in order to build this model.

        service_extensions_model = {}  # ServiceExtensions
        service_extensions_model['name'] = 'flavor'
        service_extensions_model['value'] = 'testString'
        service_extensions_model['type'] = 'string'

        # Construct a json representation of a CatalogRef model
        catalog_ref_model_json = {}
        catalog_ref_model_json['dry_run'] = True
        catalog_ref_model_json['owning_account'] = 'testString'
        catalog_ref_model_json['item_icon_url'] = 'testString'
        catalog_ref_model_json['item_id'] = 'testString'
        catalog_ref_model_json['item_name'] = 'testString'
        catalog_ref_model_json['item_readme_url'] = 'testString'
        catalog_ref_model_json['item_url'] = 'testString'
        catalog_ref_model_json['launch_url'] = 'testString'
        catalog_ref_model_json['offering_version'] = 'testString'
        catalog_ref_model_json['service_extensions'] = [service_extensions_model]

        # Construct a model instance of CatalogRef by calling from_dict on the json representation
        catalog_ref_model = CatalogRef.from_dict(catalog_ref_model_json)
        assert catalog_ref_model != False

        # Construct a model instance of CatalogRef by calling from_dict on the json representation
        catalog_ref_model_dict = CatalogRef.from_dict(catalog_ref_model_json).__dict__
        catalog_ref_model2 = CatalogRef(**catalog_ref_model_dict)

        # Verify the model instances are equivalent
        assert catalog_ref_model == catalog_ref_model2

        # Convert model instance back to dict and verify no loss of data
        catalog_ref_model_json2 = catalog_ref_model.to_dict()
        assert catalog_ref_model_json2 == catalog_ref_model_json


class TestModel_CatalogSource:
    """
    Test Class for CatalogSource
    """

    def test_catalog_source_serialization(self):
        """
        Test serialization/deserialization for CatalogSource
        """

        # Construct a json representation of a CatalogSource model
        catalog_source_model_json = {}
        catalog_source_model_json['catalog_name'] = 'testString'
        catalog_source_model_json['catalog_id'] = 'testString'
        catalog_source_model_json['offering_name'] = 'testString'
        catalog_source_model_json['offering_version'] = 'testString'
        catalog_source_model_json['offering_kind'] = 'testString'
        catalog_source_model_json['offering_target_kind'] = 'testString'
        catalog_source_model_json['offering_id'] = 'testString'
        catalog_source_model_json['offering_version_id'] = 'testString'
        catalog_source_model_json['offering_version_flavour_name'] = 'testString'
        catalog_source_model_json['offering_repo_url'] = 'testString'
        catalog_source_model_json['offering_provisioner_working_directory'] = 'testString'
        catalog_source_model_json['dry_run'] = True
        catalog_source_model_json['owning_account'] = 'testString'
        catalog_source_model_json['item_icon_url'] = 'testString'
        catalog_source_model_json['item_id'] = 'testString'
        catalog_source_model_json['item_name'] = 'testString'
        catalog_source_model_json['item_readme_url'] = 'testString'
        catalog_source_model_json['item_url'] = 'testString'
        catalog_source_model_json['launch_url'] = 'testString'

        # Construct a model instance of CatalogSource by calling from_dict on the json representation
        catalog_source_model = CatalogSource.from_dict(catalog_source_model_json)
        assert catalog_source_model != False

        # Construct a model instance of CatalogSource by calling from_dict on the json representation
        catalog_source_model_dict = CatalogSource.from_dict(catalog_source_model_json).__dict__
        catalog_source_model2 = CatalogSource(**catalog_source_model_dict)

        # Verify the model instances are equivalent
        assert catalog_source_model == catalog_source_model2

        # Convert model instance back to dict and verify no loss of data
        catalog_source_model_json2 = catalog_source_model.to_dict()
        assert catalog_source_model_json2 == catalog_source_model_json


class TestModel_CommandsInfo:
    """
    Test Class for CommandsInfo
    """

    def test_commands_info_serialization(self):
        """
        Test serialization/deserialization for CommandsInfo
        """

        # Construct a json representation of a CommandsInfo model
        commands_info_model_json = {}
        commands_info_model_json['name'] = 'testString'
        commands_info_model_json['outcome'] = 'testString'

        # Construct a model instance of CommandsInfo by calling from_dict on the json representation
        commands_info_model = CommandsInfo.from_dict(commands_info_model_json)
        assert commands_info_model != False

        # Construct a model instance of CommandsInfo by calling from_dict on the json representation
        commands_info_model_dict = CommandsInfo.from_dict(commands_info_model_json).__dict__
        commands_info_model2 = CommandsInfo(**commands_info_model_dict)

        # Verify the model instances are equivalent
        assert commands_info_model == commands_info_model2

        # Convert model instance back to dict and verify no loss of data
        commands_info_model_json2 = commands_info_model.to_dict()
        assert commands_info_model_json2 == commands_info_model_json


class TestModel_ConnectionState:
    """
    Test Class for ConnectionState
    """

    def test_connection_state_serialization(self):
        """
        Test serialization/deserialization for ConnectionState
        """

        # Construct a json representation of a ConnectionState model
        connection_state_model_json = {}
        connection_state_model_json['state'] = 'Connected'
        connection_state_model_json['checked_at'] = '2019-01-01T12:00:00Z'

        # Construct a model instance of ConnectionState by calling from_dict on the json representation
        connection_state_model = ConnectionState.from_dict(connection_state_model_json)
        assert connection_state_model != False

        # Construct a model instance of ConnectionState by calling from_dict on the json representation
        connection_state_model_dict = ConnectionState.from_dict(connection_state_model_json).__dict__
        connection_state_model2 = ConnectionState(**connection_state_model_dict)

        # Verify the model instances are equivalent
        assert connection_state_model == connection_state_model2

        # Convert model instance back to dict and verify no loss of data
        connection_state_model_json2 = connection_state_model.to_dict()
        assert connection_state_model_json2 == connection_state_model_json


class TestModel_CredentialVariableData:
    """
    Test Class for CredentialVariableData
    """

    def test_credential_variable_data_serialization(self):
        """
        Test serialization/deserialization for CredentialVariableData
        """

        # Construct dict forms of any model objects needed in order to build this model.

        credential_variable_metadata_model = {}  # CredentialVariableMetadata
        credential_variable_metadata_model['type'] = 'string'
        credential_variable_metadata_model['aliases'] = ['testString']
        credential_variable_metadata_model['description'] = 'testString'
        credential_variable_metadata_model['cloud_data_type'] = 'testString'
        credential_variable_metadata_model['default_value'] = 'testString'
        credential_variable_metadata_model['link_status'] = 'normal'
        credential_variable_metadata_model['immutable'] = True
        credential_variable_metadata_model['hidden'] = True
        credential_variable_metadata_model['required'] = True
        credential_variable_metadata_model['position'] = 38
        credential_variable_metadata_model['group_by'] = 'testString'
        credential_variable_metadata_model['source'] = 'testString'

        # Construct a json representation of a CredentialVariableData model
        credential_variable_data_model_json = {}
        credential_variable_data_model_json['name'] = 'testString'
        credential_variable_data_model_json['value'] = (
            '-----BEGIN OPENSSH PRIVATE KEY-----\\nXXXXXXXXXXXXX\\n-----END OPENSSH PRIVATE KEY-----\\n'
        )
        credential_variable_data_model_json['use_default'] = True
        credential_variable_data_model_json['metadata'] = credential_variable_metadata_model

        # Construct a model instance of CredentialVariableData by calling from_dict on the json representation
        credential_variable_data_model = CredentialVariableData.from_dict(credential_variable_data_model_json)
        assert credential_variable_data_model != False

        # Construct a model instance of CredentialVariableData by calling from_dict on the json representation
        credential_variable_data_model_dict = CredentialVariableData.from_dict(
            credential_variable_data_model_json
        ).__dict__
        credential_variable_data_model2 = CredentialVariableData(**credential_variable_data_model_dict)

        # Verify the model instances are equivalent
        assert credential_variable_data_model == credential_variable_data_model2

        # Convert model instance back to dict and verify no loss of data
        credential_variable_data_model_json2 = credential_variable_data_model.to_dict()
        assert credential_variable_data_model_json2 == credential_variable_data_model_json


class TestModel_CredentialVariableMetadata:
    """
    Test Class for CredentialVariableMetadata
    """

    def test_credential_variable_metadata_serialization(self):
        """
        Test serialization/deserialization for CredentialVariableMetadata
        """

        # Construct a json representation of a CredentialVariableMetadata model
        credential_variable_metadata_model_json = {}
        credential_variable_metadata_model_json['type'] = 'string'
        credential_variable_metadata_model_json['aliases'] = ['testString']
        credential_variable_metadata_model_json['description'] = 'testString'
        credential_variable_metadata_model_json['cloud_data_type'] = 'testString'
        credential_variable_metadata_model_json['default_value'] = 'testString'
        credential_variable_metadata_model_json['link_status'] = 'normal'
        credential_variable_metadata_model_json['immutable'] = True
        credential_variable_metadata_model_json['hidden'] = True
        credential_variable_metadata_model_json['required'] = True
        credential_variable_metadata_model_json['position'] = 38
        credential_variable_metadata_model_json['group_by'] = 'testString'
        credential_variable_metadata_model_json['source'] = 'testString'

        # Construct a model instance of CredentialVariableMetadata by calling from_dict on the json representation
        credential_variable_metadata_model = CredentialVariableMetadata.from_dict(
            credential_variable_metadata_model_json
        )
        assert credential_variable_metadata_model != False

        # Construct a model instance of CredentialVariableMetadata by calling from_dict on the json representation
        credential_variable_metadata_model_dict = CredentialVariableMetadata.from_dict(
            credential_variable_metadata_model_json
        ).__dict__
        credential_variable_metadata_model2 = CredentialVariableMetadata(**credential_variable_metadata_model_dict)

        # Verify the model instances are equivalent
        assert credential_variable_metadata_model == credential_variable_metadata_model2

        # Convert model instance back to dict and verify no loss of data
        credential_variable_metadata_model_json2 = credential_variable_metadata_model.to_dict()
        assert credential_variable_metadata_model_json2 == credential_variable_metadata_model_json


class TestModel_Dependencies:
    """
    Test Class for Dependencies
    """

    def test_dependencies_serialization(self):
        """
        Test serialization/deserialization for Dependencies
        """

        # Construct a json representation of a Dependencies model
        dependencies_model_json = {}
        dependencies_model_json['parents'] = ['testString']
        dependencies_model_json['children'] = ['testString']

        # Construct a model instance of Dependencies by calling from_dict on the json representation
        dependencies_model = Dependencies.from_dict(dependencies_model_json)
        assert dependencies_model != False

        # Construct a model instance of Dependencies by calling from_dict on the json representation
        dependencies_model_dict = Dependencies.from_dict(dependencies_model_json).__dict__
        dependencies_model2 = Dependencies(**dependencies_model_dict)

        # Verify the model instances are equivalent
        assert dependencies_model == dependencies_model2

        # Convert model instance back to dict and verify no loss of data
        dependencies_model_json2 = dependencies_model.to_dict()
        assert dependencies_model_json2 == dependencies_model_json


class TestModel_EncryptionInfo:
    """
    Test Class for EncryptionInfo
    """

    def test_encryption_info_serialization(self):
        """
        Test serialization/deserialization for EncryptionInfo
        """

        # Construct a json representation of a EncryptionInfo model
        encryption_info_model_json = {}
        encryption_info_model_json['crn'] = 'testString'
        encryption_info_model_json['scheme'] = 'testString'

        # Construct a model instance of EncryptionInfo by calling from_dict on the json representation
        encryption_info_model = EncryptionInfo.from_dict(encryption_info_model_json)
        assert encryption_info_model != False

        # Construct a model instance of EncryptionInfo by calling from_dict on the json representation
        encryption_info_model_dict = EncryptionInfo.from_dict(encryption_info_model_json).__dict__
        encryption_info_model2 = EncryptionInfo(**encryption_info_model_dict)

        # Verify the model instances are equivalent
        assert encryption_info_model == encryption_info_model2

        # Convert model instance back to dict and verify no loss of data
        encryption_info_model_json2 = encryption_info_model.to_dict()
        assert encryption_info_model_json2 == encryption_info_model_json


class TestModel_EnvVariableRequestMap:
    """
    Test Class for EnvVariableRequestMap
    """

    def test_env_variable_request_map_serialization(self):
        """
        Test serialization/deserialization for EnvVariableRequestMap
        """

        # Construct a json representation of a EnvVariableRequestMap model
        env_variable_request_map_model_json = {}
        env_variable_request_map_model_json['hidden'] = True
        env_variable_request_map_model_json['name'] = 'testString'
        env_variable_request_map_model_json['secure'] = True
        env_variable_request_map_model_json['value'] = 'testString'

        # Construct a model instance of EnvVariableRequestMap by calling from_dict on the json representation
        env_variable_request_map_model = EnvVariableRequestMap.from_dict(env_variable_request_map_model_json)
        assert env_variable_request_map_model != False

        # Construct a model instance of EnvVariableRequestMap by calling from_dict on the json representation
        env_variable_request_map_model_dict = EnvVariableRequestMap.from_dict(
            env_variable_request_map_model_json
        ).__dict__
        env_variable_request_map_model2 = EnvVariableRequestMap(**env_variable_request_map_model_dict)

        # Verify the model instances are equivalent
        assert env_variable_request_map_model == env_variable_request_map_model2

        # Convert model instance back to dict and verify no loss of data
        env_variable_request_map_model_json2 = env_variable_request_map_model.to_dict()
        assert env_variable_request_map_model_json2 == env_variable_request_map_model_json


class TestModel_EnvVariableResponse:
    """
    Test Class for EnvVariableResponse
    """

    def test_env_variable_response_serialization(self):
        """
        Test serialization/deserialization for EnvVariableResponse
        """

        # Construct a json representation of a EnvVariableResponse model
        env_variable_response_model_json = {}
        env_variable_response_model_json['hidden'] = True
        env_variable_response_model_json['name'] = 'testString'
        env_variable_response_model_json['secure'] = True
        env_variable_response_model_json['value'] = 'testString'

        # Construct a model instance of EnvVariableResponse by calling from_dict on the json representation
        env_variable_response_model = EnvVariableResponse.from_dict(env_variable_response_model_json)
        assert env_variable_response_model != False

        # Construct a model instance of EnvVariableResponse by calling from_dict on the json representation
        env_variable_response_model_dict = EnvVariableResponse.from_dict(env_variable_response_model_json).__dict__
        env_variable_response_model2 = EnvVariableResponse(**env_variable_response_model_dict)

        # Verify the model instances are equivalent
        assert env_variable_response_model == env_variable_response_model2

        # Convert model instance back to dict and verify no loss of data
        env_variable_response_model_json2 = env_variable_response_model.to_dict()
        assert env_variable_response_model_json2 == env_variable_response_model_json


class TestModel_EnvironmentValuesMetadata:
    """
    Test Class for EnvironmentValuesMetadata
    """

    def test_environment_values_metadata_serialization(self):
        """
        Test serialization/deserialization for EnvironmentValuesMetadata
        """

        # Construct a json representation of a EnvironmentValuesMetadata model
        environment_values_metadata_model_json = {}
        environment_values_metadata_model_json['hidden'] = True
        environment_values_metadata_model_json['name'] = 'testString'
        environment_values_metadata_model_json['secure'] = True

        # Construct a model instance of EnvironmentValuesMetadata by calling from_dict on the json representation
        environment_values_metadata_model = EnvironmentValuesMetadata.from_dict(environment_values_metadata_model_json)
        assert environment_values_metadata_model != False

        # Construct a model instance of EnvironmentValuesMetadata by calling from_dict on the json representation
        environment_values_metadata_model_dict = EnvironmentValuesMetadata.from_dict(
            environment_values_metadata_model_json
        ).__dict__
        environment_values_metadata_model2 = EnvironmentValuesMetadata(**environment_values_metadata_model_dict)

        # Verify the model instances are equivalent
        assert environment_values_metadata_model == environment_values_metadata_model2

        # Convert model instance back to dict and verify no loss of data
        environment_values_metadata_model_json2 = environment_values_metadata_model.to_dict()
        assert environment_values_metadata_model_json2 == environment_values_metadata_model_json


class TestModel_ExternalSource:
    """
    Test Class for ExternalSource
    """

    def test_external_source_serialization(self):
        """
        Test serialization/deserialization for ExternalSource
        """

        # Construct dict forms of any model objects needed in order to build this model.

        git_source_model = {}  # GitSource
        git_source_model['computed_git_repo_url'] = 'testString'
        git_source_model['git_repo_url'] = 'testString'
        git_source_model['git_token'] = 'testString'
        git_source_model['git_repo_folder'] = 'testString'
        git_source_model['git_release'] = 'testString'
        git_source_model['git_branch'] = 'testString'

        catalog_source_model = {}  # CatalogSource
        catalog_source_model['catalog_name'] = 'testString'
        catalog_source_model['catalog_id'] = 'testString'
        catalog_source_model['offering_name'] = 'testString'
        catalog_source_model['offering_version'] = 'testString'
        catalog_source_model['offering_kind'] = 'testString'
        catalog_source_model['offering_target_kind'] = 'testString'
        catalog_source_model['offering_id'] = 'testString'
        catalog_source_model['offering_version_id'] = 'testString'
        catalog_source_model['offering_version_flavour_name'] = 'testString'
        catalog_source_model['offering_repo_url'] = 'testString'
        catalog_source_model['offering_provisioner_working_directory'] = 'testString'
        catalog_source_model['dry_run'] = True
        catalog_source_model['owning_account'] = 'testString'
        catalog_source_model['item_icon_url'] = 'testString'
        catalog_source_model['item_id'] = 'testString'
        catalog_source_model['item_name'] = 'testString'
        catalog_source_model['item_readme_url'] = 'testString'
        catalog_source_model['item_url'] = 'testString'
        catalog_source_model['launch_url'] = 'testString'

        # Construct a json representation of a ExternalSource model
        external_source_model_json = {}
        external_source_model_json['source_type'] = 'local'
        external_source_model_json['git'] = git_source_model
        external_source_model_json['catalog'] = catalog_source_model

        # Construct a model instance of ExternalSource by calling from_dict on the json representation
        external_source_model = ExternalSource.from_dict(external_source_model_json)
        assert external_source_model != False

        # Construct a model instance of ExternalSource by calling from_dict on the json representation
        external_source_model_dict = ExternalSource.from_dict(external_source_model_json).__dict__
        external_source_model2 = ExternalSource(**external_source_model_dict)

        # Verify the model instances are equivalent
        assert external_source_model == external_source_model2

        # Convert model instance back to dict and verify no loss of data
        external_source_model_json2 = external_source_model.to_dict()
        assert external_source_model_json2 == external_source_model_json


class TestModel_GitSource:
    """
    Test Class for GitSource
    """

    def test_git_source_serialization(self):
        """
        Test serialization/deserialization for GitSource
        """

        # Construct a json representation of a GitSource model
        git_source_model_json = {}
        git_source_model_json['computed_git_repo_url'] = 'testString'
        git_source_model_json['git_repo_url'] = 'testString'
        git_source_model_json['git_token'] = 'testString'
        git_source_model_json['git_repo_folder'] = 'testString'
        git_source_model_json['git_release'] = 'testString'
        git_source_model_json['git_branch'] = 'testString'

        # Construct a model instance of GitSource by calling from_dict on the json representation
        git_source_model = GitSource.from_dict(git_source_model_json)
        assert git_source_model != False

        # Construct a model instance of GitSource by calling from_dict on the json representation
        git_source_model_dict = GitSource.from_dict(git_source_model_json).__dict__
        git_source_model2 = GitSource(**git_source_model_dict)

        # Verify the model instances are equivalent
        assert git_source_model == git_source_model2

        # Convert model instance back to dict and verify no loss of data
        git_source_model_json2 = git_source_model.to_dict()
        assert git_source_model_json2 == git_source_model_json


class TestModel_InjectTerraformTemplateInnerTftParametersItem:
    """
    Test Class for InjectTerraformTemplateInnerTftParametersItem
    """

    def test_inject_terraform_template_inner_tft_parameters_item_serialization(self):
        """
        Test serialization/deserialization for InjectTerraformTemplateInnerTftParametersItem
        """

        # Construct a json representation of a InjectTerraformTemplateInnerTftParametersItem model
        inject_terraform_template_inner_tft_parameters_item_model_json = {}
        inject_terraform_template_inner_tft_parameters_item_model_json['name'] = 'testString'
        inject_terraform_template_inner_tft_parameters_item_model_json['value'] = 'testString'

        # Construct a model instance of InjectTerraformTemplateInnerTftParametersItem by calling from_dict on the json representation
        inject_terraform_template_inner_tft_parameters_item_model = (
            InjectTerraformTemplateInnerTftParametersItem.from_dict(
                inject_terraform_template_inner_tft_parameters_item_model_json
            )
        )
        assert inject_terraform_template_inner_tft_parameters_item_model != False

        # Construct a model instance of InjectTerraformTemplateInnerTftParametersItem by calling from_dict on the json representation
        inject_terraform_template_inner_tft_parameters_item_model_dict = (
            InjectTerraformTemplateInnerTftParametersItem.from_dict(
                inject_terraform_template_inner_tft_parameters_item_model_json
            ).__dict__
        )
        inject_terraform_template_inner_tft_parameters_item_model2 = InjectTerraformTemplateInnerTftParametersItem(
            **inject_terraform_template_inner_tft_parameters_item_model_dict
        )

        # Verify the model instances are equivalent
        assert (
            inject_terraform_template_inner_tft_parameters_item_model
            == inject_terraform_template_inner_tft_parameters_item_model2
        )

        # Convert model instance back to dict and verify no loss of data
        inject_terraform_template_inner_tft_parameters_item_model_json2 = (
            inject_terraform_template_inner_tft_parameters_item_model.to_dict()
        )
        assert (
            inject_terraform_template_inner_tft_parameters_item_model_json2
            == inject_terraform_template_inner_tft_parameters_item_model_json
        )


class TestModel_InjectTerraformTemplateInner:
    """
    Test Class for InjectTerraformTemplateInner
    """

    def test_inject_terraform_template_inner_serialization(self):
        """
        Test serialization/deserialization for InjectTerraformTemplateInner
        """

        # Construct dict forms of any model objects needed in order to build this model.

        inject_terraform_template_inner_tft_parameters_item_model = {}  # InjectTerraformTemplateInnerTftParametersItem
        inject_terraform_template_inner_tft_parameters_item_model['name'] = 'testString'
        inject_terraform_template_inner_tft_parameters_item_model['value'] = 'testString'

        # Construct a json representation of a InjectTerraformTemplateInner model
        inject_terraform_template_inner_model_json = {}
        inject_terraform_template_inner_model_json['tft_git_url'] = 'testString'
        inject_terraform_template_inner_model_json['tft_git_token'] = 'testString'
        inject_terraform_template_inner_model_json['tft_prefix'] = 'testString'
        inject_terraform_template_inner_model_json['injection_type'] = 'testString'
        inject_terraform_template_inner_model_json['tft_name'] = 'testString'
        inject_terraform_template_inner_model_json['tft_parameters'] = [
            inject_terraform_template_inner_tft_parameters_item_model
        ]

        # Construct a model instance of InjectTerraformTemplateInner by calling from_dict on the json representation
        inject_terraform_template_inner_model = InjectTerraformTemplateInner.from_dict(
            inject_terraform_template_inner_model_json
        )
        assert inject_terraform_template_inner_model != False

        # Construct a model instance of InjectTerraformTemplateInner by calling from_dict on the json representation
        inject_terraform_template_inner_model_dict = InjectTerraformTemplateInner.from_dict(
            inject_terraform_template_inner_model_json
        ).__dict__
        inject_terraform_template_inner_model2 = InjectTerraformTemplateInner(
            **inject_terraform_template_inner_model_dict
        )

        # Verify the model instances are equivalent
        assert inject_terraform_template_inner_model == inject_terraform_template_inner_model2

        # Convert model instance back to dict and verify no loss of data
        inject_terraform_template_inner_model_json2 = inject_terraform_template_inner_model.to_dict()
        assert inject_terraform_template_inner_model_json2 == inject_terraform_template_inner_model_json


class TestModel_InventoryResourceRecord:
    """
    Test Class for InventoryResourceRecord
    """

    def test_inventory_resource_record_serialization(self):
        """
        Test serialization/deserialization for InventoryResourceRecord
        """

        # Construct a json representation of a InventoryResourceRecord model
        inventory_resource_record_model_json = {}
        inventory_resource_record_model_json['name'] = 'testString'
        inventory_resource_record_model_json['description'] = 'testString'
        inventory_resource_record_model_json['location'] = 'us-south'
        inventory_resource_record_model_json['resource_group'] = 'testString'
        inventory_resource_record_model_json['inventories_ini'] = 'testString'
        inventory_resource_record_model_json['resource_queries'] = ['testString']

        # Construct a model instance of InventoryResourceRecord by calling from_dict on the json representation
        inventory_resource_record_model = InventoryResourceRecord.from_dict(inventory_resource_record_model_json)
        assert inventory_resource_record_model != False

        # Construct a model instance of InventoryResourceRecord by calling from_dict on the json representation
        inventory_resource_record_model_dict = InventoryResourceRecord.from_dict(
            inventory_resource_record_model_json
        ).__dict__
        inventory_resource_record_model2 = InventoryResourceRecord(**inventory_resource_record_model_dict)

        # Verify the model instances are equivalent
        assert inventory_resource_record_model == inventory_resource_record_model2

        # Convert model instance back to dict and verify no loss of data
        inventory_resource_record_model_json2 = inventory_resource_record_model.to_dict()
        assert inventory_resource_record_model_json2 == inventory_resource_record_model_json


class TestModel_InventoryResourceRecordList:
    """
    Test Class for InventoryResourceRecordList
    """

    def test_inventory_resource_record_list_serialization(self):
        """
        Test serialization/deserialization for InventoryResourceRecordList
        """

        # Construct dict forms of any model objects needed in order to build this model.

        inventory_resource_record_model = {}  # InventoryResourceRecord
        inventory_resource_record_model['name'] = 'testString'
        inventory_resource_record_model['description'] = 'testString'
        inventory_resource_record_model['location'] = 'us-south'
        inventory_resource_record_model['resource_group'] = 'testString'
        inventory_resource_record_model['inventories_ini'] = 'testString'
        inventory_resource_record_model['resource_queries'] = ['testString']

        # Construct a json representation of a InventoryResourceRecordList model
        inventory_resource_record_list_model_json = {}
        inventory_resource_record_list_model_json['total_count'] = 26
        inventory_resource_record_list_model_json['limit'] = 26
        inventory_resource_record_list_model_json['offset'] = 26
        inventory_resource_record_list_model_json['inventories'] = [inventory_resource_record_model]

        # Construct a model instance of InventoryResourceRecordList by calling from_dict on the json representation
        inventory_resource_record_list_model = InventoryResourceRecordList.from_dict(
            inventory_resource_record_list_model_json
        )
        assert inventory_resource_record_list_model != False

        # Construct a model instance of InventoryResourceRecordList by calling from_dict on the json representation
        inventory_resource_record_list_model_dict = InventoryResourceRecordList.from_dict(
            inventory_resource_record_list_model_json
        ).__dict__
        inventory_resource_record_list_model2 = InventoryResourceRecordList(**inventory_resource_record_list_model_dict)

        # Verify the model instances are equivalent
        assert inventory_resource_record_list_model == inventory_resource_record_list_model2

        # Convert model instance back to dict and verify no loss of data
        inventory_resource_record_list_model_json2 = inventory_resource_record_list_model.to_dict()
        assert inventory_resource_record_list_model_json2 == inventory_resource_record_list_model_json


class TestModel_Job:
    """
    Test Class for Job
    """

    def test_job_serialization(self):
        """
        Test serialization/deserialization for Job
        """

        # Construct dict forms of any model objects needed in order to build this model.

        variable_metadata_model = {}  # VariableMetadata
        variable_metadata_model['type'] = 'boolean'
        variable_metadata_model['aliases'] = ['testString']
        variable_metadata_model['description'] = 'testString'
        variable_metadata_model['cloud_data_type'] = 'testString'
        variable_metadata_model['default_value'] = 'testString'
        variable_metadata_model['link_status'] = 'normal'
        variable_metadata_model['secure'] = True
        variable_metadata_model['immutable'] = True
        variable_metadata_model['hidden'] = True
        variable_metadata_model['required'] = True
        variable_metadata_model['options'] = ['testString']
        variable_metadata_model['min_value'] = 38
        variable_metadata_model['max_value'] = 38
        variable_metadata_model['min_length'] = 38
        variable_metadata_model['max_length'] = 38
        variable_metadata_model['matches'] = 'testString'
        variable_metadata_model['position'] = 38
        variable_metadata_model['group_by'] = 'testString'
        variable_metadata_model['source'] = 'testString'

        variable_data_model = {}  # VariableData
        variable_data_model['name'] = 'testString'
        variable_data_model['value'] = 'testString'
        variable_data_model['use_default'] = True
        variable_data_model['metadata'] = variable_metadata_model

        job_status_workitem_model = {}  # JobStatusWorkitem
        job_status_workitem_model['workspace_id'] = 'testString'
        job_status_workitem_model['workspace_name'] = 'testString'
        job_status_workitem_model['job_id'] = 'testString'
        job_status_workitem_model['status_code'] = 'job_pending'
        job_status_workitem_model['status_message'] = 'testString'
        job_status_workitem_model['updated_at'] = '2019-01-01T12:00:00Z'

        job_status_flow_model = {}  # JobStatusFlow
        job_status_flow_model['flow_id'] = 'testString'
        job_status_flow_model['flow_name'] = 'testString'
        job_status_flow_model['status_code'] = 'job_pending'
        job_status_flow_model['status_message'] = 'testString'
        job_status_flow_model['workitems'] = [job_status_workitem_model]
        job_status_flow_model['updated_at'] = '2019-01-01T12:00:00Z'

        job_status_template_model = {}  # JobStatusTemplate
        job_status_template_model['template_id'] = 'testString'
        job_status_template_model['template_name'] = 'testString'
        job_status_template_model['flow_index'] = 38
        job_status_template_model['status_code'] = 'job_pending'
        job_status_template_model['status_message'] = 'testString'
        job_status_template_model['updated_at'] = '2019-01-01T12:00:00Z'

        job_status_workspace_model = {}  # JobStatusWorkspace
        job_status_workspace_model['workspace_name'] = 'testString'
        job_status_workspace_model['status_code'] = 'job_pending'
        job_status_workspace_model['status_message'] = 'testString'
        job_status_workspace_model['flow_status'] = job_status_flow_model
        job_status_workspace_model['template_status'] = [job_status_template_model]
        job_status_workspace_model['updated_at'] = '2019-01-01T12:00:00Z'

        job_status_action_model = {}  # JobStatusAction
        job_status_action_model['action_name'] = 'testString'
        job_status_action_model['status_code'] = 'job_pending'
        job_status_action_model['status_message'] = 'testString'
        job_status_action_model['bastion_status_code'] = 'none'
        job_status_action_model['bastion_status_message'] = 'testString'
        job_status_action_model['targets_status_code'] = 'none'
        job_status_action_model['targets_status_message'] = 'testString'
        job_status_action_model['updated_at'] = '2019-01-01T12:00:00Z'

        job_status_schematics_resources_model = {}  # JobStatusSchematicsResources
        job_status_schematics_resources_model['status_code'] = 'job_pending'
        job_status_schematics_resources_model['status_message'] = 'testString'
        job_status_schematics_resources_model['schematics_resource_id'] = 'testString'
        job_status_schematics_resources_model['updated_at'] = '2019-01-01T12:00:00Z'

        job_status_system_model = {}  # JobStatusSystem
        job_status_system_model['system_status_message'] = 'testString'
        job_status_system_model['system_status_code'] = 'job_pending'
        job_status_system_model['schematics_resource_status'] = [job_status_schematics_resources_model]
        job_status_system_model['updated_at'] = '2019-01-01T12:00:00Z'

        job_status_model = {}  # JobStatus
        job_status_model['position_in_queue'] = 72.5
        job_status_model['total_in_queue'] = 72.5
        job_status_model['workspace_job_status'] = job_status_workspace_model
        job_status_model['action_job_status'] = job_status_action_model
        job_status_model['system_job_status'] = job_status_system_model
        job_status_model['flow_job_status'] = job_status_flow_model

        cart_order_data_model = {}  # CartOrderData
        cart_order_data_model['name'] = 'testString'
        cart_order_data_model['value'] = 'testString'
        cart_order_data_model['type'] = 'testString'
        cart_order_data_model['usage_kind'] = ['servicetags']

        job_data_template_model = {}  # JobDataTemplate
        job_data_template_model['template_id'] = 'testString'
        job_data_template_model['template_name'] = 'testString'
        job_data_template_model['flow_index'] = 38
        job_data_template_model['inputs'] = [variable_data_model]
        job_data_template_model['outputs'] = [variable_data_model]
        job_data_template_model['settings'] = [variable_data_model]
        job_data_template_model['updated_at'] = '2019-01-01T12:00:00Z'

        job_data_workspace_model = {}  # JobDataWorkspace
        job_data_workspace_model['workspace_name'] = 'testString'
        job_data_workspace_model['flow_id'] = 'testString'
        job_data_workspace_model['flow_name'] = 'testString'
        job_data_workspace_model['inputs'] = [variable_data_model]
        job_data_workspace_model['outputs'] = [variable_data_model]
        job_data_workspace_model['settings'] = [variable_data_model]
        job_data_workspace_model['template_data'] = [job_data_template_model]
        job_data_workspace_model['updated_at'] = '2019-01-01T12:00:00Z'

        inventory_resource_record_model = {}  # InventoryResourceRecord
        inventory_resource_record_model['name'] = 'testString'
        inventory_resource_record_model['description'] = 'testString'
        inventory_resource_record_model['location'] = 'us-south'
        inventory_resource_record_model['resource_group'] = 'testString'
        inventory_resource_record_model['inventories_ini'] = 'testString'
        inventory_resource_record_model['resource_queries'] = ['testString']

        job_data_action_model = {}  # JobDataAction
        job_data_action_model['action_name'] = 'testString'
        job_data_action_model['inputs'] = [variable_data_model]
        job_data_action_model['outputs'] = [variable_data_model]
        job_data_action_model['settings'] = [variable_data_model]
        job_data_action_model['updated_at'] = '2019-01-01T12:00:00Z'
        job_data_action_model['inventory_record'] = inventory_resource_record_model
        job_data_action_model['materialized_inventory'] = 'testString'

        job_data_system_model = {}  # JobDataSystem
        job_data_system_model['key_id'] = 'testString'
        job_data_system_model['schematics_resource_id'] = ['testString']
        job_data_system_model['updated_at'] = '2019-01-01T12:00:00Z'

        git_source_model = {}  # GitSource
        git_source_model['computed_git_repo_url'] = 'testString'
        git_source_model['git_repo_url'] = 'testString'
        git_source_model['git_token'] = 'testString'
        git_source_model['git_repo_folder'] = 'testString'
        git_source_model['git_release'] = 'testString'
        git_source_model['git_branch'] = 'testString'

        catalog_source_model = {}  # CatalogSource
        catalog_source_model['catalog_name'] = 'testString'
        catalog_source_model['catalog_id'] = 'testString'
        catalog_source_model['offering_name'] = 'testString'
        catalog_source_model['offering_version'] = 'testString'
        catalog_source_model['offering_kind'] = 'testString'
        catalog_source_model['offering_target_kind'] = 'testString'
        catalog_source_model['offering_id'] = 'testString'
        catalog_source_model['offering_version_id'] = 'testString'
        catalog_source_model['offering_version_flavour_name'] = 'testString'
        catalog_source_model['offering_repo_url'] = 'testString'
        catalog_source_model['offering_provisioner_working_directory'] = 'testString'
        catalog_source_model['dry_run'] = True
        catalog_source_model['owning_account'] = 'testString'
        catalog_source_model['item_icon_url'] = 'testString'
        catalog_source_model['item_id'] = 'testString'
        catalog_source_model['item_name'] = 'testString'
        catalog_source_model['item_readme_url'] = 'testString'
        catalog_source_model['item_url'] = 'testString'
        catalog_source_model['launch_url'] = 'testString'

        external_source_model = {}  # ExternalSource
        external_source_model['source_type'] = 'local'
        external_source_model['git'] = git_source_model
        external_source_model['catalog'] = catalog_source_model

        job_data_work_item_last_job_model = {}  # JobDataWorkItemLastJob
        job_data_work_item_last_job_model['command_object'] = 'workspace'
        job_data_work_item_last_job_model['command_object_name'] = 'testString'
        job_data_work_item_last_job_model['command_object_id'] = 'testString'
        job_data_work_item_last_job_model['command_name'] = 'workspace_plan'
        job_data_work_item_last_job_model['job_id'] = 'testString'
        job_data_work_item_last_job_model['job_status'] = 'job_pending'

        job_data_work_item_model = {}  # JobDataWorkItem
        job_data_work_item_model['command_object_id'] = 'testString'
        job_data_work_item_model['command_object_name'] = 'testString'
        job_data_work_item_model['layers'] = 'testString'
        job_data_work_item_model['source_type'] = 'local'
        job_data_work_item_model['source'] = external_source_model
        job_data_work_item_model['inputs'] = [variable_data_model]
        job_data_work_item_model['outputs'] = [variable_data_model]
        job_data_work_item_model['settings'] = [variable_data_model]
        job_data_work_item_model['last_job'] = job_data_work_item_last_job_model
        job_data_work_item_model['updated_at'] = '2019-01-01T12:00:00Z'

        job_data_flow_model = {}  # JobDataFlow
        job_data_flow_model['flow_id'] = 'testString'
        job_data_flow_model['flow_name'] = 'testString'
        job_data_flow_model['workitems'] = [job_data_work_item_model]
        job_data_flow_model['updated_at'] = '2019-01-01T12:00:00Z'

        job_data_model = {}  # JobData
        job_data_model['job_type'] = 'repo_download_job'
        job_data_model['workspace_job_data'] = job_data_workspace_model
        job_data_model['action_job_data'] = job_data_action_model
        job_data_model['system_job_data'] = job_data_system_model
        job_data_model['flow_job_data'] = job_data_flow_model

        bastion_resource_definition_model = {}  # BastionResourceDefinition
        bastion_resource_definition_model['name'] = 'testString'
        bastion_resource_definition_model['host'] = 'testString'

        job_log_summary_repo_download_job_model = {}  # JobLogSummaryRepoDownloadJob

        job_log_summary_workspace_job_model = {}  # JobLogSummaryWorkspaceJob

        job_log_summary_workitems_model = {}  # JobLogSummaryWorkitems
        job_log_summary_workitems_model['workspace_id'] = 'testString'
        job_log_summary_workitems_model['job_id'] = 'testString'
        job_log_summary_workitems_model['log_url'] = 'testString'

        job_log_summary_flow_job_model = {}  # JobLogSummaryFlowJob
        job_log_summary_flow_job_model['workitems'] = [job_log_summary_workitems_model]

        job_log_summary_action_job_recap_model = {}  # JobLogSummaryActionJobRecap
        job_log_summary_action_job_recap_model['target'] = ['testString']
        job_log_summary_action_job_recap_model['ok'] = 72.5
        job_log_summary_action_job_recap_model['changed'] = 72.5
        job_log_summary_action_job_recap_model['failed'] = 72.5
        job_log_summary_action_job_recap_model['skipped'] = 72.5
        job_log_summary_action_job_recap_model['unreachable'] = 72.5

        job_log_summary_action_job_model = {}  # JobLogSummaryActionJob
        job_log_summary_action_job_model['recap'] = job_log_summary_action_job_recap_model

        job_log_summary_system_job_model = {}  # JobLogSummarySystemJob
        job_log_summary_system_job_model['success'] = 72.5
        job_log_summary_system_job_model['failed'] = 72.5

        job_log_summary_model = {}  # JobLogSummary
        job_log_summary_model['job_type'] = 'repo_download_job'
        job_log_summary_model['repo_download_job'] = job_log_summary_repo_download_job_model
        job_log_summary_model['workspace_job'] = job_log_summary_workspace_job_model
        job_log_summary_model['flow_job'] = job_log_summary_flow_job_model
        job_log_summary_model['action_job'] = job_log_summary_action_job_model
        job_log_summary_model['system_job'] = job_log_summary_system_job_model

        agent_info_model = {}  # AgentInfo
        agent_info_model['id'] = 'testString'
        agent_info_model['name'] = 'testString'
        agent_info_model['assignment_policy_id'] = 'testString'

        # Construct a json representation of a Job model
        job_model_json = {}
        job_model_json['command_object'] = 'workspace'
        job_model_json['command_object_id'] = 'testString'
        job_model_json['command_name'] = 'workspace_plan'
        job_model_json['command_parameter'] = 'testString'
        job_model_json['command_options'] = ['testString']
        job_model_json['inputs'] = [variable_data_model]
        job_model_json['settings'] = [variable_data_model]
        job_model_json['tags'] = ['testString']
        job_model_json['location'] = 'us-south'
        job_model_json['status'] = job_status_model
        job_model_json['cart_order_data'] = [cart_order_data_model]
        job_model_json['data'] = job_data_model
        job_model_json['bastion'] = bastion_resource_definition_model
        job_model_json['log_summary'] = job_log_summary_model
        job_model_json['agent'] = agent_info_model

        # Construct a model instance of Job by calling from_dict on the json representation
        job_model = Job.from_dict(job_model_json)
        assert job_model != False

        # Construct a model instance of Job by calling from_dict on the json representation
        job_model_dict = Job.from_dict(job_model_json).__dict__
        job_model2 = Job(**job_model_dict)

        # Verify the model instances are equivalent
        assert job_model == job_model2

        # Convert model instance back to dict and verify no loss of data
        job_model_json2 = job_model.to_dict()
        assert job_model_json2 == job_model_json


class TestModel_JobData:
    """
    Test Class for JobData
    """

    def test_job_data_serialization(self):
        """
        Test serialization/deserialization for JobData
        """

        # Construct dict forms of any model objects needed in order to build this model.

        variable_metadata_model = {}  # VariableMetadata
        variable_metadata_model['type'] = 'boolean'
        variable_metadata_model['aliases'] = ['testString']
        variable_metadata_model['description'] = 'testString'
        variable_metadata_model['cloud_data_type'] = 'testString'
        variable_metadata_model['default_value'] = 'testString'
        variable_metadata_model['link_status'] = 'normal'
        variable_metadata_model['secure'] = True
        variable_metadata_model['immutable'] = True
        variable_metadata_model['hidden'] = True
        variable_metadata_model['required'] = True
        variable_metadata_model['options'] = ['testString']
        variable_metadata_model['min_value'] = 38
        variable_metadata_model['max_value'] = 38
        variable_metadata_model['min_length'] = 38
        variable_metadata_model['max_length'] = 38
        variable_metadata_model['matches'] = 'testString'
        variable_metadata_model['position'] = 38
        variable_metadata_model['group_by'] = 'testString'
        variable_metadata_model['source'] = 'testString'

        variable_data_model = {}  # VariableData
        variable_data_model['name'] = 'testString'
        variable_data_model['value'] = 'testString'
        variable_data_model['use_default'] = True
        variable_data_model['metadata'] = variable_metadata_model

        job_data_template_model = {}  # JobDataTemplate
        job_data_template_model['template_id'] = 'testString'
        job_data_template_model['template_name'] = 'testString'
        job_data_template_model['flow_index'] = 38
        job_data_template_model['inputs'] = [variable_data_model]
        job_data_template_model['outputs'] = [variable_data_model]
        job_data_template_model['settings'] = [variable_data_model]
        job_data_template_model['updated_at'] = '2019-01-01T12:00:00Z'

        job_data_workspace_model = {}  # JobDataWorkspace
        job_data_workspace_model['workspace_name'] = 'testString'
        job_data_workspace_model['flow_id'] = 'testString'
        job_data_workspace_model['flow_name'] = 'testString'
        job_data_workspace_model['inputs'] = [variable_data_model]
        job_data_workspace_model['outputs'] = [variable_data_model]
        job_data_workspace_model['settings'] = [variable_data_model]
        job_data_workspace_model['template_data'] = [job_data_template_model]
        job_data_workspace_model['updated_at'] = '2019-01-01T12:00:00Z'

        inventory_resource_record_model = {}  # InventoryResourceRecord
        inventory_resource_record_model['name'] = 'testString'
        inventory_resource_record_model['description'] = 'testString'
        inventory_resource_record_model['location'] = 'us-south'
        inventory_resource_record_model['resource_group'] = 'testString'
        inventory_resource_record_model['inventories_ini'] = 'testString'
        inventory_resource_record_model['resource_queries'] = ['testString']

        job_data_action_model = {}  # JobDataAction
        job_data_action_model['action_name'] = 'testString'
        job_data_action_model['inputs'] = [variable_data_model]
        job_data_action_model['outputs'] = [variable_data_model]
        job_data_action_model['settings'] = [variable_data_model]
        job_data_action_model['updated_at'] = '2019-01-01T12:00:00Z'
        job_data_action_model['inventory_record'] = inventory_resource_record_model
        job_data_action_model['materialized_inventory'] = 'testString'

        job_data_system_model = {}  # JobDataSystem
        job_data_system_model['key_id'] = 'testString'
        job_data_system_model['schematics_resource_id'] = ['testString']
        job_data_system_model['updated_at'] = '2019-01-01T12:00:00Z'

        git_source_model = {}  # GitSource
        git_source_model['computed_git_repo_url'] = 'testString'
        git_source_model['git_repo_url'] = 'testString'
        git_source_model['git_token'] = 'testString'
        git_source_model['git_repo_folder'] = 'testString'
        git_source_model['git_release'] = 'testString'
        git_source_model['git_branch'] = 'testString'

        catalog_source_model = {}  # CatalogSource
        catalog_source_model['catalog_name'] = 'testString'
        catalog_source_model['catalog_id'] = 'testString'
        catalog_source_model['offering_name'] = 'testString'
        catalog_source_model['offering_version'] = 'testString'
        catalog_source_model['offering_kind'] = 'testString'
        catalog_source_model['offering_target_kind'] = 'testString'
        catalog_source_model['offering_id'] = 'testString'
        catalog_source_model['offering_version_id'] = 'testString'
        catalog_source_model['offering_version_flavour_name'] = 'testString'
        catalog_source_model['offering_repo_url'] = 'testString'
        catalog_source_model['offering_provisioner_working_directory'] = 'testString'
        catalog_source_model['dry_run'] = True
        catalog_source_model['owning_account'] = 'testString'
        catalog_source_model['item_icon_url'] = 'testString'
        catalog_source_model['item_id'] = 'testString'
        catalog_source_model['item_name'] = 'testString'
        catalog_source_model['item_readme_url'] = 'testString'
        catalog_source_model['item_url'] = 'testString'
        catalog_source_model['launch_url'] = 'testString'

        external_source_model = {}  # ExternalSource
        external_source_model['source_type'] = 'local'
        external_source_model['git'] = git_source_model
        external_source_model['catalog'] = catalog_source_model

        job_data_work_item_last_job_model = {}  # JobDataWorkItemLastJob
        job_data_work_item_last_job_model['command_object'] = 'workspace'
        job_data_work_item_last_job_model['command_object_name'] = 'testString'
        job_data_work_item_last_job_model['command_object_id'] = 'testString'
        job_data_work_item_last_job_model['command_name'] = 'workspace_plan'
        job_data_work_item_last_job_model['job_id'] = 'testString'
        job_data_work_item_last_job_model['job_status'] = 'job_pending'

        job_data_work_item_model = {}  # JobDataWorkItem
        job_data_work_item_model['command_object_id'] = 'testString'
        job_data_work_item_model['command_object_name'] = 'testString'
        job_data_work_item_model['layers'] = 'testString'
        job_data_work_item_model['source_type'] = 'local'
        job_data_work_item_model['source'] = external_source_model
        job_data_work_item_model['inputs'] = [variable_data_model]
        job_data_work_item_model['outputs'] = [variable_data_model]
        job_data_work_item_model['settings'] = [variable_data_model]
        job_data_work_item_model['last_job'] = job_data_work_item_last_job_model
        job_data_work_item_model['updated_at'] = '2019-01-01T12:00:00Z'

        job_data_flow_model = {}  # JobDataFlow
        job_data_flow_model['flow_id'] = 'testString'
        job_data_flow_model['flow_name'] = 'testString'
        job_data_flow_model['workitems'] = [job_data_work_item_model]
        job_data_flow_model['updated_at'] = '2019-01-01T12:00:00Z'

        # Construct a json representation of a JobData model
        job_data_model_json = {}
        job_data_model_json['job_type'] = 'repo_download_job'
        job_data_model_json['workspace_job_data'] = job_data_workspace_model
        job_data_model_json['action_job_data'] = job_data_action_model
        job_data_model_json['system_job_data'] = job_data_system_model
        job_data_model_json['flow_job_data'] = job_data_flow_model

        # Construct a model instance of JobData by calling from_dict on the json representation
        job_data_model = JobData.from_dict(job_data_model_json)
        assert job_data_model != False

        # Construct a model instance of JobData by calling from_dict on the json representation
        job_data_model_dict = JobData.from_dict(job_data_model_json).__dict__
        job_data_model2 = JobData(**job_data_model_dict)

        # Verify the model instances are equivalent
        assert job_data_model == job_data_model2

        # Convert model instance back to dict and verify no loss of data
        job_data_model_json2 = job_data_model.to_dict()
        assert job_data_model_json2 == job_data_model_json


class TestModel_JobDataAction:
    """
    Test Class for JobDataAction
    """

    def test_job_data_action_serialization(self):
        """
        Test serialization/deserialization for JobDataAction
        """

        # Construct dict forms of any model objects needed in order to build this model.

        variable_metadata_model = {}  # VariableMetadata
        variable_metadata_model['type'] = 'boolean'
        variable_metadata_model['aliases'] = ['testString']
        variable_metadata_model['description'] = 'testString'
        variable_metadata_model['cloud_data_type'] = 'testString'
        variable_metadata_model['default_value'] = 'testString'
        variable_metadata_model['link_status'] = 'normal'
        variable_metadata_model['secure'] = True
        variable_metadata_model['immutable'] = True
        variable_metadata_model['hidden'] = True
        variable_metadata_model['required'] = True
        variable_metadata_model['options'] = ['testString']
        variable_metadata_model['min_value'] = 38
        variable_metadata_model['max_value'] = 38
        variable_metadata_model['min_length'] = 38
        variable_metadata_model['max_length'] = 38
        variable_metadata_model['matches'] = 'testString'
        variable_metadata_model['position'] = 38
        variable_metadata_model['group_by'] = 'testString'
        variable_metadata_model['source'] = 'testString'

        variable_data_model = {}  # VariableData
        variable_data_model['name'] = 'testString'
        variable_data_model['value'] = 'testString'
        variable_data_model['use_default'] = True
        variable_data_model['metadata'] = variable_metadata_model

        inventory_resource_record_model = {}  # InventoryResourceRecord
        inventory_resource_record_model['name'] = 'testString'
        inventory_resource_record_model['description'] = 'testString'
        inventory_resource_record_model['location'] = 'us-south'
        inventory_resource_record_model['resource_group'] = 'testString'
        inventory_resource_record_model['inventories_ini'] = 'testString'
        inventory_resource_record_model['resource_queries'] = ['testString']

        # Construct a json representation of a JobDataAction model
        job_data_action_model_json = {}
        job_data_action_model_json['action_name'] = 'testString'
        job_data_action_model_json['inputs'] = [variable_data_model]
        job_data_action_model_json['outputs'] = [variable_data_model]
        job_data_action_model_json['settings'] = [variable_data_model]
        job_data_action_model_json['updated_at'] = '2019-01-01T12:00:00Z'
        job_data_action_model_json['inventory_record'] = inventory_resource_record_model
        job_data_action_model_json['materialized_inventory'] = 'testString'

        # Construct a model instance of JobDataAction by calling from_dict on the json representation
        job_data_action_model = JobDataAction.from_dict(job_data_action_model_json)
        assert job_data_action_model != False

        # Construct a model instance of JobDataAction by calling from_dict on the json representation
        job_data_action_model_dict = JobDataAction.from_dict(job_data_action_model_json).__dict__
        job_data_action_model2 = JobDataAction(**job_data_action_model_dict)

        # Verify the model instances are equivalent
        assert job_data_action_model == job_data_action_model2

        # Convert model instance back to dict and verify no loss of data
        job_data_action_model_json2 = job_data_action_model.to_dict()
        assert job_data_action_model_json2 == job_data_action_model_json


class TestModel_JobDataFlow:
    """
    Test Class for JobDataFlow
    """

    def test_job_data_flow_serialization(self):
        """
        Test serialization/deserialization for JobDataFlow
        """

        # Construct dict forms of any model objects needed in order to build this model.

        git_source_model = {}  # GitSource
        git_source_model['computed_git_repo_url'] = 'testString'
        git_source_model['git_repo_url'] = 'testString'
        git_source_model['git_token'] = 'testString'
        git_source_model['git_repo_folder'] = 'testString'
        git_source_model['git_release'] = 'testString'
        git_source_model['git_branch'] = 'testString'

        catalog_source_model = {}  # CatalogSource
        catalog_source_model['catalog_name'] = 'testString'
        catalog_source_model['catalog_id'] = 'testString'
        catalog_source_model['offering_name'] = 'testString'
        catalog_source_model['offering_version'] = 'testString'
        catalog_source_model['offering_kind'] = 'testString'
        catalog_source_model['offering_target_kind'] = 'testString'
        catalog_source_model['offering_id'] = 'testString'
        catalog_source_model['offering_version_id'] = 'testString'
        catalog_source_model['offering_version_flavour_name'] = 'testString'
        catalog_source_model['offering_repo_url'] = 'testString'
        catalog_source_model['offering_provisioner_working_directory'] = 'testString'
        catalog_source_model['dry_run'] = True
        catalog_source_model['owning_account'] = 'testString'
        catalog_source_model['item_icon_url'] = 'testString'
        catalog_source_model['item_id'] = 'testString'
        catalog_source_model['item_name'] = 'testString'
        catalog_source_model['item_readme_url'] = 'testString'
        catalog_source_model['item_url'] = 'testString'
        catalog_source_model['launch_url'] = 'testString'

        external_source_model = {}  # ExternalSource
        external_source_model['source_type'] = 'local'
        external_source_model['git'] = git_source_model
        external_source_model['catalog'] = catalog_source_model

        variable_metadata_model = {}  # VariableMetadata
        variable_metadata_model['type'] = 'boolean'
        variable_metadata_model['aliases'] = ['testString']
        variable_metadata_model['description'] = 'testString'
        variable_metadata_model['cloud_data_type'] = 'testString'
        variable_metadata_model['default_value'] = 'testString'
        variable_metadata_model['link_status'] = 'normal'
        variable_metadata_model['secure'] = True
        variable_metadata_model['immutable'] = True
        variable_metadata_model['hidden'] = True
        variable_metadata_model['required'] = True
        variable_metadata_model['options'] = ['testString']
        variable_metadata_model['min_value'] = 38
        variable_metadata_model['max_value'] = 38
        variable_metadata_model['min_length'] = 38
        variable_metadata_model['max_length'] = 38
        variable_metadata_model['matches'] = 'testString'
        variable_metadata_model['position'] = 38
        variable_metadata_model['group_by'] = 'testString'
        variable_metadata_model['source'] = 'testString'

        variable_data_model = {}  # VariableData
        variable_data_model['name'] = 'testString'
        variable_data_model['value'] = 'testString'
        variable_data_model['use_default'] = True
        variable_data_model['metadata'] = variable_metadata_model

        job_data_work_item_last_job_model = {}  # JobDataWorkItemLastJob
        job_data_work_item_last_job_model['command_object'] = 'workspace'
        job_data_work_item_last_job_model['command_object_name'] = 'testString'
        job_data_work_item_last_job_model['command_object_id'] = 'testString'
        job_data_work_item_last_job_model['command_name'] = 'workspace_plan'
        job_data_work_item_last_job_model['job_id'] = 'testString'
        job_data_work_item_last_job_model['job_status'] = 'job_pending'

        job_data_work_item_model = {}  # JobDataWorkItem
        job_data_work_item_model['command_object_id'] = 'testString'
        job_data_work_item_model['command_object_name'] = 'testString'
        job_data_work_item_model['layers'] = 'testString'
        job_data_work_item_model['source_type'] = 'local'
        job_data_work_item_model['source'] = external_source_model
        job_data_work_item_model['inputs'] = [variable_data_model]
        job_data_work_item_model['outputs'] = [variable_data_model]
        job_data_work_item_model['settings'] = [variable_data_model]
        job_data_work_item_model['last_job'] = job_data_work_item_last_job_model
        job_data_work_item_model['updated_at'] = '2019-01-01T12:00:00Z'

        # Construct a json representation of a JobDataFlow model
        job_data_flow_model_json = {}
        job_data_flow_model_json['flow_id'] = 'testString'
        job_data_flow_model_json['flow_name'] = 'testString'
        job_data_flow_model_json['workitems'] = [job_data_work_item_model]
        job_data_flow_model_json['updated_at'] = '2019-01-01T12:00:00Z'

        # Construct a model instance of JobDataFlow by calling from_dict on the json representation
        job_data_flow_model = JobDataFlow.from_dict(job_data_flow_model_json)
        assert job_data_flow_model != False

        # Construct a model instance of JobDataFlow by calling from_dict on the json representation
        job_data_flow_model_dict = JobDataFlow.from_dict(job_data_flow_model_json).__dict__
        job_data_flow_model2 = JobDataFlow(**job_data_flow_model_dict)

        # Verify the model instances are equivalent
        assert job_data_flow_model == job_data_flow_model2

        # Convert model instance back to dict and verify no loss of data
        job_data_flow_model_json2 = job_data_flow_model.to_dict()
        assert job_data_flow_model_json2 == job_data_flow_model_json


class TestModel_JobDataSystem:
    """
    Test Class for JobDataSystem
    """

    def test_job_data_system_serialization(self):
        """
        Test serialization/deserialization for JobDataSystem
        """

        # Construct a json representation of a JobDataSystem model
        job_data_system_model_json = {}
        job_data_system_model_json['key_id'] = 'testString'
        job_data_system_model_json['schematics_resource_id'] = ['testString']
        job_data_system_model_json['updated_at'] = '2019-01-01T12:00:00Z'

        # Construct a model instance of JobDataSystem by calling from_dict on the json representation
        job_data_system_model = JobDataSystem.from_dict(job_data_system_model_json)
        assert job_data_system_model != False

        # Construct a model instance of JobDataSystem by calling from_dict on the json representation
        job_data_system_model_dict = JobDataSystem.from_dict(job_data_system_model_json).__dict__
        job_data_system_model2 = JobDataSystem(**job_data_system_model_dict)

        # Verify the model instances are equivalent
        assert job_data_system_model == job_data_system_model2

        # Convert model instance back to dict and verify no loss of data
        job_data_system_model_json2 = job_data_system_model.to_dict()
        assert job_data_system_model_json2 == job_data_system_model_json


class TestModel_JobDataTemplate:
    """
    Test Class for JobDataTemplate
    """

    def test_job_data_template_serialization(self):
        """
        Test serialization/deserialization for JobDataTemplate
        """

        # Construct dict forms of any model objects needed in order to build this model.

        variable_metadata_model = {}  # VariableMetadata
        variable_metadata_model['type'] = 'boolean'
        variable_metadata_model['aliases'] = ['testString']
        variable_metadata_model['description'] = 'testString'
        variable_metadata_model['cloud_data_type'] = 'testString'
        variable_metadata_model['default_value'] = 'testString'
        variable_metadata_model['link_status'] = 'normal'
        variable_metadata_model['secure'] = True
        variable_metadata_model['immutable'] = True
        variable_metadata_model['hidden'] = True
        variable_metadata_model['required'] = True
        variable_metadata_model['options'] = ['testString']
        variable_metadata_model['min_value'] = 38
        variable_metadata_model['max_value'] = 38
        variable_metadata_model['min_length'] = 38
        variable_metadata_model['max_length'] = 38
        variable_metadata_model['matches'] = 'testString'
        variable_metadata_model['position'] = 38
        variable_metadata_model['group_by'] = 'testString'
        variable_metadata_model['source'] = 'testString'

        variable_data_model = {}  # VariableData
        variable_data_model['name'] = 'testString'
        variable_data_model['value'] = 'testString'
        variable_data_model['use_default'] = True
        variable_data_model['metadata'] = variable_metadata_model

        # Construct a json representation of a JobDataTemplate model
        job_data_template_model_json = {}
        job_data_template_model_json['template_id'] = 'testString'
        job_data_template_model_json['template_name'] = 'testString'
        job_data_template_model_json['flow_index'] = 38
        job_data_template_model_json['inputs'] = [variable_data_model]
        job_data_template_model_json['outputs'] = [variable_data_model]
        job_data_template_model_json['settings'] = [variable_data_model]
        job_data_template_model_json['updated_at'] = '2019-01-01T12:00:00Z'

        # Construct a model instance of JobDataTemplate by calling from_dict on the json representation
        job_data_template_model = JobDataTemplate.from_dict(job_data_template_model_json)
        assert job_data_template_model != False

        # Construct a model instance of JobDataTemplate by calling from_dict on the json representation
        job_data_template_model_dict = JobDataTemplate.from_dict(job_data_template_model_json).__dict__
        job_data_template_model2 = JobDataTemplate(**job_data_template_model_dict)

        # Verify the model instances are equivalent
        assert job_data_template_model == job_data_template_model2

        # Convert model instance back to dict and verify no loss of data
        job_data_template_model_json2 = job_data_template_model.to_dict()
        assert job_data_template_model_json2 == job_data_template_model_json


class TestModel_JobDataWorkItem:
    """
    Test Class for JobDataWorkItem
    """

    def test_job_data_work_item_serialization(self):
        """
        Test serialization/deserialization for JobDataWorkItem
        """

        # Construct dict forms of any model objects needed in order to build this model.

        git_source_model = {}  # GitSource
        git_source_model['computed_git_repo_url'] = 'testString'
        git_source_model['git_repo_url'] = 'testString'
        git_source_model['git_token'] = 'testString'
        git_source_model['git_repo_folder'] = 'testString'
        git_source_model['git_release'] = 'testString'
        git_source_model['git_branch'] = 'testString'

        catalog_source_model = {}  # CatalogSource
        catalog_source_model['catalog_name'] = 'testString'
        catalog_source_model['catalog_id'] = 'testString'
        catalog_source_model['offering_name'] = 'testString'
        catalog_source_model['offering_version'] = 'testString'
        catalog_source_model['offering_kind'] = 'testString'
        catalog_source_model['offering_target_kind'] = 'testString'
        catalog_source_model['offering_id'] = 'testString'
        catalog_source_model['offering_version_id'] = 'testString'
        catalog_source_model['offering_version_flavour_name'] = 'testString'
        catalog_source_model['offering_repo_url'] = 'testString'
        catalog_source_model['offering_provisioner_working_directory'] = 'testString'
        catalog_source_model['dry_run'] = True
        catalog_source_model['owning_account'] = 'testString'
        catalog_source_model['item_icon_url'] = 'testString'
        catalog_source_model['item_id'] = 'testString'
        catalog_source_model['item_name'] = 'testString'
        catalog_source_model['item_readme_url'] = 'testString'
        catalog_source_model['item_url'] = 'testString'
        catalog_source_model['launch_url'] = 'testString'

        external_source_model = {}  # ExternalSource
        external_source_model['source_type'] = 'local'
        external_source_model['git'] = git_source_model
        external_source_model['catalog'] = catalog_source_model

        variable_metadata_model = {}  # VariableMetadata
        variable_metadata_model['type'] = 'boolean'
        variable_metadata_model['aliases'] = ['testString']
        variable_metadata_model['description'] = 'testString'
        variable_metadata_model['cloud_data_type'] = 'testString'
        variable_metadata_model['default_value'] = 'testString'
        variable_metadata_model['link_status'] = 'normal'
        variable_metadata_model['secure'] = True
        variable_metadata_model['immutable'] = True
        variable_metadata_model['hidden'] = True
        variable_metadata_model['required'] = True
        variable_metadata_model['options'] = ['testString']
        variable_metadata_model['min_value'] = 38
        variable_metadata_model['max_value'] = 38
        variable_metadata_model['min_length'] = 38
        variable_metadata_model['max_length'] = 38
        variable_metadata_model['matches'] = 'testString'
        variable_metadata_model['position'] = 38
        variable_metadata_model['group_by'] = 'testString'
        variable_metadata_model['source'] = 'testString'

        variable_data_model = {}  # VariableData
        variable_data_model['name'] = 'testString'
        variable_data_model['value'] = 'testString'
        variable_data_model['use_default'] = True
        variable_data_model['metadata'] = variable_metadata_model

        job_data_work_item_last_job_model = {}  # JobDataWorkItemLastJob
        job_data_work_item_last_job_model['command_object'] = 'workspace'
        job_data_work_item_last_job_model['command_object_name'] = 'testString'
        job_data_work_item_last_job_model['command_object_id'] = 'testString'
        job_data_work_item_last_job_model['command_name'] = 'workspace_plan'
        job_data_work_item_last_job_model['job_id'] = 'testString'
        job_data_work_item_last_job_model['job_status'] = 'job_pending'

        # Construct a json representation of a JobDataWorkItem model
        job_data_work_item_model_json = {}
        job_data_work_item_model_json['command_object_id'] = 'testString'
        job_data_work_item_model_json['command_object_name'] = 'testString'
        job_data_work_item_model_json['layers'] = 'testString'
        job_data_work_item_model_json['source_type'] = 'local'
        job_data_work_item_model_json['source'] = external_source_model
        job_data_work_item_model_json['inputs'] = [variable_data_model]
        job_data_work_item_model_json['outputs'] = [variable_data_model]
        job_data_work_item_model_json['settings'] = [variable_data_model]
        job_data_work_item_model_json['last_job'] = job_data_work_item_last_job_model
        job_data_work_item_model_json['updated_at'] = '2019-01-01T12:00:00Z'

        # Construct a model instance of JobDataWorkItem by calling from_dict on the json representation
        job_data_work_item_model = JobDataWorkItem.from_dict(job_data_work_item_model_json)
        assert job_data_work_item_model != False

        # Construct a model instance of JobDataWorkItem by calling from_dict on the json representation
        job_data_work_item_model_dict = JobDataWorkItem.from_dict(job_data_work_item_model_json).__dict__
        job_data_work_item_model2 = JobDataWorkItem(**job_data_work_item_model_dict)

        # Verify the model instances are equivalent
        assert job_data_work_item_model == job_data_work_item_model2

        # Convert model instance back to dict and verify no loss of data
        job_data_work_item_model_json2 = job_data_work_item_model.to_dict()
        assert job_data_work_item_model_json2 == job_data_work_item_model_json


class TestModel_JobDataWorkItemLastJob:
    """
    Test Class for JobDataWorkItemLastJob
    """

    def test_job_data_work_item_last_job_serialization(self):
        """
        Test serialization/deserialization for JobDataWorkItemLastJob
        """

        # Construct a json representation of a JobDataWorkItemLastJob model
        job_data_work_item_last_job_model_json = {}
        job_data_work_item_last_job_model_json['command_object'] = 'workspace'
        job_data_work_item_last_job_model_json['command_object_name'] = 'testString'
        job_data_work_item_last_job_model_json['command_object_id'] = 'testString'
        job_data_work_item_last_job_model_json['command_name'] = 'workspace_plan'
        job_data_work_item_last_job_model_json['job_id'] = 'testString'
        job_data_work_item_last_job_model_json['job_status'] = 'job_pending'

        # Construct a model instance of JobDataWorkItemLastJob by calling from_dict on the json representation
        job_data_work_item_last_job_model = JobDataWorkItemLastJob.from_dict(job_data_work_item_last_job_model_json)
        assert job_data_work_item_last_job_model != False

        # Construct a model instance of JobDataWorkItemLastJob by calling from_dict on the json representation
        job_data_work_item_last_job_model_dict = JobDataWorkItemLastJob.from_dict(
            job_data_work_item_last_job_model_json
        ).__dict__
        job_data_work_item_last_job_model2 = JobDataWorkItemLastJob(**job_data_work_item_last_job_model_dict)

        # Verify the model instances are equivalent
        assert job_data_work_item_last_job_model == job_data_work_item_last_job_model2

        # Convert model instance back to dict and verify no loss of data
        job_data_work_item_last_job_model_json2 = job_data_work_item_last_job_model.to_dict()
        assert job_data_work_item_last_job_model_json2 == job_data_work_item_last_job_model_json


class TestModel_JobDataWorkspace:
    """
    Test Class for JobDataWorkspace
    """

    def test_job_data_workspace_serialization(self):
        """
        Test serialization/deserialization for JobDataWorkspace
        """

        # Construct dict forms of any model objects needed in order to build this model.

        variable_metadata_model = {}  # VariableMetadata
        variable_metadata_model['type'] = 'boolean'
        variable_metadata_model['aliases'] = ['testString']
        variable_metadata_model['description'] = 'testString'
        variable_metadata_model['cloud_data_type'] = 'testString'
        variable_metadata_model['default_value'] = 'testString'
        variable_metadata_model['link_status'] = 'normal'
        variable_metadata_model['secure'] = True
        variable_metadata_model['immutable'] = True
        variable_metadata_model['hidden'] = True
        variable_metadata_model['required'] = True
        variable_metadata_model['options'] = ['testString']
        variable_metadata_model['min_value'] = 38
        variable_metadata_model['max_value'] = 38
        variable_metadata_model['min_length'] = 38
        variable_metadata_model['max_length'] = 38
        variable_metadata_model['matches'] = 'testString'
        variable_metadata_model['position'] = 38
        variable_metadata_model['group_by'] = 'testString'
        variable_metadata_model['source'] = 'testString'

        variable_data_model = {}  # VariableData
        variable_data_model['name'] = 'testString'
        variable_data_model['value'] = 'testString'
        variable_data_model['use_default'] = True
        variable_data_model['metadata'] = variable_metadata_model

        job_data_template_model = {}  # JobDataTemplate
        job_data_template_model['template_id'] = 'testString'
        job_data_template_model['template_name'] = 'testString'
        job_data_template_model['flow_index'] = 38
        job_data_template_model['inputs'] = [variable_data_model]
        job_data_template_model['outputs'] = [variable_data_model]
        job_data_template_model['settings'] = [variable_data_model]
        job_data_template_model['updated_at'] = '2019-01-01T12:00:00Z'

        # Construct a json representation of a JobDataWorkspace model
        job_data_workspace_model_json = {}
        job_data_workspace_model_json['workspace_name'] = 'testString'
        job_data_workspace_model_json['flow_id'] = 'testString'
        job_data_workspace_model_json['flow_name'] = 'testString'
        job_data_workspace_model_json['inputs'] = [variable_data_model]
        job_data_workspace_model_json['outputs'] = [variable_data_model]
        job_data_workspace_model_json['settings'] = [variable_data_model]
        job_data_workspace_model_json['template_data'] = [job_data_template_model]
        job_data_workspace_model_json['updated_at'] = '2019-01-01T12:00:00Z'

        # Construct a model instance of JobDataWorkspace by calling from_dict on the json representation
        job_data_workspace_model = JobDataWorkspace.from_dict(job_data_workspace_model_json)
        assert job_data_workspace_model != False

        # Construct a model instance of JobDataWorkspace by calling from_dict on the json representation
        job_data_workspace_model_dict = JobDataWorkspace.from_dict(job_data_workspace_model_json).__dict__
        job_data_workspace_model2 = JobDataWorkspace(**job_data_workspace_model_dict)

        # Verify the model instances are equivalent
        assert job_data_workspace_model == job_data_workspace_model2

        # Convert model instance back to dict and verify no loss of data
        job_data_workspace_model_json2 = job_data_workspace_model.to_dict()
        assert job_data_workspace_model_json2 == job_data_workspace_model_json


class TestModel_JobFileContent:
    """
    Test Class for JobFileContent
    """

    def test_job_file_content_serialization(self):
        """
        Test serialization/deserialization for JobFileContent
        """

        # Construct a json representation of a JobFileContent model
        job_file_content_model_json = {}
        job_file_content_model_json['file_name'] = 'testString'
        job_file_content_model_json['file_content'] = 'testString'

        # Construct a model instance of JobFileContent by calling from_dict on the json representation
        job_file_content_model = JobFileContent.from_dict(job_file_content_model_json)
        assert job_file_content_model != False

        # Construct a model instance of JobFileContent by calling from_dict on the json representation
        job_file_content_model_dict = JobFileContent.from_dict(job_file_content_model_json).__dict__
        job_file_content_model2 = JobFileContent(**job_file_content_model_dict)

        # Verify the model instances are equivalent
        assert job_file_content_model == job_file_content_model2

        # Convert model instance back to dict and verify no loss of data
        job_file_content_model_json2 = job_file_content_model.to_dict()
        assert job_file_content_model_json2 == job_file_content_model_json


class TestModel_JobFileData:
    """
    Test Class for JobFileData
    """

    def test_job_file_data_serialization(self):
        """
        Test serialization/deserialization for JobFileData
        """

        # Construct dict forms of any model objects needed in order to build this model.

        job_file_data_summary_model = {}  # JobFileDataSummary
        job_file_data_summary_model['name'] = 'testString'
        job_file_data_summary_model['type'] = 'number'
        job_file_data_summary_model['value'] = 'testString'

        job_file_content_model = {}  # JobFileContent
        job_file_content_model['file_name'] = 'testString'
        job_file_content_model['file_content'] = 'testString'

        # Construct a json representation of a JobFileData model
        job_file_data_model_json = {}
        job_file_data_model_json['job_id'] = 'testString'
        job_file_data_model_json['job_name'] = 'testString'
        job_file_data_model_json['summary'] = [job_file_data_summary_model]
        job_file_data_model_json['file_type'] = 'state_file'
        job_file_data_model_json['file_content'] = 'testString'
        job_file_data_model_json['additional_files'] = [job_file_content_model]
        job_file_data_model_json['updated_at'] = '2019-01-01T12:00:00Z'

        # Construct a model instance of JobFileData by calling from_dict on the json representation
        job_file_data_model = JobFileData.from_dict(job_file_data_model_json)
        assert job_file_data_model != False

        # Construct a model instance of JobFileData by calling from_dict on the json representation
        job_file_data_model_dict = JobFileData.from_dict(job_file_data_model_json).__dict__
        job_file_data_model2 = JobFileData(**job_file_data_model_dict)

        # Verify the model instances are equivalent
        assert job_file_data_model == job_file_data_model2

        # Convert model instance back to dict and verify no loss of data
        job_file_data_model_json2 = job_file_data_model.to_dict()
        assert job_file_data_model_json2 == job_file_data_model_json


class TestModel_JobFileDataSummary:
    """
    Test Class for JobFileDataSummary
    """

    def test_job_file_data_summary_serialization(self):
        """
        Test serialization/deserialization for JobFileDataSummary
        """

        # Construct a json representation of a JobFileDataSummary model
        job_file_data_summary_model_json = {}
        job_file_data_summary_model_json['name'] = 'testString'
        job_file_data_summary_model_json['type'] = 'number'
        job_file_data_summary_model_json['value'] = 'testString'

        # Construct a model instance of JobFileDataSummary by calling from_dict on the json representation
        job_file_data_summary_model = JobFileDataSummary.from_dict(job_file_data_summary_model_json)
        assert job_file_data_summary_model != False

        # Construct a model instance of JobFileDataSummary by calling from_dict on the json representation
        job_file_data_summary_model_dict = JobFileDataSummary.from_dict(job_file_data_summary_model_json).__dict__
        job_file_data_summary_model2 = JobFileDataSummary(**job_file_data_summary_model_dict)

        # Verify the model instances are equivalent
        assert job_file_data_summary_model == job_file_data_summary_model2

        # Convert model instance back to dict and verify no loss of data
        job_file_data_summary_model_json2 = job_file_data_summary_model.to_dict()
        assert job_file_data_summary_model_json2 == job_file_data_summary_model_json


class TestModel_JobList:
    """
    Test Class for JobList
    """

    def test_job_list_serialization(self):
        """
        Test serialization/deserialization for JobList
        """

        # Construct dict forms of any model objects needed in order to build this model.

        job_status_workitem_model = {}  # JobStatusWorkitem
        job_status_workitem_model['workspace_id'] = 'testString'
        job_status_workitem_model['workspace_name'] = 'testString'
        job_status_workitem_model['job_id'] = 'testString'
        job_status_workitem_model['status_code'] = 'job_pending'
        job_status_workitem_model['status_message'] = 'testString'
        job_status_workitem_model['updated_at'] = '2019-01-01T12:00:00Z'

        job_status_flow_model = {}  # JobStatusFlow
        job_status_flow_model['flow_id'] = 'testString'
        job_status_flow_model['flow_name'] = 'testString'
        job_status_flow_model['status_code'] = 'job_pending'
        job_status_flow_model['status_message'] = 'testString'
        job_status_flow_model['workitems'] = [job_status_workitem_model]
        job_status_flow_model['updated_at'] = '2019-01-01T12:00:00Z'

        job_status_template_model = {}  # JobStatusTemplate
        job_status_template_model['template_id'] = 'testString'
        job_status_template_model['template_name'] = 'testString'
        job_status_template_model['flow_index'] = 38
        job_status_template_model['status_code'] = 'job_pending'
        job_status_template_model['status_message'] = 'testString'
        job_status_template_model['updated_at'] = '2019-01-01T12:00:00Z'

        job_status_workspace_model = {}  # JobStatusWorkspace
        job_status_workspace_model['workspace_name'] = 'testString'
        job_status_workspace_model['status_code'] = 'job_pending'
        job_status_workspace_model['status_message'] = 'testString'
        job_status_workspace_model['flow_status'] = job_status_flow_model
        job_status_workspace_model['template_status'] = [job_status_template_model]
        job_status_workspace_model['updated_at'] = '2019-01-01T12:00:00Z'

        job_status_action_model = {}  # JobStatusAction
        job_status_action_model['action_name'] = 'testString'
        job_status_action_model['status_code'] = 'job_pending'
        job_status_action_model['status_message'] = 'testString'
        job_status_action_model['bastion_status_code'] = 'none'
        job_status_action_model['bastion_status_message'] = 'testString'
        job_status_action_model['targets_status_code'] = 'none'
        job_status_action_model['targets_status_message'] = 'testString'
        job_status_action_model['updated_at'] = '2019-01-01T12:00:00Z'

        job_status_schematics_resources_model = {}  # JobStatusSchematicsResources
        job_status_schematics_resources_model['status_code'] = 'job_pending'
        job_status_schematics_resources_model['status_message'] = 'testString'
        job_status_schematics_resources_model['schematics_resource_id'] = 'testString'
        job_status_schematics_resources_model['updated_at'] = '2019-01-01T12:00:00Z'

        job_status_system_model = {}  # JobStatusSystem
        job_status_system_model['system_status_message'] = 'testString'
        job_status_system_model['system_status_code'] = 'job_pending'
        job_status_system_model['schematics_resource_status'] = [job_status_schematics_resources_model]
        job_status_system_model['updated_at'] = '2019-01-01T12:00:00Z'

        job_status_model = {}  # JobStatus
        job_status_model['position_in_queue'] = 72.5
        job_status_model['total_in_queue'] = 72.5
        job_status_model['workspace_job_status'] = job_status_workspace_model
        job_status_model['action_job_status'] = job_status_action_model
        job_status_model['system_job_status'] = job_status_system_model
        job_status_model['flow_job_status'] = job_status_flow_model

        job_log_summary_repo_download_job_model = {}  # JobLogSummaryRepoDownloadJob

        job_log_summary_workspace_job_model = {}  # JobLogSummaryWorkspaceJob

        job_log_summary_workitems_model = {}  # JobLogSummaryWorkitems
        job_log_summary_workitems_model['workspace_id'] = 'testString'
        job_log_summary_workitems_model['job_id'] = 'testString'
        job_log_summary_workitems_model['log_url'] = 'testString'

        job_log_summary_flow_job_model = {}  # JobLogSummaryFlowJob
        job_log_summary_flow_job_model['workitems'] = [job_log_summary_workitems_model]

        job_log_summary_action_job_recap_model = {}  # JobLogSummaryActionJobRecap
        job_log_summary_action_job_recap_model['target'] = ['testString']
        job_log_summary_action_job_recap_model['ok'] = 72.5
        job_log_summary_action_job_recap_model['changed'] = 72.5
        job_log_summary_action_job_recap_model['failed'] = 72.5
        job_log_summary_action_job_recap_model['skipped'] = 72.5
        job_log_summary_action_job_recap_model['unreachable'] = 72.5

        job_log_summary_action_job_model = {}  # JobLogSummaryActionJob
        job_log_summary_action_job_model['recap'] = job_log_summary_action_job_recap_model

        job_log_summary_system_job_model = {}  # JobLogSummarySystemJob
        job_log_summary_system_job_model['success'] = 72.5
        job_log_summary_system_job_model['failed'] = 72.5

        job_log_summary_model = {}  # JobLogSummary
        job_log_summary_model['job_type'] = 'repo_download_job'
        job_log_summary_model['repo_download_job'] = job_log_summary_repo_download_job_model
        job_log_summary_model['workspace_job'] = job_log_summary_workspace_job_model
        job_log_summary_model['flow_job'] = job_log_summary_flow_job_model
        job_log_summary_model['action_job'] = job_log_summary_action_job_model
        job_log_summary_model['system_job'] = job_log_summary_system_job_model

        agent_info_model = {}  # AgentInfo
        agent_info_model['id'] = 'testString'
        agent_info_model['name'] = 'testString'
        agent_info_model['assignment_policy_id'] = 'testString'

        job_lite_model = {}  # JobLite
        job_lite_model['id'] = 'testString'
        job_lite_model['name'] = 'testString'
        job_lite_model['description'] = 'testString'
        job_lite_model['command_object'] = 'workspace'
        job_lite_model['command_object_id'] = 'testString'
        job_lite_model['command_name'] = 'workspace_plan'
        job_lite_model['tags'] = ['testString']
        job_lite_model['location'] = 'us-south'
        job_lite_model['resource_group'] = 'testString'
        job_lite_model['submitted_at'] = '2019-01-01T12:00:00Z'
        job_lite_model['submitted_by'] = 'testString'
        job_lite_model['duration'] = 'testString'
        job_lite_model['start_at'] = '2019-01-01T12:00:00Z'
        job_lite_model['end_at'] = '2019-01-01T12:00:00Z'
        job_lite_model['status'] = job_status_model
        job_lite_model['log_summary'] = job_log_summary_model
        job_lite_model['updated_at'] = '2019-01-01T12:00:00Z'
        job_lite_model['job_runner_id'] = 'testString'
        job_lite_model['agent'] = agent_info_model

        # Construct a json representation of a JobList model
        job_list_model_json = {}
        job_list_model_json['total_count'] = 26
        job_list_model_json['limit'] = 26
        job_list_model_json['offset'] = 26
        job_list_model_json['jobs'] = [job_lite_model]

        # Construct a model instance of JobList by calling from_dict on the json representation
        job_list_model = JobList.from_dict(job_list_model_json)
        assert job_list_model != False

        # Construct a model instance of JobList by calling from_dict on the json representation
        job_list_model_dict = JobList.from_dict(job_list_model_json).__dict__
        job_list_model2 = JobList(**job_list_model_dict)

        # Verify the model instances are equivalent
        assert job_list_model == job_list_model2

        # Convert model instance back to dict and verify no loss of data
        job_list_model_json2 = job_list_model.to_dict()
        assert job_list_model_json2 == job_list_model_json


class TestModel_JobLite:
    """
    Test Class for JobLite
    """

    def test_job_lite_serialization(self):
        """
        Test serialization/deserialization for JobLite
        """

        # Construct dict forms of any model objects needed in order to build this model.

        job_status_workitem_model = {}  # JobStatusWorkitem
        job_status_workitem_model['workspace_id'] = 'testString'
        job_status_workitem_model['workspace_name'] = 'testString'
        job_status_workitem_model['job_id'] = 'testString'
        job_status_workitem_model['status_code'] = 'job_pending'
        job_status_workitem_model['status_message'] = 'testString'
        job_status_workitem_model['updated_at'] = '2019-01-01T12:00:00Z'

        job_status_flow_model = {}  # JobStatusFlow
        job_status_flow_model['flow_id'] = 'testString'
        job_status_flow_model['flow_name'] = 'testString'
        job_status_flow_model['status_code'] = 'job_pending'
        job_status_flow_model['status_message'] = 'testString'
        job_status_flow_model['workitems'] = [job_status_workitem_model]
        job_status_flow_model['updated_at'] = '2019-01-01T12:00:00Z'

        job_status_template_model = {}  # JobStatusTemplate
        job_status_template_model['template_id'] = 'testString'
        job_status_template_model['template_name'] = 'testString'
        job_status_template_model['flow_index'] = 38
        job_status_template_model['status_code'] = 'job_pending'
        job_status_template_model['status_message'] = 'testString'
        job_status_template_model['updated_at'] = '2019-01-01T12:00:00Z'

        job_status_workspace_model = {}  # JobStatusWorkspace
        job_status_workspace_model['workspace_name'] = 'testString'
        job_status_workspace_model['status_code'] = 'job_pending'
        job_status_workspace_model['status_message'] = 'testString'
        job_status_workspace_model['flow_status'] = job_status_flow_model
        job_status_workspace_model['template_status'] = [job_status_template_model]
        job_status_workspace_model['updated_at'] = '2019-01-01T12:00:00Z'

        job_status_action_model = {}  # JobStatusAction
        job_status_action_model['action_name'] = 'testString'
        job_status_action_model['status_code'] = 'job_pending'
        job_status_action_model['status_message'] = 'testString'
        job_status_action_model['bastion_status_code'] = 'none'
        job_status_action_model['bastion_status_message'] = 'testString'
        job_status_action_model['targets_status_code'] = 'none'
        job_status_action_model['targets_status_message'] = 'testString'
        job_status_action_model['updated_at'] = '2019-01-01T12:00:00Z'

        job_status_schematics_resources_model = {}  # JobStatusSchematicsResources
        job_status_schematics_resources_model['status_code'] = 'job_pending'
        job_status_schematics_resources_model['status_message'] = 'testString'
        job_status_schematics_resources_model['schematics_resource_id'] = 'testString'
        job_status_schematics_resources_model['updated_at'] = '2019-01-01T12:00:00Z'

        job_status_system_model = {}  # JobStatusSystem
        job_status_system_model['system_status_message'] = 'testString'
        job_status_system_model['system_status_code'] = 'job_pending'
        job_status_system_model['schematics_resource_status'] = [job_status_schematics_resources_model]
        job_status_system_model['updated_at'] = '2019-01-01T12:00:00Z'

        job_status_model = {}  # JobStatus
        job_status_model['position_in_queue'] = 72.5
        job_status_model['total_in_queue'] = 72.5
        job_status_model['workspace_job_status'] = job_status_workspace_model
        job_status_model['action_job_status'] = job_status_action_model
        job_status_model['system_job_status'] = job_status_system_model
        job_status_model['flow_job_status'] = job_status_flow_model

        job_log_summary_repo_download_job_model = {}  # JobLogSummaryRepoDownloadJob

        job_log_summary_workspace_job_model = {}  # JobLogSummaryWorkspaceJob

        job_log_summary_workitems_model = {}  # JobLogSummaryWorkitems
        job_log_summary_workitems_model['workspace_id'] = 'testString'
        job_log_summary_workitems_model['job_id'] = 'testString'
        job_log_summary_workitems_model['log_url'] = 'testString'

        job_log_summary_flow_job_model = {}  # JobLogSummaryFlowJob
        job_log_summary_flow_job_model['workitems'] = [job_log_summary_workitems_model]

        job_log_summary_action_job_recap_model = {}  # JobLogSummaryActionJobRecap
        job_log_summary_action_job_recap_model['target'] = ['testString']
        job_log_summary_action_job_recap_model['ok'] = 72.5
        job_log_summary_action_job_recap_model['changed'] = 72.5
        job_log_summary_action_job_recap_model['failed'] = 72.5
        job_log_summary_action_job_recap_model['skipped'] = 72.5
        job_log_summary_action_job_recap_model['unreachable'] = 72.5

        job_log_summary_action_job_model = {}  # JobLogSummaryActionJob
        job_log_summary_action_job_model['recap'] = job_log_summary_action_job_recap_model

        job_log_summary_system_job_model = {}  # JobLogSummarySystemJob
        job_log_summary_system_job_model['success'] = 72.5
        job_log_summary_system_job_model['failed'] = 72.5

        job_log_summary_model = {}  # JobLogSummary
        job_log_summary_model['job_type'] = 'repo_download_job'
        job_log_summary_model['repo_download_job'] = job_log_summary_repo_download_job_model
        job_log_summary_model['workspace_job'] = job_log_summary_workspace_job_model
        job_log_summary_model['flow_job'] = job_log_summary_flow_job_model
        job_log_summary_model['action_job'] = job_log_summary_action_job_model
        job_log_summary_model['system_job'] = job_log_summary_system_job_model

        agent_info_model = {}  # AgentInfo
        agent_info_model['id'] = 'testString'
        agent_info_model['name'] = 'testString'
        agent_info_model['assignment_policy_id'] = 'testString'

        # Construct a json representation of a JobLite model
        job_lite_model_json = {}
        job_lite_model_json['id'] = 'testString'
        job_lite_model_json['name'] = 'testString'
        job_lite_model_json['description'] = 'testString'
        job_lite_model_json['command_object'] = 'workspace'
        job_lite_model_json['command_object_id'] = 'testString'
        job_lite_model_json['command_name'] = 'workspace_plan'
        job_lite_model_json['tags'] = ['testString']
        job_lite_model_json['location'] = 'us-south'
        job_lite_model_json['resource_group'] = 'testString'
        job_lite_model_json['submitted_at'] = '2019-01-01T12:00:00Z'
        job_lite_model_json['submitted_by'] = 'testString'
        job_lite_model_json['duration'] = 'testString'
        job_lite_model_json['start_at'] = '2019-01-01T12:00:00Z'
        job_lite_model_json['end_at'] = '2019-01-01T12:00:00Z'
        job_lite_model_json['status'] = job_status_model
        job_lite_model_json['log_summary'] = job_log_summary_model
        job_lite_model_json['updated_at'] = '2019-01-01T12:00:00Z'
        job_lite_model_json['job_runner_id'] = 'testString'
        job_lite_model_json['agent'] = agent_info_model

        # Construct a model instance of JobLite by calling from_dict on the json representation
        job_lite_model = JobLite.from_dict(job_lite_model_json)
        assert job_lite_model != False

        # Construct a model instance of JobLite by calling from_dict on the json representation
        job_lite_model_dict = JobLite.from_dict(job_lite_model_json).__dict__
        job_lite_model2 = JobLite(**job_lite_model_dict)

        # Verify the model instances are equivalent
        assert job_lite_model == job_lite_model2

        # Convert model instance back to dict and verify no loss of data
        job_lite_model_json2 = job_lite_model.to_dict()
        assert job_lite_model_json2 == job_lite_model_json


class TestModel_JobLog:
    """
    Test Class for JobLog
    """

    def test_job_log_serialization(self):
        """
        Test serialization/deserialization for JobLog
        """

        # Construct dict forms of any model objects needed in order to build this model.

        job_log_summary_repo_download_job_model = {}  # JobLogSummaryRepoDownloadJob

        job_log_summary_workspace_job_model = {}  # JobLogSummaryWorkspaceJob

        job_log_summary_workitems_model = {}  # JobLogSummaryWorkitems
        job_log_summary_workitems_model['workspace_id'] = 'testString'
        job_log_summary_workitems_model['job_id'] = 'testString'
        job_log_summary_workitems_model['log_url'] = 'testString'

        job_log_summary_flow_job_model = {}  # JobLogSummaryFlowJob
        job_log_summary_flow_job_model['workitems'] = [job_log_summary_workitems_model]

        job_log_summary_action_job_recap_model = {}  # JobLogSummaryActionJobRecap
        job_log_summary_action_job_recap_model['target'] = ['testString']
        job_log_summary_action_job_recap_model['ok'] = 72.5
        job_log_summary_action_job_recap_model['changed'] = 72.5
        job_log_summary_action_job_recap_model['failed'] = 72.5
        job_log_summary_action_job_recap_model['skipped'] = 72.5
        job_log_summary_action_job_recap_model['unreachable'] = 72.5

        job_log_summary_action_job_model = {}  # JobLogSummaryActionJob
        job_log_summary_action_job_model['recap'] = job_log_summary_action_job_recap_model

        job_log_summary_system_job_model = {}  # JobLogSummarySystemJob
        job_log_summary_system_job_model['success'] = 72.5
        job_log_summary_system_job_model['failed'] = 72.5

        job_log_summary_model = {}  # JobLogSummary
        job_log_summary_model['job_type'] = 'repo_download_job'
        job_log_summary_model['repo_download_job'] = job_log_summary_repo_download_job_model
        job_log_summary_model['workspace_job'] = job_log_summary_workspace_job_model
        job_log_summary_model['flow_job'] = job_log_summary_flow_job_model
        job_log_summary_model['action_job'] = job_log_summary_action_job_model
        job_log_summary_model['system_job'] = job_log_summary_system_job_model

        # Construct a json representation of a JobLog model
        job_log_model_json = {}
        job_log_model_json['job_id'] = 'testString'
        job_log_model_json['job_name'] = 'testString'
        job_log_model_json['log_summary'] = job_log_summary_model
        job_log_model_json['format'] = 'json'
        job_log_model_json['details'] = 'VGhpcyBpcyBhIG1vY2sgYnl0ZSBhcnJheSB2YWx1ZS4='
        job_log_model_json['updated_at'] = '2019-01-01T12:00:00Z'

        # Construct a model instance of JobLog by calling from_dict on the json representation
        job_log_model = JobLog.from_dict(job_log_model_json)
        assert job_log_model != False

        # Construct a model instance of JobLog by calling from_dict on the json representation
        job_log_model_dict = JobLog.from_dict(job_log_model_json).__dict__
        job_log_model2 = JobLog(**job_log_model_dict)

        # Verify the model instances are equivalent
        assert job_log_model == job_log_model2

        # Convert model instance back to dict and verify no loss of data
        job_log_model_json2 = job_log_model.to_dict()
        assert job_log_model_json2 == job_log_model_json


class TestModel_JobLogSummary:
    """
    Test Class for JobLogSummary
    """

    def test_job_log_summary_serialization(self):
        """
        Test serialization/deserialization for JobLogSummary
        """

        # Construct dict forms of any model objects needed in order to build this model.

        job_log_summary_repo_download_job_model = {}  # JobLogSummaryRepoDownloadJob

        job_log_summary_workspace_job_model = {}  # JobLogSummaryWorkspaceJob

        job_log_summary_workitems_model = {}  # JobLogSummaryWorkitems
        job_log_summary_workitems_model['workspace_id'] = 'testString'
        job_log_summary_workitems_model['job_id'] = 'testString'
        job_log_summary_workitems_model['log_url'] = 'testString'

        job_log_summary_flow_job_model = {}  # JobLogSummaryFlowJob
        job_log_summary_flow_job_model['workitems'] = [job_log_summary_workitems_model]

        job_log_summary_action_job_recap_model = {}  # JobLogSummaryActionJobRecap
        job_log_summary_action_job_recap_model['target'] = ['testString']
        job_log_summary_action_job_recap_model['ok'] = 72.5
        job_log_summary_action_job_recap_model['changed'] = 72.5
        job_log_summary_action_job_recap_model['failed'] = 72.5
        job_log_summary_action_job_recap_model['skipped'] = 72.5
        job_log_summary_action_job_recap_model['unreachable'] = 72.5

        job_log_summary_action_job_model = {}  # JobLogSummaryActionJob
        job_log_summary_action_job_model['recap'] = job_log_summary_action_job_recap_model

        job_log_summary_system_job_model = {}  # JobLogSummarySystemJob
        job_log_summary_system_job_model['success'] = 72.5
        job_log_summary_system_job_model['failed'] = 72.5

        # Construct a json representation of a JobLogSummary model
        job_log_summary_model_json = {}
        job_log_summary_model_json['job_type'] = 'repo_download_job'
        job_log_summary_model_json['repo_download_job'] = job_log_summary_repo_download_job_model
        job_log_summary_model_json['workspace_job'] = job_log_summary_workspace_job_model
        job_log_summary_model_json['flow_job'] = job_log_summary_flow_job_model
        job_log_summary_model_json['action_job'] = job_log_summary_action_job_model
        job_log_summary_model_json['system_job'] = job_log_summary_system_job_model

        # Construct a model instance of JobLogSummary by calling from_dict on the json representation
        job_log_summary_model = JobLogSummary.from_dict(job_log_summary_model_json)
        assert job_log_summary_model != False

        # Construct a model instance of JobLogSummary by calling from_dict on the json representation
        job_log_summary_model_dict = JobLogSummary.from_dict(job_log_summary_model_json).__dict__
        job_log_summary_model2 = JobLogSummary(**job_log_summary_model_dict)

        # Verify the model instances are equivalent
        assert job_log_summary_model == job_log_summary_model2

        # Convert model instance back to dict and verify no loss of data
        job_log_summary_model_json2 = job_log_summary_model.to_dict()
        assert job_log_summary_model_json2 == job_log_summary_model_json


class TestModel_JobLogSummaryWorkitems:
    """
    Test Class for JobLogSummaryWorkitems
    """

    def test_job_log_summary_workitems_serialization(self):
        """
        Test serialization/deserialization for JobLogSummaryWorkitems
        """

        # Construct a json representation of a JobLogSummaryWorkitems model
        job_log_summary_workitems_model_json = {}
        job_log_summary_workitems_model_json['workspace_id'] = 'testString'
        job_log_summary_workitems_model_json['job_id'] = 'testString'
        job_log_summary_workitems_model_json['log_url'] = 'testString'

        # Construct a model instance of JobLogSummaryWorkitems by calling from_dict on the json representation
        job_log_summary_workitems_model = JobLogSummaryWorkitems.from_dict(job_log_summary_workitems_model_json)
        assert job_log_summary_workitems_model != False

        # Construct a model instance of JobLogSummaryWorkitems by calling from_dict on the json representation
        job_log_summary_workitems_model_dict = JobLogSummaryWorkitems.from_dict(
            job_log_summary_workitems_model_json
        ).__dict__
        job_log_summary_workitems_model2 = JobLogSummaryWorkitems(**job_log_summary_workitems_model_dict)

        # Verify the model instances are equivalent
        assert job_log_summary_workitems_model == job_log_summary_workitems_model2

        # Convert model instance back to dict and verify no loss of data
        job_log_summary_workitems_model_json2 = job_log_summary_workitems_model.to_dict()
        assert job_log_summary_workitems_model_json2 == job_log_summary_workitems_model_json


class TestModel_JobLogSummaryActionJob:
    """
    Test Class for JobLogSummaryActionJob
    """

    def test_job_log_summary_action_job_serialization(self):
        """
        Test serialization/deserialization for JobLogSummaryActionJob
        """

        # Construct dict forms of any model objects needed in order to build this model.

        job_log_summary_action_job_recap_model = {}  # JobLogSummaryActionJobRecap
        job_log_summary_action_job_recap_model['target'] = ['testString']
        job_log_summary_action_job_recap_model['ok'] = 72.5
        job_log_summary_action_job_recap_model['changed'] = 72.5
        job_log_summary_action_job_recap_model['failed'] = 72.5
        job_log_summary_action_job_recap_model['skipped'] = 72.5
        job_log_summary_action_job_recap_model['unreachable'] = 72.5

        # Construct a json representation of a JobLogSummaryActionJob model
        job_log_summary_action_job_model_json = {}
        job_log_summary_action_job_model_json['recap'] = job_log_summary_action_job_recap_model

        # Construct a model instance of JobLogSummaryActionJob by calling from_dict on the json representation
        job_log_summary_action_job_model = JobLogSummaryActionJob.from_dict(job_log_summary_action_job_model_json)
        assert job_log_summary_action_job_model != False

        # Construct a model instance of JobLogSummaryActionJob by calling from_dict on the json representation
        job_log_summary_action_job_model_dict = JobLogSummaryActionJob.from_dict(
            job_log_summary_action_job_model_json
        ).__dict__
        job_log_summary_action_job_model2 = JobLogSummaryActionJob(**job_log_summary_action_job_model_dict)

        # Verify the model instances are equivalent
        assert job_log_summary_action_job_model == job_log_summary_action_job_model2

        # Convert model instance back to dict and verify no loss of data
        job_log_summary_action_job_model_json2 = job_log_summary_action_job_model.to_dict()
        assert job_log_summary_action_job_model_json2 == job_log_summary_action_job_model_json


class TestModel_JobLogSummaryActionJobRecap:
    """
    Test Class for JobLogSummaryActionJobRecap
    """

    def test_job_log_summary_action_job_recap_serialization(self):
        """
        Test serialization/deserialization for JobLogSummaryActionJobRecap
        """

        # Construct a json representation of a JobLogSummaryActionJobRecap model
        job_log_summary_action_job_recap_model_json = {}
        job_log_summary_action_job_recap_model_json['target'] = ['testString']
        job_log_summary_action_job_recap_model_json['ok'] = 72.5
        job_log_summary_action_job_recap_model_json['changed'] = 72.5
        job_log_summary_action_job_recap_model_json['failed'] = 72.5
        job_log_summary_action_job_recap_model_json['skipped'] = 72.5
        job_log_summary_action_job_recap_model_json['unreachable'] = 72.5

        # Construct a model instance of JobLogSummaryActionJobRecap by calling from_dict on the json representation
        job_log_summary_action_job_recap_model = JobLogSummaryActionJobRecap.from_dict(
            job_log_summary_action_job_recap_model_json
        )
        assert job_log_summary_action_job_recap_model != False

        # Construct a model instance of JobLogSummaryActionJobRecap by calling from_dict on the json representation
        job_log_summary_action_job_recap_model_dict = JobLogSummaryActionJobRecap.from_dict(
            job_log_summary_action_job_recap_model_json
        ).__dict__
        job_log_summary_action_job_recap_model2 = JobLogSummaryActionJobRecap(
            **job_log_summary_action_job_recap_model_dict
        )

        # Verify the model instances are equivalent
        assert job_log_summary_action_job_recap_model == job_log_summary_action_job_recap_model2

        # Convert model instance back to dict and verify no loss of data
        job_log_summary_action_job_recap_model_json2 = job_log_summary_action_job_recap_model.to_dict()
        assert job_log_summary_action_job_recap_model_json2 == job_log_summary_action_job_recap_model_json


class TestModel_JobLogSummaryFlowJob:
    """
    Test Class for JobLogSummaryFlowJob
    """

    def test_job_log_summary_flow_job_serialization(self):
        """
        Test serialization/deserialization for JobLogSummaryFlowJob
        """

        # Construct dict forms of any model objects needed in order to build this model.

        job_log_summary_workitems_model = {}  # JobLogSummaryWorkitems
        job_log_summary_workitems_model['workspace_id'] = 'testString'
        job_log_summary_workitems_model['job_id'] = 'testString'
        job_log_summary_workitems_model['log_url'] = 'testString'

        # Construct a json representation of a JobLogSummaryFlowJob model
        job_log_summary_flow_job_model_json = {}
        job_log_summary_flow_job_model_json['workitems'] = [job_log_summary_workitems_model]

        # Construct a model instance of JobLogSummaryFlowJob by calling from_dict on the json representation
        job_log_summary_flow_job_model = JobLogSummaryFlowJob.from_dict(job_log_summary_flow_job_model_json)
        assert job_log_summary_flow_job_model != False

        # Construct a model instance of JobLogSummaryFlowJob by calling from_dict on the json representation
        job_log_summary_flow_job_model_dict = JobLogSummaryFlowJob.from_dict(
            job_log_summary_flow_job_model_json
        ).__dict__
        job_log_summary_flow_job_model2 = JobLogSummaryFlowJob(**job_log_summary_flow_job_model_dict)

        # Verify the model instances are equivalent
        assert job_log_summary_flow_job_model == job_log_summary_flow_job_model2

        # Convert model instance back to dict and verify no loss of data
        job_log_summary_flow_job_model_json2 = job_log_summary_flow_job_model.to_dict()
        assert job_log_summary_flow_job_model_json2 == job_log_summary_flow_job_model_json


class TestModel_JobLogSummaryLogErrors:
    """
    Test Class for JobLogSummaryLogErrors
    """

    def test_job_log_summary_log_errors_serialization(self):
        """
        Test serialization/deserialization for JobLogSummaryLogErrors
        """

        # Construct a json representation of a JobLogSummaryLogErrors model
        job_log_summary_log_errors_model_json = {}
        job_log_summary_log_errors_model_json['error_code'] = 'testString'
        job_log_summary_log_errors_model_json['error_msg'] = 'testString'
        job_log_summary_log_errors_model_json['error_count'] = 72.5

        # Construct a model instance of JobLogSummaryLogErrors by calling from_dict on the json representation
        job_log_summary_log_errors_model = JobLogSummaryLogErrors.from_dict(job_log_summary_log_errors_model_json)
        assert job_log_summary_log_errors_model != False

        # Construct a model instance of JobLogSummaryLogErrors by calling from_dict on the json representation
        job_log_summary_log_errors_model_dict = JobLogSummaryLogErrors.from_dict(
            job_log_summary_log_errors_model_json
        ).__dict__
        job_log_summary_log_errors_model2 = JobLogSummaryLogErrors(**job_log_summary_log_errors_model_dict)

        # Verify the model instances are equivalent
        assert job_log_summary_log_errors_model == job_log_summary_log_errors_model2

        # Convert model instance back to dict and verify no loss of data
        job_log_summary_log_errors_model_json2 = job_log_summary_log_errors_model.to_dict()
        assert job_log_summary_log_errors_model_json2 == job_log_summary_log_errors_model_json


class TestModel_JobLogSummaryRepoDownloadJob:
    """
    Test Class for JobLogSummaryRepoDownloadJob
    """

    def test_job_log_summary_repo_download_job_serialization(self):
        """
        Test serialization/deserialization for JobLogSummaryRepoDownloadJob
        """

        # Construct a json representation of a JobLogSummaryRepoDownloadJob model
        job_log_summary_repo_download_job_model_json = {}

        # Construct a model instance of JobLogSummaryRepoDownloadJob by calling from_dict on the json representation
        job_log_summary_repo_download_job_model = JobLogSummaryRepoDownloadJob.from_dict(
            job_log_summary_repo_download_job_model_json
        )
        assert job_log_summary_repo_download_job_model != False

        # Construct a model instance of JobLogSummaryRepoDownloadJob by calling from_dict on the json representation
        job_log_summary_repo_download_job_model_dict = JobLogSummaryRepoDownloadJob.from_dict(
            job_log_summary_repo_download_job_model_json
        ).__dict__
        job_log_summary_repo_download_job_model2 = JobLogSummaryRepoDownloadJob(
            **job_log_summary_repo_download_job_model_dict
        )

        # Verify the model instances are equivalent
        assert job_log_summary_repo_download_job_model == job_log_summary_repo_download_job_model2

        # Convert model instance back to dict and verify no loss of data
        job_log_summary_repo_download_job_model_json2 = job_log_summary_repo_download_job_model.to_dict()
        assert job_log_summary_repo_download_job_model_json2 == job_log_summary_repo_download_job_model_json


class TestModel_JobLogSummarySystemJob:
    """
    Test Class for JobLogSummarySystemJob
    """

    def test_job_log_summary_system_job_serialization(self):
        """
        Test serialization/deserialization for JobLogSummarySystemJob
        """

        # Construct a json representation of a JobLogSummarySystemJob model
        job_log_summary_system_job_model_json = {}
        job_log_summary_system_job_model_json['success'] = 72.5
        job_log_summary_system_job_model_json['failed'] = 72.5

        # Construct a model instance of JobLogSummarySystemJob by calling from_dict on the json representation
        job_log_summary_system_job_model = JobLogSummarySystemJob.from_dict(job_log_summary_system_job_model_json)
        assert job_log_summary_system_job_model != False

        # Construct a model instance of JobLogSummarySystemJob by calling from_dict on the json representation
        job_log_summary_system_job_model_dict = JobLogSummarySystemJob.from_dict(
            job_log_summary_system_job_model_json
        ).__dict__
        job_log_summary_system_job_model2 = JobLogSummarySystemJob(**job_log_summary_system_job_model_dict)

        # Verify the model instances are equivalent
        assert job_log_summary_system_job_model == job_log_summary_system_job_model2

        # Convert model instance back to dict and verify no loss of data
        job_log_summary_system_job_model_json2 = job_log_summary_system_job_model.to_dict()
        assert job_log_summary_system_job_model_json2 == job_log_summary_system_job_model_json


class TestModel_JobLogSummaryWorkspaceJob:
    """
    Test Class for JobLogSummaryWorkspaceJob
    """

    def test_job_log_summary_workspace_job_serialization(self):
        """
        Test serialization/deserialization for JobLogSummaryWorkspaceJob
        """

        # Construct a json representation of a JobLogSummaryWorkspaceJob model
        job_log_summary_workspace_job_model_json = {}

        # Construct a model instance of JobLogSummaryWorkspaceJob by calling from_dict on the json representation
        job_log_summary_workspace_job_model = JobLogSummaryWorkspaceJob.from_dict(
            job_log_summary_workspace_job_model_json
        )
        assert job_log_summary_workspace_job_model != False

        # Construct a model instance of JobLogSummaryWorkspaceJob by calling from_dict on the json representation
        job_log_summary_workspace_job_model_dict = JobLogSummaryWorkspaceJob.from_dict(
            job_log_summary_workspace_job_model_json
        ).__dict__
        job_log_summary_workspace_job_model2 = JobLogSummaryWorkspaceJob(**job_log_summary_workspace_job_model_dict)

        # Verify the model instances are equivalent
        assert job_log_summary_workspace_job_model == job_log_summary_workspace_job_model2

        # Convert model instance back to dict and verify no loss of data
        job_log_summary_workspace_job_model_json2 = job_log_summary_workspace_job_model.to_dict()
        assert job_log_summary_workspace_job_model_json2 == job_log_summary_workspace_job_model_json


class TestModel_JobStatus:
    """
    Test Class for JobStatus
    """

    def test_job_status_serialization(self):
        """
        Test serialization/deserialization for JobStatus
        """

        # Construct dict forms of any model objects needed in order to build this model.

        job_status_workitem_model = {}  # JobStatusWorkitem
        job_status_workitem_model['workspace_id'] = 'testString'
        job_status_workitem_model['workspace_name'] = 'testString'
        job_status_workitem_model['job_id'] = 'testString'
        job_status_workitem_model['status_code'] = 'job_pending'
        job_status_workitem_model['status_message'] = 'testString'
        job_status_workitem_model['updated_at'] = '2019-01-01T12:00:00Z'

        job_status_flow_model = {}  # JobStatusFlow
        job_status_flow_model['flow_id'] = 'testString'
        job_status_flow_model['flow_name'] = 'testString'
        job_status_flow_model['status_code'] = 'job_pending'
        job_status_flow_model['status_message'] = 'testString'
        job_status_flow_model['workitems'] = [job_status_workitem_model]
        job_status_flow_model['updated_at'] = '2019-01-01T12:00:00Z'

        job_status_template_model = {}  # JobStatusTemplate
        job_status_template_model['template_id'] = 'testString'
        job_status_template_model['template_name'] = 'testString'
        job_status_template_model['flow_index'] = 38
        job_status_template_model['status_code'] = 'job_pending'
        job_status_template_model['status_message'] = 'testString'
        job_status_template_model['updated_at'] = '2019-01-01T12:00:00Z'

        job_status_workspace_model = {}  # JobStatusWorkspace
        job_status_workspace_model['workspace_name'] = 'testString'
        job_status_workspace_model['status_code'] = 'job_pending'
        job_status_workspace_model['status_message'] = 'testString'
        job_status_workspace_model['flow_status'] = job_status_flow_model
        job_status_workspace_model['template_status'] = [job_status_template_model]
        job_status_workspace_model['updated_at'] = '2019-01-01T12:00:00Z'

        job_status_action_model = {}  # JobStatusAction
        job_status_action_model['action_name'] = 'testString'
        job_status_action_model['status_code'] = 'job_pending'
        job_status_action_model['status_message'] = 'testString'
        job_status_action_model['bastion_status_code'] = 'none'
        job_status_action_model['bastion_status_message'] = 'testString'
        job_status_action_model['targets_status_code'] = 'none'
        job_status_action_model['targets_status_message'] = 'testString'
        job_status_action_model['updated_at'] = '2019-01-01T12:00:00Z'

        job_status_schematics_resources_model = {}  # JobStatusSchematicsResources
        job_status_schematics_resources_model['status_code'] = 'job_pending'
        job_status_schematics_resources_model['status_message'] = 'testString'
        job_status_schematics_resources_model['schematics_resource_id'] = 'testString'
        job_status_schematics_resources_model['updated_at'] = '2019-01-01T12:00:00Z'

        job_status_system_model = {}  # JobStatusSystem
        job_status_system_model['system_status_message'] = 'testString'
        job_status_system_model['system_status_code'] = 'job_pending'
        job_status_system_model['schematics_resource_status'] = [job_status_schematics_resources_model]
        job_status_system_model['updated_at'] = '2019-01-01T12:00:00Z'

        # Construct a json representation of a JobStatus model
        job_status_model_json = {}
        job_status_model_json['position_in_queue'] = 72.5
        job_status_model_json['total_in_queue'] = 72.5
        job_status_model_json['workspace_job_status'] = job_status_workspace_model
        job_status_model_json['action_job_status'] = job_status_action_model
        job_status_model_json['system_job_status'] = job_status_system_model
        job_status_model_json['flow_job_status'] = job_status_flow_model

        # Construct a model instance of JobStatus by calling from_dict on the json representation
        job_status_model = JobStatus.from_dict(job_status_model_json)
        assert job_status_model != False

        # Construct a model instance of JobStatus by calling from_dict on the json representation
        job_status_model_dict = JobStatus.from_dict(job_status_model_json).__dict__
        job_status_model2 = JobStatus(**job_status_model_dict)

        # Verify the model instances are equivalent
        assert job_status_model == job_status_model2

        # Convert model instance back to dict and verify no loss of data
        job_status_model_json2 = job_status_model.to_dict()
        assert job_status_model_json2 == job_status_model_json


class TestModel_JobStatusAction:
    """
    Test Class for JobStatusAction
    """

    def test_job_status_action_serialization(self):
        """
        Test serialization/deserialization for JobStatusAction
        """

        # Construct a json representation of a JobStatusAction model
        job_status_action_model_json = {}
        job_status_action_model_json['action_name'] = 'testString'
        job_status_action_model_json['status_code'] = 'job_pending'
        job_status_action_model_json['status_message'] = 'testString'
        job_status_action_model_json['bastion_status_code'] = 'none'
        job_status_action_model_json['bastion_status_message'] = 'testString'
        job_status_action_model_json['targets_status_code'] = 'none'
        job_status_action_model_json['targets_status_message'] = 'testString'
        job_status_action_model_json['updated_at'] = '2019-01-01T12:00:00Z'

        # Construct a model instance of JobStatusAction by calling from_dict on the json representation
        job_status_action_model = JobStatusAction.from_dict(job_status_action_model_json)
        assert job_status_action_model != False

        # Construct a model instance of JobStatusAction by calling from_dict on the json representation
        job_status_action_model_dict = JobStatusAction.from_dict(job_status_action_model_json).__dict__
        job_status_action_model2 = JobStatusAction(**job_status_action_model_dict)

        # Verify the model instances are equivalent
        assert job_status_action_model == job_status_action_model2

        # Convert model instance back to dict and verify no loss of data
        job_status_action_model_json2 = job_status_action_model.to_dict()
        assert job_status_action_model_json2 == job_status_action_model_json


class TestModel_JobStatusFlow:
    """
    Test Class for JobStatusFlow
    """

    def test_job_status_flow_serialization(self):
        """
        Test serialization/deserialization for JobStatusFlow
        """

        # Construct dict forms of any model objects needed in order to build this model.

        job_status_workitem_model = {}  # JobStatusWorkitem
        job_status_workitem_model['workspace_id'] = 'testString'
        job_status_workitem_model['workspace_name'] = 'testString'
        job_status_workitem_model['job_id'] = 'testString'
        job_status_workitem_model['status_code'] = 'job_pending'
        job_status_workitem_model['status_message'] = 'testString'
        job_status_workitem_model['updated_at'] = '2019-01-01T12:00:00Z'

        # Construct a json representation of a JobStatusFlow model
        job_status_flow_model_json = {}
        job_status_flow_model_json['flow_id'] = 'testString'
        job_status_flow_model_json['flow_name'] = 'testString'
        job_status_flow_model_json['status_code'] = 'job_pending'
        job_status_flow_model_json['status_message'] = 'testString'
        job_status_flow_model_json['workitems'] = [job_status_workitem_model]
        job_status_flow_model_json['updated_at'] = '2019-01-01T12:00:00Z'

        # Construct a model instance of JobStatusFlow by calling from_dict on the json representation
        job_status_flow_model = JobStatusFlow.from_dict(job_status_flow_model_json)
        assert job_status_flow_model != False

        # Construct a model instance of JobStatusFlow by calling from_dict on the json representation
        job_status_flow_model_dict = JobStatusFlow.from_dict(job_status_flow_model_json).__dict__
        job_status_flow_model2 = JobStatusFlow(**job_status_flow_model_dict)

        # Verify the model instances are equivalent
        assert job_status_flow_model == job_status_flow_model2

        # Convert model instance back to dict and verify no loss of data
        job_status_flow_model_json2 = job_status_flow_model.to_dict()
        assert job_status_flow_model_json2 == job_status_flow_model_json


class TestModel_JobStatusSchematicsResources:
    """
    Test Class for JobStatusSchematicsResources
    """

    def test_job_status_schematics_resources_serialization(self):
        """
        Test serialization/deserialization for JobStatusSchematicsResources
        """

        # Construct a json representation of a JobStatusSchematicsResources model
        job_status_schematics_resources_model_json = {}
        job_status_schematics_resources_model_json['status_code'] = 'job_pending'
        job_status_schematics_resources_model_json['status_message'] = 'testString'
        job_status_schematics_resources_model_json['schematics_resource_id'] = 'testString'
        job_status_schematics_resources_model_json['updated_at'] = '2019-01-01T12:00:00Z'

        # Construct a model instance of JobStatusSchematicsResources by calling from_dict on the json representation
        job_status_schematics_resources_model = JobStatusSchematicsResources.from_dict(
            job_status_schematics_resources_model_json
        )
        assert job_status_schematics_resources_model != False

        # Construct a model instance of JobStatusSchematicsResources by calling from_dict on the json representation
        job_status_schematics_resources_model_dict = JobStatusSchematicsResources.from_dict(
            job_status_schematics_resources_model_json
        ).__dict__
        job_status_schematics_resources_model2 = JobStatusSchematicsResources(
            **job_status_schematics_resources_model_dict
        )

        # Verify the model instances are equivalent
        assert job_status_schematics_resources_model == job_status_schematics_resources_model2

        # Convert model instance back to dict and verify no loss of data
        job_status_schematics_resources_model_json2 = job_status_schematics_resources_model.to_dict()
        assert job_status_schematics_resources_model_json2 == job_status_schematics_resources_model_json


class TestModel_JobStatusSystem:
    """
    Test Class for JobStatusSystem
    """

    def test_job_status_system_serialization(self):
        """
        Test serialization/deserialization for JobStatusSystem
        """

        # Construct dict forms of any model objects needed in order to build this model.

        job_status_schematics_resources_model = {}  # JobStatusSchematicsResources
        job_status_schematics_resources_model['status_code'] = 'job_pending'
        job_status_schematics_resources_model['status_message'] = 'testString'
        job_status_schematics_resources_model['schematics_resource_id'] = 'testString'
        job_status_schematics_resources_model['updated_at'] = '2019-01-01T12:00:00Z'

        # Construct a json representation of a JobStatusSystem model
        job_status_system_model_json = {}
        job_status_system_model_json['system_status_message'] = 'testString'
        job_status_system_model_json['system_status_code'] = 'job_pending'
        job_status_system_model_json['schematics_resource_status'] = [job_status_schematics_resources_model]
        job_status_system_model_json['updated_at'] = '2019-01-01T12:00:00Z'

        # Construct a model instance of JobStatusSystem by calling from_dict on the json representation
        job_status_system_model = JobStatusSystem.from_dict(job_status_system_model_json)
        assert job_status_system_model != False

        # Construct a model instance of JobStatusSystem by calling from_dict on the json representation
        job_status_system_model_dict = JobStatusSystem.from_dict(job_status_system_model_json).__dict__
        job_status_system_model2 = JobStatusSystem(**job_status_system_model_dict)

        # Verify the model instances are equivalent
        assert job_status_system_model == job_status_system_model2

        # Convert model instance back to dict and verify no loss of data
        job_status_system_model_json2 = job_status_system_model.to_dict()
        assert job_status_system_model_json2 == job_status_system_model_json


class TestModel_JobStatusTemplate:
    """
    Test Class for JobStatusTemplate
    """

    def test_job_status_template_serialization(self):
        """
        Test serialization/deserialization for JobStatusTemplate
        """

        # Construct a json representation of a JobStatusTemplate model
        job_status_template_model_json = {}
        job_status_template_model_json['template_id'] = 'testString'
        job_status_template_model_json['template_name'] = 'testString'
        job_status_template_model_json['flow_index'] = 38
        job_status_template_model_json['status_code'] = 'job_pending'
        job_status_template_model_json['status_message'] = 'testString'
        job_status_template_model_json['updated_at'] = '2019-01-01T12:00:00Z'

        # Construct a model instance of JobStatusTemplate by calling from_dict on the json representation
        job_status_template_model = JobStatusTemplate.from_dict(job_status_template_model_json)
        assert job_status_template_model != False

        # Construct a model instance of JobStatusTemplate by calling from_dict on the json representation
        job_status_template_model_dict = JobStatusTemplate.from_dict(job_status_template_model_json).__dict__
        job_status_template_model2 = JobStatusTemplate(**job_status_template_model_dict)

        # Verify the model instances are equivalent
        assert job_status_template_model == job_status_template_model2

        # Convert model instance back to dict and verify no loss of data
        job_status_template_model_json2 = job_status_template_model.to_dict()
        assert job_status_template_model_json2 == job_status_template_model_json


class TestModel_JobStatusWorkitem:
    """
    Test Class for JobStatusWorkitem
    """

    def test_job_status_workitem_serialization(self):
        """
        Test serialization/deserialization for JobStatusWorkitem
        """

        # Construct a json representation of a JobStatusWorkitem model
        job_status_workitem_model_json = {}
        job_status_workitem_model_json['workspace_id'] = 'testString'
        job_status_workitem_model_json['workspace_name'] = 'testString'
        job_status_workitem_model_json['job_id'] = 'testString'
        job_status_workitem_model_json['status_code'] = 'job_pending'
        job_status_workitem_model_json['status_message'] = 'testString'
        job_status_workitem_model_json['updated_at'] = '2019-01-01T12:00:00Z'

        # Construct a model instance of JobStatusWorkitem by calling from_dict on the json representation
        job_status_workitem_model = JobStatusWorkitem.from_dict(job_status_workitem_model_json)
        assert job_status_workitem_model != False

        # Construct a model instance of JobStatusWorkitem by calling from_dict on the json representation
        job_status_workitem_model_dict = JobStatusWorkitem.from_dict(job_status_workitem_model_json).__dict__
        job_status_workitem_model2 = JobStatusWorkitem(**job_status_workitem_model_dict)

        # Verify the model instances are equivalent
        assert job_status_workitem_model == job_status_workitem_model2

        # Convert model instance back to dict and verify no loss of data
        job_status_workitem_model_json2 = job_status_workitem_model.to_dict()
        assert job_status_workitem_model_json2 == job_status_workitem_model_json


class TestModel_JobStatusWorkspace:
    """
    Test Class for JobStatusWorkspace
    """

    def test_job_status_workspace_serialization(self):
        """
        Test serialization/deserialization for JobStatusWorkspace
        """

        # Construct dict forms of any model objects needed in order to build this model.

        job_status_workitem_model = {}  # JobStatusWorkitem
        job_status_workitem_model['workspace_id'] = 'testString'
        job_status_workitem_model['workspace_name'] = 'testString'
        job_status_workitem_model['job_id'] = 'testString'
        job_status_workitem_model['status_code'] = 'job_pending'
        job_status_workitem_model['status_message'] = 'testString'
        job_status_workitem_model['updated_at'] = '2019-01-01T12:00:00Z'

        job_status_flow_model = {}  # JobStatusFlow
        job_status_flow_model['flow_id'] = 'testString'
        job_status_flow_model['flow_name'] = 'testString'
        job_status_flow_model['status_code'] = 'job_pending'
        job_status_flow_model['status_message'] = 'testString'
        job_status_flow_model['workitems'] = [job_status_workitem_model]
        job_status_flow_model['updated_at'] = '2019-01-01T12:00:00Z'

        job_status_template_model = {}  # JobStatusTemplate
        job_status_template_model['template_id'] = 'testString'
        job_status_template_model['template_name'] = 'testString'
        job_status_template_model['flow_index'] = 38
        job_status_template_model['status_code'] = 'job_pending'
        job_status_template_model['status_message'] = 'testString'
        job_status_template_model['updated_at'] = '2019-01-01T12:00:00Z'

        # Construct a json representation of a JobStatusWorkspace model
        job_status_workspace_model_json = {}
        job_status_workspace_model_json['workspace_name'] = 'testString'
        job_status_workspace_model_json['status_code'] = 'job_pending'
        job_status_workspace_model_json['status_message'] = 'testString'
        job_status_workspace_model_json['flow_status'] = job_status_flow_model
        job_status_workspace_model_json['template_status'] = [job_status_template_model]
        job_status_workspace_model_json['updated_at'] = '2019-01-01T12:00:00Z'

        # Construct a model instance of JobStatusWorkspace by calling from_dict on the json representation
        job_status_workspace_model = JobStatusWorkspace.from_dict(job_status_workspace_model_json)
        assert job_status_workspace_model != False

        # Construct a model instance of JobStatusWorkspace by calling from_dict on the json representation
        job_status_workspace_model_dict = JobStatusWorkspace.from_dict(job_status_workspace_model_json).__dict__
        job_status_workspace_model2 = JobStatusWorkspace(**job_status_workspace_model_dict)

        # Verify the model instances are equivalent
        assert job_status_workspace_model == job_status_workspace_model2

        # Convert model instance back to dict and verify no loss of data
        job_status_workspace_model_json2 = job_status_workspace_model.to_dict()
        assert job_status_workspace_model_json2 == job_status_workspace_model_json


class TestModel_KMSDiscovery:
    """
    Test Class for KMSDiscovery
    """

    def test_kms_discovery_serialization(self):
        """
        Test serialization/deserialization for KMSDiscovery
        """

        # Construct dict forms of any model objects needed in order to build this model.

        kms_instances_keys_model = {}  # KMSInstancesKeys
        kms_instances_keys_model['name'] = 'testString'
        kms_instances_keys_model['crn'] = 'testString'
        kms_instances_keys_model['error'] = 'testString'

        kms_instances_model = {}  # KMSInstances
        kms_instances_model['location'] = 'testString'
        kms_instances_model['encryption_scheme'] = 'testString'
        kms_instances_model['resource_group'] = 'testString'
        kms_instances_model['kms_crn'] = 'testString'
        kms_instances_model['kms_name'] = 'testString'
        kms_instances_model['kms_private_endpoint'] = 'testString'
        kms_instances_model['kms_public_endpoint'] = 'testString'
        kms_instances_model['keys'] = [kms_instances_keys_model]

        # Construct a json representation of a KMSDiscovery model
        kms_discovery_model_json = {}
        kms_discovery_model_json['total_count'] = 26
        kms_discovery_model_json['limit'] = 26
        kms_discovery_model_json['offset'] = 26
        kms_discovery_model_json['kms_instances'] = [kms_instances_model]

        # Construct a model instance of KMSDiscovery by calling from_dict on the json representation
        kms_discovery_model = KMSDiscovery.from_dict(kms_discovery_model_json)
        assert kms_discovery_model != False

        # Construct a model instance of KMSDiscovery by calling from_dict on the json representation
        kms_discovery_model_dict = KMSDiscovery.from_dict(kms_discovery_model_json).__dict__
        kms_discovery_model2 = KMSDiscovery(**kms_discovery_model_dict)

        # Verify the model instances are equivalent
        assert kms_discovery_model == kms_discovery_model2

        # Convert model instance back to dict and verify no loss of data
        kms_discovery_model_json2 = kms_discovery_model.to_dict()
        assert kms_discovery_model_json2 == kms_discovery_model_json


class TestModel_KMSInstances:
    """
    Test Class for KMSInstances
    """

    def test_kms_instances_serialization(self):
        """
        Test serialization/deserialization for KMSInstances
        """

        # Construct dict forms of any model objects needed in order to build this model.

        kms_instances_keys_model = {}  # KMSInstancesKeys
        kms_instances_keys_model['name'] = 'testString'
        kms_instances_keys_model['crn'] = 'testString'
        kms_instances_keys_model['error'] = 'testString'

        # Construct a json representation of a KMSInstances model
        kms_instances_model_json = {}
        kms_instances_model_json['location'] = 'testString'
        kms_instances_model_json['encryption_scheme'] = 'testString'
        kms_instances_model_json['resource_group'] = 'testString'
        kms_instances_model_json['kms_crn'] = 'testString'
        kms_instances_model_json['kms_name'] = 'testString'
        kms_instances_model_json['kms_private_endpoint'] = 'testString'
        kms_instances_model_json['kms_public_endpoint'] = 'testString'
        kms_instances_model_json['keys'] = [kms_instances_keys_model]

        # Construct a model instance of KMSInstances by calling from_dict on the json representation
        kms_instances_model = KMSInstances.from_dict(kms_instances_model_json)
        assert kms_instances_model != False

        # Construct a model instance of KMSInstances by calling from_dict on the json representation
        kms_instances_model_dict = KMSInstances.from_dict(kms_instances_model_json).__dict__
        kms_instances_model2 = KMSInstances(**kms_instances_model_dict)

        # Verify the model instances are equivalent
        assert kms_instances_model == kms_instances_model2

        # Convert model instance back to dict and verify no loss of data
        kms_instances_model_json2 = kms_instances_model.to_dict()
        assert kms_instances_model_json2 == kms_instances_model_json


class TestModel_KMSInstancesKeys:
    """
    Test Class for KMSInstancesKeys
    """

    def test_kms_instances_keys_serialization(self):
        """
        Test serialization/deserialization for KMSInstancesKeys
        """

        # Construct a json representation of a KMSInstancesKeys model
        kms_instances_keys_model_json = {}
        kms_instances_keys_model_json['name'] = 'testString'
        kms_instances_keys_model_json['crn'] = 'testString'
        kms_instances_keys_model_json['error'] = 'testString'

        # Construct a model instance of KMSInstancesKeys by calling from_dict on the json representation
        kms_instances_keys_model = KMSInstancesKeys.from_dict(kms_instances_keys_model_json)
        assert kms_instances_keys_model != False

        # Construct a model instance of KMSInstancesKeys by calling from_dict on the json representation
        kms_instances_keys_model_dict = KMSInstancesKeys.from_dict(kms_instances_keys_model_json).__dict__
        kms_instances_keys_model2 = KMSInstancesKeys(**kms_instances_keys_model_dict)

        # Verify the model instances are equivalent
        assert kms_instances_keys_model == kms_instances_keys_model2

        # Convert model instance back to dict and verify no loss of data
        kms_instances_keys_model_json2 = kms_instances_keys_model.to_dict()
        assert kms_instances_keys_model_json2 == kms_instances_keys_model_json


class TestModel_KMSSettings:
    """
    Test Class for KMSSettings
    """

    def test_kms_settings_serialization(self):
        """
        Test serialization/deserialization for KMSSettings
        """

        # Construct dict forms of any model objects needed in order to build this model.

        kms_settings_primary_crk_model = {}  # KMSSettingsPrimaryCrk
        kms_settings_primary_crk_model['kms_name'] = 'testString'
        kms_settings_primary_crk_model['kms_private_endpoint'] = 'testString'
        kms_settings_primary_crk_model['key_crn'] = 'testString'

        kms_settings_secondary_crk_model = {}  # KMSSettingsSecondaryCrk
        kms_settings_secondary_crk_model['kms_name'] = 'testString'
        kms_settings_secondary_crk_model['kms_private_endpoint'] = 'testString'
        kms_settings_secondary_crk_model['key_crn'] = 'testString'

        # Construct a json representation of a KMSSettings model
        kms_settings_model_json = {}
        kms_settings_model_json['location'] = 'testString'
        kms_settings_model_json['encryption_scheme'] = 'testString'
        kms_settings_model_json['resource_group'] = 'testString'
        kms_settings_model_json['primary_crk'] = kms_settings_primary_crk_model
        kms_settings_model_json['secondary_crk'] = kms_settings_secondary_crk_model

        # Construct a model instance of KMSSettings by calling from_dict on the json representation
        kms_settings_model = KMSSettings.from_dict(kms_settings_model_json)
        assert kms_settings_model != False

        # Construct a model instance of KMSSettings by calling from_dict on the json representation
        kms_settings_model_dict = KMSSettings.from_dict(kms_settings_model_json).__dict__
        kms_settings_model2 = KMSSettings(**kms_settings_model_dict)

        # Verify the model instances are equivalent
        assert kms_settings_model == kms_settings_model2

        # Convert model instance back to dict and verify no loss of data
        kms_settings_model_json2 = kms_settings_model.to_dict()
        assert kms_settings_model_json2 == kms_settings_model_json


class TestModel_KMSSettingsPrimaryCrk:
    """
    Test Class for KMSSettingsPrimaryCrk
    """

    def test_kms_settings_primary_crk_serialization(self):
        """
        Test serialization/deserialization for KMSSettingsPrimaryCrk
        """

        # Construct a json representation of a KMSSettingsPrimaryCrk model
        kms_settings_primary_crk_model_json = {}
        kms_settings_primary_crk_model_json['kms_name'] = 'testString'
        kms_settings_primary_crk_model_json['kms_private_endpoint'] = 'testString'
        kms_settings_primary_crk_model_json['key_crn'] = 'testString'

        # Construct a model instance of KMSSettingsPrimaryCrk by calling from_dict on the json representation
        kms_settings_primary_crk_model = KMSSettingsPrimaryCrk.from_dict(kms_settings_primary_crk_model_json)
        assert kms_settings_primary_crk_model != False

        # Construct a model instance of KMSSettingsPrimaryCrk by calling from_dict on the json representation
        kms_settings_primary_crk_model_dict = KMSSettingsPrimaryCrk.from_dict(
            kms_settings_primary_crk_model_json
        ).__dict__
        kms_settings_primary_crk_model2 = KMSSettingsPrimaryCrk(**kms_settings_primary_crk_model_dict)

        # Verify the model instances are equivalent
        assert kms_settings_primary_crk_model == kms_settings_primary_crk_model2

        # Convert model instance back to dict and verify no loss of data
        kms_settings_primary_crk_model_json2 = kms_settings_primary_crk_model.to_dict()
        assert kms_settings_primary_crk_model_json2 == kms_settings_primary_crk_model_json


class TestModel_KMSSettingsSecondaryCrk:
    """
    Test Class for KMSSettingsSecondaryCrk
    """

    def test_kms_settings_secondary_crk_serialization(self):
        """
        Test serialization/deserialization for KMSSettingsSecondaryCrk
        """

        # Construct a json representation of a KMSSettingsSecondaryCrk model
        kms_settings_secondary_crk_model_json = {}
        kms_settings_secondary_crk_model_json['kms_name'] = 'testString'
        kms_settings_secondary_crk_model_json['kms_private_endpoint'] = 'testString'
        kms_settings_secondary_crk_model_json['key_crn'] = 'testString'

        # Construct a model instance of KMSSettingsSecondaryCrk by calling from_dict on the json representation
        kms_settings_secondary_crk_model = KMSSettingsSecondaryCrk.from_dict(kms_settings_secondary_crk_model_json)
        assert kms_settings_secondary_crk_model != False

        # Construct a model instance of KMSSettingsSecondaryCrk by calling from_dict on the json representation
        kms_settings_secondary_crk_model_dict = KMSSettingsSecondaryCrk.from_dict(
            kms_settings_secondary_crk_model_json
        ).__dict__
        kms_settings_secondary_crk_model2 = KMSSettingsSecondaryCrk(**kms_settings_secondary_crk_model_dict)

        # Verify the model instances are equivalent
        assert kms_settings_secondary_crk_model == kms_settings_secondary_crk_model2

        # Convert model instance back to dict and verify no loss of data
        kms_settings_secondary_crk_model_json2 = kms_settings_secondary_crk_model.to_dict()
        assert kms_settings_secondary_crk_model_json2 == kms_settings_secondary_crk_model_json


class TestModel_LastJob:
    """
    Test Class for LastJob
    """

    def test_last_job_serialization(self):
        """
        Test serialization/deserialization for LastJob
        """

        # Construct a json representation of a LastJob model
        last_job_model_json = {}
        last_job_model_json['job_id'] = 'testString'
        last_job_model_json['job_name'] = 'testString'
        last_job_model_json['job_status'] = 'testString'

        # Construct a model instance of LastJob by calling from_dict on the json representation
        last_job_model = LastJob.from_dict(last_job_model_json)
        assert last_job_model != False

        # Construct a model instance of LastJob by calling from_dict on the json representation
        last_job_model_dict = LastJob.from_dict(last_job_model_json).__dict__
        last_job_model2 = LastJob(**last_job_model_dict)

        # Verify the model instances are equivalent
        assert last_job_model == last_job_model2

        # Convert model instance back to dict and verify no loss of data
        last_job_model_json2 = last_job_model.to_dict()
        assert last_job_model_json2 == last_job_model_json


class TestModel_LogStoreResponse:
    """
    Test Class for LogStoreResponse
    """

    def test_log_store_response_serialization(self):
        """
        Test serialization/deserialization for LogStoreResponse
        """

        # Construct a json representation of a LogStoreResponse model
        log_store_response_model_json = {}
        log_store_response_model_json['engine_name'] = 'testString'
        log_store_response_model_json['engine_version'] = 'testString'
        log_store_response_model_json['id'] = 'testString'
        log_store_response_model_json['log_store_url'] = 'testString'

        # Construct a model instance of LogStoreResponse by calling from_dict on the json representation
        log_store_response_model = LogStoreResponse.from_dict(log_store_response_model_json)
        assert log_store_response_model != False

        # Construct a model instance of LogStoreResponse by calling from_dict on the json representation
        log_store_response_model_dict = LogStoreResponse.from_dict(log_store_response_model_json).__dict__
        log_store_response_model2 = LogStoreResponse(**log_store_response_model_dict)

        # Verify the model instances are equivalent
        assert log_store_response_model == log_store_response_model2

        # Convert model instance back to dict and verify no loss of data
        log_store_response_model_json2 = log_store_response_model.to_dict()
        assert log_store_response_model_json2 == log_store_response_model_json


class TestModel_LogStoreResponseList:
    """
    Test Class for LogStoreResponseList
    """

    def test_log_store_response_list_serialization(self):
        """
        Test serialization/deserialization for LogStoreResponseList
        """

        # Construct dict forms of any model objects needed in order to build this model.

        log_store_response_model = {}  # LogStoreResponse
        log_store_response_model['engine_name'] = 'testString'
        log_store_response_model['engine_version'] = 'testString'
        log_store_response_model['id'] = 'testString'
        log_store_response_model['log_store_url'] = 'testString'

        # Construct a json representation of a LogStoreResponseList model
        log_store_response_list_model_json = {}
        log_store_response_list_model_json['runtime_data'] = [log_store_response_model]

        # Construct a model instance of LogStoreResponseList by calling from_dict on the json representation
        log_store_response_list_model = LogStoreResponseList.from_dict(log_store_response_list_model_json)
        assert log_store_response_list_model != False

        # Construct a model instance of LogStoreResponseList by calling from_dict on the json representation
        log_store_response_list_model_dict = LogStoreResponseList.from_dict(log_store_response_list_model_json).__dict__
        log_store_response_list_model2 = LogStoreResponseList(**log_store_response_list_model_dict)

        # Verify the model instances are equivalent
        assert log_store_response_list_model == log_store_response_list_model2

        # Convert model instance back to dict and verify no loss of data
        log_store_response_list_model_json2 = log_store_response_list_model.to_dict()
        assert log_store_response_list_model_json2 == log_store_response_list_model_json


class TestModel_LogSummary:
    """
    Test Class for LogSummary
    """

    def test_log_summary_serialization(self):
        """
        Test serialization/deserialization for LogSummary
        """

        # Construct a json representation of a LogSummary model
        log_summary_model_json = {}
        log_summary_model_json['activity_status'] = 'testString'
        log_summary_model_json['detected_template_type'] = 'testString'
        log_summary_model_json['discarded_files'] = 26
        log_summary_model_json['error'] = 'testString'
        log_summary_model_json['resources_added'] = 26
        log_summary_model_json['resources_destroyed'] = 26
        log_summary_model_json['resources_modified'] = 26
        log_summary_model_json['scanned_files'] = 26
        log_summary_model_json['template_variable_count'] = 26
        log_summary_model_json['time_taken'] = 72.5

        # Construct a model instance of LogSummary by calling from_dict on the json representation
        log_summary_model = LogSummary.from_dict(log_summary_model_json)
        assert log_summary_model != False

        # Construct a model instance of LogSummary by calling from_dict on the json representation
        log_summary_model_dict = LogSummary.from_dict(log_summary_model_json).__dict__
        log_summary_model2 = LogSummary(**log_summary_model_dict)

        # Verify the model instances are equivalent
        assert log_summary_model == log_summary_model2

        # Convert model instance back to dict and verify no loss of data
        log_summary_model_json2 = log_summary_model.to_dict()
        assert log_summary_model_json2 == log_summary_model_json


class TestModel_OutputValuesInner:
    """
    Test Class for OutputValuesInner
    """

    def test_output_values_inner_serialization(self):
        """
        Test serialization/deserialization for OutputValuesInner
        """

        # Construct a json representation of a OutputValuesInner model
        output_values_inner_model_json = {}
        output_values_inner_model_json['folder'] = 'testString'
        output_values_inner_model_json['id'] = 'testString'
        output_values_inner_model_json['output_values'] = [{'anyKey': 'anyValue'}]
        output_values_inner_model_json['value_type'] = 'testString'

        # Construct a model instance of OutputValuesInner by calling from_dict on the json representation
        output_values_inner_model = OutputValuesInner.from_dict(output_values_inner_model_json)
        assert output_values_inner_model != False

        # Construct a model instance of OutputValuesInner by calling from_dict on the json representation
        output_values_inner_model_dict = OutputValuesInner.from_dict(output_values_inner_model_json).__dict__
        output_values_inner_model2 = OutputValuesInner(**output_values_inner_model_dict)

        # Verify the model instances are equivalent
        assert output_values_inner_model == output_values_inner_model2

        # Convert model instance back to dict and verify no loss of data
        output_values_inner_model_json2 = output_values_inner_model.to_dict()
        assert output_values_inner_model_json2 == output_values_inner_model_json


class TestModel_Policy:
    """
    Test Class for Policy
    """

    def test_policy_serialization(self):
        """
        Test serialization/deserialization for Policy
        """

        # Construct dict forms of any model objects needed in order to build this model.

        user_state_model = {}  # UserState
        user_state_model['state'] = 'draft'
        user_state_model['set_by'] = 'testString'
        user_state_model['set_at'] = '2019-01-01T12:00:00Z'

        policy_object_selector_model = {}  # PolicyObjectSelector
        policy_object_selector_model['kind'] = 'workspace'
        policy_object_selector_model['tags'] = ['testString']
        policy_object_selector_model['resource_groups'] = ['testString']
        policy_object_selector_model['locations'] = ['us-south']

        policy_objects_model = {}  # PolicyObjects
        policy_objects_model['selector_kind'] = 'ids'
        policy_objects_model['selector_ids'] = ['testString']
        policy_objects_model['selector_scope'] = [policy_object_selector_model]

        agent_assignment_policy_parameter_model = {}  # AgentAssignmentPolicyParameter
        agent_assignment_policy_parameter_model['selector_kind'] = 'ids'
        agent_assignment_policy_parameter_model['selector_ids'] = ['testString']
        agent_assignment_policy_parameter_model['selector_scope'] = [policy_object_selector_model]

        policy_parameter_model = {}  # PolicyParameter
        policy_parameter_model['agent_assignment_policy_parameter'] = agent_assignment_policy_parameter_model

        scoped_resource_model = {}  # ScopedResource
        scoped_resource_model['kind'] = 'workspace'
        scoped_resource_model['id'] = 'testString'

        # Construct a json representation of a Policy model
        policy_model_json = {}
        policy_model_json['name'] = 'Agent1-DevWS'
        policy_model_json['description'] = 'Policy for job execution of secured workspaces on agent1'
        policy_model_json['resource_group'] = 'Default'
        policy_model_json['tags'] = ['policy:secured-job']
        policy_model_json['location'] = 'us-south'
        policy_model_json['state'] = user_state_model
        policy_model_json['kind'] = 'agent_assignment_policy'
        policy_model_json['target'] = policy_objects_model
        policy_model_json['parameter'] = policy_parameter_model
        policy_model_json['scoped_resources'] = [scoped_resource_model]

        # Construct a model instance of Policy by calling from_dict on the json representation
        policy_model = Policy.from_dict(policy_model_json)
        assert policy_model != False

        # Construct a model instance of Policy by calling from_dict on the json representation
        policy_model_dict = Policy.from_dict(policy_model_json).__dict__
        policy_model2 = Policy(**policy_model_dict)

        # Verify the model instances are equivalent
        assert policy_model == policy_model2

        # Convert model instance back to dict and verify no loss of data
        policy_model_json2 = policy_model.to_dict()
        assert policy_model_json2 == policy_model_json


class TestModel_PolicyList:
    """
    Test Class for PolicyList
    """

    def test_policy_list_serialization(self):
        """
        Test serialization/deserialization for PolicyList
        """

        # Construct a json representation of a PolicyList model
        policy_list_model_json = {}
        policy_list_model_json['offset'] = 26

        # Construct a model instance of PolicyList by calling from_dict on the json representation
        policy_list_model = PolicyList.from_dict(policy_list_model_json)
        assert policy_list_model != False

        # Construct a model instance of PolicyList by calling from_dict on the json representation
        policy_list_model_dict = PolicyList.from_dict(policy_list_model_json).__dict__
        policy_list_model2 = PolicyList(**policy_list_model_dict)

        # Verify the model instances are equivalent
        assert policy_list_model == policy_list_model2

        # Convert model instance back to dict and verify no loss of data
        policy_list_model_json2 = policy_list_model.to_dict()
        assert policy_list_model_json2 == policy_list_model_json


class TestModel_PolicyLite:
    """
    Test Class for PolicyLite
    """

    def test_policy_lite_serialization(self):
        """
        Test serialization/deserialization for PolicyLite
        """

        # Construct dict forms of any model objects needed in order to build this model.

        user_state_model = {}  # UserState
        user_state_model['state'] = 'draft'
        user_state_model['set_by'] = 'testString'
        user_state_model['set_at'] = '2019-01-01T12:00:00Z'

        # Construct a json representation of a PolicyLite model
        policy_lite_model_json = {}
        policy_lite_model_json['location'] = 'us-south'
        policy_lite_model_json['state'] = user_state_model
        policy_lite_model_json['policy_kind'] = 'agent_assignment_policy'

        # Construct a model instance of PolicyLite by calling from_dict on the json representation
        policy_lite_model = PolicyLite.from_dict(policy_lite_model_json)
        assert policy_lite_model != False

        # Construct a model instance of PolicyLite by calling from_dict on the json representation
        policy_lite_model_dict = PolicyLite.from_dict(policy_lite_model_json).__dict__
        policy_lite_model2 = PolicyLite(**policy_lite_model_dict)

        # Verify the model instances are equivalent
        assert policy_lite_model == policy_lite_model2

        # Convert model instance back to dict and verify no loss of data
        policy_lite_model_json2 = policy_lite_model.to_dict()
        assert policy_lite_model_json2 == policy_lite_model_json


class TestModel_PolicyObjectSelector:
    """
    Test Class for PolicyObjectSelector
    """

    def test_policy_object_selector_serialization(self):
        """
        Test serialization/deserialization for PolicyObjectSelector
        """

        # Construct a json representation of a PolicyObjectSelector model
        policy_object_selector_model_json = {}
        policy_object_selector_model_json['kind'] = 'workspace'
        policy_object_selector_model_json['tags'] = ['testString']
        policy_object_selector_model_json['resource_groups'] = ['testString']
        policy_object_selector_model_json['locations'] = ['us-south']

        # Construct a model instance of PolicyObjectSelector by calling from_dict on the json representation
        policy_object_selector_model = PolicyObjectSelector.from_dict(policy_object_selector_model_json)
        assert policy_object_selector_model != False

        # Construct a model instance of PolicyObjectSelector by calling from_dict on the json representation
        policy_object_selector_model_dict = PolicyObjectSelector.from_dict(policy_object_selector_model_json).__dict__
        policy_object_selector_model2 = PolicyObjectSelector(**policy_object_selector_model_dict)

        # Verify the model instances are equivalent
        assert policy_object_selector_model == policy_object_selector_model2

        # Convert model instance back to dict and verify no loss of data
        policy_object_selector_model_json2 = policy_object_selector_model.to_dict()
        assert policy_object_selector_model_json2 == policy_object_selector_model_json


class TestModel_PolicyObjects:
    """
    Test Class for PolicyObjects
    """

    def test_policy_objects_serialization(self):
        """
        Test serialization/deserialization for PolicyObjects
        """

        # Construct dict forms of any model objects needed in order to build this model.

        policy_object_selector_model = {}  # PolicyObjectSelector
        policy_object_selector_model['kind'] = 'workspace'
        policy_object_selector_model['tags'] = ['testString']
        policy_object_selector_model['resource_groups'] = ['testString']
        policy_object_selector_model['locations'] = ['us-south']

        # Construct a json representation of a PolicyObjects model
        policy_objects_model_json = {}
        policy_objects_model_json['selector_kind'] = 'ids'
        policy_objects_model_json['selector_ids'] = ['testString']
        policy_objects_model_json['selector_scope'] = [policy_object_selector_model]

        # Construct a model instance of PolicyObjects by calling from_dict on the json representation
        policy_objects_model = PolicyObjects.from_dict(policy_objects_model_json)
        assert policy_objects_model != False

        # Construct a model instance of PolicyObjects by calling from_dict on the json representation
        policy_objects_model_dict = PolicyObjects.from_dict(policy_objects_model_json).__dict__
        policy_objects_model2 = PolicyObjects(**policy_objects_model_dict)

        # Verify the model instances are equivalent
        assert policy_objects_model == policy_objects_model2

        # Convert model instance back to dict and verify no loss of data
        policy_objects_model_json2 = policy_objects_model.to_dict()
        assert policy_objects_model_json2 == policy_objects_model_json


class TestModel_PolicyParameter:
    """
    Test Class for PolicyParameter
    """

    def test_policy_parameter_serialization(self):
        """
        Test serialization/deserialization for PolicyParameter
        """

        # Construct dict forms of any model objects needed in order to build this model.

        policy_object_selector_model = {}  # PolicyObjectSelector
        policy_object_selector_model['kind'] = 'workspace'
        policy_object_selector_model['tags'] = ['testString']
        policy_object_selector_model['resource_groups'] = ['testString']
        policy_object_selector_model['locations'] = ['us-south']

        agent_assignment_policy_parameter_model = {}  # AgentAssignmentPolicyParameter
        agent_assignment_policy_parameter_model['selector_kind'] = 'ids'
        agent_assignment_policy_parameter_model['selector_ids'] = ['testString']
        agent_assignment_policy_parameter_model['selector_scope'] = [policy_object_selector_model]

        # Construct a json representation of a PolicyParameter model
        policy_parameter_model_json = {}
        policy_parameter_model_json['agent_assignment_policy_parameter'] = agent_assignment_policy_parameter_model

        # Construct a model instance of PolicyParameter by calling from_dict on the json representation
        policy_parameter_model = PolicyParameter.from_dict(policy_parameter_model_json)
        assert policy_parameter_model != False

        # Construct a model instance of PolicyParameter by calling from_dict on the json representation
        policy_parameter_model_dict = PolicyParameter.from_dict(policy_parameter_model_json).__dict__
        policy_parameter_model2 = PolicyParameter(**policy_parameter_model_dict)

        # Verify the model instances are equivalent
        assert policy_parameter_model == policy_parameter_model2

        # Convert model instance back to dict and verify no loss of data
        policy_parameter_model_json2 = policy_parameter_model.to_dict()
        assert policy_parameter_model_json2 == policy_parameter_model_json


class TestModel_ResourceGroupResponse:
    """
    Test Class for ResourceGroupResponse
    """

    def test_resource_group_response_serialization(self):
        """
        Test serialization/deserialization for ResourceGroupResponse
        """

        # Construct a json representation of a ResourceGroupResponse model
        resource_group_response_model_json = {}
        resource_group_response_model_json['account_id'] = 'testString'
        resource_group_response_model_json['crn'] = 'testString'
        resource_group_response_model_json['default'] = True
        resource_group_response_model_json['name'] = 'testString'
        resource_group_response_model_json['resource_group_id'] = 'testString'
        resource_group_response_model_json['state'] = 'testString'

        # Construct a model instance of ResourceGroupResponse by calling from_dict on the json representation
        resource_group_response_model = ResourceGroupResponse.from_dict(resource_group_response_model_json)
        assert resource_group_response_model != False

        # Construct a model instance of ResourceGroupResponse by calling from_dict on the json representation
        resource_group_response_model_dict = ResourceGroupResponse.from_dict(
            resource_group_response_model_json
        ).__dict__
        resource_group_response_model2 = ResourceGroupResponse(**resource_group_response_model_dict)

        # Verify the model instances are equivalent
        assert resource_group_response_model == resource_group_response_model2

        # Convert model instance back to dict and verify no loss of data
        resource_group_response_model_json2 = resource_group_response_model.to_dict()
        assert resource_group_response_model_json2 == resource_group_response_model_json


class TestModel_ResourceQuery:
    """
    Test Class for ResourceQuery
    """

    def test_resource_query_serialization(self):
        """
        Test serialization/deserialization for ResourceQuery
        """

        # Construct dict forms of any model objects needed in order to build this model.

        resource_query_param_model = {}  # ResourceQueryParam
        resource_query_param_model['name'] = 'testString'
        resource_query_param_model['value'] = 'testString'
        resource_query_param_model['description'] = 'testString'

        # Construct a json representation of a ResourceQuery model
        resource_query_model_json = {}
        resource_query_model_json['query_type'] = 'workspaces'
        resource_query_model_json['query_condition'] = [resource_query_param_model]
        resource_query_model_json['query_select'] = ['testString']

        # Construct a model instance of ResourceQuery by calling from_dict on the json representation
        resource_query_model = ResourceQuery.from_dict(resource_query_model_json)
        assert resource_query_model != False

        # Construct a model instance of ResourceQuery by calling from_dict on the json representation
        resource_query_model_dict = ResourceQuery.from_dict(resource_query_model_json).__dict__
        resource_query_model2 = ResourceQuery(**resource_query_model_dict)

        # Verify the model instances are equivalent
        assert resource_query_model == resource_query_model2

        # Convert model instance back to dict and verify no loss of data
        resource_query_model_json2 = resource_query_model.to_dict()
        assert resource_query_model_json2 == resource_query_model_json


class TestModel_ResourceQueryParam:
    """
    Test Class for ResourceQueryParam
    """

    def test_resource_query_param_serialization(self):
        """
        Test serialization/deserialization for ResourceQueryParam
        """

        # Construct a json representation of a ResourceQueryParam model
        resource_query_param_model_json = {}
        resource_query_param_model_json['name'] = 'testString'
        resource_query_param_model_json['value'] = 'testString'
        resource_query_param_model_json['description'] = 'testString'

        # Construct a model instance of ResourceQueryParam by calling from_dict on the json representation
        resource_query_param_model = ResourceQueryParam.from_dict(resource_query_param_model_json)
        assert resource_query_param_model != False

        # Construct a model instance of ResourceQueryParam by calling from_dict on the json representation
        resource_query_param_model_dict = ResourceQueryParam.from_dict(resource_query_param_model_json).__dict__
        resource_query_param_model2 = ResourceQueryParam(**resource_query_param_model_dict)

        # Verify the model instances are equivalent
        assert resource_query_param_model == resource_query_param_model2

        # Convert model instance back to dict and verify no loss of data
        resource_query_param_model_json2 = resource_query_param_model.to_dict()
        assert resource_query_param_model_json2 == resource_query_param_model_json


class TestModel_ResourceQueryRecord:
    """
    Test Class for ResourceQueryRecord
    """

    def test_resource_query_record_serialization(self):
        """
        Test serialization/deserialization for ResourceQueryRecord
        """

        # Construct dict forms of any model objects needed in order to build this model.

        resource_query_param_model = {}  # ResourceQueryParam
        resource_query_param_model['name'] = 'testString'
        resource_query_param_model['value'] = 'testString'
        resource_query_param_model['description'] = 'testString'

        resource_query_model = {}  # ResourceQuery
        resource_query_model['query_type'] = 'workspaces'
        resource_query_model['query_condition'] = [resource_query_param_model]
        resource_query_model['query_select'] = ['testString']

        # Construct a json representation of a ResourceQueryRecord model
        resource_query_record_model_json = {}
        resource_query_record_model_json['type'] = 'vsi'
        resource_query_record_model_json['name'] = 'testString'
        resource_query_record_model_json['queries'] = [resource_query_model]

        # Construct a model instance of ResourceQueryRecord by calling from_dict on the json representation
        resource_query_record_model = ResourceQueryRecord.from_dict(resource_query_record_model_json)
        assert resource_query_record_model != False

        # Construct a model instance of ResourceQueryRecord by calling from_dict on the json representation
        resource_query_record_model_dict = ResourceQueryRecord.from_dict(resource_query_record_model_json).__dict__
        resource_query_record_model2 = ResourceQueryRecord(**resource_query_record_model_dict)

        # Verify the model instances are equivalent
        assert resource_query_record_model == resource_query_record_model2

        # Convert model instance back to dict and verify no loss of data
        resource_query_record_model_json2 = resource_query_record_model.to_dict()
        assert resource_query_record_model_json2 == resource_query_record_model_json


class TestModel_ResourceQueryRecordList:
    """
    Test Class for ResourceQueryRecordList
    """

    def test_resource_query_record_list_serialization(self):
        """
        Test serialization/deserialization for ResourceQueryRecordList
        """

        # Construct dict forms of any model objects needed in order to build this model.

        resource_query_param_model = {}  # ResourceQueryParam
        resource_query_param_model['name'] = 'testString'
        resource_query_param_model['value'] = 'testString'
        resource_query_param_model['description'] = 'testString'

        resource_query_model = {}  # ResourceQuery
        resource_query_model['query_type'] = 'workspaces'
        resource_query_model['query_condition'] = [resource_query_param_model]
        resource_query_model['query_select'] = ['testString']

        resource_query_record_model = {}  # ResourceQueryRecord
        resource_query_record_model['type'] = 'vsi'
        resource_query_record_model['name'] = 'testString'
        resource_query_record_model['queries'] = [resource_query_model]

        # Construct a json representation of a ResourceQueryRecordList model
        resource_query_record_list_model_json = {}
        resource_query_record_list_model_json['total_count'] = 26
        resource_query_record_list_model_json['limit'] = 26
        resource_query_record_list_model_json['offset'] = 26
        resource_query_record_list_model_json['resource_queries'] = [resource_query_record_model]

        # Construct a model instance of ResourceQueryRecordList by calling from_dict on the json representation
        resource_query_record_list_model = ResourceQueryRecordList.from_dict(resource_query_record_list_model_json)
        assert resource_query_record_list_model != False

        # Construct a model instance of ResourceQueryRecordList by calling from_dict on the json representation
        resource_query_record_list_model_dict = ResourceQueryRecordList.from_dict(
            resource_query_record_list_model_json
        ).__dict__
        resource_query_record_list_model2 = ResourceQueryRecordList(**resource_query_record_list_model_dict)

        # Verify the model instances are equivalent
        assert resource_query_record_list_model == resource_query_record_list_model2

        # Convert model instance back to dict and verify no loss of data
        resource_query_record_list_model_json2 = resource_query_record_list_model.to_dict()
        assert resource_query_record_list_model_json2 == resource_query_record_list_model_json


class TestModel_ResourceQueryResponseRecord:
    """
    Test Class for ResourceQueryResponseRecord
    """

    def test_resource_query_response_record_serialization(self):
        """
        Test serialization/deserialization for ResourceQueryResponseRecord
        """

        # Construct dict forms of any model objects needed in order to build this model.

        resource_query_param_model = {}  # ResourceQueryParam
        resource_query_param_model['name'] = 'testString'
        resource_query_param_model['value'] = 'testString'
        resource_query_param_model['description'] = 'testString'

        resource_query_response_record_query_output_model = {}  # ResourceQueryResponseRecordQueryOutput
        resource_query_response_record_query_output_model['name'] = 'testString'
        resource_query_response_record_query_output_model['value'] = 'testString'

        resource_query_response_record_response_model = {}  # ResourceQueryResponseRecordResponse
        resource_query_response_record_response_model['query_type'] = 'workspaces'
        resource_query_response_record_response_model['query_condition'] = [resource_query_param_model]
        resource_query_response_record_response_model['query_select'] = ['testString']
        resource_query_response_record_response_model['query_output'] = [
            resource_query_response_record_query_output_model
        ]

        # Construct a json representation of a ResourceQueryResponseRecord model
        resource_query_response_record_model_json = {}
        resource_query_response_record_model_json['response'] = [resource_query_response_record_response_model]

        # Construct a model instance of ResourceQueryResponseRecord by calling from_dict on the json representation
        resource_query_response_record_model = ResourceQueryResponseRecord.from_dict(
            resource_query_response_record_model_json
        )
        assert resource_query_response_record_model != False

        # Construct a model instance of ResourceQueryResponseRecord by calling from_dict on the json representation
        resource_query_response_record_model_dict = ResourceQueryResponseRecord.from_dict(
            resource_query_response_record_model_json
        ).__dict__
        resource_query_response_record_model2 = ResourceQueryResponseRecord(**resource_query_response_record_model_dict)

        # Verify the model instances are equivalent
        assert resource_query_response_record_model == resource_query_response_record_model2

        # Convert model instance back to dict and verify no loss of data
        resource_query_response_record_model_json2 = resource_query_response_record_model.to_dict()
        assert resource_query_response_record_model_json2 == resource_query_response_record_model_json


class TestModel_ResourceQueryResponseRecordQueryOutput:
    """
    Test Class for ResourceQueryResponseRecordQueryOutput
    """

    def test_resource_query_response_record_query_output_serialization(self):
        """
        Test serialization/deserialization for ResourceQueryResponseRecordQueryOutput
        """

        # Construct a json representation of a ResourceQueryResponseRecordQueryOutput model
        resource_query_response_record_query_output_model_json = {}
        resource_query_response_record_query_output_model_json['name'] = 'testString'
        resource_query_response_record_query_output_model_json['value'] = 'testString'

        # Construct a model instance of ResourceQueryResponseRecordQueryOutput by calling from_dict on the json representation
        resource_query_response_record_query_output_model = ResourceQueryResponseRecordQueryOutput.from_dict(
            resource_query_response_record_query_output_model_json
        )
        assert resource_query_response_record_query_output_model != False

        # Construct a model instance of ResourceQueryResponseRecordQueryOutput by calling from_dict on the json representation
        resource_query_response_record_query_output_model_dict = ResourceQueryResponseRecordQueryOutput.from_dict(
            resource_query_response_record_query_output_model_json
        ).__dict__
        resource_query_response_record_query_output_model2 = ResourceQueryResponseRecordQueryOutput(
            **resource_query_response_record_query_output_model_dict
        )

        # Verify the model instances are equivalent
        assert resource_query_response_record_query_output_model == resource_query_response_record_query_output_model2

        # Convert model instance back to dict and verify no loss of data
        resource_query_response_record_query_output_model_json2 = (
            resource_query_response_record_query_output_model.to_dict()
        )
        assert (
            resource_query_response_record_query_output_model_json2
            == resource_query_response_record_query_output_model_json
        )


class TestModel_ResourceQueryResponseRecordResponse:
    """
    Test Class for ResourceQueryResponseRecordResponse
    """

    def test_resource_query_response_record_response_serialization(self):
        """
        Test serialization/deserialization for ResourceQueryResponseRecordResponse
        """

        # Construct dict forms of any model objects needed in order to build this model.

        resource_query_param_model = {}  # ResourceQueryParam
        resource_query_param_model['name'] = 'testString'
        resource_query_param_model['value'] = 'testString'
        resource_query_param_model['description'] = 'testString'

        resource_query_response_record_query_output_model = {}  # ResourceQueryResponseRecordQueryOutput
        resource_query_response_record_query_output_model['name'] = 'testString'
        resource_query_response_record_query_output_model['value'] = 'testString'

        # Construct a json representation of a ResourceQueryResponseRecordResponse model
        resource_query_response_record_response_model_json = {}
        resource_query_response_record_response_model_json['query_type'] = 'workspaces'
        resource_query_response_record_response_model_json['query_condition'] = [resource_query_param_model]
        resource_query_response_record_response_model_json['query_select'] = ['testString']
        resource_query_response_record_response_model_json['query_output'] = [
            resource_query_response_record_query_output_model
        ]

        # Construct a model instance of ResourceQueryResponseRecordResponse by calling from_dict on the json representation
        resource_query_response_record_response_model = ResourceQueryResponseRecordResponse.from_dict(
            resource_query_response_record_response_model_json
        )
        assert resource_query_response_record_response_model != False

        # Construct a model instance of ResourceQueryResponseRecordResponse by calling from_dict on the json representation
        resource_query_response_record_response_model_dict = ResourceQueryResponseRecordResponse.from_dict(
            resource_query_response_record_response_model_json
        ).__dict__
        resource_query_response_record_response_model2 = ResourceQueryResponseRecordResponse(
            **resource_query_response_record_response_model_dict
        )

        # Verify the model instances are equivalent
        assert resource_query_response_record_response_model == resource_query_response_record_response_model2

        # Convert model instance back to dict and verify no loss of data
        resource_query_response_record_response_model_json2 = resource_query_response_record_response_model.to_dict()
        assert resource_query_response_record_response_model_json2 == resource_query_response_record_response_model_json


class TestModel_SchematicsLocations:
    """
    Test Class for SchematicsLocations
    """

    def test_schematics_locations_serialization(self):
        """
        Test serialization/deserialization for SchematicsLocations
        """

        # Construct dict forms of any model objects needed in order to build this model.

        agent_metadata_info_model = {}  # AgentMetadataInfo
        agent_metadata_info_model['name'] = 'purpose'
        agent_metadata_info_model['value'] = ['git', 'terraform', 'ansible']

        # Construct a json representation of a SchematicsLocations model
        schematics_locations_model_json = {}
        schematics_locations_model_json['name'] = 'testString'
        schematics_locations_model_json['id'] = 'testString'
        schematics_locations_model_json['country'] = 'testString'
        schematics_locations_model_json['geography'] = 'testString'
        schematics_locations_model_json['geography_code'] = 'testString'
        schematics_locations_model_json['metro'] = 'testString'
        schematics_locations_model_json['multizone_metro'] = 'testString'
        schematics_locations_model_json['kind'] = 'testString'
        schematics_locations_model_json['paired_region'] = ['testString']
        schematics_locations_model_json['restricted'] = True
        schematics_locations_model_json['agent_metadata'] = [agent_metadata_info_model]

        # Construct a model instance of SchematicsLocations by calling from_dict on the json representation
        schematics_locations_model = SchematicsLocations.from_dict(schematics_locations_model_json)
        assert schematics_locations_model != False

        # Construct a model instance of SchematicsLocations by calling from_dict on the json representation
        schematics_locations_model_dict = SchematicsLocations.from_dict(schematics_locations_model_json).__dict__
        schematics_locations_model2 = SchematicsLocations(**schematics_locations_model_dict)

        # Verify the model instances are equivalent
        assert schematics_locations_model == schematics_locations_model2

        # Convert model instance back to dict and verify no loss of data
        schematics_locations_model_json2 = schematics_locations_model.to_dict()
        assert schematics_locations_model_json2 == schematics_locations_model_json


class TestModel_SchematicsLocationsList:
    """
    Test Class for SchematicsLocationsList
    """

    def test_schematics_locations_list_serialization(self):
        """
        Test serialization/deserialization for SchematicsLocationsList
        """

        # Construct dict forms of any model objects needed in order to build this model.

        schematics_locations_lite_model = {}  # SchematicsLocationsLite
        schematics_locations_lite_model['region'] = 'testString'
        schematics_locations_lite_model['metro'] = 'testString'
        schematics_locations_lite_model['geography_code'] = 'testString'
        schematics_locations_lite_model['geography'] = 'testString'
        schematics_locations_lite_model['country'] = 'testString'
        schematics_locations_lite_model['kind'] = 'testString'
        schematics_locations_lite_model['paired_region'] = ['testString']
        schematics_locations_lite_model['restricted'] = True
        schematics_locations_lite_model['display_name'] = 'testString'
        schematics_locations_lite_model['schematics_regional_public_endpoint'] = 'testString'
        schematics_locations_lite_model['schematics_regional_private_endpoint'] = 'testString'

        # Construct a json representation of a SchematicsLocationsList model
        schematics_locations_list_model_json = {}
        schematics_locations_list_model_json['locations'] = [schematics_locations_lite_model]

        # Construct a model instance of SchematicsLocationsList by calling from_dict on the json representation
        schematics_locations_list_model = SchematicsLocationsList.from_dict(schematics_locations_list_model_json)
        assert schematics_locations_list_model != False

        # Construct a model instance of SchematicsLocationsList by calling from_dict on the json representation
        schematics_locations_list_model_dict = SchematicsLocationsList.from_dict(
            schematics_locations_list_model_json
        ).__dict__
        schematics_locations_list_model2 = SchematicsLocationsList(**schematics_locations_list_model_dict)

        # Verify the model instances are equivalent
        assert schematics_locations_list_model == schematics_locations_list_model2

        # Convert model instance back to dict and verify no loss of data
        schematics_locations_list_model_json2 = schematics_locations_list_model.to_dict()
        assert schematics_locations_list_model_json2 == schematics_locations_list_model_json


class TestModel_SchematicsLocationsLite:
    """
    Test Class for SchematicsLocationsLite
    """

    def test_schematics_locations_lite_serialization(self):
        """
        Test serialization/deserialization for SchematicsLocationsLite
        """

        # Construct a json representation of a SchematicsLocationsLite model
        schematics_locations_lite_model_json = {}
        schematics_locations_lite_model_json['region'] = 'testString'
        schematics_locations_lite_model_json['metro'] = 'testString'
        schematics_locations_lite_model_json['geography_code'] = 'testString'
        schematics_locations_lite_model_json['geography'] = 'testString'
        schematics_locations_lite_model_json['country'] = 'testString'
        schematics_locations_lite_model_json['kind'] = 'testString'
        schematics_locations_lite_model_json['paired_region'] = ['testString']
        schematics_locations_lite_model_json['restricted'] = True
        schematics_locations_lite_model_json['display_name'] = 'testString'
        schematics_locations_lite_model_json['schematics_regional_public_endpoint'] = 'testString'
        schematics_locations_lite_model_json['schematics_regional_private_endpoint'] = 'testString'

        # Construct a model instance of SchematicsLocationsLite by calling from_dict on the json representation
        schematics_locations_lite_model = SchematicsLocationsLite.from_dict(schematics_locations_lite_model_json)
        assert schematics_locations_lite_model != False

        # Construct a model instance of SchematicsLocationsLite by calling from_dict on the json representation
        schematics_locations_lite_model_dict = SchematicsLocationsLite.from_dict(
            schematics_locations_lite_model_json
        ).__dict__
        schematics_locations_lite_model2 = SchematicsLocationsLite(**schematics_locations_lite_model_dict)

        # Verify the model instances are equivalent
        assert schematics_locations_lite_model == schematics_locations_lite_model2

        # Convert model instance back to dict and verify no loss of data
        schematics_locations_lite_model_json2 = schematics_locations_lite_model.to_dict()
        assert schematics_locations_lite_model_json2 == schematics_locations_lite_model_json


class TestModel_ScopedResource:
    """
    Test Class for ScopedResource
    """

    def test_scoped_resource_serialization(self):
        """
        Test serialization/deserialization for ScopedResource
        """

        # Construct a json representation of a ScopedResource model
        scoped_resource_model_json = {}
        scoped_resource_model_json['kind'] = 'workspace'
        scoped_resource_model_json['id'] = 'testString'

        # Construct a model instance of ScopedResource by calling from_dict on the json representation
        scoped_resource_model = ScopedResource.from_dict(scoped_resource_model_json)
        assert scoped_resource_model != False

        # Construct a model instance of ScopedResource by calling from_dict on the json representation
        scoped_resource_model_dict = ScopedResource.from_dict(scoped_resource_model_json).__dict__
        scoped_resource_model2 = ScopedResource(**scoped_resource_model_dict)

        # Verify the model instances are equivalent
        assert scoped_resource_model == scoped_resource_model2

        # Convert model instance back to dict and verify no loss of data
        scoped_resource_model_json2 = scoped_resource_model.to_dict()
        assert scoped_resource_model_json2 == scoped_resource_model_json


class TestModel_ServiceExtensions:
    """
    Test Class for ServiceExtensions
    """

    def test_service_extensions_serialization(self):
        """
        Test serialization/deserialization for ServiceExtensions
        """

        # Construct a json representation of a ServiceExtensions model
        service_extensions_model_json = {}
        service_extensions_model_json['name'] = 'flavor'
        service_extensions_model_json['value'] = 'testString'
        service_extensions_model_json['type'] = 'string'

        # Construct a model instance of ServiceExtensions by calling from_dict on the json representation
        service_extensions_model = ServiceExtensions.from_dict(service_extensions_model_json)
        assert service_extensions_model != False

        # Construct a model instance of ServiceExtensions by calling from_dict on the json representation
        service_extensions_model_dict = ServiceExtensions.from_dict(service_extensions_model_json).__dict__
        service_extensions_model2 = ServiceExtensions(**service_extensions_model_dict)

        # Verify the model instances are equivalent
        assert service_extensions_model == service_extensions_model2

        # Convert model instance back to dict and verify no loss of data
        service_extensions_model_json2 = service_extensions_model.to_dict()
        assert service_extensions_model_json2 == service_extensions_model_json


class TestModel_SharedTargetData:
    """
    Test Class for SharedTargetData
    """

    def test_shared_target_data_serialization(self):
        """
        Test serialization/deserialization for SharedTargetData
        """

        # Construct a json representation of a SharedTargetData model
        shared_target_data_model_json = {}
        shared_target_data_model_json['cluster_created_on'] = 'testString'
        shared_target_data_model_json['cluster_id'] = 'testString'
        shared_target_data_model_json['cluster_name'] = 'testString'
        shared_target_data_model_json['cluster_type'] = 'testString'
        shared_target_data_model_json['entitlement_keys'] = [{'anyKey': 'anyValue'}]
        shared_target_data_model_json['namespace'] = 'testString'
        shared_target_data_model_json['region'] = 'testString'
        shared_target_data_model_json['resource_group_id'] = 'testString'
        shared_target_data_model_json['worker_count'] = 26
        shared_target_data_model_json['worker_machine_type'] = 'testString'

        # Construct a model instance of SharedTargetData by calling from_dict on the json representation
        shared_target_data_model = SharedTargetData.from_dict(shared_target_data_model_json)
        assert shared_target_data_model != False

        # Construct a model instance of SharedTargetData by calling from_dict on the json representation
        shared_target_data_model_dict = SharedTargetData.from_dict(shared_target_data_model_json).__dict__
        shared_target_data_model2 = SharedTargetData(**shared_target_data_model_dict)

        # Verify the model instances are equivalent
        assert shared_target_data_model == shared_target_data_model2

        # Convert model instance back to dict and verify no loss of data
        shared_target_data_model_json2 = shared_target_data_model.to_dict()
        assert shared_target_data_model_json2 == shared_target_data_model_json


class TestModel_SharedTargetDataResponse:
    """
    Test Class for SharedTargetDataResponse
    """

    def test_shared_target_data_response_serialization(self):
        """
        Test serialization/deserialization for SharedTargetDataResponse
        """

        # Construct a json representation of a SharedTargetDataResponse model
        shared_target_data_response_model_json = {}
        shared_target_data_response_model_json['cluster_id'] = 'testString'
        shared_target_data_response_model_json['cluster_name'] = 'testString'
        shared_target_data_response_model_json['entitlement_keys'] = [{'anyKey': 'anyValue'}]
        shared_target_data_response_model_json['namespace'] = 'testString'
        shared_target_data_response_model_json['region'] = 'testString'
        shared_target_data_response_model_json['resource_group_id'] = 'testString'

        # Construct a model instance of SharedTargetDataResponse by calling from_dict on the json representation
        shared_target_data_response_model = SharedTargetDataResponse.from_dict(shared_target_data_response_model_json)
        assert shared_target_data_response_model != False

        # Construct a model instance of SharedTargetDataResponse by calling from_dict on the json representation
        shared_target_data_response_model_dict = SharedTargetDataResponse.from_dict(
            shared_target_data_response_model_json
        ).__dict__
        shared_target_data_response_model2 = SharedTargetDataResponse(**shared_target_data_response_model_dict)

        # Verify the model instances are equivalent
        assert shared_target_data_response_model == shared_target_data_response_model2

        # Convert model instance back to dict and verify no loss of data
        shared_target_data_response_model_json2 = shared_target_data_response_model.to_dict()
        assert shared_target_data_response_model_json2 == shared_target_data_response_model_json


class TestModel_StateStoreResponse:
    """
    Test Class for StateStoreResponse
    """

    def test_state_store_response_serialization(self):
        """
        Test serialization/deserialization for StateStoreResponse
        """

        # Construct a json representation of a StateStoreResponse model
        state_store_response_model_json = {}
        state_store_response_model_json['engine_name'] = 'testString'
        state_store_response_model_json['engine_version'] = 'testString'
        state_store_response_model_json['id'] = 'testString'
        state_store_response_model_json['state_store_url'] = 'testString'

        # Construct a model instance of StateStoreResponse by calling from_dict on the json representation
        state_store_response_model = StateStoreResponse.from_dict(state_store_response_model_json)
        assert state_store_response_model != False

        # Construct a model instance of StateStoreResponse by calling from_dict on the json representation
        state_store_response_model_dict = StateStoreResponse.from_dict(state_store_response_model_json).__dict__
        state_store_response_model2 = StateStoreResponse(**state_store_response_model_dict)

        # Verify the model instances are equivalent
        assert state_store_response_model == state_store_response_model2

        # Convert model instance back to dict and verify no loss of data
        state_store_response_model_json2 = state_store_response_model.to_dict()
        assert state_store_response_model_json2 == state_store_response_model_json


class TestModel_StateStoreResponseList:
    """
    Test Class for StateStoreResponseList
    """

    def test_state_store_response_list_serialization(self):
        """
        Test serialization/deserialization for StateStoreResponseList
        """

        # Construct dict forms of any model objects needed in order to build this model.

        state_store_response_model = {}  # StateStoreResponse
        state_store_response_model['engine_name'] = 'testString'
        state_store_response_model['engine_version'] = 'testString'
        state_store_response_model['id'] = 'testString'
        state_store_response_model['state_store_url'] = 'testString'

        # Construct a json representation of a StateStoreResponseList model
        state_store_response_list_model_json = {}
        state_store_response_list_model_json['runtime_data'] = [state_store_response_model]

        # Construct a model instance of StateStoreResponseList by calling from_dict on the json representation
        state_store_response_list_model = StateStoreResponseList.from_dict(state_store_response_list_model_json)
        assert state_store_response_list_model != False

        # Construct a model instance of StateStoreResponseList by calling from_dict on the json representation
        state_store_response_list_model_dict = StateStoreResponseList.from_dict(
            state_store_response_list_model_json
        ).__dict__
        state_store_response_list_model2 = StateStoreResponseList(**state_store_response_list_model_dict)

        # Verify the model instances are equivalent
        assert state_store_response_list_model == state_store_response_list_model2

        # Convert model instance back to dict and verify no loss of data
        state_store_response_list_model_json2 = state_store_response_list_model.to_dict()
        assert state_store_response_list_model_json2 == state_store_response_list_model_json


class TestModel_SystemLock:
    """
    Test Class for SystemLock
    """

    def test_system_lock_serialization(self):
        """
        Test serialization/deserialization for SystemLock
        """

        # Construct a json representation of a SystemLock model
        system_lock_model_json = {}
        system_lock_model_json['sys_locked'] = True
        system_lock_model_json['sys_locked_by'] = 'testString'
        system_lock_model_json['sys_locked_at'] = '2019-01-01T12:00:00Z'

        # Construct a model instance of SystemLock by calling from_dict on the json representation
        system_lock_model = SystemLock.from_dict(system_lock_model_json)
        assert system_lock_model != False

        # Construct a model instance of SystemLock by calling from_dict on the json representation
        system_lock_model_dict = SystemLock.from_dict(system_lock_model_json).__dict__
        system_lock_model2 = SystemLock(**system_lock_model_dict)

        # Verify the model instances are equivalent
        assert system_lock_model == system_lock_model2

        # Convert model instance back to dict and verify no loss of data
        system_lock_model_json2 = system_lock_model.to_dict()
        assert system_lock_model_json2 == system_lock_model_json


class TestModel_TemplateMetaDataResponse:
    """
    Test Class for TemplateMetaDataResponse
    """

    def test_template_meta_data_response_serialization(self):
        """
        Test serialization/deserialization for TemplateMetaDataResponse
        """

        # Construct dict forms of any model objects needed in order to build this model.

        variable_metadata_model = {}  # VariableMetadata
        variable_metadata_model['type'] = 'boolean'
        variable_metadata_model['aliases'] = ['testString']
        variable_metadata_model['description'] = 'testString'
        variable_metadata_model['cloud_data_type'] = 'testString'
        variable_metadata_model['default_value'] = 'testString'
        variable_metadata_model['link_status'] = 'normal'
        variable_metadata_model['secure'] = True
        variable_metadata_model['immutable'] = True
        variable_metadata_model['hidden'] = True
        variable_metadata_model['required'] = True
        variable_metadata_model['options'] = ['testString']
        variable_metadata_model['min_value'] = 38
        variable_metadata_model['max_value'] = 38
        variable_metadata_model['min_length'] = 38
        variable_metadata_model['max_length'] = 38
        variable_metadata_model['matches'] = 'testString'
        variable_metadata_model['position'] = 38
        variable_metadata_model['group_by'] = 'testString'
        variable_metadata_model['source'] = 'testString'

        variable_data_model = {}  # VariableData
        variable_data_model['name'] = 'testString'
        variable_data_model['value'] = 'testString'
        variable_data_model['use_default'] = True
        variable_data_model['metadata'] = variable_metadata_model

        # Construct a json representation of a TemplateMetaDataResponse model
        template_meta_data_response_model_json = {}
        template_meta_data_response_model_json['type'] = 'testString'
        template_meta_data_response_model_json['variables'] = [variable_data_model]

        # Construct a model instance of TemplateMetaDataResponse by calling from_dict on the json representation
        template_meta_data_response_model = TemplateMetaDataResponse.from_dict(template_meta_data_response_model_json)
        assert template_meta_data_response_model != False

        # Construct a model instance of TemplateMetaDataResponse by calling from_dict on the json representation
        template_meta_data_response_model_dict = TemplateMetaDataResponse.from_dict(
            template_meta_data_response_model_json
        ).__dict__
        template_meta_data_response_model2 = TemplateMetaDataResponse(**template_meta_data_response_model_dict)

        # Verify the model instances are equivalent
        assert template_meta_data_response_model == template_meta_data_response_model2

        # Convert model instance back to dict and verify no loss of data
        template_meta_data_response_model_json2 = template_meta_data_response_model.to_dict()
        assert template_meta_data_response_model_json2 == template_meta_data_response_model_json


class TestModel_TemplateReadme:
    """
    Test Class for TemplateReadme
    """

    def test_template_readme_serialization(self):
        """
        Test serialization/deserialization for TemplateReadme
        """

        # Construct a json representation of a TemplateReadme model
        template_readme_model_json = {}
        template_readme_model_json['readme'] = 'testString'

        # Construct a model instance of TemplateReadme by calling from_dict on the json representation
        template_readme_model = TemplateReadme.from_dict(template_readme_model_json)
        assert template_readme_model != False

        # Construct a model instance of TemplateReadme by calling from_dict on the json representation
        template_readme_model_dict = TemplateReadme.from_dict(template_readme_model_json).__dict__
        template_readme_model2 = TemplateReadme(**template_readme_model_dict)

        # Verify the model instances are equivalent
        assert template_readme_model == template_readme_model2

        # Convert model instance back to dict and verify no loss of data
        template_readme_model_json2 = template_readme_model.to_dict()
        assert template_readme_model_json2 == template_readme_model_json


class TestModel_TemplateRepoRequest:
    """
    Test Class for TemplateRepoRequest
    """

    def test_template_repo_request_serialization(self):
        """
        Test serialization/deserialization for TemplateRepoRequest
        """

        # Construct a json representation of a TemplateRepoRequest model
        template_repo_request_model_json = {}
        template_repo_request_model_json['branch'] = 'testString'
        template_repo_request_model_json['release'] = 'testString'
        template_repo_request_model_json['repo_sha_value'] = 'testString'
        template_repo_request_model_json['repo_url'] = 'testString'
        template_repo_request_model_json['url'] = 'testString'
        template_repo_request_model_json['skip_submodules_checkout'] = True

        # Construct a model instance of TemplateRepoRequest by calling from_dict on the json representation
        template_repo_request_model = TemplateRepoRequest.from_dict(template_repo_request_model_json)
        assert template_repo_request_model != False

        # Construct a model instance of TemplateRepoRequest by calling from_dict on the json representation
        template_repo_request_model_dict = TemplateRepoRequest.from_dict(template_repo_request_model_json).__dict__
        template_repo_request_model2 = TemplateRepoRequest(**template_repo_request_model_dict)

        # Verify the model instances are equivalent
        assert template_repo_request_model == template_repo_request_model2

        # Convert model instance back to dict and verify no loss of data
        template_repo_request_model_json2 = template_repo_request_model.to_dict()
        assert template_repo_request_model_json2 == template_repo_request_model_json


class TestModel_TemplateRepoResponse:
    """
    Test Class for TemplateRepoResponse
    """

    def test_template_repo_response_serialization(self):
        """
        Test serialization/deserialization for TemplateRepoResponse
        """

        # Construct a json representation of a TemplateRepoResponse model
        template_repo_response_model_json = {}
        template_repo_response_model_json['branch'] = 'testString'
        template_repo_response_model_json['full_url'] = 'testString'
        template_repo_response_model_json['has_uploadedgitrepotar'] = True
        template_repo_response_model_json['release'] = 'testString'
        template_repo_response_model_json['repo_sha_value'] = 'testString'
        template_repo_response_model_json['repo_url'] = 'testString'
        template_repo_response_model_json['url'] = 'testString'
        template_repo_response_model_json['skip_submodules_checkout'] = True

        # Construct a model instance of TemplateRepoResponse by calling from_dict on the json representation
        template_repo_response_model = TemplateRepoResponse.from_dict(template_repo_response_model_json)
        assert template_repo_response_model != False

        # Construct a model instance of TemplateRepoResponse by calling from_dict on the json representation
        template_repo_response_model_dict = TemplateRepoResponse.from_dict(template_repo_response_model_json).__dict__
        template_repo_response_model2 = TemplateRepoResponse(**template_repo_response_model_dict)

        # Verify the model instances are equivalent
        assert template_repo_response_model == template_repo_response_model2

        # Convert model instance back to dict and verify no loss of data
        template_repo_response_model_json2 = template_repo_response_model.to_dict()
        assert template_repo_response_model_json2 == template_repo_response_model_json


class TestModel_TemplateRepoTarUploadResponse:
    """
    Test Class for TemplateRepoTarUploadResponse
    """

    def test_template_repo_tar_upload_response_serialization(self):
        """
        Test serialization/deserialization for TemplateRepoTarUploadResponse
        """

        # Construct a json representation of a TemplateRepoTarUploadResponse model
        template_repo_tar_upload_response_model_json = {}
        template_repo_tar_upload_response_model_json['file_value'] = 'testString'
        template_repo_tar_upload_response_model_json['has_received_file'] = True
        template_repo_tar_upload_response_model_json['id'] = 'testString'

        # Construct a model instance of TemplateRepoTarUploadResponse by calling from_dict on the json representation
        template_repo_tar_upload_response_model = TemplateRepoTarUploadResponse.from_dict(
            template_repo_tar_upload_response_model_json
        )
        assert template_repo_tar_upload_response_model != False

        # Construct a model instance of TemplateRepoTarUploadResponse by calling from_dict on the json representation
        template_repo_tar_upload_response_model_dict = TemplateRepoTarUploadResponse.from_dict(
            template_repo_tar_upload_response_model_json
        ).__dict__
        template_repo_tar_upload_response_model2 = TemplateRepoTarUploadResponse(
            **template_repo_tar_upload_response_model_dict
        )

        # Verify the model instances are equivalent
        assert template_repo_tar_upload_response_model == template_repo_tar_upload_response_model2

        # Convert model instance back to dict and verify no loss of data
        template_repo_tar_upload_response_model_json2 = template_repo_tar_upload_response_model.to_dict()
        assert template_repo_tar_upload_response_model_json2 == template_repo_tar_upload_response_model_json


class TestModel_TemplateRepoUpdateRequest:
    """
    Test Class for TemplateRepoUpdateRequest
    """

    def test_template_repo_update_request_serialization(self):
        """
        Test serialization/deserialization for TemplateRepoUpdateRequest
        """

        # Construct a json representation of a TemplateRepoUpdateRequest model
        template_repo_update_request_model_json = {}
        template_repo_update_request_model_json['branch'] = 'testString'
        template_repo_update_request_model_json['release'] = 'testString'
        template_repo_update_request_model_json['repo_sha_value'] = 'testString'
        template_repo_update_request_model_json['repo_url'] = 'testString'
        template_repo_update_request_model_json['url'] = 'testString'
        template_repo_update_request_model_json['skip_submodules_checkout'] = True

        # Construct a model instance of TemplateRepoUpdateRequest by calling from_dict on the json representation
        template_repo_update_request_model = TemplateRepoUpdateRequest.from_dict(
            template_repo_update_request_model_json
        )
        assert template_repo_update_request_model != False

        # Construct a model instance of TemplateRepoUpdateRequest by calling from_dict on the json representation
        template_repo_update_request_model_dict = TemplateRepoUpdateRequest.from_dict(
            template_repo_update_request_model_json
        ).__dict__
        template_repo_update_request_model2 = TemplateRepoUpdateRequest(**template_repo_update_request_model_dict)

        # Verify the model instances are equivalent
        assert template_repo_update_request_model == template_repo_update_request_model2

        # Convert model instance back to dict and verify no loss of data
        template_repo_update_request_model_json2 = template_repo_update_request_model.to_dict()
        assert template_repo_update_request_model_json2 == template_repo_update_request_model_json


class TestModel_TemplateResources:
    """
    Test Class for TemplateResources
    """

    def test_template_resources_serialization(self):
        """
        Test serialization/deserialization for TemplateResources
        """

        # Construct a json representation of a TemplateResources model
        template_resources_model_json = {}
        template_resources_model_json['folder'] = 'testString'
        template_resources_model_json['id'] = 'testString'
        template_resources_model_json['generated_at'] = '2019-01-01T12:00:00Z'
        template_resources_model_json['null_resources'] = [{'anyKey': 'anyValue'}]
        template_resources_model_json['related_resources'] = [{'anyKey': 'anyValue'}]
        template_resources_model_json['resources'] = [{'anyKey': 'anyValue'}]
        template_resources_model_json['resources_count'] = 26
        template_resources_model_json['type'] = 'testString'

        # Construct a model instance of TemplateResources by calling from_dict on the json representation
        template_resources_model = TemplateResources.from_dict(template_resources_model_json)
        assert template_resources_model != False

        # Construct a model instance of TemplateResources by calling from_dict on the json representation
        template_resources_model_dict = TemplateResources.from_dict(template_resources_model_json).__dict__
        template_resources_model2 = TemplateResources(**template_resources_model_dict)

        # Verify the model instances are equivalent
        assert template_resources_model == template_resources_model2

        # Convert model instance back to dict and verify no loss of data
        template_resources_model_json2 = template_resources_model.to_dict()
        assert template_resources_model_json2 == template_resources_model_json


class TestModel_TemplateRunTimeDataResponse:
    """
    Test Class for TemplateRunTimeDataResponse
    """

    def test_template_run_time_data_response_serialization(self):
        """
        Test serialization/deserialization for TemplateRunTimeDataResponse
        """

        # Construct a json representation of a TemplateRunTimeDataResponse model
        template_run_time_data_response_model_json = {}
        template_run_time_data_response_model_json['engine_cmd'] = 'testString'
        template_run_time_data_response_model_json['engine_name'] = 'testString'
        template_run_time_data_response_model_json['engine_version'] = 'testString'
        template_run_time_data_response_model_json['id'] = 'testString'
        template_run_time_data_response_model_json['log_store_url'] = 'testString'
        template_run_time_data_response_model_json['output_values'] = [{'anyKey': 'anyValue'}]
        template_run_time_data_response_model_json['resources'] = [[{'anyKey': 'anyValue'}]]
        template_run_time_data_response_model_json['state_store_url'] = 'testString'

        # Construct a model instance of TemplateRunTimeDataResponse by calling from_dict on the json representation
        template_run_time_data_response_model = TemplateRunTimeDataResponse.from_dict(
            template_run_time_data_response_model_json
        )
        assert template_run_time_data_response_model != False

        # Construct a model instance of TemplateRunTimeDataResponse by calling from_dict on the json representation
        template_run_time_data_response_model_dict = TemplateRunTimeDataResponse.from_dict(
            template_run_time_data_response_model_json
        ).__dict__
        template_run_time_data_response_model2 = TemplateRunTimeDataResponse(
            **template_run_time_data_response_model_dict
        )

        # Verify the model instances are equivalent
        assert template_run_time_data_response_model == template_run_time_data_response_model2

        # Convert model instance back to dict and verify no loss of data
        template_run_time_data_response_model_json2 = template_run_time_data_response_model.to_dict()
        assert template_run_time_data_response_model_json2 == template_run_time_data_response_model_json


class TestModel_TemplateSourceDataRequest:
    """
    Test Class for TemplateSourceDataRequest
    """

    def test_template_source_data_request_serialization(self):
        """
        Test serialization/deserialization for TemplateSourceDataRequest
        """

        # Construct dict forms of any model objects needed in order to build this model.

        environment_values_metadata_model = {}  # EnvironmentValuesMetadata
        environment_values_metadata_model['hidden'] = True
        environment_values_metadata_model['name'] = 'testString'
        environment_values_metadata_model['secure'] = True

        inject_terraform_template_inner_tft_parameters_item_model = {}  # InjectTerraformTemplateInnerTftParametersItem
        inject_terraform_template_inner_tft_parameters_item_model['name'] = 'testString'
        inject_terraform_template_inner_tft_parameters_item_model['value'] = 'testString'

        inject_terraform_template_inner_model = {}  # InjectTerraformTemplateInner
        inject_terraform_template_inner_model['tft_git_url'] = 'testString'
        inject_terraform_template_inner_model['tft_git_token'] = 'testString'
        inject_terraform_template_inner_model['tft_prefix'] = 'testString'
        inject_terraform_template_inner_model['injection_type'] = 'testString'
        inject_terraform_template_inner_model['tft_name'] = 'testString'
        inject_terraform_template_inner_model['tft_parameters'] = [
            inject_terraform_template_inner_tft_parameters_item_model
        ]

        workspace_variable_request_model = {}  # WorkspaceVariableRequest
        workspace_variable_request_model['description'] = 'testString'
        workspace_variable_request_model['name'] = 'testString'
        workspace_variable_request_model['secure'] = True
        workspace_variable_request_model['type'] = 'testString'
        workspace_variable_request_model['use_default'] = True
        workspace_variable_request_model['value'] = 'testString'

        # Construct a json representation of a TemplateSourceDataRequest model
        template_source_data_request_model_json = {}
        template_source_data_request_model_json['env_values'] = [{'anyKey': 'anyValue'}]
        template_source_data_request_model_json['env_values_metadata'] = [environment_values_metadata_model]
        template_source_data_request_model_json['folder'] = 'testString'
        template_source_data_request_model_json['compact'] = True
        template_source_data_request_model_json['init_state_file'] = 'testString'
        template_source_data_request_model_json['injectors'] = [inject_terraform_template_inner_model]
        template_source_data_request_model_json['type'] = 'testString'
        template_source_data_request_model_json['uninstall_script_name'] = 'testString'
        template_source_data_request_model_json['values'] = 'testString'
        template_source_data_request_model_json['values_metadata'] = [{'anyKey': 'anyValue'}]
        template_source_data_request_model_json['variablestore'] = [workspace_variable_request_model]

        # Construct a model instance of TemplateSourceDataRequest by calling from_dict on the json representation
        template_source_data_request_model = TemplateSourceDataRequest.from_dict(
            template_source_data_request_model_json
        )
        assert template_source_data_request_model != False

        # Construct a model instance of TemplateSourceDataRequest by calling from_dict on the json representation
        template_source_data_request_model_dict = TemplateSourceDataRequest.from_dict(
            template_source_data_request_model_json
        ).__dict__
        template_source_data_request_model2 = TemplateSourceDataRequest(**template_source_data_request_model_dict)

        # Verify the model instances are equivalent
        assert template_source_data_request_model == template_source_data_request_model2

        # Convert model instance back to dict and verify no loss of data
        template_source_data_request_model_json2 = template_source_data_request_model.to_dict()
        assert template_source_data_request_model_json2 == template_source_data_request_model_json


class TestModel_TemplateSourceDataResponse:
    """
    Test Class for TemplateSourceDataResponse
    """

    def test_template_source_data_response_serialization(self):
        """
        Test serialization/deserialization for TemplateSourceDataResponse
        """

        # Construct dict forms of any model objects needed in order to build this model.

        env_variable_response_model = {}  # EnvVariableResponse
        env_variable_response_model['hidden'] = True
        env_variable_response_model['name'] = 'testString'
        env_variable_response_model['secure'] = True
        env_variable_response_model['value'] = 'testString'

        workspace_variable_response_model = {}  # WorkspaceVariableResponse
        workspace_variable_response_model['description'] = 'testString'
        workspace_variable_response_model['name'] = 'testString'
        workspace_variable_response_model['secure'] = True
        workspace_variable_response_model['type'] = 'testString'
        workspace_variable_response_model['value'] = 'testString'

        # Construct a json representation of a TemplateSourceDataResponse model
        template_source_data_response_model_json = {}
        template_source_data_response_model_json['env_values'] = [env_variable_response_model]
        template_source_data_response_model_json['folder'] = 'testString'
        template_source_data_response_model_json['compact'] = True
        template_source_data_response_model_json['has_githubtoken'] = True
        template_source_data_response_model_json['id'] = 'testString'
        template_source_data_response_model_json['type'] = 'testString'
        template_source_data_response_model_json['uninstall_script_name'] = 'testString'
        template_source_data_response_model_json['values'] = 'testString'
        template_source_data_response_model_json['values_metadata'] = [{'anyKey': 'anyValue'}]
        template_source_data_response_model_json['values_url'] = 'testString'
        template_source_data_response_model_json['variablestore'] = [workspace_variable_response_model]

        # Construct a model instance of TemplateSourceDataResponse by calling from_dict on the json representation
        template_source_data_response_model = TemplateSourceDataResponse.from_dict(
            template_source_data_response_model_json
        )
        assert template_source_data_response_model != False

        # Construct a model instance of TemplateSourceDataResponse by calling from_dict on the json representation
        template_source_data_response_model_dict = TemplateSourceDataResponse.from_dict(
            template_source_data_response_model_json
        ).__dict__
        template_source_data_response_model2 = TemplateSourceDataResponse(**template_source_data_response_model_dict)

        # Verify the model instances are equivalent
        assert template_source_data_response_model == template_source_data_response_model2

        # Convert model instance back to dict and verify no loss of data
        template_source_data_response_model_json2 = template_source_data_response_model.to_dict()
        assert template_source_data_response_model_json2 == template_source_data_response_model_json


class TestModel_TemplateStateStore:
    """
    Test Class for TemplateStateStore
    """

    def test_template_state_store_serialization(self):
        """
        Test serialization/deserialization for TemplateStateStore
        """

        # Construct a json representation of a TemplateStateStore model
        template_state_store_model_json = {}
        template_state_store_model_json['version'] = 72.5
        template_state_store_model_json['terraform_version'] = 'testString'
        template_state_store_model_json['serial'] = 72.5
        template_state_store_model_json['lineage'] = 'testString'
        template_state_store_model_json['modules'] = [{'anyKey': 'anyValue'}]

        # Construct a model instance of TemplateStateStore by calling from_dict on the json representation
        template_state_store_model = TemplateStateStore.from_dict(template_state_store_model_json)
        assert template_state_store_model != False

        # Construct a model instance of TemplateStateStore by calling from_dict on the json representation
        template_state_store_model_dict = TemplateStateStore.from_dict(template_state_store_model_json).__dict__
        template_state_store_model2 = TemplateStateStore(**template_state_store_model_dict)

        # Verify the model instances are equivalent
        assert template_state_store_model == template_state_store_model2

        # Convert model instance back to dict and verify no loss of data
        template_state_store_model_json2 = template_state_store_model.to_dict()
        assert template_state_store_model_json2 == template_state_store_model_json


class TestModel_TemplateValues:
    """
    Test Class for TemplateValues
    """

    def test_template_values_serialization(self):
        """
        Test serialization/deserialization for TemplateValues
        """

        # Construct a json representation of a TemplateValues model
        template_values_model_json = {}
        template_values_model_json['values_metadata'] = [{'anyKey': 'anyValue'}]

        # Construct a model instance of TemplateValues by calling from_dict on the json representation
        template_values_model = TemplateValues.from_dict(template_values_model_json)
        assert template_values_model != False

        # Construct a model instance of TemplateValues by calling from_dict on the json representation
        template_values_model_dict = TemplateValues.from_dict(template_values_model_json).__dict__
        template_values_model2 = TemplateValues(**template_values_model_dict)

        # Verify the model instances are equivalent
        assert template_values_model == template_values_model2

        # Convert model instance back to dict and verify no loss of data
        template_values_model_json2 = template_values_model.to_dict()
        assert template_values_model_json2 == template_values_model_json


class TestModel_TerraformCommand:
    """
    Test Class for TerraformCommand
    """

    def test_terraform_command_serialization(self):
        """
        Test serialization/deserialization for TerraformCommand
        """

        # Construct a json representation of a TerraformCommand model
        terraform_command_model_json = {}
        terraform_command_model_json['command'] = 'testString'
        terraform_command_model_json['command_params'] = 'testString'
        terraform_command_model_json['command_name'] = 'testString'
        terraform_command_model_json['command_desc'] = 'testString'
        terraform_command_model_json['command_on_error'] = 'testString'
        terraform_command_model_json['command_depends_on'] = 'testString'
        terraform_command_model_json['command_status'] = 'testString'

        # Construct a model instance of TerraformCommand by calling from_dict on the json representation
        terraform_command_model = TerraformCommand.from_dict(terraform_command_model_json)
        assert terraform_command_model != False

        # Construct a model instance of TerraformCommand by calling from_dict on the json representation
        terraform_command_model_dict = TerraformCommand.from_dict(terraform_command_model_json).__dict__
        terraform_command_model2 = TerraformCommand(**terraform_command_model_dict)

        # Verify the model instances are equivalent
        assert terraform_command_model == terraform_command_model2

        # Convert model instance back to dict and verify no loss of data
        terraform_command_model_json2 = terraform_command_model.to_dict()
        assert terraform_command_model_json2 == terraform_command_model_json


class TestModel_UserState:
    """
    Test Class for UserState
    """

    def test_user_state_serialization(self):
        """
        Test serialization/deserialization for UserState
        """

        # Construct a json representation of a UserState model
        user_state_model_json = {}
        user_state_model_json['state'] = 'draft'
        user_state_model_json['set_by'] = 'testString'
        user_state_model_json['set_at'] = '2019-01-01T12:00:00Z'

        # Construct a model instance of UserState by calling from_dict on the json representation
        user_state_model = UserState.from_dict(user_state_model_json)
        assert user_state_model != False

        # Construct a model instance of UserState by calling from_dict on the json representation
        user_state_model_dict = UserState.from_dict(user_state_model_json).__dict__
        user_state_model2 = UserState(**user_state_model_dict)

        # Verify the model instances are equivalent
        assert user_state_model == user_state_model2

        # Convert model instance back to dict and verify no loss of data
        user_state_model_json2 = user_state_model.to_dict()
        assert user_state_model_json2 == user_state_model_json


class TestModel_UserValues:
    """
    Test Class for UserValues
    """

    def test_user_values_serialization(self):
        """
        Test serialization/deserialization for UserValues
        """

        # Construct dict forms of any model objects needed in order to build this model.

        env_variable_request_map_model = {}  # EnvVariableRequestMap
        env_variable_request_map_model['hidden'] = True
        env_variable_request_map_model['name'] = 'testString'
        env_variable_request_map_model['secure'] = True
        env_variable_request_map_model['value'] = 'testString'

        workspace_variable_response_model = {}  # WorkspaceVariableResponse
        workspace_variable_response_model['description'] = 'testString'
        workspace_variable_response_model['name'] = 'testString'
        workspace_variable_response_model['secure'] = True
        workspace_variable_response_model['type'] = 'testString'
        workspace_variable_response_model['value'] = 'testString'

        # Construct a json representation of a UserValues model
        user_values_model_json = {}
        user_values_model_json['env_values'] = [{'anyKey': 'anyValue'}]
        user_values_model_json['env_values_map'] = [env_variable_request_map_model]
        user_values_model_json['values'] = 'testString'
        user_values_model_json['variablestore'] = [workspace_variable_response_model]

        # Construct a model instance of UserValues by calling from_dict on the json representation
        user_values_model = UserValues.from_dict(user_values_model_json)
        assert user_values_model != False

        # Construct a model instance of UserValues by calling from_dict on the json representation
        user_values_model_dict = UserValues.from_dict(user_values_model_json).__dict__
        user_values_model2 = UserValues(**user_values_model_dict)

        # Verify the model instances are equivalent
        assert user_values_model == user_values_model2

        # Convert model instance back to dict and verify no loss of data
        user_values_model_json2 = user_values_model.to_dict()
        assert user_values_model_json2 == user_values_model_json


class TestModel_VariableData:
    """
    Test Class for VariableData
    """

    def test_variable_data_serialization(self):
        """
        Test serialization/deserialization for VariableData
        """

        # Construct dict forms of any model objects needed in order to build this model.

        variable_metadata_model = {}  # VariableMetadata
        variable_metadata_model['type'] = 'boolean'
        variable_metadata_model['aliases'] = ['testString']
        variable_metadata_model['description'] = 'testString'
        variable_metadata_model['cloud_data_type'] = 'testString'
        variable_metadata_model['default_value'] = 'testString'
        variable_metadata_model['link_status'] = 'normal'
        variable_metadata_model['secure'] = True
        variable_metadata_model['immutable'] = True
        variable_metadata_model['hidden'] = True
        variable_metadata_model['required'] = True
        variable_metadata_model['options'] = ['testString']
        variable_metadata_model['min_value'] = 38
        variable_metadata_model['max_value'] = 38
        variable_metadata_model['min_length'] = 38
        variable_metadata_model['max_length'] = 38
        variable_metadata_model['matches'] = 'testString'
        variable_metadata_model['position'] = 38
        variable_metadata_model['group_by'] = 'testString'
        variable_metadata_model['source'] = 'testString'

        # Construct a json representation of a VariableData model
        variable_data_model_json = {}
        variable_data_model_json['name'] = 'testString'
        variable_data_model_json['value'] = 'testString'
        variable_data_model_json['use_default'] = True
        variable_data_model_json['metadata'] = variable_metadata_model

        # Construct a model instance of VariableData by calling from_dict on the json representation
        variable_data_model = VariableData.from_dict(variable_data_model_json)
        assert variable_data_model != False

        # Construct a model instance of VariableData by calling from_dict on the json representation
        variable_data_model_dict = VariableData.from_dict(variable_data_model_json).__dict__
        variable_data_model2 = VariableData(**variable_data_model_dict)

        # Verify the model instances are equivalent
        assert variable_data_model == variable_data_model2

        # Convert model instance back to dict and verify no loss of data
        variable_data_model_json2 = variable_data_model.to_dict()
        assert variable_data_model_json2 == variable_data_model_json


class TestModel_VariableMetadata:
    """
    Test Class for VariableMetadata
    """

    def test_variable_metadata_serialization(self):
        """
        Test serialization/deserialization for VariableMetadata
        """

        # Construct a json representation of a VariableMetadata model
        variable_metadata_model_json = {}
        variable_metadata_model_json['type'] = 'boolean'
        variable_metadata_model_json['aliases'] = ['testString']
        variable_metadata_model_json['description'] = 'testString'
        variable_metadata_model_json['cloud_data_type'] = 'testString'
        variable_metadata_model_json['default_value'] = 'testString'
        variable_metadata_model_json['link_status'] = 'normal'
        variable_metadata_model_json['secure'] = True
        variable_metadata_model_json['immutable'] = True
        variable_metadata_model_json['hidden'] = True
        variable_metadata_model_json['required'] = True
        variable_metadata_model_json['options'] = ['testString']
        variable_metadata_model_json['min_value'] = 38
        variable_metadata_model_json['max_value'] = 38
        variable_metadata_model_json['min_length'] = 38
        variable_metadata_model_json['max_length'] = 38
        variable_metadata_model_json['matches'] = 'testString'
        variable_metadata_model_json['position'] = 38
        variable_metadata_model_json['group_by'] = 'testString'
        variable_metadata_model_json['source'] = 'testString'

        # Construct a model instance of VariableMetadata by calling from_dict on the json representation
        variable_metadata_model = VariableMetadata.from_dict(variable_metadata_model_json)
        assert variable_metadata_model != False

        # Construct a model instance of VariableMetadata by calling from_dict on the json representation
        variable_metadata_model_dict = VariableMetadata.from_dict(variable_metadata_model_json).__dict__
        variable_metadata_model2 = VariableMetadata(**variable_metadata_model_dict)

        # Verify the model instances are equivalent
        assert variable_metadata_model == variable_metadata_model2

        # Convert model instance back to dict and verify no loss of data
        variable_metadata_model_json2 = variable_metadata_model.to_dict()
        assert variable_metadata_model_json2 == variable_metadata_model_json


class TestModel_VersionResponse:
    """
    Test Class for VersionResponse
    """

    def test_version_response_serialization(self):
        """
        Test serialization/deserialization for VersionResponse
        """

        # Construct a json representation of a VersionResponse model
        version_response_model_json = {}
        version_response_model_json['builddate'] = 'testString'
        version_response_model_json['buildno'] = 'testString'
        version_response_model_json['commitsha'] = 'testString'
        version_response_model_json['helm_provider_version'] = 'testString'
        version_response_model_json['helm_version'] = 'testString'
        version_response_model_json['supported_template_types'] = {'anyKey': 'anyValue'}
        version_response_model_json['terraform_provider_version'] = 'testString'
        version_response_model_json['terraform_version'] = 'testString'

        # Construct a model instance of VersionResponse by calling from_dict on the json representation
        version_response_model = VersionResponse.from_dict(version_response_model_json)
        assert version_response_model != False

        # Construct a model instance of VersionResponse by calling from_dict on the json representation
        version_response_model_dict = VersionResponse.from_dict(version_response_model_json).__dict__
        version_response_model2 = VersionResponse(**version_response_model_dict)

        # Verify the model instances are equivalent
        assert version_response_model == version_response_model2

        # Convert model instance back to dict and verify no loss of data
        version_response_model_json2 = version_response_model.to_dict()
        assert version_response_model_json2 == version_response_model_json


class TestModel_WorkspaceActivities:
    """
    Test Class for WorkspaceActivities
    """

    def test_workspace_activities_serialization(self):
        """
        Test serialization/deserialization for WorkspaceActivities
        """

        # Construct dict forms of any model objects needed in order to build this model.

        log_summary_model = {}  # LogSummary
        log_summary_model['activity_status'] = 'testString'
        log_summary_model['detected_template_type'] = 'testString'
        log_summary_model['discarded_files'] = 26
        log_summary_model['error'] = 'testString'
        log_summary_model['resources_added'] = 26
        log_summary_model['resources_destroyed'] = 26
        log_summary_model['resources_modified'] = 26
        log_summary_model['scanned_files'] = 26
        log_summary_model['template_variable_count'] = 26
        log_summary_model['time_taken'] = 72.5

        workspace_activity_template_model = {}  # WorkspaceActivityTemplate
        workspace_activity_template_model['end_time'] = '2019-01-01T12:00:00Z'
        workspace_activity_template_model['log_summary'] = log_summary_model
        workspace_activity_template_model['log_url'] = 'testString'
        workspace_activity_template_model['message'] = 'testString'
        workspace_activity_template_model['start_time'] = '2019-01-01T12:00:00Z'
        workspace_activity_template_model['status'] = 'testString'
        workspace_activity_template_model['template_id'] = 'testString'
        workspace_activity_template_model['template_type'] = 'testString'

        workspace_activity_model = {}  # WorkspaceActivity
        workspace_activity_model['action_id'] = 'testString'
        workspace_activity_model['message'] = ['testString']
        workspace_activity_model['name'] = 'testString'
        workspace_activity_model['performed_at'] = '2019-01-01T12:00:00Z'
        workspace_activity_model['performed_by'] = 'testString'
        workspace_activity_model['status'] = 'testString'
        workspace_activity_model['templates'] = [workspace_activity_template_model]

        # Construct a json representation of a WorkspaceActivities model
        workspace_activities_model_json = {}
        workspace_activities_model_json['actions'] = [workspace_activity_model]
        workspace_activities_model_json['workspace_id'] = 'testString'
        workspace_activities_model_json['workspace_name'] = 'testString'

        # Construct a model instance of WorkspaceActivities by calling from_dict on the json representation
        workspace_activities_model = WorkspaceActivities.from_dict(workspace_activities_model_json)
        assert workspace_activities_model != False

        # Construct a model instance of WorkspaceActivities by calling from_dict on the json representation
        workspace_activities_model_dict = WorkspaceActivities.from_dict(workspace_activities_model_json).__dict__
        workspace_activities_model2 = WorkspaceActivities(**workspace_activities_model_dict)

        # Verify the model instances are equivalent
        assert workspace_activities_model == workspace_activities_model2

        # Convert model instance back to dict and verify no loss of data
        workspace_activities_model_json2 = workspace_activities_model.to_dict()
        assert workspace_activities_model_json2 == workspace_activities_model_json


class TestModel_WorkspaceActivity:
    """
    Test Class for WorkspaceActivity
    """

    def test_workspace_activity_serialization(self):
        """
        Test serialization/deserialization for WorkspaceActivity
        """

        # Construct dict forms of any model objects needed in order to build this model.

        log_summary_model = {}  # LogSummary
        log_summary_model['activity_status'] = 'testString'
        log_summary_model['detected_template_type'] = 'testString'
        log_summary_model['discarded_files'] = 26
        log_summary_model['error'] = 'testString'
        log_summary_model['resources_added'] = 26
        log_summary_model['resources_destroyed'] = 26
        log_summary_model['resources_modified'] = 26
        log_summary_model['scanned_files'] = 26
        log_summary_model['template_variable_count'] = 26
        log_summary_model['time_taken'] = 72.5

        workspace_activity_template_model = {}  # WorkspaceActivityTemplate
        workspace_activity_template_model['end_time'] = '2019-01-01T12:00:00Z'
        workspace_activity_template_model['log_summary'] = log_summary_model
        workspace_activity_template_model['log_url'] = 'testString'
        workspace_activity_template_model['message'] = 'testString'
        workspace_activity_template_model['start_time'] = '2019-01-01T12:00:00Z'
        workspace_activity_template_model['status'] = 'testString'
        workspace_activity_template_model['template_id'] = 'testString'
        workspace_activity_template_model['template_type'] = 'testString'

        # Construct a json representation of a WorkspaceActivity model
        workspace_activity_model_json = {}
        workspace_activity_model_json['action_id'] = 'testString'
        workspace_activity_model_json['message'] = ['testString']
        workspace_activity_model_json['name'] = 'testString'
        workspace_activity_model_json['performed_at'] = '2019-01-01T12:00:00Z'
        workspace_activity_model_json['performed_by'] = 'testString'
        workspace_activity_model_json['status'] = 'testString'
        workspace_activity_model_json['templates'] = [workspace_activity_template_model]

        # Construct a model instance of WorkspaceActivity by calling from_dict on the json representation
        workspace_activity_model = WorkspaceActivity.from_dict(workspace_activity_model_json)
        assert workspace_activity_model != False

        # Construct a model instance of WorkspaceActivity by calling from_dict on the json representation
        workspace_activity_model_dict = WorkspaceActivity.from_dict(workspace_activity_model_json).__dict__
        workspace_activity_model2 = WorkspaceActivity(**workspace_activity_model_dict)

        # Verify the model instances are equivalent
        assert workspace_activity_model == workspace_activity_model2

        # Convert model instance back to dict and verify no loss of data
        workspace_activity_model_json2 = workspace_activity_model.to_dict()
        assert workspace_activity_model_json2 == workspace_activity_model_json


class TestModel_WorkspaceActivityApplyResult:
    """
    Test Class for WorkspaceActivityApplyResult
    """

    def test_workspace_activity_apply_result_serialization(self):
        """
        Test serialization/deserialization for WorkspaceActivityApplyResult
        """

        # Construct a json representation of a WorkspaceActivityApplyResult model
        workspace_activity_apply_result_model_json = {}
        workspace_activity_apply_result_model_json['activityid'] = 'testString'

        # Construct a model instance of WorkspaceActivityApplyResult by calling from_dict on the json representation
        workspace_activity_apply_result_model = WorkspaceActivityApplyResult.from_dict(
            workspace_activity_apply_result_model_json
        )
        assert workspace_activity_apply_result_model != False

        # Construct a model instance of WorkspaceActivityApplyResult by calling from_dict on the json representation
        workspace_activity_apply_result_model_dict = WorkspaceActivityApplyResult.from_dict(
            workspace_activity_apply_result_model_json
        ).__dict__
        workspace_activity_apply_result_model2 = WorkspaceActivityApplyResult(
            **workspace_activity_apply_result_model_dict
        )

        # Verify the model instances are equivalent
        assert workspace_activity_apply_result_model == workspace_activity_apply_result_model2

        # Convert model instance back to dict and verify no loss of data
        workspace_activity_apply_result_model_json2 = workspace_activity_apply_result_model.to_dict()
        assert workspace_activity_apply_result_model_json2 == workspace_activity_apply_result_model_json


class TestModel_WorkspaceActivityCommandResult:
    """
    Test Class for WorkspaceActivityCommandResult
    """

    def test_workspace_activity_command_result_serialization(self):
        """
        Test serialization/deserialization for WorkspaceActivityCommandResult
        """

        # Construct a json representation of a WorkspaceActivityCommandResult model
        workspace_activity_command_result_model_json = {}
        workspace_activity_command_result_model_json['activityid'] = 'testString'

        # Construct a model instance of WorkspaceActivityCommandResult by calling from_dict on the json representation
        workspace_activity_command_result_model = WorkspaceActivityCommandResult.from_dict(
            workspace_activity_command_result_model_json
        )
        assert workspace_activity_command_result_model != False

        # Construct a model instance of WorkspaceActivityCommandResult by calling from_dict on the json representation
        workspace_activity_command_result_model_dict = WorkspaceActivityCommandResult.from_dict(
            workspace_activity_command_result_model_json
        ).__dict__
        workspace_activity_command_result_model2 = WorkspaceActivityCommandResult(
            **workspace_activity_command_result_model_dict
        )

        # Verify the model instances are equivalent
        assert workspace_activity_command_result_model == workspace_activity_command_result_model2

        # Convert model instance back to dict and verify no loss of data
        workspace_activity_command_result_model_json2 = workspace_activity_command_result_model.to_dict()
        assert workspace_activity_command_result_model_json2 == workspace_activity_command_result_model_json


class TestModel_WorkspaceActivityDestroyResult:
    """
    Test Class for WorkspaceActivityDestroyResult
    """

    def test_workspace_activity_destroy_result_serialization(self):
        """
        Test serialization/deserialization for WorkspaceActivityDestroyResult
        """

        # Construct a json representation of a WorkspaceActivityDestroyResult model
        workspace_activity_destroy_result_model_json = {}
        workspace_activity_destroy_result_model_json['activityid'] = 'testString'

        # Construct a model instance of WorkspaceActivityDestroyResult by calling from_dict on the json representation
        workspace_activity_destroy_result_model = WorkspaceActivityDestroyResult.from_dict(
            workspace_activity_destroy_result_model_json
        )
        assert workspace_activity_destroy_result_model != False

        # Construct a model instance of WorkspaceActivityDestroyResult by calling from_dict on the json representation
        workspace_activity_destroy_result_model_dict = WorkspaceActivityDestroyResult.from_dict(
            workspace_activity_destroy_result_model_json
        ).__dict__
        workspace_activity_destroy_result_model2 = WorkspaceActivityDestroyResult(
            **workspace_activity_destroy_result_model_dict
        )

        # Verify the model instances are equivalent
        assert workspace_activity_destroy_result_model == workspace_activity_destroy_result_model2

        # Convert model instance back to dict and verify no loss of data
        workspace_activity_destroy_result_model_json2 = workspace_activity_destroy_result_model.to_dict()
        assert workspace_activity_destroy_result_model_json2 == workspace_activity_destroy_result_model_json


class TestModel_WorkspaceActivityLogs:
    """
    Test Class for WorkspaceActivityLogs
    """

    def test_workspace_activity_logs_serialization(self):
        """
        Test serialization/deserialization for WorkspaceActivityLogs
        """

        # Construct dict forms of any model objects needed in order to build this model.

        workspace_activity_template_logs_model = {}  # WorkspaceActivityTemplateLogs
        workspace_activity_template_logs_model['log_url'] = 'testString'
        workspace_activity_template_logs_model['template_id'] = 'testString'
        workspace_activity_template_logs_model['template_type'] = 'testString'

        # Construct a json representation of a WorkspaceActivityLogs model
        workspace_activity_logs_model_json = {}
        workspace_activity_logs_model_json['action_id'] = 'testString'
        workspace_activity_logs_model_json['name'] = 'testString'
        workspace_activity_logs_model_json['templates'] = [workspace_activity_template_logs_model]

        # Construct a model instance of WorkspaceActivityLogs by calling from_dict on the json representation
        workspace_activity_logs_model = WorkspaceActivityLogs.from_dict(workspace_activity_logs_model_json)
        assert workspace_activity_logs_model != False

        # Construct a model instance of WorkspaceActivityLogs by calling from_dict on the json representation
        workspace_activity_logs_model_dict = WorkspaceActivityLogs.from_dict(
            workspace_activity_logs_model_json
        ).__dict__
        workspace_activity_logs_model2 = WorkspaceActivityLogs(**workspace_activity_logs_model_dict)

        # Verify the model instances are equivalent
        assert workspace_activity_logs_model == workspace_activity_logs_model2

        # Convert model instance back to dict and verify no loss of data
        workspace_activity_logs_model_json2 = workspace_activity_logs_model.to_dict()
        assert workspace_activity_logs_model_json2 == workspace_activity_logs_model_json


class TestModel_WorkspaceActivityOptionsTemplate:
    """
    Test Class for WorkspaceActivityOptionsTemplate
    """

    def test_workspace_activity_options_template_serialization(self):
        """
        Test serialization/deserialization for WorkspaceActivityOptionsTemplate
        """

        # Construct a json representation of a WorkspaceActivityOptionsTemplate model
        workspace_activity_options_template_model_json = {}
        workspace_activity_options_template_model_json['target'] = ['testString']
        workspace_activity_options_template_model_json['tf_vars'] = ['testString']

        # Construct a model instance of WorkspaceActivityOptionsTemplate by calling from_dict on the json representation
        workspace_activity_options_template_model = WorkspaceActivityOptionsTemplate.from_dict(
            workspace_activity_options_template_model_json
        )
        assert workspace_activity_options_template_model != False

        # Construct a model instance of WorkspaceActivityOptionsTemplate by calling from_dict on the json representation
        workspace_activity_options_template_model_dict = WorkspaceActivityOptionsTemplate.from_dict(
            workspace_activity_options_template_model_json
        ).__dict__
        workspace_activity_options_template_model2 = WorkspaceActivityOptionsTemplate(
            **workspace_activity_options_template_model_dict
        )

        # Verify the model instances are equivalent
        assert workspace_activity_options_template_model == workspace_activity_options_template_model2

        # Convert model instance back to dict and verify no loss of data
        workspace_activity_options_template_model_json2 = workspace_activity_options_template_model.to_dict()
        assert workspace_activity_options_template_model_json2 == workspace_activity_options_template_model_json


class TestModel_WorkspaceActivityPlanResult:
    """
    Test Class for WorkspaceActivityPlanResult
    """

    def test_workspace_activity_plan_result_serialization(self):
        """
        Test serialization/deserialization for WorkspaceActivityPlanResult
        """

        # Construct a json representation of a WorkspaceActivityPlanResult model
        workspace_activity_plan_result_model_json = {}
        workspace_activity_plan_result_model_json['activityid'] = 'testString'

        # Construct a model instance of WorkspaceActivityPlanResult by calling from_dict on the json representation
        workspace_activity_plan_result_model = WorkspaceActivityPlanResult.from_dict(
            workspace_activity_plan_result_model_json
        )
        assert workspace_activity_plan_result_model != False

        # Construct a model instance of WorkspaceActivityPlanResult by calling from_dict on the json representation
        workspace_activity_plan_result_model_dict = WorkspaceActivityPlanResult.from_dict(
            workspace_activity_plan_result_model_json
        ).__dict__
        workspace_activity_plan_result_model2 = WorkspaceActivityPlanResult(**workspace_activity_plan_result_model_dict)

        # Verify the model instances are equivalent
        assert workspace_activity_plan_result_model == workspace_activity_plan_result_model2

        # Convert model instance back to dict and verify no loss of data
        workspace_activity_plan_result_model_json2 = workspace_activity_plan_result_model.to_dict()
        assert workspace_activity_plan_result_model_json2 == workspace_activity_plan_result_model_json


class TestModel_WorkspaceActivityRefreshResult:
    """
    Test Class for WorkspaceActivityRefreshResult
    """

    def test_workspace_activity_refresh_result_serialization(self):
        """
        Test serialization/deserialization for WorkspaceActivityRefreshResult
        """

        # Construct a json representation of a WorkspaceActivityRefreshResult model
        workspace_activity_refresh_result_model_json = {}
        workspace_activity_refresh_result_model_json['activityid'] = 'testString'

        # Construct a model instance of WorkspaceActivityRefreshResult by calling from_dict on the json representation
        workspace_activity_refresh_result_model = WorkspaceActivityRefreshResult.from_dict(
            workspace_activity_refresh_result_model_json
        )
        assert workspace_activity_refresh_result_model != False

        # Construct a model instance of WorkspaceActivityRefreshResult by calling from_dict on the json representation
        workspace_activity_refresh_result_model_dict = WorkspaceActivityRefreshResult.from_dict(
            workspace_activity_refresh_result_model_json
        ).__dict__
        workspace_activity_refresh_result_model2 = WorkspaceActivityRefreshResult(
            **workspace_activity_refresh_result_model_dict
        )

        # Verify the model instances are equivalent
        assert workspace_activity_refresh_result_model == workspace_activity_refresh_result_model2

        # Convert model instance back to dict and verify no loss of data
        workspace_activity_refresh_result_model_json2 = workspace_activity_refresh_result_model.to_dict()
        assert workspace_activity_refresh_result_model_json2 == workspace_activity_refresh_result_model_json


class TestModel_WorkspaceActivityTemplate:
    """
    Test Class for WorkspaceActivityTemplate
    """

    def test_workspace_activity_template_serialization(self):
        """
        Test serialization/deserialization for WorkspaceActivityTemplate
        """

        # Construct dict forms of any model objects needed in order to build this model.

        log_summary_model = {}  # LogSummary
        log_summary_model['activity_status'] = 'testString'
        log_summary_model['detected_template_type'] = 'testString'
        log_summary_model['discarded_files'] = 26
        log_summary_model['error'] = 'testString'
        log_summary_model['resources_added'] = 26
        log_summary_model['resources_destroyed'] = 26
        log_summary_model['resources_modified'] = 26
        log_summary_model['scanned_files'] = 26
        log_summary_model['template_variable_count'] = 26
        log_summary_model['time_taken'] = 72.5

        # Construct a json representation of a WorkspaceActivityTemplate model
        workspace_activity_template_model_json = {}
        workspace_activity_template_model_json['end_time'] = '2019-01-01T12:00:00Z'
        workspace_activity_template_model_json['log_summary'] = log_summary_model
        workspace_activity_template_model_json['log_url'] = 'testString'
        workspace_activity_template_model_json['message'] = 'testString'
        workspace_activity_template_model_json['start_time'] = '2019-01-01T12:00:00Z'
        workspace_activity_template_model_json['status'] = 'testString'
        workspace_activity_template_model_json['template_id'] = 'testString'
        workspace_activity_template_model_json['template_type'] = 'testString'

        # Construct a model instance of WorkspaceActivityTemplate by calling from_dict on the json representation
        workspace_activity_template_model = WorkspaceActivityTemplate.from_dict(workspace_activity_template_model_json)
        assert workspace_activity_template_model != False

        # Construct a model instance of WorkspaceActivityTemplate by calling from_dict on the json representation
        workspace_activity_template_model_dict = WorkspaceActivityTemplate.from_dict(
            workspace_activity_template_model_json
        ).__dict__
        workspace_activity_template_model2 = WorkspaceActivityTemplate(**workspace_activity_template_model_dict)

        # Verify the model instances are equivalent
        assert workspace_activity_template_model == workspace_activity_template_model2

        # Convert model instance back to dict and verify no loss of data
        workspace_activity_template_model_json2 = workspace_activity_template_model.to_dict()
        assert workspace_activity_template_model_json2 == workspace_activity_template_model_json


class TestModel_WorkspaceActivityTemplateLogs:
    """
    Test Class for WorkspaceActivityTemplateLogs
    """

    def test_workspace_activity_template_logs_serialization(self):
        """
        Test serialization/deserialization for WorkspaceActivityTemplateLogs
        """

        # Construct a json representation of a WorkspaceActivityTemplateLogs model
        workspace_activity_template_logs_model_json = {}
        workspace_activity_template_logs_model_json['log_url'] = 'testString'
        workspace_activity_template_logs_model_json['template_id'] = 'testString'
        workspace_activity_template_logs_model_json['template_type'] = 'testString'

        # Construct a model instance of WorkspaceActivityTemplateLogs by calling from_dict on the json representation
        workspace_activity_template_logs_model = WorkspaceActivityTemplateLogs.from_dict(
            workspace_activity_template_logs_model_json
        )
        assert workspace_activity_template_logs_model != False

        # Construct a model instance of WorkspaceActivityTemplateLogs by calling from_dict on the json representation
        workspace_activity_template_logs_model_dict = WorkspaceActivityTemplateLogs.from_dict(
            workspace_activity_template_logs_model_json
        ).__dict__
        workspace_activity_template_logs_model2 = WorkspaceActivityTemplateLogs(
            **workspace_activity_template_logs_model_dict
        )

        # Verify the model instances are equivalent
        assert workspace_activity_template_logs_model == workspace_activity_template_logs_model2

        # Convert model instance back to dict and verify no loss of data
        workspace_activity_template_logs_model_json2 = workspace_activity_template_logs_model.to_dict()
        assert workspace_activity_template_logs_model_json2 == workspace_activity_template_logs_model_json


class TestModel_WorkspaceBulkDeleteResponse:
    """
    Test Class for WorkspaceBulkDeleteResponse
    """

    def test_workspace_bulk_delete_response_serialization(self):
        """
        Test serialization/deserialization for WorkspaceBulkDeleteResponse
        """

        # Construct a json representation of a WorkspaceBulkDeleteResponse model
        workspace_bulk_delete_response_model_json = {}
        workspace_bulk_delete_response_model_json['job'] = 'testString'
        workspace_bulk_delete_response_model_json['job_id'] = 'testString'

        # Construct a model instance of WorkspaceBulkDeleteResponse by calling from_dict on the json representation
        workspace_bulk_delete_response_model = WorkspaceBulkDeleteResponse.from_dict(
            workspace_bulk_delete_response_model_json
        )
        assert workspace_bulk_delete_response_model != False

        # Construct a model instance of WorkspaceBulkDeleteResponse by calling from_dict on the json representation
        workspace_bulk_delete_response_model_dict = WorkspaceBulkDeleteResponse.from_dict(
            workspace_bulk_delete_response_model_json
        ).__dict__
        workspace_bulk_delete_response_model2 = WorkspaceBulkDeleteResponse(**workspace_bulk_delete_response_model_dict)

        # Verify the model instances are equivalent
        assert workspace_bulk_delete_response_model == workspace_bulk_delete_response_model2

        # Convert model instance back to dict and verify no loss of data
        workspace_bulk_delete_response_model_json2 = workspace_bulk_delete_response_model.to_dict()
        assert workspace_bulk_delete_response_model_json2 == workspace_bulk_delete_response_model_json


class TestModel_WorkspaceJobResponse:
    """
    Test Class for WorkspaceJobResponse
    """

    def test_workspace_job_response_serialization(self):
        """
        Test serialization/deserialization for WorkspaceJobResponse
        """

        # Construct dict forms of any model objects needed in order to build this model.

        workspace_job_status_type_model = {}  # WorkspaceJobStatusType
        workspace_job_status_type_model['failed'] = ['testString']
        workspace_job_status_type_model['in_progress'] = ['testString']
        workspace_job_status_type_model['success'] = ['testString']
        workspace_job_status_type_model['last_updated_on'] = '2019-01-01T12:00:00Z'

        # Construct a json representation of a WorkspaceJobResponse model
        workspace_job_response_model_json = {}
        workspace_job_response_model_json['job_status'] = workspace_job_status_type_model

        # Construct a model instance of WorkspaceJobResponse by calling from_dict on the json representation
        workspace_job_response_model = WorkspaceJobResponse.from_dict(workspace_job_response_model_json)
        assert workspace_job_response_model != False

        # Construct a model instance of WorkspaceJobResponse by calling from_dict on the json representation
        workspace_job_response_model_dict = WorkspaceJobResponse.from_dict(workspace_job_response_model_json).__dict__
        workspace_job_response_model2 = WorkspaceJobResponse(**workspace_job_response_model_dict)

        # Verify the model instances are equivalent
        assert workspace_job_response_model == workspace_job_response_model2

        # Convert model instance back to dict and verify no loss of data
        workspace_job_response_model_json2 = workspace_job_response_model.to_dict()
        assert workspace_job_response_model_json2 == workspace_job_response_model_json


class TestModel_WorkspaceJobStatusType:
    """
    Test Class for WorkspaceJobStatusType
    """

    def test_workspace_job_status_type_serialization(self):
        """
        Test serialization/deserialization for WorkspaceJobStatusType
        """

        # Construct a json representation of a WorkspaceJobStatusType model
        workspace_job_status_type_model_json = {}
        workspace_job_status_type_model_json['failed'] = ['testString']
        workspace_job_status_type_model_json['in_progress'] = ['testString']
        workspace_job_status_type_model_json['success'] = ['testString']
        workspace_job_status_type_model_json['last_updated_on'] = '2019-01-01T12:00:00Z'

        # Construct a model instance of WorkspaceJobStatusType by calling from_dict on the json representation
        workspace_job_status_type_model = WorkspaceJobStatusType.from_dict(workspace_job_status_type_model_json)
        assert workspace_job_status_type_model != False

        # Construct a model instance of WorkspaceJobStatusType by calling from_dict on the json representation
        workspace_job_status_type_model_dict = WorkspaceJobStatusType.from_dict(
            workspace_job_status_type_model_json
        ).__dict__
        workspace_job_status_type_model2 = WorkspaceJobStatusType(**workspace_job_status_type_model_dict)

        # Verify the model instances are equivalent
        assert workspace_job_status_type_model == workspace_job_status_type_model2

        # Convert model instance back to dict and verify no loss of data
        workspace_job_status_type_model_json2 = workspace_job_status_type_model.to_dict()
        assert workspace_job_status_type_model_json2 == workspace_job_status_type_model_json


class TestModel_WorkspaceResponse:
    """
    Test Class for WorkspaceResponse
    """

    def test_workspace_response_serialization(self):
        """
        Test serialization/deserialization for WorkspaceResponse
        """

        # Construct dict forms of any model objects needed in order to build this model.

        service_extensions_model = {}  # ServiceExtensions
        service_extensions_model['name'] = 'flavor'
        service_extensions_model['value'] = 'testString'
        service_extensions_model['type'] = 'string'

        catalog_ref_model = {}  # CatalogRef
        catalog_ref_model['dry_run'] = True
        catalog_ref_model['owning_account'] = 'testString'
        catalog_ref_model['item_icon_url'] = 'testString'
        catalog_ref_model['item_id'] = 'testString'
        catalog_ref_model['item_name'] = 'testString'
        catalog_ref_model['item_readme_url'] = 'testString'
        catalog_ref_model['item_url'] = 'testString'
        catalog_ref_model['launch_url'] = 'testString'
        catalog_ref_model['offering_version'] = 'testString'
        catalog_ref_model['service_extensions'] = [service_extensions_model]

        dependencies_model = {}  # Dependencies
        dependencies_model['parents'] = ['testString']
        dependencies_model['children'] = ['testString']

        shared_target_data_response_model = {}  # SharedTargetDataResponse
        shared_target_data_response_model['cluster_id'] = 'testString'
        shared_target_data_response_model['cluster_name'] = 'testString'
        shared_target_data_response_model['entitlement_keys'] = [{'anyKey': 'anyValue'}]
        shared_target_data_response_model['namespace'] = 'testString'
        shared_target_data_response_model['region'] = 'testString'
        shared_target_data_response_model['resource_group_id'] = 'testString'

        env_variable_response_model = {}  # EnvVariableResponse
        env_variable_response_model['hidden'] = True
        env_variable_response_model['name'] = 'testString'
        env_variable_response_model['secure'] = True
        env_variable_response_model['value'] = 'testString'

        workspace_variable_response_model = {}  # WorkspaceVariableResponse
        workspace_variable_response_model['description'] = 'testString'
        workspace_variable_response_model['name'] = 'testString'
        workspace_variable_response_model['secure'] = True
        workspace_variable_response_model['type'] = 'testString'
        workspace_variable_response_model['value'] = 'testString'

        template_source_data_response_model = {}  # TemplateSourceDataResponse
        template_source_data_response_model['env_values'] = [env_variable_response_model]
        template_source_data_response_model['folder'] = 'testString'
        template_source_data_response_model['compact'] = True
        template_source_data_response_model['has_githubtoken'] = True
        template_source_data_response_model['id'] = 'testString'
        template_source_data_response_model['type'] = 'testString'
        template_source_data_response_model['uninstall_script_name'] = 'testString'
        template_source_data_response_model['values'] = 'testString'
        template_source_data_response_model['values_metadata'] = [{'anyKey': 'anyValue'}]
        template_source_data_response_model['values_url'] = 'testString'
        template_source_data_response_model['variablestore'] = [workspace_variable_response_model]

        template_repo_response_model = {}  # TemplateRepoResponse
        template_repo_response_model['branch'] = 'testString'
        template_repo_response_model['full_url'] = 'testString'
        template_repo_response_model['has_uploadedgitrepotar'] = True
        template_repo_response_model['release'] = 'testString'
        template_repo_response_model['repo_sha_value'] = 'testString'
        template_repo_response_model['repo_url'] = 'testString'
        template_repo_response_model['url'] = 'testString'
        template_repo_response_model['skip_submodules_checkout'] = True

        last_job_model = {}  # LastJob
        last_job_model['job_id'] = 'testString'
        last_job_model['job_name'] = 'testString'
        last_job_model['job_status'] = 'testString'

        workspace_status_response_model = {}  # WorkspaceStatusResponse
        workspace_status_response_model['frozen'] = True
        workspace_status_response_model['frozen_at'] = '2019-01-01T12:00:00Z'
        workspace_status_response_model['frozen_by'] = 'testString'
        workspace_status_response_model['locked'] = True
        workspace_status_response_model['locked_by'] = 'testString'
        workspace_status_response_model['locked_time'] = '2019-01-01T12:00:00Z'

        workspace_status_message_model = {}  # WorkspaceStatusMessage
        workspace_status_message_model['status_code'] = 'testString'
        workspace_status_message_model['status_msg'] = 'testString'

        agent_info_model = {}  # AgentInfo
        agent_info_model['id'] = 'testString'
        agent_info_model['name'] = 'testString'
        agent_info_model['assignment_policy_id'] = 'testString'

        variable_metadata_model = {}  # VariableMetadata
        variable_metadata_model['type'] = 'boolean'
        variable_metadata_model['aliases'] = ['testString']
        variable_metadata_model['description'] = 'testString'
        variable_metadata_model['cloud_data_type'] = 'testString'
        variable_metadata_model['default_value'] = 'testString'
        variable_metadata_model['link_status'] = 'normal'
        variable_metadata_model['secure'] = True
        variable_metadata_model['immutable'] = True
        variable_metadata_model['hidden'] = True
        variable_metadata_model['required'] = True
        variable_metadata_model['options'] = ['testString']
        variable_metadata_model['min_value'] = 38
        variable_metadata_model['max_value'] = 38
        variable_metadata_model['min_length'] = 38
        variable_metadata_model['max_length'] = 38
        variable_metadata_model['matches'] = 'testString'
        variable_metadata_model['position'] = 38
        variable_metadata_model['group_by'] = 'testString'
        variable_metadata_model['source'] = 'testString'

        variable_data_model = {}  # VariableData
        variable_data_model['name'] = 'testString'
        variable_data_model['value'] = 'testString'
        variable_data_model['use_default'] = True
        variable_data_model['metadata'] = variable_metadata_model

        # Construct a json representation of a WorkspaceResponse model
        workspace_response_model_json = {}
        workspace_response_model_json['applied_shareddata_ids'] = ['testString']
        workspace_response_model_json['catalog_ref'] = catalog_ref_model
        workspace_response_model_json['dependencies'] = dependencies_model
        workspace_response_model_json['description'] = 'testString'
        workspace_response_model_json['location'] = 'testString'
        workspace_response_model_json['name'] = 'testString'
        workspace_response_model_json['resource_group'] = 'testString'
        workspace_response_model_json['shared_data'] = shared_target_data_response_model
        workspace_response_model_json['status'] = 'testString'
        workspace_response_model_json['tags'] = ['testString']
        workspace_response_model_json['template_data'] = [template_source_data_response_model]
        workspace_response_model_json['template_ref'] = 'testString'
        workspace_response_model_json['template_repo'] = template_repo_response_model
        workspace_response_model_json['type'] = ['testString']
        workspace_response_model_json['cart_id'] = 'testString'
        workspace_response_model_json['project_id'] = 'testString'
        workspace_response_model_json['last_action_name'] = 'testString'
        workspace_response_model_json['last_activity_id'] = 'testString'
        workspace_response_model_json['last_job'] = last_job_model
        workspace_response_model_json['workspace_status'] = workspace_status_response_model
        workspace_response_model_json['workspace_status_msg'] = workspace_status_message_model
        workspace_response_model_json['agent'] = agent_info_model
        workspace_response_model_json['settings'] = [variable_data_model]

        # Construct a model instance of WorkspaceResponse by calling from_dict on the json representation
        workspace_response_model = WorkspaceResponse.from_dict(workspace_response_model_json)
        assert workspace_response_model != False

        # Construct a model instance of WorkspaceResponse by calling from_dict on the json representation
        workspace_response_model_dict = WorkspaceResponse.from_dict(workspace_response_model_json).__dict__
        workspace_response_model2 = WorkspaceResponse(**workspace_response_model_dict)

        # Verify the model instances are equivalent
        assert workspace_response_model == workspace_response_model2

        # Convert model instance back to dict and verify no loss of data
        workspace_response_model_json2 = workspace_response_model.to_dict()
        assert workspace_response_model_json2 == workspace_response_model_json


class TestModel_WorkspaceResponseList:
    """
    Test Class for WorkspaceResponseList
    """

    def test_workspace_response_list_serialization(self):
        """
        Test serialization/deserialization for WorkspaceResponseList
        """

        # Construct dict forms of any model objects needed in order to build this model.

        service_extensions_model = {}  # ServiceExtensions
        service_extensions_model['name'] = 'flavor'
        service_extensions_model['value'] = 'testString'
        service_extensions_model['type'] = 'string'

        catalog_ref_model = {}  # CatalogRef
        catalog_ref_model['dry_run'] = True
        catalog_ref_model['owning_account'] = 'testString'
        catalog_ref_model['item_icon_url'] = 'testString'
        catalog_ref_model['item_id'] = 'testString'
        catalog_ref_model['item_name'] = 'testString'
        catalog_ref_model['item_readme_url'] = 'testString'
        catalog_ref_model['item_url'] = 'testString'
        catalog_ref_model['launch_url'] = 'testString'
        catalog_ref_model['offering_version'] = 'testString'
        catalog_ref_model['service_extensions'] = [service_extensions_model]

        dependencies_model = {}  # Dependencies
        dependencies_model['parents'] = ['testString']
        dependencies_model['children'] = ['testString']

        shared_target_data_response_model = {}  # SharedTargetDataResponse
        shared_target_data_response_model['cluster_id'] = 'testString'
        shared_target_data_response_model['cluster_name'] = 'testString'
        shared_target_data_response_model['entitlement_keys'] = [{'anyKey': 'anyValue'}]
        shared_target_data_response_model['namespace'] = 'testString'
        shared_target_data_response_model['region'] = 'testString'
        shared_target_data_response_model['resource_group_id'] = 'testString'

        env_variable_response_model = {}  # EnvVariableResponse
        env_variable_response_model['hidden'] = True
        env_variable_response_model['name'] = 'testString'
        env_variable_response_model['secure'] = True
        env_variable_response_model['value'] = 'testString'

        workspace_variable_response_model = {}  # WorkspaceVariableResponse
        workspace_variable_response_model['description'] = 'testString'
        workspace_variable_response_model['name'] = 'testString'
        workspace_variable_response_model['secure'] = True
        workspace_variable_response_model['type'] = 'testString'
        workspace_variable_response_model['value'] = 'testString'

        template_source_data_response_model = {}  # TemplateSourceDataResponse
        template_source_data_response_model['env_values'] = [env_variable_response_model]
        template_source_data_response_model['folder'] = 'testString'
        template_source_data_response_model['compact'] = True
        template_source_data_response_model['has_githubtoken'] = True
        template_source_data_response_model['id'] = 'testString'
        template_source_data_response_model['type'] = 'testString'
        template_source_data_response_model['uninstall_script_name'] = 'testString'
        template_source_data_response_model['values'] = 'testString'
        template_source_data_response_model['values_metadata'] = [{'anyKey': 'anyValue'}]
        template_source_data_response_model['values_url'] = 'testString'
        template_source_data_response_model['variablestore'] = [workspace_variable_response_model]

        template_repo_response_model = {}  # TemplateRepoResponse
        template_repo_response_model['branch'] = 'testString'
        template_repo_response_model['full_url'] = 'testString'
        template_repo_response_model['has_uploadedgitrepotar'] = True
        template_repo_response_model['release'] = 'testString'
        template_repo_response_model['repo_sha_value'] = 'testString'
        template_repo_response_model['repo_url'] = 'testString'
        template_repo_response_model['url'] = 'testString'
        template_repo_response_model['skip_submodules_checkout'] = True

        last_job_model = {}  # LastJob
        last_job_model['job_id'] = 'testString'
        last_job_model['job_name'] = 'testString'
        last_job_model['job_status'] = 'testString'

        workspace_status_response_model = {}  # WorkspaceStatusResponse
        workspace_status_response_model['frozen'] = True
        workspace_status_response_model['frozen_at'] = '2019-01-01T12:00:00Z'
        workspace_status_response_model['frozen_by'] = 'testString'
        workspace_status_response_model['locked'] = True
        workspace_status_response_model['locked_by'] = 'testString'
        workspace_status_response_model['locked_time'] = '2019-01-01T12:00:00Z'

        workspace_status_message_model = {}  # WorkspaceStatusMessage
        workspace_status_message_model['status_code'] = 'testString'
        workspace_status_message_model['status_msg'] = 'testString'

        agent_info_model = {}  # AgentInfo
        agent_info_model['id'] = 'testString'
        agent_info_model['name'] = 'testString'
        agent_info_model['assignment_policy_id'] = 'testString'

        variable_metadata_model = {}  # VariableMetadata
        variable_metadata_model['type'] = 'boolean'
        variable_metadata_model['aliases'] = ['testString']
        variable_metadata_model['description'] = 'testString'
        variable_metadata_model['cloud_data_type'] = 'testString'
        variable_metadata_model['default_value'] = 'testString'
        variable_metadata_model['link_status'] = 'normal'
        variable_metadata_model['secure'] = True
        variable_metadata_model['immutable'] = True
        variable_metadata_model['hidden'] = True
        variable_metadata_model['required'] = True
        variable_metadata_model['options'] = ['testString']
        variable_metadata_model['min_value'] = 38
        variable_metadata_model['max_value'] = 38
        variable_metadata_model['min_length'] = 38
        variable_metadata_model['max_length'] = 38
        variable_metadata_model['matches'] = 'testString'
        variable_metadata_model['position'] = 38
        variable_metadata_model['group_by'] = 'testString'
        variable_metadata_model['source'] = 'testString'

        variable_data_model = {}  # VariableData
        variable_data_model['name'] = 'testString'
        variable_data_model['value'] = 'testString'
        variable_data_model['use_default'] = True
        variable_data_model['metadata'] = variable_metadata_model

        workspace_response_model = {}  # WorkspaceResponse
        workspace_response_model['applied_shareddata_ids'] = ['testString']
        workspace_response_model['catalog_ref'] = catalog_ref_model
        workspace_response_model['dependencies'] = dependencies_model
        workspace_response_model['description'] = 'testString'
        workspace_response_model['location'] = 'testString'
        workspace_response_model['name'] = 'testString'
        workspace_response_model['resource_group'] = 'testString'
        workspace_response_model['shared_data'] = shared_target_data_response_model
        workspace_response_model['status'] = 'testString'
        workspace_response_model['tags'] = ['testString']
        workspace_response_model['template_data'] = [template_source_data_response_model]
        workspace_response_model['template_ref'] = 'testString'
        workspace_response_model['template_repo'] = template_repo_response_model
        workspace_response_model['type'] = ['testString']
        workspace_response_model['cart_id'] = 'testString'
        workspace_response_model['project_id'] = 'testString'
        workspace_response_model['last_action_name'] = 'testString'
        workspace_response_model['last_activity_id'] = 'testString'
        workspace_response_model['last_job'] = last_job_model
        workspace_response_model['workspace_status'] = workspace_status_response_model
        workspace_response_model['workspace_status_msg'] = workspace_status_message_model
        workspace_response_model['agent'] = agent_info_model
        workspace_response_model['settings'] = [variable_data_model]

        # Construct a json representation of a WorkspaceResponseList model
        workspace_response_list_model_json = {}
        workspace_response_list_model_json['count'] = 26
        workspace_response_list_model_json['limit'] = 26
        workspace_response_list_model_json['offset'] = 26
        workspace_response_list_model_json['workspaces'] = [workspace_response_model]

        # Construct a model instance of WorkspaceResponseList by calling from_dict on the json representation
        workspace_response_list_model = WorkspaceResponseList.from_dict(workspace_response_list_model_json)
        assert workspace_response_list_model != False

        # Construct a model instance of WorkspaceResponseList by calling from_dict on the json representation
        workspace_response_list_model_dict = WorkspaceResponseList.from_dict(
            workspace_response_list_model_json
        ).__dict__
        workspace_response_list_model2 = WorkspaceResponseList(**workspace_response_list_model_dict)

        # Verify the model instances are equivalent
        assert workspace_response_list_model == workspace_response_list_model2

        # Convert model instance back to dict and verify no loss of data
        workspace_response_list_model_json2 = workspace_response_list_model.to_dict()
        assert workspace_response_list_model_json2 == workspace_response_list_model_json


class TestModel_WorkspaceStatusMessage:
    """
    Test Class for WorkspaceStatusMessage
    """

    def test_workspace_status_message_serialization(self):
        """
        Test serialization/deserialization for WorkspaceStatusMessage
        """

        # Construct a json representation of a WorkspaceStatusMessage model
        workspace_status_message_model_json = {}
        workspace_status_message_model_json['status_code'] = 'testString'
        workspace_status_message_model_json['status_msg'] = 'testString'

        # Construct a model instance of WorkspaceStatusMessage by calling from_dict on the json representation
        workspace_status_message_model = WorkspaceStatusMessage.from_dict(workspace_status_message_model_json)
        assert workspace_status_message_model != False

        # Construct a model instance of WorkspaceStatusMessage by calling from_dict on the json representation
        workspace_status_message_model_dict = WorkspaceStatusMessage.from_dict(
            workspace_status_message_model_json
        ).__dict__
        workspace_status_message_model2 = WorkspaceStatusMessage(**workspace_status_message_model_dict)

        # Verify the model instances are equivalent
        assert workspace_status_message_model == workspace_status_message_model2

        # Convert model instance back to dict and verify no loss of data
        workspace_status_message_model_json2 = workspace_status_message_model.to_dict()
        assert workspace_status_message_model_json2 == workspace_status_message_model_json


class TestModel_WorkspaceStatusRequest:
    """
    Test Class for WorkspaceStatusRequest
    """

    def test_workspace_status_request_serialization(self):
        """
        Test serialization/deserialization for WorkspaceStatusRequest
        """

        # Construct a json representation of a WorkspaceStatusRequest model
        workspace_status_request_model_json = {}
        workspace_status_request_model_json['frozen'] = True
        workspace_status_request_model_json['frozen_at'] = '2019-01-01T12:00:00Z'
        workspace_status_request_model_json['frozen_by'] = 'testString'
        workspace_status_request_model_json['locked'] = True
        workspace_status_request_model_json['locked_by'] = 'testString'
        workspace_status_request_model_json['locked_time'] = '2019-01-01T12:00:00Z'

        # Construct a model instance of WorkspaceStatusRequest by calling from_dict on the json representation
        workspace_status_request_model = WorkspaceStatusRequest.from_dict(workspace_status_request_model_json)
        assert workspace_status_request_model != False

        # Construct a model instance of WorkspaceStatusRequest by calling from_dict on the json representation
        workspace_status_request_model_dict = WorkspaceStatusRequest.from_dict(
            workspace_status_request_model_json
        ).__dict__
        workspace_status_request_model2 = WorkspaceStatusRequest(**workspace_status_request_model_dict)

        # Verify the model instances are equivalent
        assert workspace_status_request_model == workspace_status_request_model2

        # Convert model instance back to dict and verify no loss of data
        workspace_status_request_model_json2 = workspace_status_request_model.to_dict()
        assert workspace_status_request_model_json2 == workspace_status_request_model_json


class TestModel_WorkspaceStatusResponse:
    """
    Test Class for WorkspaceStatusResponse
    """

    def test_workspace_status_response_serialization(self):
        """
        Test serialization/deserialization for WorkspaceStatusResponse
        """

        # Construct a json representation of a WorkspaceStatusResponse model
        workspace_status_response_model_json = {}
        workspace_status_response_model_json['frozen'] = True
        workspace_status_response_model_json['frozen_at'] = '2019-01-01T12:00:00Z'
        workspace_status_response_model_json['frozen_by'] = 'testString'
        workspace_status_response_model_json['locked'] = True
        workspace_status_response_model_json['locked_by'] = 'testString'
        workspace_status_response_model_json['locked_time'] = '2019-01-01T12:00:00Z'

        # Construct a model instance of WorkspaceStatusResponse by calling from_dict on the json representation
        workspace_status_response_model = WorkspaceStatusResponse.from_dict(workspace_status_response_model_json)
        assert workspace_status_response_model != False

        # Construct a model instance of WorkspaceStatusResponse by calling from_dict on the json representation
        workspace_status_response_model_dict = WorkspaceStatusResponse.from_dict(
            workspace_status_response_model_json
        ).__dict__
        workspace_status_response_model2 = WorkspaceStatusResponse(**workspace_status_response_model_dict)

        # Verify the model instances are equivalent
        assert workspace_status_response_model == workspace_status_response_model2

        # Convert model instance back to dict and verify no loss of data
        workspace_status_response_model_json2 = workspace_status_response_model.to_dict()
        assert workspace_status_response_model_json2 == workspace_status_response_model_json


class TestModel_WorkspaceStatusUpdateRequest:
    """
    Test Class for WorkspaceStatusUpdateRequest
    """

    def test_workspace_status_update_request_serialization(self):
        """
        Test serialization/deserialization for WorkspaceStatusUpdateRequest
        """

        # Construct a json representation of a WorkspaceStatusUpdateRequest model
        workspace_status_update_request_model_json = {}
        workspace_status_update_request_model_json['frozen'] = True
        workspace_status_update_request_model_json['frozen_at'] = '2019-01-01T12:00:00Z'
        workspace_status_update_request_model_json['frozen_by'] = 'testString'
        workspace_status_update_request_model_json['locked'] = True
        workspace_status_update_request_model_json['locked_by'] = 'testString'
        workspace_status_update_request_model_json['locked_time'] = '2019-01-01T12:00:00Z'

        # Construct a model instance of WorkspaceStatusUpdateRequest by calling from_dict on the json representation
        workspace_status_update_request_model = WorkspaceStatusUpdateRequest.from_dict(
            workspace_status_update_request_model_json
        )
        assert workspace_status_update_request_model != False

        # Construct a model instance of WorkspaceStatusUpdateRequest by calling from_dict on the json representation
        workspace_status_update_request_model_dict = WorkspaceStatusUpdateRequest.from_dict(
            workspace_status_update_request_model_json
        ).__dict__
        workspace_status_update_request_model2 = WorkspaceStatusUpdateRequest(
            **workspace_status_update_request_model_dict
        )

        # Verify the model instances are equivalent
        assert workspace_status_update_request_model == workspace_status_update_request_model2

        # Convert model instance back to dict and verify no loss of data
        workspace_status_update_request_model_json2 = workspace_status_update_request_model.to_dict()
        assert workspace_status_update_request_model_json2 == workspace_status_update_request_model_json


class TestModel_WorkspaceTemplateValuesResponse:
    """
    Test Class for WorkspaceTemplateValuesResponse
    """

    def test_workspace_template_values_response_serialization(self):
        """
        Test serialization/deserialization for WorkspaceTemplateValuesResponse
        """

        # Construct dict forms of any model objects needed in order to build this model.

        template_run_time_data_response_model = {}  # TemplateRunTimeDataResponse
        template_run_time_data_response_model['engine_cmd'] = 'testString'
        template_run_time_data_response_model['engine_name'] = 'testString'
        template_run_time_data_response_model['engine_version'] = 'testString'
        template_run_time_data_response_model['id'] = 'testString'
        template_run_time_data_response_model['log_store_url'] = 'testString'
        template_run_time_data_response_model['output_values'] = [{'anyKey': 'anyValue'}]
        template_run_time_data_response_model['resources'] = [[{'anyKey': 'anyValue'}]]
        template_run_time_data_response_model['state_store_url'] = 'testString'

        shared_target_data_model = {}  # SharedTargetData
        shared_target_data_model['cluster_created_on'] = 'testString'
        shared_target_data_model['cluster_id'] = 'testString'
        shared_target_data_model['cluster_name'] = 'testString'
        shared_target_data_model['cluster_type'] = 'testString'
        shared_target_data_model['entitlement_keys'] = [{'anyKey': 'anyValue'}]
        shared_target_data_model['namespace'] = 'testString'
        shared_target_data_model['region'] = 'testString'
        shared_target_data_model['resource_group_id'] = 'testString'
        shared_target_data_model['worker_count'] = 26
        shared_target_data_model['worker_machine_type'] = 'testString'

        env_variable_response_model = {}  # EnvVariableResponse
        env_variable_response_model['hidden'] = True
        env_variable_response_model['name'] = 'testString'
        env_variable_response_model['secure'] = True
        env_variable_response_model['value'] = 'testString'

        workspace_variable_response_model = {}  # WorkspaceVariableResponse
        workspace_variable_response_model['description'] = 'testString'
        workspace_variable_response_model['name'] = 'testString'
        workspace_variable_response_model['secure'] = True
        workspace_variable_response_model['type'] = 'testString'
        workspace_variable_response_model['value'] = 'testString'

        template_source_data_response_model = {}  # TemplateSourceDataResponse
        template_source_data_response_model['env_values'] = [env_variable_response_model]
        template_source_data_response_model['folder'] = 'testString'
        template_source_data_response_model['compact'] = True
        template_source_data_response_model['has_githubtoken'] = True
        template_source_data_response_model['id'] = 'testString'
        template_source_data_response_model['type'] = 'testString'
        template_source_data_response_model['uninstall_script_name'] = 'testString'
        template_source_data_response_model['values'] = 'testString'
        template_source_data_response_model['values_metadata'] = [{'anyKey': 'anyValue'}]
        template_source_data_response_model['values_url'] = 'testString'
        template_source_data_response_model['variablestore'] = [workspace_variable_response_model]

        # Construct a json representation of a WorkspaceTemplateValuesResponse model
        workspace_template_values_response_model_json = {}
        workspace_template_values_response_model_json['runtime_data'] = [template_run_time_data_response_model]
        workspace_template_values_response_model_json['shared_data'] = shared_target_data_model
        workspace_template_values_response_model_json['template_data'] = [template_source_data_response_model]

        # Construct a model instance of WorkspaceTemplateValuesResponse by calling from_dict on the json representation
        workspace_template_values_response_model = WorkspaceTemplateValuesResponse.from_dict(
            workspace_template_values_response_model_json
        )
        assert workspace_template_values_response_model != False

        # Construct a model instance of WorkspaceTemplateValuesResponse by calling from_dict on the json representation
        workspace_template_values_response_model_dict = WorkspaceTemplateValuesResponse.from_dict(
            workspace_template_values_response_model_json
        ).__dict__
        workspace_template_values_response_model2 = WorkspaceTemplateValuesResponse(
            **workspace_template_values_response_model_dict
        )

        # Verify the model instances are equivalent
        assert workspace_template_values_response_model == workspace_template_values_response_model2

        # Convert model instance back to dict and verify no loss of data
        workspace_template_values_response_model_json2 = workspace_template_values_response_model.to_dict()
        assert workspace_template_values_response_model_json2 == workspace_template_values_response_model_json


class TestModel_WorkspaceVariableRequest:
    """
    Test Class for WorkspaceVariableRequest
    """

    def test_workspace_variable_request_serialization(self):
        """
        Test serialization/deserialization for WorkspaceVariableRequest
        """

        # Construct a json representation of a WorkspaceVariableRequest model
        workspace_variable_request_model_json = {}
        workspace_variable_request_model_json['description'] = 'testString'
        workspace_variable_request_model_json['name'] = 'testString'
        workspace_variable_request_model_json['secure'] = True
        workspace_variable_request_model_json['type'] = 'testString'
        workspace_variable_request_model_json['use_default'] = True
        workspace_variable_request_model_json['value'] = 'testString'

        # Construct a model instance of WorkspaceVariableRequest by calling from_dict on the json representation
        workspace_variable_request_model = WorkspaceVariableRequest.from_dict(workspace_variable_request_model_json)
        assert workspace_variable_request_model != False

        # Construct a model instance of WorkspaceVariableRequest by calling from_dict on the json representation
        workspace_variable_request_model_dict = WorkspaceVariableRequest.from_dict(
            workspace_variable_request_model_json
        ).__dict__
        workspace_variable_request_model2 = WorkspaceVariableRequest(**workspace_variable_request_model_dict)

        # Verify the model instances are equivalent
        assert workspace_variable_request_model == workspace_variable_request_model2

        # Convert model instance back to dict and verify no loss of data
        workspace_variable_request_model_json2 = workspace_variable_request_model.to_dict()
        assert workspace_variable_request_model_json2 == workspace_variable_request_model_json


class TestModel_WorkspaceVariableResponse:
    """
    Test Class for WorkspaceVariableResponse
    """

    def test_workspace_variable_response_serialization(self):
        """
        Test serialization/deserialization for WorkspaceVariableResponse
        """

        # Construct a json representation of a WorkspaceVariableResponse model
        workspace_variable_response_model_json = {}
        workspace_variable_response_model_json['description'] = 'testString'
        workspace_variable_response_model_json['name'] = 'testString'
        workspace_variable_response_model_json['secure'] = True
        workspace_variable_response_model_json['type'] = 'testString'
        workspace_variable_response_model_json['value'] = 'testString'

        # Construct a model instance of WorkspaceVariableResponse by calling from_dict on the json representation
        workspace_variable_response_model = WorkspaceVariableResponse.from_dict(workspace_variable_response_model_json)
        assert workspace_variable_response_model != False

        # Construct a model instance of WorkspaceVariableResponse by calling from_dict on the json representation
        workspace_variable_response_model_dict = WorkspaceVariableResponse.from_dict(
            workspace_variable_response_model_json
        ).__dict__
        workspace_variable_response_model2 = WorkspaceVariableResponse(**workspace_variable_response_model_dict)

        # Verify the model instances are equivalent
        assert workspace_variable_response_model == workspace_variable_response_model2

        # Convert model instance back to dict and verify no loss of data
        workspace_variable_response_model_json2 = workspace_variable_response_model.to_dict()
        assert workspace_variable_response_model_json2 == workspace_variable_response_model_json


# endregion
##############################################################################
# End of Model Tests
##############################################################################
