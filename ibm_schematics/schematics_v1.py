# coding: utf-8

# (C) Copyright IBM Corp. 2024.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

# IBM OpenAPI SDK Code Generator Version: 3.96.1-5136e54a-20241108-203028

"""
IBM Cloud Schematics service is to provide the capability to manage resources  of cloud
provider infrastructure by using file based configurations.  With the IBM Cloud Schematics
service you can specify the  required set of resources and the configuration in `config
files`,  and then pass the config files to the service to fulfill it by  calling the
necessary actions on the infrastructure.  This principle is known as Infrastructure as
Code.  For more information, refer to [Getting started with IBM Cloud Schematics]
(https://cloud.ibm.com/docs/schematics?topic=schematics-getting-started).

API Version: 1.0
"""

from datetime import datetime
from enum import Enum
from typing import BinaryIO, Dict, List, Optional
import base64
import json
import logging

from ibm_cloud_sdk_core import BaseService, DetailedResponse
from ibm_cloud_sdk_core.authenticators.authenticator import Authenticator
from ibm_cloud_sdk_core.get_authenticator import get_authenticator_from_environment
from ibm_cloud_sdk_core.utils import convert_model, datetime_to_string, string_to_datetime

from .common import get_sdk_headers

##############################################################################
# Service
##############################################################################


class SchematicsV1(BaseService):
    """The schematics V1 service."""

    DEFAULT_SERVICE_URL = 'https://schematics.cloud.ibm.com'
    DEFAULT_SERVICE_NAME = 'schematics'

    @classmethod
    def new_instance(
        cls,
        service_name: str = DEFAULT_SERVICE_NAME,
    ) -> 'SchematicsV1':
        """
        Return a new client for the schematics service using the specified
               parameters and external configuration.
        """
        authenticator = get_authenticator_from_environment(service_name)
        service = cls(authenticator)
        service.configure_service(service_name)
        return service

    def __init__(
        self,
        authenticator: Authenticator = None,
    ) -> None:
        """
        Construct a new client for the schematics service.

        :param Authenticator authenticator: The authenticator specifies the authentication mechanism.
               Get up to date information from https://github.com/IBM/python-sdk-core/blob/main/README.md
               about initializing the authenticator of your choice.
        """
        BaseService.__init__(self, service_url=self.DEFAULT_SERVICE_URL, authenticator=authenticator)

    #########################
    # util
    #########################

    def list_schematics_location(
        self,
        **kwargs,
    ) -> DetailedResponse:
        """
        List supported schematics locations.

        Retrieve a list of IBM Cloud locations where you can create the Schematics
        workspace or action. workspaces.
          <h3>Authorization</h3>
          Schematics support generic authorization for its resources.
          For more information, about Schematics access and permissions,
          see [Schematics service access roles and required
        permissions](https://cloud.ibm.com/docs/schematics?topic=schematics-access#access-roles).

        :param dict headers: A `dict` containing the request headers
        :return: A `DetailedResponse` containing the result, headers and HTTP status code.
        :rtype: DetailedResponse with `List[SchematicsLocations]` result
        """

        headers = {}
        sdk_headers = get_sdk_headers(
            service_name=self.DEFAULT_SERVICE_NAME,
            service_version='V1',
            operation_id='list_schematics_location',
        )
        headers.update(sdk_headers)

        if 'headers' in kwargs:
            headers.update(kwargs.get('headers'))
            del kwargs['headers']
        headers['Accept'] = 'application/json'

        url = '/v1/locations'
        request = self.prepare_request(
            method='GET',
            url=url,
            headers=headers,
        )

        response = self.send(request, **kwargs)
        return response

    def list_locations(
        self,
        **kwargs,
    ) -> DetailedResponse:
        """
        List supported locations.

        Retrieve a list of IBM Cloud locations where you can work with the Schematics
        objects.
          <h3>Authorization</h3>
          Schematics support generic authorization for its resources.
          For more information, about Schematics access and permissions,
          see [Schematics service access roles and required
        permissions](https://cloud.ibm.com/docs/schematics?topic=schematics-access#access-roles).

        :param dict headers: A `dict` containing the request headers
        :return: A `DetailedResponse` containing the result, headers and HTTP status code.
        :rtype: DetailedResponse with `dict` result representing a `SchematicsLocationsList` object
        """

        headers = {}
        sdk_headers = get_sdk_headers(
            service_name=self.DEFAULT_SERVICE_NAME,
            service_version='V1',
            operation_id='list_locations',
        )
        headers.update(sdk_headers)

        if 'headers' in kwargs:
            headers.update(kwargs.get('headers'))
            del kwargs['headers']
        headers['Accept'] = 'application/json'

        url = '/v2/locations'
        request = self.prepare_request(
            method='GET',
            url=url,
            headers=headers,
        )

        response = self.send(request, **kwargs)
        return response

    def list_resource_group(
        self,
        **kwargs,
    ) -> DetailedResponse:
        """
        List resource groups.

        Retrieve a list of IBM Cloud resource groups that your account has access to.
          <h3>Authorization</h3>
          Schematics support generic authorization for its resources.
          For more information, about Schematics access and permissions,
          see [Schematics service access roles and required
        permissions](https://cloud.ibm.com/docs/schematics?topic=schematics-access#access-roles).

        :param dict headers: A `dict` containing the request headers
        :return: A `DetailedResponse` containing the result, headers and HTTP status code.
        :rtype: DetailedResponse with `List[ResourceGroupResponse]` result
        """

        headers = {}
        sdk_headers = get_sdk_headers(
            service_name=self.DEFAULT_SERVICE_NAME,
            service_version='V1',
            operation_id='list_resource_group',
        )
        headers.update(sdk_headers)

        if 'headers' in kwargs:
            headers.update(kwargs.get('headers'))
            del kwargs['headers']
        headers['Accept'] = 'application/json'

        url = '/v1/resource_groups'
        request = self.prepare_request(
            method='GET',
            url=url,
            headers=headers,
        )

        response = self.send(request, **kwargs)
        return response

    def get_schematics_version(
        self,
        **kwargs,
    ) -> DetailedResponse:
        """
        Get Schematics API information.

        Retrieve detailed information about the IBM Cloud Schematics API version and the
        version of the provider plug-ins that the API uses.

        :param dict headers: A `dict` containing the request headers
        :return: A `DetailedResponse` containing the result, headers and HTTP status code.
        :rtype: DetailedResponse with `dict` result representing a `VersionResponse` object
        """

        headers = {}
        sdk_headers = get_sdk_headers(
            service_name=self.DEFAULT_SERVICE_NAME,
            service_version='V1',
            operation_id='get_schematics_version',
        )
        headers.update(sdk_headers)

        if 'headers' in kwargs:
            headers.update(kwargs.get('headers'))
            del kwargs['headers']
        headers['Accept'] = 'application/json'

        url = '/v1/version'
        request = self.prepare_request(
            method='GET',
            url=url,
            headers=headers,
        )

        response = self.send(request, **kwargs)
        return response

    def process_template_meta_data(
        self,
        template_type: str,
        source: 'ExternalSource',
        *,
        region: Optional[str] = None,
        source_type: Optional[str] = None,
        x_github_token: Optional[str] = None,
        **kwargs,
    ) -> DetailedResponse:
        """
        Get variable metadata by parsing the template.

        Get the variable metadata from the template. This metadata can be passed in the
        payload during Schematics workspace create or update API call.
         <h3>Authorization</h3>
         Schematics support generic authorization for its resources.
         For more information, about Schematics access and permissions, see
         [Schematics service access roles and required
        permissions](https://cloud.ibm.com/docs/schematics?topic=schematics-access#access-roles).

        :param str template_type: Template type such as **terraform**, **ansible**,
               **helm**, **cloudpak**, or **bash script**.
        :param ExternalSource source: Source of templates, playbooks, or controls.
        :param str region: (optional) Region on which request should process.
               Applicable only on global endpoint.
        :param str source_type: (optional) Type of source for the Template.
        :param str x_github_token: (optional) The personal access token to
               authenticate with your private GitHub or GitLab repository and access your
               Terraform template.
        :param dict headers: A `dict` containing the request headers
        :return: A `DetailedResponse` containing the result, headers and HTTP status code.
        :rtype: DetailedResponse with `dict` result representing a `TemplateMetaDataResponse` object
        """

        if template_type is None:
            raise ValueError('template_type must be provided')
        if source is None:
            raise ValueError('source must be provided')
        source = convert_model(source)
        headers = {
            'X-Github-token': x_github_token,
        }
        sdk_headers = get_sdk_headers(
            service_name=self.DEFAULT_SERVICE_NAME,
            service_version='V1',
            operation_id='process_template_meta_data',
        )
        headers.update(sdk_headers)

        data = {
            'template_type': template_type,
            'source': source,
            'region': region,
            'source_type': source_type,
        }
        data = {k: v for (k, v) in data.items() if v is not None}
        data = json.dumps(data)
        headers['content-type'] = 'application/json'

        if 'headers' in kwargs:
            headers.update(kwargs.get('headers'))
            del kwargs['headers']
        headers['Accept'] = 'application/json'

        url = '/v2/template_metadata_processor'
        request = self.prepare_request(
            method='POST',
            url=url,
            headers=headers,
            data=data,
        )

        response = self.send(request, **kwargs)
        return response

    #########################
    # workspaces
    #########################

    def list_workspaces(
        self,
        *,
        offset: Optional[int] = None,
        limit: Optional[int] = None,
        profile: Optional[str] = None,
        resource_group: Optional[str] = None,
        **kwargs,
    ) -> DetailedResponse:
        """
        List workspaces.

        Retrieve a list of Schematics workspaces from your IBM Cloud account that you have
        access to. The list of workspaces that is returned depends on the API endpoint
        that you use. For example, if you use an API endpoint for a geography, such as
        North America, only workspaces that are created in `us-south` or `us-east` are
        returned.
         For more information about supported API endpoints, see [API
        endpoints](/apidocs/schematics#api-endpoints).
          <h3>Authorization</h3>
          Schematics support generic authorization for its resources.
          For more information, about Schematics access and permissions,
          see [Schematics service access roles and required
        permissions](https://cloud.ibm.com/docs/schematics?topic=schematics-access#access-roles).

        :param int offset: (optional) The starting position of the item in the list
               of items. For example, if you have three workspaces in your account, the
               first workspace is assigned position number 0, the second workspace is
               assigned position number 1, and so forth. If you have 6 workspaces and you
               want to list the details for workspaces `2-6`, enter 1. To limit the number
               of workspaces that is returned, use the `limit` option in addition to the
               `offset` option. Negative numbers are not supported and are ignored.
        :param int limit: (optional) The maximum number of items that you want to
               list. The number must be a positive integer between 1 and 2000. If no value
               is provided, 100 is used by default.
        :param str profile: (optional) Level of details returned by the get method.
        :param str resource_group: (optional) The resource group (by default, fetch
               from all resource groups) name or ID.
        :param dict headers: A `dict` containing the request headers
        :return: A `DetailedResponse` containing the result, headers and HTTP status code.
        :rtype: DetailedResponse with `dict` result representing a `WorkspaceResponseList` object
        """

        headers = {}
        sdk_headers = get_sdk_headers(
            service_name=self.DEFAULT_SERVICE_NAME,
            service_version='V1',
            operation_id='list_workspaces',
        )
        headers.update(sdk_headers)

        params = {
            'offset': offset,
            'limit': limit,
            'profile': profile,
            'resource_group': resource_group,
        }

        if 'headers' in kwargs:
            headers.update(kwargs.get('headers'))
            del kwargs['headers']
        headers['Accept'] = 'application/json'

        url = '/v1/workspaces'
        request = self.prepare_request(
            method='GET',
            url=url,
            headers=headers,
            params=params,
        )

        response = self.send(request, **kwargs)
        return response

    def create_workspace(
        self,
        *,
        applied_shareddata_ids: Optional[List[str]] = None,
        catalog_ref: Optional['CatalogRef'] = None,
        dependencies: Optional['Dependencies'] = None,
        description: Optional[str] = None,
        location: Optional[str] = None,
        name: Optional[str] = None,
        resource_group: Optional[str] = None,
        shared_data: Optional['SharedTargetData'] = None,
        tags: Optional[List[str]] = None,
        template_data: Optional[List['TemplateSourceDataRequest']] = None,
        template_ref: Optional[str] = None,
        template_repo: Optional['TemplateRepoRequest'] = None,
        type: Optional[List[str]] = None,
        workspace_status: Optional['WorkspaceStatusRequest'] = None,
        agent_id: Optional[str] = None,
        settings: Optional[List['VariableData']] = None,
        x_github_token: Optional[str] = None,
        **kwargs,
    ) -> DetailedResponse:
        """
        Create a workspace.

        Create an IBM Cloud Schematics workspace that points to the source repository
        where your Terraform template or the IBM Cloud software template is stored. You
        can decide to create your workspace without connecting it to a GitHub or GitLab
        repository. Your workspace is then created with a **Draft** state. To later
        connect your workspace to a GitHub or GitLab repository, you must use the `PUT
        /v1/workspaces/{id}` API to update the workspace or use the
        `/v1/workspaces/{id}/templates/{template_id}/template_repo_upload` API to upload a
        TAR file instead.
         **Getting API endpoint**:-
         * The Schematics API endpoint that you use to create the workspace determines
        where your Schematics actions run and your data is stored. See [API
        endpoints](/apidocs/schematics#api-endpoints) for more information.
         * If you use the API endpoint for a geography and not a specific location, such
        as North America, you can specify the location in your API request body.
         * If you do not specify the location in the request body, Schematics determines
        your workspace location based on availability.
         * If you use an API endpoint for a specific location, such as Frankfurt, the
        location that you enter in your API request body must match your API endpoint.
         * You also have the option to not specify a location in your API request body if
        you use a location-specific API endpoint.
         **Getting IAM access token** :-
         * Before you create Schematics workspace, you need to create the IAM access token
        for your IBM Cloud Account.
         * To create IAM access token, use `export IBMCLOUD_API_KEY=<ibmcloud_api_key>`
        and execute `curl -X POST "https://iam.cloud.ibm.com/identity/token" -H
        "Content-Type= application/x-www-form-urlencoded" -d
        "grant_type=urn:ibm:params:oauth:grant-type:apikey&apikey=$IBMCLOUD_API_KEY" -u
        bx:bx`. For more information, about creating IAM access token and API Docs, see
        [IAM access token](/apidocs/iam-identity-token-api#gettoken-password) and [Create
        API key](/apidocs/iam-identity-token-api#create-api-key).
         * You can set the environment values  `export ACCESS_TOKEN=<access_token>` and
        `export REFRESH_TOKEN=<refresh_token>`.
         * You can use the obtained IAM access token in create workspace `curl` command.
          <h3>Authorization</h3>
          Schematics support generic authorization for its resources.
          For more information, about Schematics access and permissions,
          see [Schematics service access roles and required
        permissions](https://cloud.ibm.com/docs/schematics?topic=schematics-access#access-roles).

        :param List[str] applied_shareddata_ids: (optional) Deprecated: List of
               applied shared dataset ID.
        :param CatalogRef catalog_ref: (optional) Information about the software
               template that you chose from the IBM Cloud catalog. This information is
               returned for IBM Cloud catalog offerings only.
        :param Dependencies dependencies: (optional) Workspace dependencies.
        :param str description: (optional) The description of the workspace.
        :param str location: (optional) The location where you want to create your
               Schematics workspace and run the Schematics jobs. The location that you
               enter must match the API endpoint that you use. For example, if you use the
               Frankfurt API endpoint, you must specify `eu-de` as your location. If you
               use an API endpoint for a geography and you do not specify a location,
               Schematics determines the location based on availability.
        :param str name: (optional) The name of your workspace. The name can be up
               to 128 characters long and can include alphanumeric characters, spaces,
               dashes, and underscores. When you create a workspace for your own Terraform
               template, consider including the microservice component that you set up
               with your Terraform template and the IBM Cloud environment where you want
               to deploy your resources in your name.
        :param str resource_group: (optional) The ID of the resource group where
               you want to provision the workspace.
        :param SharedTargetData shared_data: (optional) Information about the
               Target used by the templates originating from the  IBM Cloud catalog
               offerings. This information is not relevant for workspace created using
               your own Terraform template.
        :param List[str] tags: (optional) A list of tags that are associated with
               the workspace.
        :param List[TemplateSourceDataRequest] template_data: (optional) Input data
               for the Template.
        :param str template_ref: (optional) Workspace template ref.
        :param TemplateRepoRequest template_repo: (optional) Input variables for
               the Template repoository, while creating a workspace.
        :param List[str] type: (optional) List of Workspace type.
        :param WorkspaceStatusRequest workspace_status: (optional)
               WorkspaceStatusRequest -.
        :param str agent_id: (optional) agent id which is binded to with the
               workspace.
        :param List[VariableData] settings: (optional) Input settings to be applied
               to the workspace, for example, `job_timeout_override`.
        :param str x_github_token: (optional) The personal access token to
               authenticate with your private GitHub or GitLab repository and access your
               Terraform template.
        :param dict headers: A `dict` containing the request headers
        :return: A `DetailedResponse` containing the result, headers and HTTP status code.
        :rtype: DetailedResponse with `dict` result representing a `WorkspaceResponse` object
        """

        if catalog_ref is not None:
            catalog_ref = convert_model(catalog_ref)
        if dependencies is not None:
            dependencies = convert_model(dependencies)
        if shared_data is not None:
            shared_data = convert_model(shared_data)
        if template_data is not None:
            template_data = [convert_model(x) for x in template_data]
        if template_repo is not None:
            template_repo = convert_model(template_repo)
        if workspace_status is not None:
            workspace_status = convert_model(workspace_status)
        if settings is not None:
            settings = [convert_model(x) for x in settings]
        headers = {
            'X-Github-token': x_github_token,
        }
        sdk_headers = get_sdk_headers(
            service_name=self.DEFAULT_SERVICE_NAME,
            service_version='V1',
            operation_id='create_workspace',
        )
        headers.update(sdk_headers)

        data = {
            'applied_shareddata_ids': applied_shareddata_ids,
            'catalog_ref': catalog_ref,
            'dependencies': dependencies,
            'description': description,
            'location': location,
            'name': name,
            'resource_group': resource_group,
            'shared_data': shared_data,
            'tags': tags,
            'template_data': template_data,
            'template_ref': template_ref,
            'template_repo': template_repo,
            'type': type,
            'workspace_status': workspace_status,
            'agent_id': agent_id,
            'settings': settings,
        }
        data = {k: v for (k, v) in data.items() if v is not None}
        data = json.dumps(data)
        headers['content-type'] = 'application/json'

        if 'headers' in kwargs:
            headers.update(kwargs.get('headers'))
            del kwargs['headers']
        headers['Accept'] = 'application/json'

        url = '/v1/workspaces'
        request = self.prepare_request(
            method='POST',
            url=url,
            headers=headers,
            data=data,
        )

        response = self.send(request, **kwargs)
        return response

    def get_workspace(
        self,
        w_id: str,
        **kwargs,
    ) -> DetailedResponse:
        """
        Get workspace details.

        Retrieve detailed information for a workspace in your IBM Cloud account.
         <h3>Authorization</h3>
         Schematics support generic authorization for its resources.
         For more information, about Schematics access and permissions, see [Schematics
        service access
         roles and required
        permissions](https://cloud.ibm.com/docs/schematics?topic=schematics-access#access-roles).

        :param str w_id: The ID of the workspace.  To find the workspace ID, use
               the `GET /v1/workspaces` API.
        :param dict headers: A `dict` containing the request headers
        :return: A `DetailedResponse` containing the result, headers and HTTP status code.
        :rtype: DetailedResponse with `dict` result representing a `WorkspaceResponse` object
        """

        if not w_id:
            raise ValueError('w_id must be provided')
        headers = {}
        sdk_headers = get_sdk_headers(
            service_name=self.DEFAULT_SERVICE_NAME,
            service_version='V1',
            operation_id='get_workspace',
        )
        headers.update(sdk_headers)

        if 'headers' in kwargs:
            headers.update(kwargs.get('headers'))
            del kwargs['headers']
        headers['Accept'] = 'application/json'

        path_param_keys = ['w_id']
        path_param_values = self.encode_path_vars(w_id)
        path_param_dict = dict(zip(path_param_keys, path_param_values))
        url = '/v1/workspaces/{w_id}'.format(**path_param_dict)
        request = self.prepare_request(
            method='GET',
            url=url,
            headers=headers,
        )

        response = self.send(request, **kwargs)
        return response

    def replace_workspace(
        self,
        w_id: str,
        *,
        catalog_ref: Optional['CatalogRef'] = None,
        description: Optional[str] = None,
        dependencies: Optional['Dependencies'] = None,
        name: Optional[str] = None,
        shared_data: Optional['SharedTargetData'] = None,
        tags: Optional[List[str]] = None,
        template_data: Optional[List['TemplateSourceDataRequest']] = None,
        template_repo: Optional['TemplateRepoUpdateRequest'] = None,
        type: Optional[List[str]] = None,
        workspace_status: Optional['WorkspaceStatusUpdateRequest'] = None,
        workspace_status_msg: Optional['WorkspaceStatusMessage'] = None,
        agent_id: Optional[str] = None,
        settings: Optional[List['VariableData']] = None,
        x_github_token: Optional[str] = None,
        **kwargs,
    ) -> DetailedResponse:
        """
        Update workspace.

        Use this API to update or replace the entire workspace, including the Terraform
        template (`template_repo`) or IBM Cloud catalog software template (`catalog_ref`)
        that your workspace points to.
         **Tip**:- If you want to update workspace metadata, use the `PATCH
        /v1/workspaces/{id}` API.
         To update workspace variables, use the `PUT
        /v1/workspaces/{id}/template_data/{template_id}/values` API.
         <h3>Authorization</h3>
         Schematics support generic authorization for its resources.
         For more information, about Schematics access and permissions,
         see [Schematics service access roles and required
        permissions](https://cloud.ibm.com/docs/schematics?topic=schematics-access#access-roles).

        :param str w_id: The ID of the workspace.  To find the workspace ID, use
               the `GET /v1/workspaces` API.
        :param CatalogRef catalog_ref: (optional) Information about the software
               template that you chose from the IBM Cloud catalog. This information is
               returned for IBM Cloud catalog offerings only.
        :param str description: (optional) The description of the workspace.
        :param Dependencies dependencies: (optional) Workspace dependencies.
        :param str name: (optional) The name of the workspace.
        :param SharedTargetData shared_data: (optional) Information about the
               Target used by the templates originating from the  IBM Cloud catalog
               offerings. This information is not relevant for workspace created using
               your own Terraform template.
        :param List[str] tags: (optional) A list of tags that you want to associate
               with your workspace.
        :param List[TemplateSourceDataRequest] template_data: (optional) Input data
               for the Template.
        :param TemplateRepoUpdateRequest template_repo: (optional) Input to update
               the template repository data.
        :param List[str] type: (optional) List of Workspace type.
        :param WorkspaceStatusUpdateRequest workspace_status: (optional) Input to
               update the workspace status.
        :param WorkspaceStatusMessage workspace_status_msg: (optional) Information
               about the last job that ran against the workspace. -.
        :param str agent_id: (optional) agent id that process workspace jobs.
        :param List[VariableData] settings: (optional) Input settings to be applied
               to the workspace, for example, `job_timeout_override`.
        :param str x_github_token: (optional) The personal access token to
               authenticate with your private GitHub or GitLab repository and access your
               Terraform template.
        :param dict headers: A `dict` containing the request headers
        :return: A `DetailedResponse` containing the result, headers and HTTP status code.
        :rtype: DetailedResponse with `dict` result representing a `WorkspaceResponse` object
        """

        if not w_id:
            raise ValueError('w_id must be provided')
        if catalog_ref is not None:
            catalog_ref = convert_model(catalog_ref)
        if dependencies is not None:
            dependencies = convert_model(dependencies)
        if shared_data is not None:
            shared_data = convert_model(shared_data)
        if template_data is not None:
            template_data = [convert_model(x) for x in template_data]
        if template_repo is not None:
            template_repo = convert_model(template_repo)
        if workspace_status is not None:
            workspace_status = convert_model(workspace_status)
        if workspace_status_msg is not None:
            workspace_status_msg = convert_model(workspace_status_msg)
        if settings is not None:
            settings = [convert_model(x) for x in settings]
        headers = {
            'X-Github-token': x_github_token,
        }
        sdk_headers = get_sdk_headers(
            service_name=self.DEFAULT_SERVICE_NAME,
            service_version='V1',
            operation_id='replace_workspace',
        )
        headers.update(sdk_headers)

        data = {
            'catalog_ref': catalog_ref,
            'description': description,
            'dependencies': dependencies,
            'name': name,
            'shared_data': shared_data,
            'tags': tags,
            'template_data': template_data,
            'template_repo': template_repo,
            'type': type,
            'workspace_status': workspace_status,
            'workspace_status_msg': workspace_status_msg,
            'agent_id': agent_id,
            'settings': settings,
        }
        data = {k: v for (k, v) in data.items() if v is not None}
        data = json.dumps(data)
        headers['content-type'] = 'application/json'

        if 'headers' in kwargs:
            headers.update(kwargs.get('headers'))
            del kwargs['headers']
        headers['Accept'] = 'application/json'

        path_param_keys = ['w_id']
        path_param_values = self.encode_path_vars(w_id)
        path_param_dict = dict(zip(path_param_keys, path_param_values))
        url = '/v1/workspaces/{w_id}'.format(**path_param_dict)
        request = self.prepare_request(
            method='PUT',
            url=url,
            headers=headers,
            data=data,
        )

        response = self.send(request, **kwargs)
        return response

    def delete_workspace(
        self,
        refresh_token: str,
        w_id: str,
        *,
        destroy_resources: Optional[str] = None,
        **kwargs,
    ) -> DetailedResponse:
        """
        Delete a workspace.

        Deletes a workspace from IBM Cloud Schematics. Deleting a workspace does not
        automatically remove the IBM Cloud resources that the workspace manages. To remove
        all resources that are associated with the workspace, use the `DELETE
        /v1/workspaces/{id}?destroy_resources=true` API.
         **Note**: If you delete a workspace without deleting the resources,
         you must manage your resources with the resource dashboard or CLI afterwards.
         You cannot use IBM Cloud Schematics anymore to manage your resources.
         <h3>Authorization</h3>
         Schematics support generic authorization for its resources.
         For more information, about Schematics access and permissions,
         see [Schematics service access roles and required
        permissions](https://cloud.ibm.com/docs/schematics?topic=schematics-access#access-roles).

        :param str refresh_token: The IAM refresh token for the user or service
               identity. The IAM refresh token is required only if you want to destroy the
               Terraform resources before deleting the Schematics workspace. If you want
               to delete the workspace only and keep all your Terraform resources, refresh
               token is not required.
                 **Retrieving refresh token**:
                 * Use `export IBMCLOUD_API_KEY=<ibmcloud_api_key>`, and execute `curl -X
               POST "https://iam.cloud.ibm.com/identity/token" -H "Content-Type:
               application/x-www-form-urlencoded" -d
               "grant_type=urn:ibm:params:oauth:grant-type:apikey&apikey=$IBMCLOUD_API_KEY"
               -u bx:bx`.
                 * For more information, about creating IAM access token and API Docs,
               refer, [IAM access
               token](/apidocs/iam-identity-token-api#gettoken-password) and [Create API
               key](/apidocs/iam-identity-token-api#create-api-key).
                 **Limitation**:
                 * If the token is expired, you can use `refresh token` to get a new IAM
               access token.
                 * The `refresh_token` parameter cannot be used to retrieve a new IAM
               access token.
                 * When the IAM access token is about to expire, use the API key to create
               a new access token.
        :param str w_id: The ID of the workspace.  To find the workspace ID, use
               the `GET /v1/workspaces` API.
        :param str destroy_resources: (optional) If set to `true`, refresh_token
               header configuration is required to delete all the Terraform resources, and
               the Schematics workspace. If set to `false`, you can remove only the
               workspace. Your Terraform resources are still available and must be managed
               with the resource dashboard or CLI.
        :param dict headers: A `dict` containing the request headers
        :return: A `DetailedResponse` containing the result, headers and HTTP status code.
        :rtype: DetailedResponse with `str` result
        """

        if not refresh_token:
            raise ValueError('refresh_token must be provided')
        if not w_id:
            raise ValueError('w_id must be provided')
        headers = {
            'refresh_token': refresh_token,
        }
        sdk_headers = get_sdk_headers(
            service_name=self.DEFAULT_SERVICE_NAME,
            service_version='V1',
            operation_id='delete_workspace',
        )
        headers.update(sdk_headers)

        params = {
            'destroy_resources': destroy_resources,
        }

        if 'headers' in kwargs:
            headers.update(kwargs.get('headers'))
            del kwargs['headers']
        headers['Accept'] = 'application/json'

        path_param_keys = ['w_id']
        path_param_values = self.encode_path_vars(w_id)
        path_param_dict = dict(zip(path_param_keys, path_param_values))
        url = '/v1/workspaces/{w_id}'.format(**path_param_dict)
        request = self.prepare_request(
            method='DELETE',
            url=url,
            headers=headers,
            params=params,
        )

        response = self.send(request, **kwargs)
        return response

    def update_workspace(
        self,
        w_id: str,
        *,
        catalog_ref: Optional['CatalogRef'] = None,
        description: Optional[str] = None,
        dependencies: Optional['Dependencies'] = None,
        name: Optional[str] = None,
        shared_data: Optional['SharedTargetData'] = None,
        tags: Optional[List[str]] = None,
        template_data: Optional[List['TemplateSourceDataRequest']] = None,
        template_repo: Optional['TemplateRepoUpdateRequest'] = None,
        type: Optional[List[str]] = None,
        workspace_status: Optional['WorkspaceStatusUpdateRequest'] = None,
        workspace_status_msg: Optional['WorkspaceStatusMessage'] = None,
        agent_id: Optional[str] = None,
        settings: Optional[List['VariableData']] = None,
        **kwargs,
    ) -> DetailedResponse:
        """
        Update workspace metadata.

        Use this API to update the following workspace metadata:
         * Workspace name (`name`) - **Note**: Updating the workspace name does not update
        the ID of the workspace.
         * Workspace description (`description`)
         * Tags (`tags[]`)
         * Resource group (`resource_group`)
         * Workspace status (`workspace_status.frozen`)
         **Tip**: If you want to update information about the Terraform template
         or IBM Cloud catalog software template that your workspace points to,
         use the `PUT /v1/workspaces/{id}` API. To update workspace variables,
         use the `PUT /v1/workspaces/{id}/template_data/{template_id}/values` API.
         <h3>Authorization</h3>
         Schematics support generic authorization for its resources.
         For more information, about Schematics access and permissions,
         see [Schematics service access roles and required
        permissions](https://cloud.ibm.com/docs/schematics?topic=schematics-access#access-roles).

        :param str w_id: The ID of the workspace.  To find the workspace ID, use
               the `GET /v1/workspaces` API.
        :param CatalogRef catalog_ref: (optional) Information about the software
               template that you chose from the IBM Cloud catalog. This information is
               returned for IBM Cloud catalog offerings only.
        :param str description: (optional) The description of the workspace.
        :param Dependencies dependencies: (optional) Workspace dependencies.
        :param str name: (optional) The name of the workspace.
        :param SharedTargetData shared_data: (optional) Information about the
               Target used by the templates originating from the  IBM Cloud catalog
               offerings. This information is not relevant for workspace created using
               your own Terraform template.
        :param List[str] tags: (optional) A list of tags that you want to associate
               with your workspace.
        :param List[TemplateSourceDataRequest] template_data: (optional) Input data
               for the Template.
        :param TemplateRepoUpdateRequest template_repo: (optional) Input to update
               the template repository data.
        :param List[str] type: (optional) List of Workspace type.
        :param WorkspaceStatusUpdateRequest workspace_status: (optional) Input to
               update the workspace status.
        :param WorkspaceStatusMessage workspace_status_msg: (optional) Information
               about the last job that ran against the workspace. -.
        :param str agent_id: (optional) agent id that process workspace jobs.
        :param List[VariableData] settings: (optional) Input settings to be applied
               to the workspace, for example, `job_timeout_override`.
        :param dict headers: A `dict` containing the request headers
        :return: A `DetailedResponse` containing the result, headers and HTTP status code.
        :rtype: DetailedResponse with `dict` result representing a `WorkspaceResponse` object
        """

        if not w_id:
            raise ValueError('w_id must be provided')
        if catalog_ref is not None:
            catalog_ref = convert_model(catalog_ref)
        if dependencies is not None:
            dependencies = convert_model(dependencies)
        if shared_data is not None:
            shared_data = convert_model(shared_data)
        if template_data is not None:
            template_data = [convert_model(x) for x in template_data]
        if template_repo is not None:
            template_repo = convert_model(template_repo)
        if workspace_status is not None:
            workspace_status = convert_model(workspace_status)
        if workspace_status_msg is not None:
            workspace_status_msg = convert_model(workspace_status_msg)
        if settings is not None:
            settings = [convert_model(x) for x in settings]
        headers = {}
        sdk_headers = get_sdk_headers(
            service_name=self.DEFAULT_SERVICE_NAME,
            service_version='V1',
            operation_id='update_workspace',
        )
        headers.update(sdk_headers)

        data = {
            'catalog_ref': catalog_ref,
            'description': description,
            'dependencies': dependencies,
            'name': name,
            'shared_data': shared_data,
            'tags': tags,
            'template_data': template_data,
            'template_repo': template_repo,
            'type': type,
            'workspace_status': workspace_status,
            'workspace_status_msg': workspace_status_msg,
            'agent_id': agent_id,
            'settings': settings,
        }
        data = {k: v for (k, v) in data.items() if v is not None}
        data = json.dumps(data)
        headers['content-type'] = 'application/json'

        if 'headers' in kwargs:
            headers.update(kwargs.get('headers'))
            del kwargs['headers']
        headers['Accept'] = 'application/json'

        path_param_keys = ['w_id']
        path_param_values = self.encode_path_vars(w_id)
        path_param_dict = dict(zip(path_param_keys, path_param_values))
        url = '/v1/workspaces/{w_id}'.format(**path_param_dict)
        request = self.prepare_request(
            method='PATCH',
            url=url,
            headers=headers,
            data=data,
        )

        response = self.send(request, **kwargs)
        return response

    def get_workspace_readme(
        self,
        w_id: str,
        *,
        ref: Optional[str] = None,
        formatted: Optional[str] = None,
        **kwargs,
    ) -> DetailedResponse:
        """
        Show workspace template readme.

        Retrieve the `README.md` file of the Terraform of IBM Cloud catalog template that
        your workspace points to.

        :param str w_id: The ID of the workspace.  To find the workspace ID, use
               the `GET /v1/workspaces` API.
        :param str ref: (optional) The GitHub or GitLab branch where the
               `README.md` file is stored,  or the commit ID or tag that references the
               `README.md` file that you want to retrieve.  If you do not specify this
               option, the `README.md` file is retrieved from the master branch by
               default.
        :param str formatted: (optional) The format of the readme file.  Value
               ''markdown'' will give markdown, otherwise html.
        :param dict headers: A `dict` containing the request headers
        :return: A `DetailedResponse` containing the result, headers and HTTP status code.
        :rtype: DetailedResponse with `dict` result representing a `TemplateReadme` object

        Deprecated: this method is deprecated and may be removed in a future release.
        """

        logging.warning('A deprecated operation has been invoked: get_workspace_readme')

        if not w_id:
            raise ValueError('w_id must be provided')
        headers = {}
        sdk_headers = get_sdk_headers(
            service_name=self.DEFAULT_SERVICE_NAME,
            service_version='V1',
            operation_id='get_workspace_readme',
        )
        headers.update(sdk_headers)

        params = {
            'ref': ref,
            'formatted': formatted,
        }

        if 'headers' in kwargs:
            headers.update(kwargs.get('headers'))
            del kwargs['headers']
        headers['Accept'] = 'application/json'

        path_param_keys = ['w_id']
        path_param_values = self.encode_path_vars(w_id)
        path_param_dict = dict(zip(path_param_keys, path_param_values))
        url = '/v1/workspaces/{w_id}/templates/readme'.format(**path_param_dict)
        request = self.prepare_request(
            method='GET',
            url=url,
            headers=headers,
            params=params,
        )

        response = self.send(request, **kwargs)
        return response

    def template_repo_upload(
        self,
        w_id: str,
        t_id: str,
        *,
        file: Optional[BinaryIO] = None,
        file_content_type: Optional[str] = None,
        **kwargs,
    ) -> DetailedResponse:
        """
        Upload a TAR file to your workspace.

        Provide your Terraform template by uploading a TAR file from your local machine.
        Before you use this API, you must create a workspace without a link to a GitHub or
        GitLab repository with the `POST /v1/workspaces` API.
         <h3>Authorization</h3>
         Schematics support generic authorization for its resources.
         For more information, about Schematics access and permissions,
         see [Schematics service access roles and required
        permissions](https://cloud.ibm.com/docs/schematics?topic=schematics-access#access-roles).

        :param str w_id: The ID of the workspace where you want to upload your
               `.tar` file. To find the workspace ID, use the `GET /v1/workspaces` API.
        :param str t_id: The ID of the Terraform template in your workspace. When
               you create a workspace, a unique ID is assigned to your Terraform template,
               even if no template was provided during workspace creation. To find this
               ID, use the `GET /v1/workspaces` API and review the `template_data.id`
               value.
        :param BinaryIO file: (optional) Template tar file.
        :param str file_content_type: (optional) The content type of file.
        :param dict headers: A `dict` containing the request headers
        :return: A `DetailedResponse` containing the result, headers and HTTP status code.
        :rtype: DetailedResponse with `dict` result representing a `TemplateRepoTarUploadResponse` object
        """

        if not w_id:
            raise ValueError('w_id must be provided')
        if not t_id:
            raise ValueError('t_id must be provided')
        headers = {}
        sdk_headers = get_sdk_headers(
            service_name=self.DEFAULT_SERVICE_NAME,
            service_version='V1',
            operation_id='template_repo_upload',
        )
        headers.update(sdk_headers)

        form_data = []
        if file:
            form_data.append(('file', (None, file, file_content_type or 'application/octet-stream')))

        if 'headers' in kwargs:
            headers.update(kwargs.get('headers'))
            del kwargs['headers']
        headers['Accept'] = 'application/json'

        path_param_keys = ['w_id', 't_id']
        path_param_values = self.encode_path_vars(w_id, t_id)
        path_param_dict = dict(zip(path_param_keys, path_param_values))
        url = '/v1/workspaces/{w_id}/template_data/{t_id}/template_repo_upload'.format(**path_param_dict)
        request = self.prepare_request(
            method='PUT',
            url=url,
            headers=headers,
            files=form_data,
        )

        response = self.send(request, **kwargs)
        return response

    def get_workspace_inputs(
        self,
        w_id: str,
        t_id: str,
        **kwargs,
    ) -> DetailedResponse:
        """
        List workspace input variables.

        Retrieve a list of input variables that are declared in your Terraform or IBM
        Cloud catalog template.
         <h3>Authorization</h3>
         Schematics support generic authorization for its resources.
         For more information, about Schematics access and permissions,
         see [Schematics service access roles and required
        permissions](https://cloud.ibm.com/docs/schematics?topic=schematics-access#access-roles).

        :param str w_id: The ID of the workspace.  To find the workspace ID, use
               the `GET /v1/workspaces` API.
        :param str t_id: The ID of the Terraform template in your workspace.  When
               you create a workspace, the Terraform template that  your workspace points
               to is assigned a unique ID. Use the `GET /v1/workspaces` to look up the
               workspace IDs  and template IDs or `template_data.id` in your IBM Cloud
               account.
        :param dict headers: A `dict` containing the request headers
        :return: A `DetailedResponse` containing the result, headers and HTTP status code.
        :rtype: DetailedResponse with `dict` result representing a `TemplateValues` object
        """

        if not w_id:
            raise ValueError('w_id must be provided')
        if not t_id:
            raise ValueError('t_id must be provided')
        headers = {}
        sdk_headers = get_sdk_headers(
            service_name=self.DEFAULT_SERVICE_NAME,
            service_version='V1',
            operation_id='get_workspace_inputs',
        )
        headers.update(sdk_headers)

        if 'headers' in kwargs:
            headers.update(kwargs.get('headers'))
            del kwargs['headers']
        headers['Accept'] = 'application/json'

        path_param_keys = ['w_id', 't_id']
        path_param_values = self.encode_path_vars(w_id, t_id)
        path_param_dict = dict(zip(path_param_keys, path_param_values))
        url = '/v1/workspaces/{w_id}/template_data/{t_id}/values'.format(**path_param_dict)
        request = self.prepare_request(
            method='GET',
            url=url,
            headers=headers,
        )

        response = self.send(request, **kwargs)
        return response

    def replace_workspace_inputs(
        self,
        w_id: str,
        t_id: str,
        *,
        env_values: Optional[List[dict]] = None,
        values: Optional[str] = None,
        variablestore: Optional[List['WorkspaceVariableRequest']] = None,
        **kwargs,
    ) -> DetailedResponse:
        """
        Replace workspace input variables.

        Replace or Update the input variables for the template that your workspace points
        to.

        :param str w_id: The ID of the workspace.  To find the workspace ID, use
               the `GET /v1/workspaces` API.
        :param str t_id: The ID of the Terraform template in your workspace.  When
               you create a workspace, the Terraform template that  your workspace points
               to is assigned a unique ID. Use the `GET /v1/workspaces` to look up the
               workspace IDs  and template IDs or `template_data.id` in your IBM Cloud
               account.
        :param List[dict] env_values: (optional) A list of environment variables
               that you want to apply during the execution of a bash script or Terraform
               job. This field must be provided as a list of key-value pairs, for example,
               **TF_LOG=debug**. Each entry will be a map with one entry where `key is the
               environment variable name and value is value`. You can define environment
               variables for IBM Cloud catalog offerings that are provisioned by using a
               bash script. See [example to use special environment
               variable](https://cloud.ibm.com/docs/schematics?topic=schematics-set-parallelism#parallelism-example)
                that are supported by Schematics.
        :param str values: (optional) User values.
        :param List[WorkspaceVariableRequest] variablestore: (optional)
               VariablesRequest -.
        :param dict headers: A `dict` containing the request headers
        :return: A `DetailedResponse` containing the result, headers and HTTP status code.
        :rtype: DetailedResponse with `dict` result representing a `UserValues` object
        """

        if not w_id:
            raise ValueError('w_id must be provided')
        if not t_id:
            raise ValueError('t_id must be provided')
        if variablestore is not None:
            variablestore = [convert_model(x) for x in variablestore]
        headers = {}
        sdk_headers = get_sdk_headers(
            service_name=self.DEFAULT_SERVICE_NAME,
            service_version='V1',
            operation_id='replace_workspace_inputs',
        )
        headers.update(sdk_headers)

        data = {
            'env_values': env_values,
            'values': values,
            'variablestore': variablestore,
        }
        data = {k: v for (k, v) in data.items() if v is not None}
        data = json.dumps(data)
        headers['content-type'] = 'application/json'

        if 'headers' in kwargs:
            headers.update(kwargs.get('headers'))
            del kwargs['headers']
        headers['Accept'] = 'application/json'

        path_param_keys = ['w_id', 't_id']
        path_param_values = self.encode_path_vars(w_id, t_id)
        path_param_dict = dict(zip(path_param_keys, path_param_values))
        url = '/v1/workspaces/{w_id}/template_data/{t_id}/values'.format(**path_param_dict)
        request = self.prepare_request(
            method='PUT',
            url=url,
            headers=headers,
            data=data,
        )

        response = self.send(request, **kwargs)
        return response

    def get_all_workspace_inputs(
        self,
        w_id: str,
        **kwargs,
    ) -> DetailedResponse:
        """
        Get workspace template details.

        Retrieve detailed information about the Terraform template that your workspace
        points to.
         <h3>Authorization</h3>
         Schematics support generic authorization for its resources.
         For more information, about Schematics access and permissions,
         see [Schematics service access roles and required
        permissions](https://cloud.ibm.com/docs/schematics?topic=schematics-access#access-roles).

        :param str w_id: The ID of the workspace for which you want to retrieve
               input parameters and  values. To find the workspace ID, use the `GET
               /workspaces` API.
        :param dict headers: A `dict` containing the request headers
        :return: A `DetailedResponse` containing the result, headers and HTTP status code.
        :rtype: DetailedResponse with `dict` result representing a `WorkspaceTemplateValuesResponse` object
        """

        if not w_id:
            raise ValueError('w_id must be provided')
        headers = {}
        sdk_headers = get_sdk_headers(
            service_name=self.DEFAULT_SERVICE_NAME,
            service_version='V1',
            operation_id='get_all_workspace_inputs',
        )
        headers.update(sdk_headers)

        if 'headers' in kwargs:
            headers.update(kwargs.get('headers'))
            del kwargs['headers']
        headers['Accept'] = 'application/json'

        path_param_keys = ['w_id']
        path_param_values = self.encode_path_vars(w_id)
        path_param_dict = dict(zip(path_param_keys, path_param_values))
        url = '/v1/workspaces/{w_id}/templates/values'.format(**path_param_dict)
        request = self.prepare_request(
            method='GET',
            url=url,
            headers=headers,
        )

        response = self.send(request, **kwargs)
        return response

    def get_workspace_input_metadata(
        self,
        w_id: str,
        t_id: str,
        **kwargs,
    ) -> DetailedResponse:
        """
        List workspace variable metadata.

        Retrieve the metadata for all the workspace input variables that are declared in
        the template that your workspace points to.

        :param str w_id: The ID of the workspace for which you want to retrieve the
               metadata of the input variables that are declared in the template. To find
               the workspace ID, use the `GET /v1/workspaces` API.
        :param str t_id: The ID of the Terraform template for which you want to
               retrieve the metadata of your input variables. When you create a workspace,
               the Terraform template that your workspace points to is assigned a unique
               ID. To find this ID, use the `GET /v1/workspaces` API and review the
               `template_data.id` value.
        :param dict headers: A `dict` containing the request headers
        :return: A `DetailedResponse` containing the result, headers and HTTP status code.
        :rtype: DetailedResponse with `List[dict]` result
        """

        if not w_id:
            raise ValueError('w_id must be provided')
        if not t_id:
            raise ValueError('t_id must be provided')
        headers = {}
        sdk_headers = get_sdk_headers(
            service_name=self.DEFAULT_SERVICE_NAME,
            service_version='V1',
            operation_id='get_workspace_input_metadata',
        )
        headers.update(sdk_headers)

        if 'headers' in kwargs:
            headers.update(kwargs.get('headers'))
            del kwargs['headers']
        headers['Accept'] = 'application/json'

        path_param_keys = ['w_id', 't_id']
        path_param_values = self.encode_path_vars(w_id, t_id)
        path_param_dict = dict(zip(path_param_keys, path_param_values))
        url = '/v1/workspaces/{w_id}/template_data/{t_id}/values_metadata'.format(**path_param_dict)
        request = self.prepare_request(
            method='GET',
            url=url,
            headers=headers,
        )

        response = self.send(request, **kwargs)
        return response

    def get_workspace_outputs(
        self,
        w_id: str,
        **kwargs,
    ) -> DetailedResponse:
        """
        List workspace output values.

        Retrieve a list of Terraform output variables. You define output values in your
        Terraform template to include information that you want to make accessible for
        other Terraform templates.

        :param str w_id: The ID of the workspace for which you want to retrieve
               output parameters and  values. To find the workspace ID, use the `GET
               /workspaces` API.
        :param dict headers: A `dict` containing the request headers
        :return: A `DetailedResponse` containing the result, headers and HTTP status code.
        :rtype: DetailedResponse with `List[OutputValuesInner]` result
        """

        if not w_id:
            raise ValueError('w_id must be provided')
        headers = {}
        sdk_headers = get_sdk_headers(
            service_name=self.DEFAULT_SERVICE_NAME,
            service_version='V1',
            operation_id='get_workspace_outputs',
        )
        headers.update(sdk_headers)

        if 'headers' in kwargs:
            headers.update(kwargs.get('headers'))
            del kwargs['headers']
        headers['Accept'] = 'application/json'

        path_param_keys = ['w_id']
        path_param_values = self.encode_path_vars(w_id)
        path_param_dict = dict(zip(path_param_keys, path_param_values))
        url = '/v1/workspaces/{w_id}/output_values'.format(**path_param_dict)
        request = self.prepare_request(
            method='GET',
            url=url,
            headers=headers,
        )

        response = self.send(request, **kwargs)
        return response

    def get_workspace_resources(
        self,
        w_id: str,
        **kwargs,
    ) -> DetailedResponse:
        """
        List workspace resources.

        Retrieve a list of IBM Cloud resources that you created with your workspace.

        :param str w_id: The ID of the workspace.  To find the workspace ID, use
               the `GET /v1/workspaces` API.
        :param dict headers: A `dict` containing the request headers
        :return: A `DetailedResponse` containing the result, headers and HTTP status code.
        :rtype: DetailedResponse with `List[TemplateResources]` result
        """

        if not w_id:
            raise ValueError('w_id must be provided')
        headers = {}
        sdk_headers = get_sdk_headers(
            service_name=self.DEFAULT_SERVICE_NAME,
            service_version='V1',
            operation_id='get_workspace_resources',
        )
        headers.update(sdk_headers)

        if 'headers' in kwargs:
            headers.update(kwargs.get('headers'))
            del kwargs['headers']
        headers['Accept'] = 'application/json'

        path_param_keys = ['w_id']
        path_param_values = self.encode_path_vars(w_id)
        path_param_dict = dict(zip(path_param_keys, path_param_values))
        url = '/v1/workspaces/{w_id}/resources'.format(**path_param_dict)
        request = self.prepare_request(
            method='GET',
            url=url,
            headers=headers,
        )

        response = self.send(request, **kwargs)
        return response

    def get_workspace_state(
        self,
        w_id: str,
        **kwargs,
    ) -> DetailedResponse:
        """
        Get Terraform statefile URL.

        This API is deprecated, and is replaced by the `GET /v2/jobs/{job_id}/files`, with
        `file_type` equal `state_file`. Retrieve the URL to the Terraform statefile
        (`terraform.tfstate`). You use the URL to access the Terraform statefile. The
        Terraform statefile includes detailed information about the IBM Cloud resources
        that you provisioned with IBM Cloud Schematics and Schematics uses the file to
        determine future create, modify, or delete actions for your resources. To show the
        content of the Terraform statefile, use the `GET
        /v1/workspaces/{id}/runtime_data/{template_id}/state_store` API.
         <h3>Authorization</h3>
         Schematics support generic authorization for its resources.
         For more information, about Schematics access and permissions,
         see [Schematics service access roles and required
        permissions](https://cloud.ibm.com/docs/schematics?topic=schematics-access#access-roles).

        :param str w_id: The ID of the workspace for which you want to retrieve the
               Terraform statefile.  To find the workspace ID, use the `GET
               /v1/workspaces` API.
        :param dict headers: A `dict` containing the request headers
        :return: A `DetailedResponse` containing the result, headers and HTTP status code.
        :rtype: DetailedResponse with `dict` result representing a `StateStoreResponseList` object

        Deprecated: this method is deprecated and may be removed in a future release.
        """

        logging.warning('A deprecated operation has been invoked: get_workspace_state')

        if not w_id:
            raise ValueError('w_id must be provided')
        headers = {}
        sdk_headers = get_sdk_headers(
            service_name=self.DEFAULT_SERVICE_NAME,
            service_version='V1',
            operation_id='get_workspace_state',
        )
        headers.update(sdk_headers)

        if 'headers' in kwargs:
            headers.update(kwargs.get('headers'))
            del kwargs['headers']
        headers['Accept'] = 'application/json'

        path_param_keys = ['w_id']
        path_param_values = self.encode_path_vars(w_id)
        path_param_dict = dict(zip(path_param_keys, path_param_values))
        url = '/v1/workspaces/{w_id}/state_stores'.format(**path_param_dict)
        request = self.prepare_request(
            method='GET',
            url=url,
            headers=headers,
        )

        response = self.send(request, **kwargs)
        return response

    def get_workspace_template_state(
        self,
        w_id: str,
        t_id: str,
        **kwargs,
    ) -> DetailedResponse:
        """
        Show Terraform statefile content.

        This API is deprecated, and is replaced by the `GET /v2/jobs/{job_id}/files`, with
        `file_type` equal `state_file`. Show the content of the Terraform statefile
        (`terraform.tfstate`) that was created when your Terraform template was applied in
        IBM Cloud. The statefile holds detailed information about the IBM Cloud resources
        that were created by IBM Cloud Schematics and Schematics uses the file to
        determine future create, modify, or delete actions for your resources.

        :param str w_id: The ID of the workspace for which you want to retrieve the
               Terraform statefile.  To find the workspace ID, use the `GET
               /v1/workspaces` API.
        :param str t_id: The ID of the Terraform template for which you want to
               retrieve the Terraform statefile.  When you create a workspace, the
               Terraform template that your workspace points to is assigned a unique ID.
               To find this ID, use the `GET /v1/workspaces` API and review the
               template_data.id value.
        :param dict headers: A `dict` containing the request headers
        :return: A `DetailedResponse` containing the result, headers and HTTP status code.
        :rtype: DetailedResponse with `dict` result representing a `TemplateStateStore` object

        Deprecated: this method is deprecated and may be removed in a future release.
        """

        logging.warning('A deprecated operation has been invoked: get_workspace_template_state')

        if not w_id:
            raise ValueError('w_id must be provided')
        if not t_id:
            raise ValueError('t_id must be provided')
        headers = {}
        sdk_headers = get_sdk_headers(
            service_name=self.DEFAULT_SERVICE_NAME,
            service_version='V1',
            operation_id='get_workspace_template_state',
        )
        headers.update(sdk_headers)

        if 'headers' in kwargs:
            headers.update(kwargs.get('headers'))
            del kwargs['headers']
        headers['Accept'] = 'application/json'

        path_param_keys = ['w_id', 't_id']
        path_param_values = self.encode_path_vars(w_id, t_id)
        path_param_dict = dict(zip(path_param_keys, path_param_values))
        url = '/v1/workspaces/{w_id}/runtime_data/{t_id}/state_store'.format(**path_param_dict)
        request = self.prepare_request(
            method='GET',
            url=url,
            headers=headers,
        )

        response = self.send(request, **kwargs)
        return response

    def get_workspace_activity_logs(
        self,
        w_id: str,
        activity_id: str,
        **kwargs,
    ) -> DetailedResponse:
        """
        Get workspace job log URL.

        Get the Terraform log file URL for a workspace job. You can retrieve the log URL
        for jobs that were created with the `PUT /v1/workspaces/{id}/apply`, `POST
        /v1/workspaces/{id}/plan`, or `DELETE /v1/workspaces/{id}/destroy` API.
         <h3>Authorization</h3>
         Schematics support generic authorization for its resources.
         For more information, about Schematics access and permissions,
         see [Schematics service access roles and required
        permissions](https://cloud.ibm.com/docs/schematics?topic=schematics-access#access-roles).

        :param str w_id: The ID of the workspace for which you want to retrieve the
               Terraform statefile.  To find the workspace ID, use the `GET
               /v1/workspaces` API.
        :param str activity_id: The ID of the activity or job, for which you want
               to retrieve details.  To find the job ID, use the `GET
               /v1/workspaces/{id}/actions` API.
        :param dict headers: A `dict` containing the request headers
        :return: A `DetailedResponse` containing the result, headers and HTTP status code.
        :rtype: DetailedResponse with `dict` result representing a `WorkspaceActivityLogs` object

        Deprecated: this method is deprecated and may be removed in a future release.
        """

        logging.warning('A deprecated operation has been invoked: get_workspace_activity_logs')

        if not w_id:
            raise ValueError('w_id must be provided')
        if not activity_id:
            raise ValueError('activity_id must be provided')
        headers = {}
        sdk_headers = get_sdk_headers(
            service_name=self.DEFAULT_SERVICE_NAME,
            service_version='V1',
            operation_id='get_workspace_activity_logs',
        )
        headers.update(sdk_headers)

        if 'headers' in kwargs:
            headers.update(kwargs.get('headers'))
            del kwargs['headers']
        headers['Accept'] = 'application/json'

        path_param_keys = ['w_id', 'activity_id']
        path_param_values = self.encode_path_vars(w_id, activity_id)
        path_param_dict = dict(zip(path_param_keys, path_param_values))
        url = '/v1/workspaces/{w_id}/actions/{activity_id}/logs'.format(**path_param_dict)
        request = self.prepare_request(
            method='GET',
            url=url,
            headers=headers,
        )

        response = self.send(request, **kwargs)
        return response

    def get_workspace_log_urls(
        self,
        w_id: str,
        **kwargs,
    ) -> DetailedResponse:
        """
        Get latest workspace job log URL for all workspace templates.

        Retrieve the log file URL for the latest job of a template that ran against your
        workspace. You use this URL to retrieve detailed logs for the latest job.

        :param str w_id: The ID of the workspace.  To find the workspace ID, use
               the `GET /v1/workspaces` API.
        :param dict headers: A `dict` containing the request headers
        :return: A `DetailedResponse` containing the result, headers and HTTP status code.
        :rtype: DetailedResponse with `dict` result representing a `LogStoreResponseList` object

        Deprecated: this method is deprecated and may be removed in a future release.
        """

        logging.warning('A deprecated operation has been invoked: get_workspace_log_urls')

        if not w_id:
            raise ValueError('w_id must be provided')
        headers = {}
        sdk_headers = get_sdk_headers(
            service_name=self.DEFAULT_SERVICE_NAME,
            service_version='V1',
            operation_id='get_workspace_log_urls',
        )
        headers.update(sdk_headers)

        if 'headers' in kwargs:
            headers.update(kwargs.get('headers'))
            del kwargs['headers']
        headers['Accept'] = 'application/json'

        path_param_keys = ['w_id']
        path_param_values = self.encode_path_vars(w_id)
        path_param_dict = dict(zip(path_param_keys, path_param_values))
        url = '/v1/workspaces/{w_id}/log_stores'.format(**path_param_dict)
        request = self.prepare_request(
            method='GET',
            url=url,
            headers=headers,
        )

        response = self.send(request, **kwargs)
        return response

    def get_template_logs(
        self,
        w_id: str,
        t_id: str,
        *,
        log_tf_cmd: Optional[bool] = None,
        log_tf_prefix: Optional[bool] = None,
        log_tf_null_resource: Optional[bool] = None,
        log_tf_ansible: Optional[bool] = None,
        **kwargs,
    ) -> DetailedResponse:
        """
        Show latest logs for a workspace template.

        Show the Terraform logs for the most recent job of a template that ran against
        your workspace.
         <h3>Authorization</h3>
         Schematics support generic authorization for its resources.
         For more information, about Schematics access and permissions,
         see [Schematics service access roles and required
        permissions](https://cloud.ibm.com/docs/schematics?topic=schematics-access#access-roles).

        :param str w_id: The ID of the workspace.  To find the workspace ID, use
               the `GET /v1/workspaces` API.
        :param str t_id: The ID of the Terraform template or IBM Cloud catalog
               software template in the workspace.  Use the `GET /v1/workspaces` to look
               up the workspace IDs and template IDs or `template_data.id`.
        :param bool log_tf_cmd: (optional) Enter false to replace the first line in
               each Terraform command section, such as Terraform INIT or Terraform PLAN,
               with Schematics INIT (Schematics PLAN) in your log output.  In addition,
               the log lines Starting command: terraform init -input=false -no-color and
               Starting command: terraform apply -state=terraform.tfstate
               -var-file=schematics.tfvars -auto-approve -no-color are suppressed.  All
               subsequent command lines still use the Terraform command prefix. To remove
               this prefix, use the log_tf_prefix option.
        :param bool log_tf_prefix: (optional) `false` will hide all the terraform
               command prefix in the log statements.
        :param bool log_tf_null_resource: (optional) `false` will hide all the null
               resource prefix in the log statements.
        :param bool log_tf_ansible: (optional) `true` will format all logs to
               withhold the original format  of ansible output in the log statements.
        :param dict headers: A `dict` containing the request headers
        :return: A `DetailedResponse` containing the result, headers and HTTP status code.
        :rtype: DetailedResponse with `str` result
        """

        if not w_id:
            raise ValueError('w_id must be provided')
        if not t_id:
            raise ValueError('t_id must be provided')
        headers = {}
        sdk_headers = get_sdk_headers(
            service_name=self.DEFAULT_SERVICE_NAME,
            service_version='V1',
            operation_id='get_template_logs',
        )
        headers.update(sdk_headers)

        params = {
            'log_tf_cmd': log_tf_cmd,
            'log_tf_prefix': log_tf_prefix,
            'log_tf_null_resource': log_tf_null_resource,
            'log_tf_ansible': log_tf_ansible,
        }

        if 'headers' in kwargs:
            headers.update(kwargs.get('headers'))
            del kwargs['headers']
        headers['Accept'] = 'application/json'

        path_param_keys = ['w_id', 't_id']
        path_param_values = self.encode_path_vars(w_id, t_id)
        path_param_dict = dict(zip(path_param_keys, path_param_values))
        url = '/v1/workspaces/{w_id}/runtime_data/{t_id}/log_store'.format(**path_param_dict)
        request = self.prepare_request(
            method='GET',
            url=url,
            headers=headers,
            params=params,
        )

        response = self.send(request, **kwargs)
        return response

    def get_template_activity_log(
        self,
        w_id: str,
        t_id: str,
        activity_id: str,
        *,
        log_tf_cmd: Optional[bool] = None,
        log_tf_prefix: Optional[bool] = None,
        log_tf_null_resource: Optional[bool] = None,
        log_tf_ansible: Optional[bool] = None,
        **kwargs,
    ) -> DetailedResponse:
        """
        Show logs for a workspace job.

        Show the Terraform logs for an job that ran against your workspace.

        :param str w_id: The ID of the workspace.  To find the workspace ID, use
               the `GET /v1/workspaces` API.
        :param str t_id: The ID of the Terraform template or IBM Cloud catalog
               software template in the workspace.  Use the `GET /v1/workspaces` to look
               up the workspace IDs and template IDs or `template_data.id`.
        :param str activity_id: The ID of the activity or job, for which you want
               to retrieve details.  To find the job ID, use the `GET
               /v1/workspaces/{id}/actions` API.
        :param bool log_tf_cmd: (optional) Enter false to replace the first line in
               each Terraform command section, such as Terraform INIT or Terraform PLAN,
               with Schematics INIT (Schematics PLAN) in your log output.  In addition,
               the log lines Starting command: terraform init -input=false -no-color and
               Starting command: terraform apply -state=terraform.tfstate
               -var-file=schematics.tfvars -auto-approve -no-color are suppressed.  All
               subsequent command lines still use the Terraform command prefix. To remove
               this prefix, use the log_tf_prefix option.
        :param bool log_tf_prefix: (optional) `false` will hide all the terraform
               command prefix in the log statements.
        :param bool log_tf_null_resource: (optional) `false` will hide all the null
               resource prefix in the log statements.
        :param bool log_tf_ansible: (optional) `true` will format all logs to
               withhold the original format  of ansible output in the log statements.
        :param dict headers: A `dict` containing the request headers
        :return: A `DetailedResponse` containing the result, headers and HTTP status code.
        :rtype: DetailedResponse with `str` result
        """

        if not w_id:
            raise ValueError('w_id must be provided')
        if not t_id:
            raise ValueError('t_id must be provided')
        if not activity_id:
            raise ValueError('activity_id must be provided')
        headers = {}
        sdk_headers = get_sdk_headers(
            service_name=self.DEFAULT_SERVICE_NAME,
            service_version='V1',
            operation_id='get_template_activity_log',
        )
        headers.update(sdk_headers)

        params = {
            'log_tf_cmd': log_tf_cmd,
            'log_tf_prefix': log_tf_prefix,
            'log_tf_null_resource': log_tf_null_resource,
            'log_tf_ansible': log_tf_ansible,
        }

        if 'headers' in kwargs:
            headers.update(kwargs.get('headers'))
            del kwargs['headers']
        headers['Accept'] = 'application/json'

        path_param_keys = ['w_id', 't_id', 'activity_id']
        path_param_values = self.encode_path_vars(w_id, t_id, activity_id)
        path_param_dict = dict(zip(path_param_keys, path_param_values))
        url = '/v1/workspaces/{w_id}/runtime_data/{t_id}/log_store/actions/{activity_id}'.format(**path_param_dict)
        request = self.prepare_request(
            method='GET',
            url=url,
            headers=headers,
            params=params,
        )

        response = self.send(request, **kwargs)
        return response

    #########################
    # actions
    #########################

    def list_actions(
        self,
        *,
        offset: Optional[int] = None,
        limit: Optional[int] = None,
        sort: Optional[str] = None,
        profile: Optional[str] = None,
        **kwargs,
    ) -> DetailedResponse:
        """
        List actions.

        Retrieve a list of all Schematics actions that depends on the API endpoint that
        you have access. For example, if you use an API endpoint for a geography, such as
        North America, only actions that are created in `us-south` or `us-east` are
        retrieved.
         For more information, about supported API endpoints, see
        [API endpoints](/apidocs/schematics#api-endpoints).
         <h3>Authorization</h3>
         Schematics support generic authorization for its resources.
         For more information, about Schematics access and permissions, see
         [Schematics service access roles and required
        permissions](https://cloud.ibm.com/docs/schematics?topic=schematics-access#access-roles).

        :param int offset: (optional) The starting position of the item in the list
               of items. For example, if you have three workspaces in your account, the
               first workspace is assigned position number 0, the second workspace is
               assigned position number 1, and so forth. If you have 6 workspaces and you
               want to list the details for workspaces `2-6`, enter 1. To limit the number
               of workspaces that is returned, use the `limit` option in addition to the
               `offset` option. Negative numbers are not supported and are ignored.
        :param int limit: (optional) The maximum number of items that you want to
               list. The number must be a positive integer between 1 and 2000. If no value
               is provided, 100 is used by default.
        :param str sort: (optional) Name of the field to sort-by;  Use the '.'
               character to delineate sub-resources and sub-fields (eg. owner.last_name).
               Prepend the field with '+' or '-', indicating 'ascending' or 'descending'
               (default is ascending)   Ignore unrecognized or unsupported sort field.
        :param str profile: (optional) Level of details returned by the get method.
        :param dict headers: A `dict` containing the request headers
        :return: A `DetailedResponse` containing the result, headers and HTTP status code.
        :rtype: DetailedResponse with `dict` result representing a `ActionList` object
        """

        headers = {}
        sdk_headers = get_sdk_headers(
            service_name=self.DEFAULT_SERVICE_NAME,
            service_version='V1',
            operation_id='list_actions',
        )
        headers.update(sdk_headers)

        params = {
            'offset': offset,
            'limit': limit,
            'sort': sort,
            'profile': profile,
        }

        if 'headers' in kwargs:
            headers.update(kwargs.get('headers'))
            del kwargs['headers']
        headers['Accept'] = 'application/json'

        url = '/v2/actions'
        request = self.prepare_request(
            method='GET',
            url=url,
            headers=headers,
            params=params,
        )

        response = self.send(request, **kwargs)
        return response

    def create_action(
        self,
        *,
        name: Optional[str] = None,
        description: Optional[str] = None,
        location: Optional[str] = None,
        resource_group: Optional[str] = None,
        bastion_connection_type: Optional[str] = None,
        inventory_connection_type: Optional[str] = None,
        tags: Optional[List[str]] = None,
        user_state: Optional['UserState'] = None,
        source_readme_url: Optional[str] = None,
        source: Optional['ExternalSource'] = None,
        source_type: Optional[str] = None,
        command_parameter: Optional[str] = None,
        inventory: Optional[str] = None,
        credentials: Optional[List['CredentialVariableData']] = None,
        bastion: Optional['BastionResourceDefinition'] = None,
        bastion_credential: Optional['CredentialVariableData'] = None,
        targets_ini: Optional[str] = None,
        inputs: Optional[List['VariableData']] = None,
        outputs: Optional[List['VariableData']] = None,
        settings: Optional[List['VariableData']] = None,
        x_github_token: Optional[str] = None,
        **kwargs,
    ) -> DetailedResponse:
        """
        Create an action.

        Create an IBM Cloud Schematics action to run on a single target or groups of
        target hosts, roles, policies, or steps to deploy your resources in the target
        hosts. You can run the IBM Cloud resources the order in which you want to execute
        them. **Note** If your Git repository already contains a host file. Schematics
        does not overwrite the host file already present in your Git repository. For
        sample templates, see IBM Cloud Automation
        [templates](https://github.com/Cloud-Schematics).
         The Schematics action API now supports bastion host connection with `non-root`
        user, and bastion connection type is marked as optional, when inventory connection
        type is set as [Windows Remote
        Management](https://www.ibm.com/docs/en/license-metric-tool?topic=v-configuring-winrm-hyper-hosts)(`winrm`).
         For more information, about the Schematics create action,
         see [ibmcloud schematics action
        create](https://cloud.ibm.com/docs/schematics?topic=schematics-schematics-cli-reference#schematics-create-action).
         **Note** you cannot update the location and region once an action is created.
         Also, make sure your IP addresses are in the
        [allowlist](https://cloud.ibm.com/docs/schematics?topic=schematics-allowed-ipaddresses).
         <h3>Authorization</h3>
         Schematics support generic authorization for its resources.
         For more information, about Schematics access and permissions,
         see [Schematics service access roles and required
        permissions](/docs/schematics?topic=schematics-access#action-permissions).

        :param str name: (optional) The unique name of your action. The name can be
               up to 128 characters long and can include alphanumeric characters, spaces,
               dashes, and underscores. **Example** you can use the name to stop action.
        :param str description: (optional) Action description.
        :param str location: (optional) List of locations supported by IBM Cloud
               Schematics service.  While creating your workspace or action, choose the
               right region, since it cannot be changed.  Note, this does not limit the
               location of the IBM Cloud resources, provisioned using Schematics.
        :param str resource_group: (optional) Resource-group name for an action. By
               default, an action is created in `Default` resource group.
        :param str bastion_connection_type: (optional) Type of connection to be
               used when connecting to bastion host.  If the
               `inventory_connection_type=winrm`, then `bastion_connection_type` is not
               supported.
        :param str inventory_connection_type: (optional) Type of connection to be
               used when connecting to remote host.  **Note** Currently, WinRM supports
               only Windows system with the public IPs and do not support Bastion host.
        :param List[str] tags: (optional) Action tags.
        :param UserState user_state: (optional) User defined status of the
               Schematics object.
        :param str source_readme_url: (optional) URL of the `README` file, for the
               source URL.
        :param ExternalSource source: (optional) Source of templates, playbooks, or
               controls.
        :param str source_type: (optional) Type of source for the Template.
        :param str command_parameter: (optional) Schematics job command parameter
               (playbook-name).
        :param str inventory: (optional) Target inventory record ID, used by the
               action or ansible playbook.
        :param List[CredentialVariableData] credentials: (optional) credentials of
               the Action.
        :param BastionResourceDefinition bastion: (optional) Describes a bastion
               resource.
        :param CredentialVariableData bastion_credential: (optional) User editable
               credential variable data and system generated reference to the value.
        :param str targets_ini: (optional) Inventory of host and host group for the
               playbook in `INI` file format. For example, `"targets_ini":
               "[webserverhost]
                172.22.192.6
                [dbhost]
                172.22.192.5"`. For more information, about an inventory host group
               syntax, see [Inventory host
               groups](https://cloud.ibm.com/docs/schematics?topic=schematics-schematics-cli-reference#schematics-inventory-host-grps).
        :param List[VariableData] inputs: (optional) Input variables for the
               Action.
        :param List[VariableData] outputs: (optional) Output variables for the
               Action.
        :param List[VariableData] settings: (optional) Environment variables for
               the Action.
        :param str x_github_token: (optional) The personal access token to
               authenticate with your private GitHub or GitLab repository and access your
               Terraform template.
        :param dict headers: A `dict` containing the request headers
        :return: A `DetailedResponse` containing the result, headers and HTTP status code.
        :rtype: DetailedResponse with `dict` result representing a `Action` object
        """

        if user_state is not None:
            user_state = convert_model(user_state)
        if source is not None:
            source = convert_model(source)
        if credentials is not None:
            credentials = [convert_model(x) for x in credentials]
        if bastion is not None:
            bastion = convert_model(bastion)
        if bastion_credential is not None:
            bastion_credential = convert_model(bastion_credential)
        if inputs is not None:
            inputs = [convert_model(x) for x in inputs]
        if outputs is not None:
            outputs = [convert_model(x) for x in outputs]
        if settings is not None:
            settings = [convert_model(x) for x in settings]
        headers = {
            'X-Github-token': x_github_token,
        }
        sdk_headers = get_sdk_headers(
            service_name=self.DEFAULT_SERVICE_NAME,
            service_version='V1',
            operation_id='create_action',
        )
        headers.update(sdk_headers)

        data = {
            'name': name,
            'description': description,
            'location': location,
            'resource_group': resource_group,
            'bastion_connection_type': bastion_connection_type,
            'inventory_connection_type': inventory_connection_type,
            'tags': tags,
            'user_state': user_state,
            'source_readme_url': source_readme_url,
            'source': source,
            'source_type': source_type,
            'command_parameter': command_parameter,
            'inventory': inventory,
            'credentials': credentials,
            'bastion': bastion,
            'bastion_credential': bastion_credential,
            'targets_ini': targets_ini,
            'inputs': inputs,
            'outputs': outputs,
            'settings': settings,
        }
        data = {k: v for (k, v) in data.items() if v is not None}
        data = json.dumps(data)
        headers['content-type'] = 'application/json'

        if 'headers' in kwargs:
            headers.update(kwargs.get('headers'))
            del kwargs['headers']
        headers['Accept'] = 'application/json'

        url = '/v2/actions'
        request = self.prepare_request(
            method='POST',
            url=url,
            headers=headers,
            data=data,
        )

        response = self.send(request, **kwargs)
        return response

    def get_action(
        self,
        action_id: str,
        *,
        profile: Optional[str] = None,
        **kwargs,
    ) -> DetailedResponse:
        """
        Get action details.

        Retrieve the detailed information of an actions from your IBM Cloud account.  This
        API returns a URL to the log file that you can retrieve by using  the `GET
        /v2/actions/{action_id}/logs` API.
         <h3>Authorization</h3>
         Schematics support generic authorization for its resources.
         For more information, about Schematics access and permissions, see
         [Schematics service access roles and required
        permissions](https://cloud.ibm.com/docs/schematics?topic=schematics-access#action-permissions).

        :param str action_id: Action Id.  Use GET /actions API to look up the
               Action Ids in your IBM Cloud account.
        :param str profile: (optional) Level of details returned by the get method.
        :param dict headers: A `dict` containing the request headers
        :return: A `DetailedResponse` containing the result, headers and HTTP status code.
        :rtype: DetailedResponse with `dict` result representing a `Action` object
        """

        if not action_id:
            raise ValueError('action_id must be provided')
        headers = {}
        sdk_headers = get_sdk_headers(
            service_name=self.DEFAULT_SERVICE_NAME,
            service_version='V1',
            operation_id='get_action',
        )
        headers.update(sdk_headers)

        params = {
            'profile': profile,
        }

        if 'headers' in kwargs:
            headers.update(kwargs.get('headers'))
            del kwargs['headers']
        headers['Accept'] = 'application/json'

        path_param_keys = ['action_id']
        path_param_values = self.encode_path_vars(action_id)
        path_param_dict = dict(zip(path_param_keys, path_param_values))
        url = '/v2/actions/{action_id}'.format(**path_param_dict)
        request = self.prepare_request(
            method='GET',
            url=url,
            headers=headers,
            params=params,
        )

        response = self.send(request, **kwargs)
        return response

    def delete_action(
        self,
        action_id: str,
        *,
        force: Optional[bool] = None,
        propagate: Optional[bool] = None,
        **kwargs,
    ) -> DetailedResponse:
        """
        Delete an action.

        Delete a Schematics action and specify the Ansible playbook that you want to run
        against your IBM Cloud resources. **Note** you cannot delete or stop the job
        activity from an ongoing execution of an action defined in the playbook. You can
        repeat the execution of same job, whenever you patch the actions. For more
        information, about the Schematics action state, see  [Schematics action state
        diagram](https://cloud.ibm.com/docs/schematics?topic=schematics-action-setup#action-state-diagram).
         <h3>Authorization</h3>
         Schematics support generic authorization for its resources.
         For more information, about Schematics access and permissions, see
         [Schematics service access roles and required
        permissions](https://cloud.ibm.com/docs/schematics?topic=schematics-access#access-roles).

        :param str action_id: Action Id.  Use GET /actions API to look up the
               Action Ids in your IBM Cloud account.
        :param bool force: (optional) Equivalent to -force options in the command
               line.
        :param bool propagate: (optional) Auto propagate the chaange or deletion to
               the dependent resources.
        :param dict headers: A `dict` containing the request headers
        :return: A `DetailedResponse` containing the result, headers and HTTP status code.
        :rtype: DetailedResponse
        """

        if not action_id:
            raise ValueError('action_id must be provided')
        headers = {
            'force': force,
            'propagate': propagate,
        }
        sdk_headers = get_sdk_headers(
            service_name=self.DEFAULT_SERVICE_NAME,
            service_version='V1',
            operation_id='delete_action',
        )
        headers.update(sdk_headers)

        if 'headers' in kwargs:
            headers.update(kwargs.get('headers'))
            del kwargs['headers']

        path_param_keys = ['action_id']
        path_param_values = self.encode_path_vars(action_id)
        path_param_dict = dict(zip(path_param_keys, path_param_values))
        url = '/v2/actions/{action_id}'.format(**path_param_dict)
        request = self.prepare_request(
            method='DELETE',
            url=url,
            headers=headers,
        )

        response = self.send(request, **kwargs)
        return response

    def update_action(
        self,
        action_id: str,
        *,
        name: Optional[str] = None,
        description: Optional[str] = None,
        location: Optional[str] = None,
        resource_group: Optional[str] = None,
        bastion_connection_type: Optional[str] = None,
        inventory_connection_type: Optional[str] = None,
        tags: Optional[List[str]] = None,
        user_state: Optional['UserState'] = None,
        source_readme_url: Optional[str] = None,
        source: Optional['ExternalSource'] = None,
        source_type: Optional[str] = None,
        command_parameter: Optional[str] = None,
        inventory: Optional[str] = None,
        credentials: Optional[List['CredentialVariableData']] = None,
        bastion: Optional['BastionResourceDefinition'] = None,
        bastion_credential: Optional['CredentialVariableData'] = None,
        targets_ini: Optional[str] = None,
        inputs: Optional[List['VariableData']] = None,
        outputs: Optional[List['VariableData']] = None,
        settings: Optional[List['VariableData']] = None,
        x_github_token: Optional[str] = None,
        **kwargs,
    ) -> DetailedResponse:
        """
        Update an action.

        Update or replace an action to change the action state from the critical state to
        normal state, or pending state to the normal state for a successful execution.
        For more information, about the Schematics action state, see [Schematics action
        state
        diagram](https://cloud.ibm.com/docs/schematics?topic=schematics-action-setup#action-state-diagram).
         The Schematics action API now supports bastion host connection with `non-root`
        user, and bastion connection type is marked as optional, when inventory connection
        type is set as [Windows Remote
        Management](https://www.ibm.com/docs/en/license-metric-tool?topic=v-configuring-winrm-hyper-hosts)(`winrm`).
         **Note** you cannot update the location and region once an action is created.
        Also, make sure your IP addresses are in the
        [allowlist](https://cloud.ibm.com/docs/schematics?topic=schematics-allowed-ipaddresses].
         <h3>Authorization</h3>
         Schematics support generic authorization for its resources.
         For more information, about Schematics access and permissions, see
         [Schematics service access roles and required
        permissions](https://cloud.ibm.com/docs/schematics?topic=schematics-access#access-roles).

        :param str action_id: Action Id.  Use GET /actions API to look up the
               Action Ids in your IBM Cloud account.
        :param str name: (optional) The unique name of your action. The name can be
               up to 128 characters long and can include alphanumeric characters, spaces,
               dashes, and underscores. **Example** you can use the name to stop action.
        :param str description: (optional) Action description.
        :param str location: (optional) List of locations supported by IBM Cloud
               Schematics service.  While creating your workspace or action, choose the
               right region, since it cannot be changed.  Note, this does not limit the
               location of the IBM Cloud resources, provisioned using Schematics.
        :param str resource_group: (optional) Resource-group name for an action. By
               default, an action is created in `Default` resource group.
        :param str bastion_connection_type: (optional) Type of connection to be
               used when connecting to bastion host.  If the
               `inventory_connection_type=winrm`, then `bastion_connection_type` is not
               supported.
        :param str inventory_connection_type: (optional) Type of connection to be
               used when connecting to remote host.  **Note** Currently, WinRM supports
               only Windows system with the public IPs and do not support Bastion host.
        :param List[str] tags: (optional) Action tags.
        :param UserState user_state: (optional) User defined status of the
               Schematics object.
        :param str source_readme_url: (optional) URL of the `README` file, for the
               source URL.
        :param ExternalSource source: (optional) Source of templates, playbooks, or
               controls.
        :param str source_type: (optional) Type of source for the Template.
        :param str command_parameter: (optional) Schematics job command parameter
               (playbook-name).
        :param str inventory: (optional) Target inventory record ID, used by the
               action or ansible playbook.
        :param List[CredentialVariableData] credentials: (optional) credentials of
               the Action.
        :param BastionResourceDefinition bastion: (optional) Describes a bastion
               resource.
        :param CredentialVariableData bastion_credential: (optional) User editable
               credential variable data and system generated reference to the value.
        :param str targets_ini: (optional) Inventory of host and host group for the
               playbook in `INI` file format. For example, `"targets_ini":
               "[webserverhost]
                172.22.192.6
                [dbhost]
                172.22.192.5"`. For more information, about an inventory host group
               syntax, see [Inventory host
               groups](https://cloud.ibm.com/docs/schematics?topic=schematics-schematics-cli-reference#schematics-inventory-host-grps).
        :param List[VariableData] inputs: (optional) Input variables for the
               Action.
        :param List[VariableData] outputs: (optional) Output variables for the
               Action.
        :param List[VariableData] settings: (optional) Environment variables for
               the Action.
        :param str x_github_token: (optional) The personal access token to
               authenticate with your private GitHub or GitLab repository and access your
               Terraform template.
        :param dict headers: A `dict` containing the request headers
        :return: A `DetailedResponse` containing the result, headers and HTTP status code.
        :rtype: DetailedResponse with `dict` result representing a `Action` object
        """

        if not action_id:
            raise ValueError('action_id must be provided')
        if user_state is not None:
            user_state = convert_model(user_state)
        if source is not None:
            source = convert_model(source)
        if credentials is not None:
            credentials = [convert_model(x) for x in credentials]
        if bastion is not None:
            bastion = convert_model(bastion)
        if bastion_credential is not None:
            bastion_credential = convert_model(bastion_credential)
        if inputs is not None:
            inputs = [convert_model(x) for x in inputs]
        if outputs is not None:
            outputs = [convert_model(x) for x in outputs]
        if settings is not None:
            settings = [convert_model(x) for x in settings]
        headers = {
            'X-Github-token': x_github_token,
        }
        sdk_headers = get_sdk_headers(
            service_name=self.DEFAULT_SERVICE_NAME,
            service_version='V1',
            operation_id='update_action',
        )
        headers.update(sdk_headers)

        data = {
            'name': name,
            'description': description,
            'location': location,
            'resource_group': resource_group,
            'bastion_connection_type': bastion_connection_type,
            'inventory_connection_type': inventory_connection_type,
            'tags': tags,
            'user_state': user_state,
            'source_readme_url': source_readme_url,
            'source': source,
            'source_type': source_type,
            'command_parameter': command_parameter,
            'inventory': inventory,
            'credentials': credentials,
            'bastion': bastion,
            'bastion_credential': bastion_credential,
            'targets_ini': targets_ini,
            'inputs': inputs,
            'outputs': outputs,
            'settings': settings,
        }
        data = {k: v for (k, v) in data.items() if v is not None}
        data = json.dumps(data)
        headers['content-type'] = 'application/json'

        if 'headers' in kwargs:
            headers.update(kwargs.get('headers'))
            del kwargs['headers']
        headers['Accept'] = 'application/json'

        path_param_keys = ['action_id']
        path_param_values = self.encode_path_vars(action_id)
        path_param_dict = dict(zip(path_param_keys, path_param_values))
        url = '/v2/actions/{action_id}'.format(**path_param_dict)
        request = self.prepare_request(
            method='PATCH',
            url=url,
            headers=headers,
            data=data,
        )

        response = self.send(request, **kwargs)
        return response

    def upload_template_tar_action(
        self,
        action_id: str,
        *,
        file: Optional[BinaryIO] = None,
        file_content_type: Optional[str] = None,
        **kwargs,
    ) -> DetailedResponse:
        """
        Upload a TAR file to an action.

        Update your template by uploading tape archive file (.tar) file from  your local
        machine. Before you use this API, you must create an action  without a link to a
        GitHub or GitLab repository with the `POST /v2/actions` API.
         <h3>Authorization</h3>
         Schematics support generic authorization for its resources.
         For more information, about Schematics access and permissions,
         see [Schematics service access roles and required
        permissions](/docs/schematics?topic=schematics-access#action-permissions).

        :param str action_id: Action Id.  Use GET /actions API to look up the
               Action Ids in your IBM Cloud account.
        :param BinaryIO file: (optional) Template tar file.
        :param str file_content_type: (optional) The content type of file.
        :param dict headers: A `dict` containing the request headers
        :return: A `DetailedResponse` containing the result, headers and HTTP status code.
        :rtype: DetailedResponse with `dict` result representing a `TemplateRepoTarUploadResponse` object
        """

        if not action_id:
            raise ValueError('action_id must be provided')
        headers = {}
        sdk_headers = get_sdk_headers(
            service_name=self.DEFAULT_SERVICE_NAME,
            service_version='V1',
            operation_id='upload_template_tar_action',
        )
        headers.update(sdk_headers)

        form_data = []
        if file:
            form_data.append(('file', (None, file, file_content_type or 'application/octet-stream')))

        if 'headers' in kwargs:
            headers.update(kwargs.get('headers'))
            del kwargs['headers']
        headers['Accept'] = 'application/json'

        path_param_keys = ['action_id']
        path_param_values = self.encode_path_vars(action_id)
        path_param_dict = dict(zip(path_param_keys, path_param_values))
        url = '/v2/actions/{action_id}/template_repo_upload'.format(**path_param_dict)
        request = self.prepare_request(
            method='PUT',
            url=url,
            headers=headers,
            files=form_data,
        )

        response = self.send(request, **kwargs)
        return response

    #########################
    # jobs
    #########################

    def list_workspace_activities(
        self,
        w_id: str,
        *,
        offset: Optional[int] = None,
        limit: Optional[int] = None,
        **kwargs,
    ) -> DetailedResponse:
        """
        List workspace jobs.

        Retrieve a list of all jobs that ran against a workspace. Jobs are generated when
        you use the `apply`, `plan`, `destroy`, and `refresh`,   command API.

        :param str w_id: The ID of the workspace.  To find the workspace ID, use
               the `GET /v1/workspaces` API.
        :param int offset: (optional) The starting position of the item in the list
               of items. For example, if you have three workspaces in your account, the
               first workspace is assigned position number 0, the second workspace is
               assigned position number 1, and so forth. If you have 6 workspaces and you
               want to list the details for workspaces `2-6`, enter 1. To limit the number
               of workspaces that is returned, use the `limit` option in addition to the
               `offset` option. Negative numbers are not supported and are ignored.
        :param int limit: (optional) The maximum number of items that you want to
               list. The number must be a positive integer between 1 and 2000. If no value
               is provided, 100 is used by default.
        :param dict headers: A `dict` containing the request headers
        :return: A `DetailedResponse` containing the result, headers and HTTP status code.
        :rtype: DetailedResponse with `dict` result representing a `WorkspaceActivities` object
        """

        if not w_id:
            raise ValueError('w_id must be provided')
        headers = {}
        sdk_headers = get_sdk_headers(
            service_name=self.DEFAULT_SERVICE_NAME,
            service_version='V1',
            operation_id='list_workspace_activities',
        )
        headers.update(sdk_headers)

        params = {
            'offset': offset,
            'limit': limit,
        }

        if 'headers' in kwargs:
            headers.update(kwargs.get('headers'))
            del kwargs['headers']
        headers['Accept'] = 'application/json'

        path_param_keys = ['w_id']
        path_param_values = self.encode_path_vars(w_id)
        path_param_dict = dict(zip(path_param_keys, path_param_values))
        url = '/v1/workspaces/{w_id}/actions'.format(**path_param_dict)
        request = self.prepare_request(
            method='GET',
            url=url,
            headers=headers,
            params=params,
        )

        response = self.send(request, **kwargs)
        return response

    def get_workspace_activity(
        self,
        w_id: str,
        activity_id: str,
        **kwargs,
    ) -> DetailedResponse:
        """
        Get workspace job details.

        Get the details for a workspace job that ran against the workspace. This API
        returns the job status and a URL to the log file that you can  retrieve by using
        the `GET /v1/workspaces/{id}/actions/{action_id}/logs` API.

        :param str w_id: The ID of the workspace.  To find the workspace ID, use
               the `GET /v1/workspaces` API.
        :param str activity_id: The ID of the activity or job, for which you want
               to retrieve details.  To find the job ID, use the `GET
               /v1/workspaces/{id}/actions` API.
        :param dict headers: A `dict` containing the request headers
        :return: A `DetailedResponse` containing the result, headers and HTTP status code.
        :rtype: DetailedResponse with `dict` result representing a `WorkspaceActivity` object
        """

        if not w_id:
            raise ValueError('w_id must be provided')
        if not activity_id:
            raise ValueError('activity_id must be provided')
        headers = {}
        sdk_headers = get_sdk_headers(
            service_name=self.DEFAULT_SERVICE_NAME,
            service_version='V1',
            operation_id='get_workspace_activity',
        )
        headers.update(sdk_headers)

        if 'headers' in kwargs:
            headers.update(kwargs.get('headers'))
            del kwargs['headers']
        headers['Accept'] = 'application/json'

        path_param_keys = ['w_id', 'activity_id']
        path_param_values = self.encode_path_vars(w_id, activity_id)
        path_param_dict = dict(zip(path_param_keys, path_param_values))
        url = '/v1/workspaces/{w_id}/actions/{activity_id}'.format(**path_param_dict)
        request = self.prepare_request(
            method='GET',
            url=url,
            headers=headers,
        )

        response = self.send(request, **kwargs)
        return response

    def delete_workspace_activity(
        self,
        w_id: str,
        activity_id: str,
        **kwargs,
    ) -> DetailedResponse:
        """
        Stop the workspace job.

        Stop an ongoing schematics job that runs against your workspace.
        **Note**: If you remove the Schematics apply job that runs against your workspace,
         any changes to your IBM Cloud resources that are already applied are not
        reverted.  If a creation, update, or deletion is currently in progress, Schematics
        waits for  the job to be completed first. Then, any other resource creations,
        updates, or  deletions that are included in your Terraform template file are
        ignored.
        <h3>Authorization</h3>
         Schematics support generic authorization for its resources.
         For more information, about Schematics access and permissions,
         see [Schematics service access roles and required
        permissions](https://cloud.ibm.com/docs/schematics?topic=schematics-access#access-roles).

        :param str w_id: The ID of the workspace.  To find the workspace ID, use
               the `GET /v1/workspaces` API.
        :param str activity_id: The ID of the activity or job, for which you want
               to retrieve details.  To find the job ID, use the `GET
               /v1/workspaces/{id}/actions` API.
        :param dict headers: A `dict` containing the request headers
        :return: A `DetailedResponse` containing the result, headers and HTTP status code.
        :rtype: DetailedResponse with `dict` result representing a `WorkspaceActivityApplyResult` object
        """

        if not w_id:
            raise ValueError('w_id must be provided')
        if not activity_id:
            raise ValueError('activity_id must be provided')
        headers = {}
        sdk_headers = get_sdk_headers(
            service_name=self.DEFAULT_SERVICE_NAME,
            service_version='V1',
            operation_id='delete_workspace_activity',
        )
        headers.update(sdk_headers)

        if 'headers' in kwargs:
            headers.update(kwargs.get('headers'))
            del kwargs['headers']
        headers['Accept'] = 'application/json'

        path_param_keys = ['w_id', 'activity_id']
        path_param_values = self.encode_path_vars(w_id, activity_id)
        path_param_dict = dict(zip(path_param_keys, path_param_values))
        url = '/v1/workspaces/{w_id}/actions/{activity_id}'.format(**path_param_dict)
        request = self.prepare_request(
            method='DELETE',
            url=url,
            headers=headers,
        )

        response = self.send(request, **kwargs)
        return response

    def run_workspace_commands(
        self,
        w_id: str,
        refresh_token: str,
        *,
        commands: Optional[List['TerraformCommand']] = None,
        operation_name: Optional[str] = None,
        description: Optional[str] = None,
        **kwargs,
    ) -> DetailedResponse:
        """
        Run Terraform Commands.

        Run Terraform state commands to modify the workspace state file, by using the IBM
        Cloud Schematics API.
         <h3>Authorization</h3>
         Schematics support generic authorization for its resources.
         For more information, about Schematics access and permissions,
         see [Schematics service access roles and required
        permissions](https://cloud.ibm.com/docs/schematics?topic=schematics-access#access-roles).

        :param str w_id: The ID of the workspace.  To find the workspace ID, use
               the `GET /v1/workspaces` API.
        :param str refresh_token: The IAM refresh token for the user or service
               identity.
                 **Retrieving refresh token**:
                 * Use `export IBMCLOUD_API_KEY=<ibmcloud_api_key>`, and execute `curl -X
               POST "https://iam.cloud.ibm.com/identity/token" -H "Content-Type:
               application/x-www-form-urlencoded" -d
               "grant_type=urn:ibm:params:oauth:grant-type:apikey&apikey=$IBMCLOUD_API_KEY"
               -u bx:bx`.
                 * For more information, about creating IAM access token and API Docs,
               refer, [IAM access
               token](/apidocs/iam-identity-token-api#gettoken-password) and [Create API
               key](/apidocs/iam-identity-token-api#create-api-key).
                 **Limitation**:
                 * If the token is expired, you can use `refresh token` to get a new IAM
               access token.
                 * The `refresh_token` parameter cannot be used to retrieve a new IAM
               access token.
                 * When the IAM access token is about to expire, use the API key to create
               a new access token.
        :param List[TerraformCommand] commands: (optional) List of commands.  You
               can execute single set of commands or multiple commands.  For more
               information, about the payload of the multiple commands,  refer to
               [Commands](https://cloud.ibm.com/docs/schematics?topic=schematics-schematics-cli-reference#commands).
        :param str operation_name: (optional) Command name.
        :param str description: (optional) Command description.
        :param dict headers: A `dict` containing the request headers
        :return: A `DetailedResponse` containing the result, headers and HTTP status code.
        :rtype: DetailedResponse with `dict` result representing a `WorkspaceActivityCommandResult` object
        """

        if not w_id:
            raise ValueError('w_id must be provided')
        if not refresh_token:
            raise ValueError('refresh_token must be provided')
        if commands is not None:
            commands = [convert_model(x) for x in commands]
        headers = {
            'refresh_token': refresh_token,
        }
        sdk_headers = get_sdk_headers(
            service_name=self.DEFAULT_SERVICE_NAME,
            service_version='V1',
            operation_id='run_workspace_commands',
        )
        headers.update(sdk_headers)

        data = {
            'commands': commands,
            'operation_name': operation_name,
            'description': description,
        }
        data = {k: v for (k, v) in data.items() if v is not None}
        data = json.dumps(data)
        headers['content-type'] = 'application/json'

        if 'headers' in kwargs:
            headers.update(kwargs.get('headers'))
            del kwargs['headers']
        headers['Accept'] = 'application/json'

        path_param_keys = ['w_id']
        path_param_values = self.encode_path_vars(w_id)
        path_param_dict = dict(zip(path_param_keys, path_param_values))
        url = '/v1/workspaces/{w_id}/commands'.format(**path_param_dict)
        request = self.prepare_request(
            method='PUT',
            url=url,
            headers=headers,
            data=data,
        )

        response = self.send(request, **kwargs)
        return response

    def apply_workspace_command(
        self,
        w_id: str,
        refresh_token: str,
        *,
        action_options: Optional['WorkspaceActivityOptionsTemplate'] = None,
        delegated_token: Optional[str] = None,
        **kwargs,
    ) -> DetailedResponse:
        """
        Perform a Schematics `apply` job.

        Run a Schematics `apply` job against your workspace. An `apply` job provisions,
        modifies, or removes the IBM Cloud resources that you described in the Terraform
        template that your workspace points to. Depending on the type and number of
        resources that you want to provision or modify, this process might take a few
        minutes, or even up to hours to complete. During this time, you cannot make
        changes to your workspace. After all updates are applied, the state of the files
        is
        [persisted](https://cloud.ibm.com/docs/schematics?topic=schematics-persist-files)
        to determine what resources exist in your IBM Cloud account.
         **Important**: Your workspace must be in an `Inactive`, `Active`, `Failed`, or
         `Stopped` state to perform a Schematics `apply` job. After all updates are
        applied,
         the state of the files is
        [persisted](https://cloud.ibm.com/docs/schematics?topic=schematics-persist-files)
         to determine what resources exist in your IBM Cloud account.
         **Note**: This API returns an activity or job ID that you use to retrieve the
         log URL with the `GET /v1/workspaces/{id}/actions/{action_id}/logs` API.
         **Important:** Applying a template might incur costs. Make sure to review
         the pricing information for the resources that you specified in your
         templates before you apply the template in IBM Cloud.
         To find a summary of job that Schematics is about to perform,
         create a Terraform execution plan with the `POST /v1/workspaces/{id}/plan` API.
         <h3>Authorization</h3>
         Schematics support generic authorization for its resources.
         For more information, about Schematics access and permissions,
         see [Schematics service access roles and required
        permissions](https://cloud.ibm.com/docs/schematics?topic=schematics-access#access-roles).

        :param str w_id: The ID of the workspace for which you want to run a
               Schematics `apply` job.  To find the workspace ID, use the `GET
               /workspaces` API.
        :param str refresh_token: The IAM refresh token for the user or service
               identity.
                 **Retrieving refresh token**:
                 * Use `export IBMCLOUD_API_KEY=<ibmcloud_api_key>`, and execute `curl -X
               POST "https://iam.cloud.ibm.com/identity/token" -H "Content-Type:
               application/x-www-form-urlencoded" -d
               "grant_type=urn:ibm:params:oauth:grant-type:apikey&apikey=$IBMCLOUD_API_KEY"
               -u bx:bx`.
                 * For more information, about creating IAM access token and API Docs,
               refer, [IAM access
               token](/apidocs/iam-identity-token-api#gettoken-password) and [Create API
               key](/apidocs/iam-identity-token-api#create-api-key).
                 **Limitation**:
                 * If the token is expired, you can use `refresh token` to get a new IAM
               access token.
                 * The `refresh_token` parameter cannot be used to retrieve a new IAM
               access token.
                 * When the IAM access token is about to expire, use the API key to create
               a new access token.
        :param WorkspaceActivityOptionsTemplate action_options: (optional)
               Workspace job options template.
        :param str delegated_token: (optional) The IAM delegated token for your IBM
               Cloud account.  This token is required for requests that are sent via the
               UI only.
        :param dict headers: A `dict` containing the request headers
        :return: A `DetailedResponse` containing the result, headers and HTTP status code.
        :rtype: DetailedResponse with `dict` result representing a `WorkspaceActivityApplyResult` object
        """

        if not w_id:
            raise ValueError('w_id must be provided')
        if not refresh_token:
            raise ValueError('refresh_token must be provided')
        if action_options is not None:
            action_options = convert_model(action_options)
        headers = {
            'refresh_token': refresh_token,
            'delegated_token': delegated_token,
        }
        sdk_headers = get_sdk_headers(
            service_name=self.DEFAULT_SERVICE_NAME,
            service_version='V1',
            operation_id='apply_workspace_command',
        )
        headers.update(sdk_headers)

        data = {
            'action_options': action_options,
        }
        data = {k: v for (k, v) in data.items() if v is not None}
        data = json.dumps(data)
        headers['content-type'] = 'application/json'

        if 'headers' in kwargs:
            headers.update(kwargs.get('headers'))
            del kwargs['headers']
        headers['Accept'] = 'application/json'

        path_param_keys = ['w_id']
        path_param_values = self.encode_path_vars(w_id)
        path_param_dict = dict(zip(path_param_keys, path_param_values))
        url = '/v1/workspaces/{w_id}/apply'.format(**path_param_dict)
        request = self.prepare_request(
            method='PUT',
            url=url,
            headers=headers,
            data=data,
        )

        response = self.send(request, **kwargs)
        return response

    def destroy_workspace_command(
        self,
        w_id: str,
        refresh_token: str,
        *,
        action_options: Optional['WorkspaceActivityOptionsTemplate'] = None,
        delegated_token: Optional[str] = None,
        **kwargs,
    ) -> DetailedResponse:
        """
        Perform a Schematics `destroy` job.

        Run a Schematics `destroy` job against your workspace. A `destroy` job removes all
        IBM Cloud resources that are associated with your workspace. Removing your
        resources does not delete the Schematics workspace. To delete the workspace, use
        the `DELETE /v1/workspaces/{id}` API. This API returns an activity or job ID that
        you use to retrieve the URL to the log file with the `GET
        /v1/workspaces/{id}/actions/{action_id}/logs` API.
         **Important**: Your workspace must be in an `Active`, `Failed`, or `Stopped`
        state to perform a Schematics `destroy` job.
         **Note**: Deleting IBM Cloud resources cannot be undone. Make sure that you back
        up any required data before you remove your resources.
         <h3>Authorization</h3>
         Schematics support generic authorization for its resources.
         For more information, about Schematics access and permissions,
         see [Schematics service access roles and required
        permissions](https://cloud.ibm.com/docs/schematics?topic=schematics-access#access-roles).

        :param str w_id: The ID of the workspace for which you want to perform a
               Schematics `destroy` job.  To find the workspace ID, use the `GET
               /workspaces` API.
        :param str refresh_token: The IAM refresh token for the user or service
               identity.
                 **Retrieving refresh token**:
                 * Use `export IBMCLOUD_API_KEY=<ibmcloud_api_key>`, and execute `curl -X
               POST "https://iam.cloud.ibm.com/identity/token" -H "Content-Type:
               application/x-www-form-urlencoded" -d
               "grant_type=urn:ibm:params:oauth:grant-type:apikey&apikey=$IBMCLOUD_API_KEY"
               -u bx:bx`.
                 * For more information, about creating IAM access token and API Docs,
               refer, [IAM access
               token](/apidocs/iam-identity-token-api#gettoken-password) and [Create API
               key](/apidocs/iam-identity-token-api#create-api-key).
                 **Limitation**:
                 * If the token is expired, you can use `refresh token` to get a new IAM
               access token.
                 * The `refresh_token` parameter cannot be used to retrieve a new IAM
               access token.
                 * When the IAM access token is about to expire, use the API key to create
               a new access token.
        :param WorkspaceActivityOptionsTemplate action_options: (optional)
               Workspace job options template.
        :param str delegated_token: (optional) The IAM delegated token for your IBM
               Cloud account.  This token is required for requests that are sent via the
               UI only.
        :param dict headers: A `dict` containing the request headers
        :return: A `DetailedResponse` containing the result, headers and HTTP status code.
        :rtype: DetailedResponse with `dict` result representing a `WorkspaceActivityDestroyResult` object
        """

        if not w_id:
            raise ValueError('w_id must be provided')
        if not refresh_token:
            raise ValueError('refresh_token must be provided')
        if action_options is not None:
            action_options = convert_model(action_options)
        headers = {
            'refresh_token': refresh_token,
            'delegated_token': delegated_token,
        }
        sdk_headers = get_sdk_headers(
            service_name=self.DEFAULT_SERVICE_NAME,
            service_version='V1',
            operation_id='destroy_workspace_command',
        )
        headers.update(sdk_headers)

        data = {
            'action_options': action_options,
        }
        data = {k: v for (k, v) in data.items() if v is not None}
        data = json.dumps(data)
        headers['content-type'] = 'application/json'

        if 'headers' in kwargs:
            headers.update(kwargs.get('headers'))
            del kwargs['headers']
        headers['Accept'] = 'application/json'

        path_param_keys = ['w_id']
        path_param_values = self.encode_path_vars(w_id)
        path_param_dict = dict(zip(path_param_keys, path_param_values))
        url = '/v1/workspaces/{w_id}/destroy'.format(**path_param_dict)
        request = self.prepare_request(
            method='PUT',
            url=url,
            headers=headers,
            data=data,
        )

        response = self.send(request, **kwargs)
        return response

    def plan_workspace_command(
        self,
        w_id: str,
        refresh_token: str,
        *,
        action_options: Optional['WorkspaceActivityOptionsTemplate'] = None,
        delegated_token: Optional[str] = None,
        **kwargs,
    ) -> DetailedResponse:
        """
        Perform a Schematics `plan` job.

        Run a Schematics `plan` job against your workspace. The `plan` job creates a
        summary of IBM Cloud resources that must be created, modified, or deleted to
        achieve the state that is described in the Terraform or IBM Cloud catalog template
        that your workspace points to. During this time, you cannot make changes to your
        workspace. You can use the summary to verify your changes before you apply the
        template in IBM Cloud.
         **Important**: Your workspace must be in an `Inactive`, `Active`, `Failed`, or
        `Stopped` state to perform a Schematics `plan` job.
         **Note**: This API returns an activity or job ID that you use to retrieve the URL
        to the log file with the `GET /v1/workspaces/{id}/actions/{action_id}/logs` API.
         <h3>Authorization</h3>
         Schematics support generic authorization for its resources.
         For more information, about Schematics access and permissions,
         see [Schematics service access roles and required
        permissions](https://cloud.ibm.com/docs/schematics?topic=schematics-access#access-roles).

        :param str w_id: The ID of the workspace, for which you want to run a
               Schematics `plan` job.  To find the ID of your workspace, use the `GET
               /v1/workspaces` API.
        :param str refresh_token: The IAM refresh token for the user or service
               identity.
                 **Retrieving refresh token**:
                 * Use `export IBMCLOUD_API_KEY=<ibmcloud_api_key>`, and execute `curl -X
               POST "https://iam.cloud.ibm.com/identity/token" -H "Content-Type:
               application/x-www-form-urlencoded" -d
               "grant_type=urn:ibm:params:oauth:grant-type:apikey&apikey=$IBMCLOUD_API_KEY"
               -u bx:bx`.
                 * For more information, about creating IAM access token and API Docs,
               refer, [IAM access
               token](/apidocs/iam-identity-token-api#gettoken-password) and [Create API
               key](/apidocs/iam-identity-token-api#create-api-key).
                 **Limitation**:
                 * If the token is expired, you can use `refresh token` to get a new IAM
               access token.
                 * The `refresh_token` parameter cannot be used to retrieve a new IAM
               access token.
                 * When the IAM access token is about to expire, use the API key to create
               a new access token.
        :param WorkspaceActivityOptionsTemplate action_options: (optional)
               Workspace job options template.
        :param str delegated_token: (optional) The IAM delegated token for your IBM
               Cloud account.  This token is required for requests that are sent via the
               UI only.
        :param dict headers: A `dict` containing the request headers
        :return: A `DetailedResponse` containing the result, headers and HTTP status code.
        :rtype: DetailedResponse with `dict` result representing a `WorkspaceActivityPlanResult` object
        """

        if not w_id:
            raise ValueError('w_id must be provided')
        if not refresh_token:
            raise ValueError('refresh_token must be provided')
        if action_options is not None:
            action_options = convert_model(action_options)
        headers = {
            'refresh_token': refresh_token,
            'delegated_token': delegated_token,
        }
        sdk_headers = get_sdk_headers(
            service_name=self.DEFAULT_SERVICE_NAME,
            service_version='V1',
            operation_id='plan_workspace_command',
        )
        headers.update(sdk_headers)

        data = {
            'action_options': action_options,
        }
        data = {k: v for (k, v) in data.items() if v is not None}
        data = json.dumps(data)
        headers['content-type'] = 'application/json'

        if 'headers' in kwargs:
            headers.update(kwargs.get('headers'))
            del kwargs['headers']
        headers['Accept'] = 'application/json'

        path_param_keys = ['w_id']
        path_param_values = self.encode_path_vars(w_id)
        path_param_dict = dict(zip(path_param_keys, path_param_values))
        url = '/v1/workspaces/{w_id}/plan'.format(**path_param_dict)
        request = self.prepare_request(
            method='POST',
            url=url,
            headers=headers,
            data=data,
        )

        response = self.send(request, **kwargs)
        return response

    def refresh_workspace_command(
        self,
        w_id: str,
        refresh_token: str,
        *,
        delegated_token: Optional[str] = None,
        **kwargs,
    ) -> DetailedResponse:
        """
        Perform a Schematics `refresh` job.

        Run a Schematics `refresh` job against your workspace. A `refresh` job validates
        the IBM Cloud resources in your account against the state that is stored in the
        Terraform statefile of your workspace. If differences are found, the Terraform
        statefile is updated accordingly. This API returns an activity or job ID that you
        use to retrieve the URL to the log file with the `GET
        /v1/workspaces/{id}/actions/{action_id}/logs` API.
         <h3>Authorization</h3>
         Schematics support generic authorization for its resources.
         For more information, about Schematics access and permissions,
         see [Schematics service access roles and required
        permissions](https://cloud.ibm.com/docs/schematics?topic=schematics-access#access-roles).

        :param str w_id: The ID of the workspace, for which you want to run a
               Schematics `refresh` job.  To find the ID of your workspace, use the `GET
               /v1/workspaces` API.
        :param str refresh_token: The IAM refresh token for the user or service
               identity.
                 **Retrieving refresh token**:
                 * Use `export IBMCLOUD_API_KEY=<ibmcloud_api_key>`, and execute `curl -X
               POST "https://iam.cloud.ibm.com/identity/token" -H "Content-Type:
               application/x-www-form-urlencoded" -d
               "grant_type=urn:ibm:params:oauth:grant-type:apikey&apikey=$IBMCLOUD_API_KEY"
               -u bx:bx`.
                 * For more information, about creating IAM access token and API Docs,
               refer, [IAM access
               token](/apidocs/iam-identity-token-api#gettoken-password) and [Create API
               key](/apidocs/iam-identity-token-api#create-api-key).
                 **Limitation**:
                 * If the token is expired, you can use `refresh token` to get a new IAM
               access token.
                 * The `refresh_token` parameter cannot be used to retrieve a new IAM
               access token.
                 * When the IAM access token is about to expire, use the API key to create
               a new access token.
        :param str delegated_token: (optional) The IAM delegated token for your IBM
               Cloud account.  This token is required for requests that are sent via the
               UI only.
        :param dict headers: A `dict` containing the request headers
        :return: A `DetailedResponse` containing the result, headers and HTTP status code.
        :rtype: DetailedResponse with `dict` result representing a `WorkspaceActivityRefreshResult` object
        """

        if not w_id:
            raise ValueError('w_id must be provided')
        if not refresh_token:
            raise ValueError('refresh_token must be provided')
        headers = {
            'refresh_token': refresh_token,
            'delegated_token': delegated_token,
        }
        sdk_headers = get_sdk_headers(
            service_name=self.DEFAULT_SERVICE_NAME,
            service_version='V1',
            operation_id='refresh_workspace_command',
        )
        headers.update(sdk_headers)

        if 'headers' in kwargs:
            headers.update(kwargs.get('headers'))
            del kwargs['headers']
        headers['Accept'] = 'application/json'

        path_param_keys = ['w_id']
        path_param_values = self.encode_path_vars(w_id)
        path_param_dict = dict(zip(path_param_keys, path_param_values))
        url = '/v1/workspaces/{w_id}/refresh'.format(**path_param_dict)
        request = self.prepare_request(
            method='PUT',
            url=url,
            headers=headers,
        )

        response = self.send(request, **kwargs)
        return response

    def list_jobs(
        self,
        *,
        offset: Optional[int] = None,
        limit: Optional[int] = None,
        sort: Optional[str] = None,
        profile: Optional[str] = None,
        resource: Optional[str] = None,
        resource_id: Optional[str] = None,
        action_id: Optional[str] = None,
        workspace_id: Optional[str] = None,
        list: Optional[str] = None,
        **kwargs,
    ) -> DetailedResponse:
        """
        List jobs.

        Retrieve a list of all Schematics jobs.  The job displays a list of jobs with the
        status as `pending`, `in_progess`,  `success`, or `failed`. Jobs are generated
        when you use the  `POST /v2/jobs`, `PUT /v2/jobs/{job_id}`, or `DELETE
        /v2/jobs/{job_id}`.
         <h3>Authorization</h3>
         Schematics support generic authorization for its resources.
         For more information, about Schematics access and permissions, see
         [Schematics service access roles and required
        permissions](https://cloud.ibm.com/docs/schematics?topic=schematics-access#access-roles).

        :param int offset: (optional) The starting position of the item in the list
               of items. For example, if you have three workspaces in your account, the
               first workspace is assigned position number 0, the second workspace is
               assigned position number 1, and so forth. If you have 6 workspaces and you
               want to list the details for workspaces `2-6`, enter 1. To limit the number
               of workspaces that is returned, use the `limit` option in addition to the
               `offset` option. Negative numbers are not supported and are ignored.
        :param int limit: (optional) The maximum number of items that you want to
               list. The number must be a positive integer between 1 and 2000. If no value
               is provided, 100 is used by default.
        :param str sort: (optional) Name of the field to sort-by;  Use the '.'
               character to delineate sub-resources and sub-fields (eg. owner.last_name).
               Prepend the field with '+' or '-', indicating 'ascending' or 'descending'
               (default is ascending)   Ignore unrecognized or unsupported sort field.
        :param str profile: (optional) Level of details returned by the get method.
        :param str resource: (optional) Name of the resource (workspaces, actions,
               environment or controls).
        :param str resource_id: (optional) The Resource Id. It could be an
               Action-id or Workspace-id.
        :param str action_id: (optional) Action Id.
        :param str workspace_id: (optional) Workspace Id.
        :param str list: (optional) list jobs.
        :param dict headers: A `dict` containing the request headers
        :return: A `DetailedResponse` containing the result, headers and HTTP status code.
        :rtype: DetailedResponse with `dict` result representing a `JobList` object
        """

        headers = {}
        sdk_headers = get_sdk_headers(
            service_name=self.DEFAULT_SERVICE_NAME,
            service_version='V1',
            operation_id='list_jobs',
        )
        headers.update(sdk_headers)

        params = {
            'offset': offset,
            'limit': limit,
            'sort': sort,
            'profile': profile,
            'resource': resource,
            'resource_id': resource_id,
            'action_id': action_id,
            'workspace_id': workspace_id,
            'list': list,
        }

        if 'headers' in kwargs:
            headers.update(kwargs.get('headers'))
            del kwargs['headers']
        headers['Accept'] = 'application/json'

        url = '/v2/jobs'
        request = self.prepare_request(
            method='GET',
            url=url,
            headers=headers,
            params=params,
        )

        response = self.send(request, **kwargs)
        return response

    def create_job(
        self,
        refresh_token: str,
        *,
        command_object: Optional[str] = None,
        command_object_id: Optional[str] = None,
        command_name: Optional[str] = None,
        command_parameter: Optional[str] = None,
        command_options: Optional[List[str]] = None,
        inputs: Optional[List['VariableData']] = None,
        settings: Optional[List['VariableData']] = None,
        tags: Optional[List[str]] = None,
        location: Optional[str] = None,
        status: Optional['JobStatus'] = None,
        cart_order_data: Optional[List['CartOrderData']] = None,
        data: Optional['JobData'] = None,
        bastion: Optional['BastionResourceDefinition'] = None,
        log_summary: Optional['JobLogSummary'] = None,
        agent: Optional['AgentInfo'] = None,
        **kwargs,
    ) -> DetailedResponse:
        """
        Create a job.

        Create & launch the Schematics job. It can be used to launch an Ansible playbook
        against a target hosts.  The job displays a list of jobs with the status as
        `pending`, `in_progess`, `success`, or `failed`.

        :param str refresh_token: The IAM refresh token for the user or service
               identity.
                 **Retrieving refresh token**:
                 * Use `export IBMCLOUD_API_KEY=<ibmcloud_api_key>`, and execute `curl -X
               POST "https://iam.cloud.ibm.com/identity/token" -H "Content-Type:
               application/x-www-form-urlencoded" -d
               "grant_type=urn:ibm:params:oauth:grant-type:apikey&apikey=$IBMCLOUD_API_KEY"
               -u bx:bx`.
                 * For more information, about creating IAM access token and API Docs,
               refer, [IAM access
               token](/apidocs/iam-identity-token-api#gettoken-password) and [Create API
               key](/apidocs/iam-identity-token-api#create-api-key).
                 **Limitation**:
                 * If the token is expired, you can use `refresh token` to get a new IAM
               access token.
                 * The `refresh_token` parameter cannot be used to retrieve a new IAM
               access token.
                 * When the IAM access token is about to expire, use the API key to create
               a new access token.
        :param str command_object: (optional) Name of the Schematics automation
               resource.
        :param str command_object_id: (optional) Job command object id
               (workspace-id, action-id).
        :param str command_name: (optional) Schematics job command name.
        :param str command_parameter: (optional) Schematics job command parameter
               (playbook-name).
        :param List[str] command_options: (optional) Command line options for the
               command.
        :param List[VariableData] inputs: (optional) Job inputs used by Action or
               Workspace.
        :param List[VariableData] settings: (optional) Environment variables used
               by the Job while performing Action or Workspace.
        :param List[str] tags: (optional) User defined tags, while running the job.
        :param str location: (optional) List of locations supported by IBM Cloud
               Schematics service.  While creating your workspace or action, choose the
               right region, since it cannot be changed.  Note, this does not limit the
               location of the IBM Cloud resources, provisioned using Schematics.
        :param JobStatus status: (optional) Job Status.
        :param List[CartOrderData] cart_order_data: (optional) Contains the cart
               order data which can be used for different purpose for eg. service tagging.
        :param JobData data: (optional) Job data.
        :param BastionResourceDefinition bastion: (optional) Describes a bastion
               resource.
        :param JobLogSummary log_summary: (optional) Job log summary record.
        :param AgentInfo agent: (optional) Agent name, Agent id and associated
               policy ID information.
        :param dict headers: A `dict` containing the request headers
        :return: A `DetailedResponse` containing the result, headers and HTTP status code.
        :rtype: DetailedResponse with `dict` result representing a `Job` object
        """

        if not refresh_token:
            raise ValueError('refresh_token must be provided')
        if inputs is not None:
            inputs = [convert_model(x) for x in inputs]
        if settings is not None:
            settings = [convert_model(x) for x in settings]
        if status is not None:
            status = convert_model(status)
        if cart_order_data is not None:
            cart_order_data = [convert_model(x) for x in cart_order_data]
        if data is not None:
            data = convert_model(data)
        if bastion is not None:
            bastion = convert_model(bastion)
        if log_summary is not None:
            log_summary = convert_model(log_summary)
        if agent is not None:
            agent = convert_model(agent)
        headers = {
            'refresh_token': refresh_token,
        }
        sdk_headers = get_sdk_headers(
            service_name=self.DEFAULT_SERVICE_NAME,
            service_version='V1',
            operation_id='create_job',
        )
        headers.update(sdk_headers)

        data = {
            'command_object': command_object,
            'command_object_id': command_object_id,
            'command_name': command_name,
            'command_parameter': command_parameter,
            'command_options': command_options,
            'inputs': inputs,
            'settings': settings,
            'tags': tags,
            'location': location,
            'status': status,
            'cart_order_data': cart_order_data,
            'data': data,
            'bastion': bastion,
            'log_summary': log_summary,
            'agent': agent,
        }
        data = {k: v for (k, v) in data.items() if v is not None}
        data = json.dumps(data)
        headers['content-type'] = 'application/json'

        if 'headers' in kwargs:
            headers.update(kwargs.get('headers'))
            del kwargs['headers']
        headers['Accept'] = 'application/json'

        url = '/v2/jobs'
        request = self.prepare_request(
            method='POST',
            url=url,
            headers=headers,
            data=data,
        )

        response = self.send(request, **kwargs)
        return response

    def get_job(
        self,
        job_id: str,
        *,
        profile: Optional[str] = None,
        **kwargs,
    ) -> DetailedResponse:
        """
        Get a job.

        Retrieve the detailed information of Job
         <h3>Authorization</h3>
         Schematics support generic authorization for its resources.
         For more information, about Schematics access and permissions, see
         [Schematics service access roles and required
        permissions](https://cloud.ibm.com/docs/schematics?topic=schematics-access#access-roles).

        :param str job_id: Job Id. Use `GET /v2/jobs` API to look up the Job Ids in
               your IBM Cloud account.
        :param str profile: (optional) Level of details returned by the get method.
        :param dict headers: A `dict` containing the request headers
        :return: A `DetailedResponse` containing the result, headers and HTTP status code.
        :rtype: DetailedResponse with `dict` result representing a `Job` object
        """

        if not job_id:
            raise ValueError('job_id must be provided')
        headers = {}
        sdk_headers = get_sdk_headers(
            service_name=self.DEFAULT_SERVICE_NAME,
            service_version='V1',
            operation_id='get_job',
        )
        headers.update(sdk_headers)

        params = {
            'profile': profile,
        }

        if 'headers' in kwargs:
            headers.update(kwargs.get('headers'))
            del kwargs['headers']
        headers['Accept'] = 'application/json'

        path_param_keys = ['job_id']
        path_param_values = self.encode_path_vars(job_id)
        path_param_dict = dict(zip(path_param_keys, path_param_values))
        url = '/v2/jobs/{job_id}'.format(**path_param_dict)
        request = self.prepare_request(
            method='GET',
            url=url,
            headers=headers,
            params=params,
        )

        response = self.send(request, **kwargs)
        return response

    def update_job(
        self,
        job_id: str,
        refresh_token: str,
        *,
        command_object: Optional[str] = None,
        command_object_id: Optional[str] = None,
        command_name: Optional[str] = None,
        command_parameter: Optional[str] = None,
        command_options: Optional[List[str]] = None,
        inputs: Optional[List['VariableData']] = None,
        settings: Optional[List['VariableData']] = None,
        tags: Optional[List[str]] = None,
        location: Optional[str] = None,
        status: Optional['JobStatus'] = None,
        cart_order_data: Optional[List['CartOrderData']] = None,
        data: Optional['JobData'] = None,
        bastion: Optional['BastionResourceDefinition'] = None,
        log_summary: Optional['JobLogSummary'] = None,
        agent: Optional['AgentInfo'] = None,
        **kwargs,
    ) -> DetailedResponse:
        """
        Update a job.

        Creates a copy of the Schematics job and relaunches an existing job  by updating
        the information of an existing Schematics job.
         <h3>Authorization</h3>
         Schematics support generic authorization for its resources.
         For more information, about Schematics access and permissions, see
         [Schematics service access roles and required
        permissions](https://cloud.ibm.com/docs/schematics?topic=schematics-access#access-roles).

        :param str job_id: Job Id. Use `GET /v2/jobs` API to look up the Job Ids in
               your IBM Cloud account.
        :param str refresh_token: The IAM refresh token for the user or service
               identity.
                 **Retrieving refresh token**:
                 * Use `export IBMCLOUD_API_KEY=<ibmcloud_api_key>`, and execute `curl -X
               POST "https://iam.cloud.ibm.com/identity/token" -H "Content-Type:
               application/x-www-form-urlencoded" -d
               "grant_type=urn:ibm:params:oauth:grant-type:apikey&apikey=$IBMCLOUD_API_KEY"
               -u bx:bx`.
                 * For more information, about creating IAM access token and API Docs,
               refer, [IAM access
               token](/apidocs/iam-identity-token-api#gettoken-password) and [Create API
               key](/apidocs/iam-identity-token-api#create-api-key).
                 **Limitation**:
                 * If the token is expired, you can use `refresh token` to get a new IAM
               access token.
                 * The `refresh_token` parameter cannot be used to retrieve a new IAM
               access token.
                 * When the IAM access token is about to expire, use the API key to create
               a new access token.
        :param str command_object: (optional) Name of the Schematics automation
               resource.
        :param str command_object_id: (optional) Job command object id
               (workspace-id, action-id).
        :param str command_name: (optional) Schematics job command name.
        :param str command_parameter: (optional) Schematics job command parameter
               (playbook-name).
        :param List[str] command_options: (optional) Command line options for the
               command.
        :param List[VariableData] inputs: (optional) Job inputs used by Action or
               Workspace.
        :param List[VariableData] settings: (optional) Environment variables used
               by the Job while performing Action or Workspace.
        :param List[str] tags: (optional) User defined tags, while running the job.
        :param str location: (optional) List of locations supported by IBM Cloud
               Schematics service.  While creating your workspace or action, choose the
               right region, since it cannot be changed.  Note, this does not limit the
               location of the IBM Cloud resources, provisioned using Schematics.
        :param JobStatus status: (optional) Job Status.
        :param List[CartOrderData] cart_order_data: (optional) Contains the cart
               order data which can be used for different purpose for eg. service tagging.
        :param JobData data: (optional) Job data.
        :param BastionResourceDefinition bastion: (optional) Describes a bastion
               resource.
        :param JobLogSummary log_summary: (optional) Job log summary record.
        :param AgentInfo agent: (optional) Agent name, Agent id and associated
               policy ID information.
        :param dict headers: A `dict` containing the request headers
        :return: A `DetailedResponse` containing the result, headers and HTTP status code.
        :rtype: DetailedResponse with `dict` result representing a `Job` object
        """

        if not job_id:
            raise ValueError('job_id must be provided')
        if not refresh_token:
            raise ValueError('refresh_token must be provided')
        if inputs is not None:
            inputs = [convert_model(x) for x in inputs]
        if settings is not None:
            settings = [convert_model(x) for x in settings]
        if status is not None:
            status = convert_model(status)
        if cart_order_data is not None:
            cart_order_data = [convert_model(x) for x in cart_order_data]
        if data is not None:
            data = convert_model(data)
        if bastion is not None:
            bastion = convert_model(bastion)
        if log_summary is not None:
            log_summary = convert_model(log_summary)
        if agent is not None:
            agent = convert_model(agent)
        headers = {
            'refresh_token': refresh_token,
        }
        sdk_headers = get_sdk_headers(
            service_name=self.DEFAULT_SERVICE_NAME,
            service_version='V1',
            operation_id='update_job',
        )
        headers.update(sdk_headers)

        data = {
            'command_object': command_object,
            'command_object_id': command_object_id,
            'command_name': command_name,
            'command_parameter': command_parameter,
            'command_options': command_options,
            'inputs': inputs,
            'settings': settings,
            'tags': tags,
            'location': location,
            'status': status,
            'cart_order_data': cart_order_data,
            'data': data,
            'bastion': bastion,
            'log_summary': log_summary,
            'agent': agent,
        }
        data = {k: v for (k, v) in data.items() if v is not None}
        data = json.dumps(data)
        headers['content-type'] = 'application/json'

        if 'headers' in kwargs:
            headers.update(kwargs.get('headers'))
            del kwargs['headers']
        headers['Accept'] = 'application/json'

        path_param_keys = ['job_id']
        path_param_values = self.encode_path_vars(job_id)
        path_param_dict = dict(zip(path_param_keys, path_param_values))
        url = '/v2/jobs/{job_id}'.format(**path_param_dict)
        request = self.prepare_request(
            method='PUT',
            url=url,
            headers=headers,
            data=data,
        )

        response = self.send(request, **kwargs)
        return response

    def delete_job(
        self,
        job_id: str,
        refresh_token: str,
        *,
        force: Optional[bool] = None,
        propagate: Optional[bool] = None,
        **kwargs,
    ) -> DetailedResponse:
        """
        Stop the running Job, and delete the Job.

        Stop the running Job, and delete the Job.  **Note** You cannot delete or stop the
        job activity from an ongoing  execution of an action defined in the playbook.  You
        can repeat the execution of same job, whenever you patch or update the action or
        workspace.
         <h3>Authorization</h3>
         Schematics support generic authorization for its resources.
         For more information, about Schematics access and permissions, see
         [Schematics service access roles and required
        permissions](https://cloud.ibm.com/docs/schematics?topic=schematics-access#access-roles).

        :param str job_id: Job Id. Use `GET /v2/jobs` API to look up the Job Ids in
               your IBM Cloud account.
        :param str refresh_token: The IAM refresh token for the user or service
               identity.
                 **Retrieving refresh token**:
                 * Use `export IBMCLOUD_API_KEY=<ibmcloud_api_key>`, and execute `curl -X
               POST "https://iam.cloud.ibm.com/identity/token" -H "Content-Type:
               application/x-www-form-urlencoded" -d
               "grant_type=urn:ibm:params:oauth:grant-type:apikey&apikey=$IBMCLOUD_API_KEY"
               -u bx:bx`.
                 * For more information, about creating IAM access token and API Docs,
               refer, [IAM access
               token](/apidocs/iam-identity-token-api#gettoken-password) and [Create API
               key](/apidocs/iam-identity-token-api#create-api-key).
                 **Limitation**:
                 * If the token is expired, you can use `refresh token` to get a new IAM
               access token.
                 * The `refresh_token` parameter cannot be used to retrieve a new IAM
               access token.
                 * When the IAM access token is about to expire, use the API key to create
               a new access token.
        :param bool force: (optional) Equivalent to -force options in the command
               line.
        :param bool propagate: (optional) Auto propagate the chaange or deletion to
               the dependent resources.
        :param dict headers: A `dict` containing the request headers
        :return: A `DetailedResponse` containing the result, headers and HTTP status code.
        :rtype: DetailedResponse
        """

        if not job_id:
            raise ValueError('job_id must be provided')
        if not refresh_token:
            raise ValueError('refresh_token must be provided')
        headers = {
            'refresh_token': refresh_token,
            'force': force,
            'propagate': propagate,
        }
        sdk_headers = get_sdk_headers(
            service_name=self.DEFAULT_SERVICE_NAME,
            service_version='V1',
            operation_id='delete_job',
        )
        headers.update(sdk_headers)

        if 'headers' in kwargs:
            headers.update(kwargs.get('headers'))
            del kwargs['headers']

        path_param_keys = ['job_id']
        path_param_values = self.encode_path_vars(job_id)
        path_param_dict = dict(zip(path_param_keys, path_param_values))
        url = '/v2/jobs/{job_id}'.format(**path_param_dict)
        request = self.prepare_request(
            method='DELETE',
            url=url,
            headers=headers,
        )

        response = self.send(request, **kwargs)
        return response

    def list_job_logs(
        self,
        job_id: str,
        **kwargs,
    ) -> DetailedResponse:
        """
        Get job logs.

        Retrieve the job logs <h3>Authorization</h3> Schematics support generic
        authorization for its resources. For more information, about Schematics access and
        permissions, see [Schematics service access roles and required
        permissions](https://cloud.ibm.com/docs/schematics?topic=schematics-access#access-roles).

        :param str job_id: Job Id. Use `GET /v2/jobs` API to look up the Job Ids in
               your IBM Cloud account.
        :param dict headers: A `dict` containing the request headers
        :return: A `DetailedResponse` containing the result, headers and HTTP status code.
        :rtype: DetailedResponse with `dict` result representing a `JobLog` object
        """

        if not job_id:
            raise ValueError('job_id must be provided')
        headers = {}
        sdk_headers = get_sdk_headers(
            service_name=self.DEFAULT_SERVICE_NAME,
            service_version='V1',
            operation_id='list_job_logs',
        )
        headers.update(sdk_headers)

        if 'headers' in kwargs:
            headers.update(kwargs.get('headers'))
            del kwargs['headers']
        headers['Accept'] = 'application/json'

        path_param_keys = ['job_id']
        path_param_values = self.encode_path_vars(job_id)
        path_param_dict = dict(zip(path_param_keys, path_param_values))
        url = '/v2/jobs/{job_id}/logs'.format(**path_param_dict)
        request = self.prepare_request(
            method='GET',
            url=url,
            headers=headers,
        )

        response = self.send(request, **kwargs)
        return response

    def get_job_files(
        self,
        job_id: str,
        file_type: str,
        **kwargs,
    ) -> DetailedResponse:
        """
        Get output files from the Job record.

        Get output files from the Job record. For more information, about the Schematics
        job status, download job logs, and download the output files, see [Download
        Schematics
        Job](https://cloud.ibm.com/docs/schematics?topic=schematics-job-download).

        :param str job_id: Job Id. Use `GET /v2/jobs` API to look up the Job Ids in
               your IBM Cloud account.
        :param str file_type: The type of file you want to download eg.state_file,
               plan_json.
        :param dict headers: A `dict` containing the request headers
        :return: A `DetailedResponse` containing the result, headers and HTTP status code.
        :rtype: DetailedResponse with `dict` result representing a `JobFileData` object
        """

        if not job_id:
            raise ValueError('job_id must be provided')
        if not file_type:
            raise ValueError('file_type must be provided')
        headers = {}
        sdk_headers = get_sdk_headers(
            service_name=self.DEFAULT_SERVICE_NAME,
            service_version='V1',
            operation_id='get_job_files',
        )
        headers.update(sdk_headers)

        params = {
            'file_type': file_type,
        }

        if 'headers' in kwargs:
            headers.update(kwargs.get('headers'))
            del kwargs['headers']
        headers['Accept'] = 'application/json'

        path_param_keys = ['job_id']
        path_param_values = self.encode_path_vars(job_id)
        path_param_dict = dict(zip(path_param_keys, path_param_values))
        url = '/v2/jobs/{job_id}/files'.format(**path_param_dict)
        request = self.prepare_request(
            method='GET',
            url=url,
            headers=headers,
            params=params,
        )

        response = self.send(request, **kwargs)
        return response

    #########################
    # bulk-jobs
    #########################

    def create_workspace_deletion_job(
        self,
        refresh_token: str,
        *,
        job: Optional[str] = None,
        version: Optional[str] = None,
        workspaces: Optional[List[str]] = None,
        **kwargs,
    ) -> DetailedResponse:
        """
        Delete one or more workspace.

        Delete one or multiple Schematics workspace. Deleting a workspace does not destroy
        the resources from the Schematics workspace.
           <h3>Authorization</h3>
           Schematics support generic authorization for its resources.
           For more information, about Schematics access and permissions, see
           [Schematics service access roles and required
        permissions](https://cloud.ibm.com/docs/schematics?topic=schematics-access#access-roles).

        :param str refresh_token: The IAM refresh token for the user or service
               identity.
                 **Retrieving refresh token**:
                 * Use `export IBMCLOUD_API_KEY=<ibmcloud_api_key>`, and execute `curl -X
               POST "https://iam.cloud.ibm.com/identity/token" -H "Content-Type:
               application/x-www-form-urlencoded" -d
               "grant_type=urn:ibm:params:oauth:grant-type:apikey&apikey=$IBMCLOUD_API_KEY"
               -u bx:bx`.
                 * For more information, about creating IAM access token and API Docs,
               refer, [IAM access
               token](/apidocs/iam-identity-token-api#gettoken-password) and [Create API
               key](/apidocs/iam-identity-token-api#create-api-key).
                 **Limitation**:
                 * If the token is expired, you can use `refresh token` to get a new IAM
               access token.
                 * The `refresh_token` parameter cannot be used to retrieve a new IAM
               access token.
                 * When the IAM access token is about to expire, use the API key to create
               a new access token.
        :param str job: (optional) Job type such as delete of a batch operation.
        :param str version: (optional) A version of the terraform template.
        :param List[str] workspaces: (optional) The List of workspaces to be
               deleted.
        :param dict headers: A `dict` containing the request headers
        :return: A `DetailedResponse` containing the result, headers and HTTP status code.
        :rtype: DetailedResponse with `dict` result representing a `WorkspaceBulkDeleteResponse` object
        """

        if not refresh_token:
            raise ValueError('refresh_token must be provided')
        headers = {
            'refresh_token': refresh_token,
        }
        sdk_headers = get_sdk_headers(
            service_name=self.DEFAULT_SERVICE_NAME,
            service_version='V1',
            operation_id='create_workspace_deletion_job',
        )
        headers.update(sdk_headers)

        data = {
            'job': job,
            'version': version,
            'workspaces': workspaces,
        }
        data = {k: v for (k, v) in data.items() if v is not None}
        data = json.dumps(data)
        headers['content-type'] = 'application/json'

        if 'headers' in kwargs:
            headers.update(kwargs.get('headers'))
            del kwargs['headers']
        headers['Accept'] = 'application/json'

        url = '/v1/workspace_jobs'
        request = self.prepare_request(
            method='POST',
            url=url,
            headers=headers,
            data=data,
        )

        response = self.send(request, **kwargs)
        return response

    def get_workspace_deletion_job_status(
        self,
        wj_id: str,
        **kwargs,
    ) -> DetailedResponse:
        """
        Get the workspace deletion job status.

        Retrieve detailed information for a workspace deletion job status.
           <h3>Authorization</h3>
           Schematics support generic authorization for its resources.
           For more information, about Schematics access and permissions, see
           [Schematics service access roles and required
        permissions](https://cloud.ibm.com/docs/schematics?topic=schematics-access#access-roles).

        :param str wj_id: The workspace job ID.
        :param dict headers: A `dict` containing the request headers
        :return: A `DetailedResponse` containing the result, headers and HTTP status code.
        :rtype: DetailedResponse with `dict` result representing a `WorkspaceJobResponse` object
        """

        if not wj_id:
            raise ValueError('wj_id must be provided')
        headers = {}
        sdk_headers = get_sdk_headers(
            service_name=self.DEFAULT_SERVICE_NAME,
            service_version='V1',
            operation_id='get_workspace_deletion_job_status',
        )
        headers.update(sdk_headers)

        if 'headers' in kwargs:
            headers.update(kwargs.get('headers'))
            del kwargs['headers']
        headers['Accept'] = 'application/json'

        path_param_keys = ['wj_id']
        path_param_values = self.encode_path_vars(wj_id)
        path_param_dict = dict(zip(path_param_keys, path_param_values))
        url = '/v1/workspace_jobs/{wj_id}/status'.format(**path_param_dict)
        request = self.prepare_request(
            method='GET',
            url=url,
            headers=headers,
        )

        response = self.send(request, **kwargs)
        return response

    #########################
    # inventory
    #########################

    def list_inventories(
        self,
        *,
        offset: Optional[int] = None,
        limit: Optional[int] = None,
        sort: Optional[str] = None,
        profile: Optional[str] = None,
        **kwargs,
    ) -> DetailedResponse:
        """
        List inventory definitions.

        Retrieve a list of all Schematics inventories that depends on the API endpoint
        that you have access. For example, if you use an API endpoint for a geography,
        such as North America, only inventories that are created in `us-south` or
        `us-east` are retrieved. For more information, about supported API endpoints, see
        [APIendpoints](/apidocs/schematics#api-endpoints).
         <h3>Authorization</h3>
         Schematics support generic authorization for its resources.
         For more information, about Schematics access and permissions, see
         [Schematics service access roles and required
        permissions](https://cloud.ibm.com/docs/schematics?topic=schematics-access#access-roles).

        :param int offset: (optional) The starting position of the item in the list
               of items. For example, if you have three workspaces in your account, the
               first workspace is assigned position number 0, the second workspace is
               assigned position number 1, and so forth. If you have 6 workspaces and you
               want to list the details for workspaces `2-6`, enter 1. To limit the number
               of workspaces that is returned, use the `limit` option in addition to the
               `offset` option. Negative numbers are not supported and are ignored.
        :param int limit: (optional) The maximum number of items that you want to
               list. The number must be a positive integer between 1 and 2000. If no value
               is provided, 100 is used by default.
        :param str sort: (optional) Name of the field to sort-by;  Use the '.'
               character to delineate sub-resources and sub-fields (eg. owner.last_name).
               Prepend the field with '+' or '-', indicating 'ascending' or 'descending'
               (default is ascending)   Ignore unrecognized or unsupported sort field.
        :param str profile: (optional) Level of details returned by the get method.
        :param dict headers: A `dict` containing the request headers
        :return: A `DetailedResponse` containing the result, headers and HTTP status code.
        :rtype: DetailedResponse with `dict` result representing a `InventoryResourceRecordList` object
        """

        headers = {}
        sdk_headers = get_sdk_headers(
            service_name=self.DEFAULT_SERVICE_NAME,
            service_version='V1',
            operation_id='list_inventories',
        )
        headers.update(sdk_headers)

        params = {
            'offset': offset,
            'limit': limit,
            'sort': sort,
            'profile': profile,
        }

        if 'headers' in kwargs:
            headers.update(kwargs.get('headers'))
            del kwargs['headers']
        headers['Accept'] = 'application/json'

        url = '/v2/inventories'
        request = self.prepare_request(
            method='GET',
            url=url,
            headers=headers,
            params=params,
        )

        response = self.send(request, **kwargs)
        return response

    def create_inventory(
        self,
        *,
        name: Optional[str] = None,
        description: Optional[str] = None,
        location: Optional[str] = None,
        resource_group: Optional[str] = None,
        inventories_ini: Optional[str] = None,
        resource_queries: Optional[List[str]] = None,
        **kwargs,
    ) -> DetailedResponse:
        """
        Create an inventory definition.

        Create an IBM Cloud Schematics inventory as a single IBM Cloud resource where you
        want to run Ansible playbook by using Schematics actions. For more information,
        about inventory host groups, refer to [creating static and dynamic inventory for
        Schematics
        actions](https://cloud.ibm.com/docs/schematics?topic=schematics-inventories-setup).
         **Note** you cannot update the location and region, resource group once an action
        is created. Also, make sure your IP addresses are in the
        [allowlist](https://cloud.ibm.com/docs/schematics?topic=schematics-allowed-ipaddresses).
         If your Git repository already contains a host file. Schematics does not
        overwrite the host file already present in your Git repository.
         <h3>Authorization</h3>
         Schematics support generic authorization for its resources.
         For more information, about Schematics access and permissions, see
         [Schematics service access roles and required
        permissions](https://cloud.ibm.com/docs/schematics?topic=schematics-access#access-roles).

        :param str name: (optional) The unique name of your Inventory definition.
               The name can be up to 128 characters long and can include alphanumeric
               characters, spaces, dashes, and underscores.
        :param str description: (optional) The description of your Inventory
               definition. The description can be up to 2048 characters long in size.
        :param str location: (optional) List of locations supported by IBM Cloud
               Schematics service.  While creating your workspace or action, choose the
               right region, since it cannot be changed.  Note, this does not limit the
               location of the IBM Cloud resources, provisioned using Schematics.
        :param str resource_group: (optional) Resource-group name for the Inventory
               definition.   By default, Inventory definition will be created in Default
               Resource Group.
        :param str inventories_ini: (optional) Input inventory of host and host
               group for the playbook, in the `.ini` file format.
        :param List[str] resource_queries: (optional) Input resource query
               definitions that is used to dynamically generate the inventory of host and
               host group for the playbook.
        :param dict headers: A `dict` containing the request headers
        :return: A `DetailedResponse` containing the result, headers and HTTP status code.
        :rtype: DetailedResponse with `dict` result representing a `InventoryResourceRecord` object
        """

        headers = {}
        sdk_headers = get_sdk_headers(
            service_name=self.DEFAULT_SERVICE_NAME,
            service_version='V1',
            operation_id='create_inventory',
        )
        headers.update(sdk_headers)

        data = {
            'name': name,
            'description': description,
            'location': location,
            'resource_group': resource_group,
            'inventories_ini': inventories_ini,
            'resource_queries': resource_queries,
        }
        data = {k: v for (k, v) in data.items() if v is not None}
        data = json.dumps(data)
        headers['content-type'] = 'application/json'

        if 'headers' in kwargs:
            headers.update(kwargs.get('headers'))
            del kwargs['headers']
        headers['Accept'] = 'application/json'

        url = '/v2/inventories'
        request = self.prepare_request(
            method='POST',
            url=url,
            headers=headers,
            data=data,
        )

        response = self.send(request, **kwargs)
        return response

    def get_inventory(
        self,
        inventory_id: str,
        *,
        profile: Optional[str] = None,
        **kwargs,
    ) -> DetailedResponse:
        """
        Get an inventory definition.

        Use this API to retrieve the detailed information for a resource inventory
        definition used to target an action in your IBM Cloud account. For more
        information, about inventory get, refer to [ibmcloud schematics inventory
        get](https://cloud.ibm.com/docs/schematics?topic=schematics-schematics-cli-reference#schematics-get-inv).
         **Note** you can fetch only the location and region, resource group from where
        your inventory is created.
         Also, make sure your IP addresses are in the
        [allowlist](https://cloud.ibm.com/docs/schematics?topic=schematics-allowed-ipaddresses).
         <h3>Authorization</h3>
         Schematics support generic authorization for its resources.
         For more information, about Schematics access and permissions, see
         [Schematics service access roles and required
        permissions](https://cloud.ibm.com/docs/schematics?topic=schematics-access#access-roles).

        :param str inventory_id: Resource Inventory Id.  Use `GET /v2/inventories`
               API to look up the Resource Inventory definition Ids  in your IBM Cloud
               account.
        :param str profile: (optional) Level of details returned by the get method.
        :param dict headers: A `dict` containing the request headers
        :return: A `DetailedResponse` containing the result, headers and HTTP status code.
        :rtype: DetailedResponse with `dict` result representing a `InventoryResourceRecord` object
        """

        if not inventory_id:
            raise ValueError('inventory_id must be provided')
        headers = {}
        sdk_headers = get_sdk_headers(
            service_name=self.DEFAULT_SERVICE_NAME,
            service_version='V1',
            operation_id='get_inventory',
        )
        headers.update(sdk_headers)

        params = {
            'profile': profile,
        }

        if 'headers' in kwargs:
            headers.update(kwargs.get('headers'))
            del kwargs['headers']
        headers['Accept'] = 'application/json'

        path_param_keys = ['inventory_id']
        path_param_values = self.encode_path_vars(inventory_id)
        path_param_dict = dict(zip(path_param_keys, path_param_values))
        url = '/v2/inventories/{inventory_id}'.format(**path_param_dict)
        request = self.prepare_request(
            method='GET',
            url=url,
            headers=headers,
            params=params,
        )

        response = self.send(request, **kwargs)
        return response

    def replace_inventory(
        self,
        inventory_id: str,
        *,
        name: Optional[str] = None,
        description: Optional[str] = None,
        location: Optional[str] = None,
        resource_group: Optional[str] = None,
        inventories_ini: Optional[str] = None,
        resource_queries: Optional[List[str]] = None,
        **kwargs,
    ) -> DetailedResponse:
        """
        Update an inventory definition.

        Use this API to update the inventory definition resource used to target an action.
        For more information, about inventory update, refer to [ibmcloud schematics
        inventory
        update](https://cloud.ibm.com/docs/schematics?topic=schematics-schematics-cli-reference#schematics-update-inv).
         **Note** you cannot update the location and region, resource group once an action
        is created.
         Also, make sure your IP addresses are in the
        [allowlist](https://cloud.ibm.com/docs/schematics?topic=schematics-allowed-ipaddresses).
         <h3>Authorization</h3>
         Schematics support generic authorization for its resources.
         For more information, about Schematics access and permissions, see
         [Schematics service access roles and required
        permissions](https://cloud.ibm.com/docs/schematics?topic=schematics-access#access-roles).

        :param str inventory_id: Resource Inventory Id.  Use `GET /v2/inventories`
               API to look up the Resource Inventory definition Ids  in your IBM Cloud
               account.
        :param str name: (optional) The unique name of your Inventory definition.
               The name can be up to 128 characters long and can include alphanumeric
               characters, spaces, dashes, and underscores.
        :param str description: (optional) The description of your Inventory
               definition. The description can be up to 2048 characters long in size.
        :param str location: (optional) List of locations supported by IBM Cloud
               Schematics service.  While creating your workspace or action, choose the
               right region, since it cannot be changed.  Note, this does not limit the
               location of the IBM Cloud resources, provisioned using Schematics.
        :param str resource_group: (optional) Resource-group name for the Inventory
               definition.   By default, Inventory definition will be created in Default
               Resource Group.
        :param str inventories_ini: (optional) Input inventory of host and host
               group for the playbook, in the `.ini` file format.
        :param List[str] resource_queries: (optional) Input resource query
               definitions that is used to dynamically generate the inventory of host and
               host group for the playbook.
        :param dict headers: A `dict` containing the request headers
        :return: A `DetailedResponse` containing the result, headers and HTTP status code.
        :rtype: DetailedResponse with `dict` result representing a `InventoryResourceRecord` object
        """

        if not inventory_id:
            raise ValueError('inventory_id must be provided')
        headers = {}
        sdk_headers = get_sdk_headers(
            service_name=self.DEFAULT_SERVICE_NAME,
            service_version='V1',
            operation_id='replace_inventory',
        )
        headers.update(sdk_headers)

        data = {
            'name': name,
            'description': description,
            'location': location,
            'resource_group': resource_group,
            'inventories_ini': inventories_ini,
            'resource_queries': resource_queries,
        }
        data = {k: v for (k, v) in data.items() if v is not None}
        data = json.dumps(data)
        headers['content-type'] = 'application/json'

        if 'headers' in kwargs:
            headers.update(kwargs.get('headers'))
            del kwargs['headers']
        headers['Accept'] = 'application/json'

        path_param_keys = ['inventory_id']
        path_param_values = self.encode_path_vars(inventory_id)
        path_param_dict = dict(zip(path_param_keys, path_param_values))
        url = '/v2/inventories/{inventory_id}'.format(**path_param_dict)
        request = self.prepare_request(
            method='PUT',
            url=url,
            headers=headers,
            data=data,
        )

        response = self.send(request, **kwargs)
        return response

    def delete_inventory(
        self,
        inventory_id: str,
        *,
        force: Optional[bool] = None,
        propagate: Optional[bool] = None,
        **kwargs,
    ) -> DetailedResponse:
        """
        Delete an inventory definition.

        Use this API to delete the resource inventory definition by using the inventory ID
        that you want to run against. For more information, about inventory delete, refer
        to [ibmcloud schematics inventory
        delete](https://cloud.ibm.com/docs/schematics?topic=schematics-schematics-cli-reference#schematics-delete-inventory).
         **Note** you cannot delete the location and region, resource group from where
        your inventory is created. Also, make sure your IP addresses are in the
        [allowlist](https://cloud.ibm.com/docs/schematics?topic=schematics-allowed-ipaddresses).
         <h3>Authorization</h3>
         Schematics support generic authorization for its resources.
         For more information, about Schematics access and permissions, see
         [Schematics service access roles and required
        permissions](https://cloud.ibm.com/docs/schematics?topic=schematics-access#access-roles).

        :param str inventory_id: Resource Inventory Id.  Use `GET /v2/inventories`
               API to look up the Resource Inventory definition Ids  in your IBM Cloud
               account.
        :param bool force: (optional) Equivalent to -force options in the command
               line.
        :param bool propagate: (optional) Auto propagate the chaange or deletion to
               the dependent resources.
        :param dict headers: A `dict` containing the request headers
        :return: A `DetailedResponse` containing the result, headers and HTTP status code.
        :rtype: DetailedResponse
        """

        if not inventory_id:
            raise ValueError('inventory_id must be provided')
        headers = {
            'force': force,
            'propagate': propagate,
        }
        sdk_headers = get_sdk_headers(
            service_name=self.DEFAULT_SERVICE_NAME,
            service_version='V1',
            operation_id='delete_inventory',
        )
        headers.update(sdk_headers)

        if 'headers' in kwargs:
            headers.update(kwargs.get('headers'))
            del kwargs['headers']

        path_param_keys = ['inventory_id']
        path_param_values = self.encode_path_vars(inventory_id)
        path_param_dict = dict(zip(path_param_keys, path_param_values))
        url = '/v2/inventories/{inventory_id}'.format(**path_param_dict)
        request = self.prepare_request(
            method='DELETE',
            url=url,
            headers=headers,
        )

        response = self.send(request, **kwargs)
        return response

    def list_resource_query(
        self,
        *,
        offset: Optional[int] = None,
        limit: Optional[int] = None,
        sort: Optional[str] = None,
        profile: Optional[str] = None,
        **kwargs,
    ) -> DetailedResponse:
        """
        List resource queries.

        Retrieve the list of resource query definitions that you have access to.  The list
        of resource queries that is returned depends on the API  endpoint that you use.
        For example, if you use an API endpoint for a geography, such as North America,
        only resource query definitions that are created in `us-south` or `us-east` are
        retrieved. For more information, about supported API endpoints, see [API
        endpoints](/apidocs/schematics#api-endpoints).
        <h3>Authorization</h3>
         Schematics support generic authorization for its resources.
         For more information, about Schematics access and permissions, see
         [Schematics service access roles and required
        permissions](https://cloud.ibm.com/docs/schematics?topic=schematics-access#access-roles).

        :param int offset: (optional) The starting position of the item in the list
               of items. For example, if you have three workspaces in your account, the
               first workspace is assigned position number 0, the second workspace is
               assigned position number 1, and so forth. If you have 6 workspaces and you
               want to list the details for workspaces `2-6`, enter 1. To limit the number
               of workspaces that is returned, use the `limit` option in addition to the
               `offset` option. Negative numbers are not supported and are ignored.
        :param int limit: (optional) The maximum number of items that you want to
               list. The number must be a positive integer between 1 and 2000. If no value
               is provided, 100 is used by default.
        :param str sort: (optional) Name of the field to sort-by;  Use the '.'
               character to delineate sub-resources and sub-fields (eg. owner.last_name).
               Prepend the field with '+' or '-', indicating 'ascending' or 'descending'
               (default is ascending)   Ignore unrecognized or unsupported sort field.
        :param str profile: (optional) Level of details returned by the get method.
        :param dict headers: A `dict` containing the request headers
        :return: A `DetailedResponse` containing the result, headers and HTTP status code.
        :rtype: DetailedResponse with `dict` result representing a `ResourceQueryRecordList` object
        """

        headers = {}
        sdk_headers = get_sdk_headers(
            service_name=self.DEFAULT_SERVICE_NAME,
            service_version='V1',
            operation_id='list_resource_query',
        )
        headers.update(sdk_headers)

        params = {
            'offset': offset,
            'limit': limit,
            'sort': sort,
            'profile': profile,
        }

        if 'headers' in kwargs:
            headers.update(kwargs.get('headers'))
            del kwargs['headers']
        headers['Accept'] = 'application/json'

        url = '/v2/resources_query'
        request = self.prepare_request(
            method='GET',
            url=url,
            headers=headers,
            params=params,
        )

        response = self.send(request, **kwargs)
        return response

    def create_resource_query(
        self,
        *,
        type: Optional[str] = None,
        name: Optional[str] = None,
        queries: Optional[List['ResourceQuery']] = None,
        **kwargs,
    ) -> DetailedResponse:
        """
        Create resource query.

        Use this API to create a resource query definition that will be used to select an
        IBM Cloud resource or a group of resources as the dynamic inventory for the
        Schematics Actions.  For more information, about resource query commands, refer to
         [ibmcloud schematics resource query
        create](https://cloud.ibm.com/docs/schematics?topic=schematics-schematics-cli-reference#schematics-create-rq).
        **Note** you cannot update the location and region, resource group  once an action
        is created. Also, make sure your IP addresses are  in the
        [allowlist](https://cloud.ibm.com/docs/schematics?topic=schematics-allowed-ipaddresses).
         If your Git repository already contains a host file.  Schematics does not
        overwrite the host file already present in your Git repository.
        <h3>Authorization</h3>
         Schematics support generic authorization for its resources.
         For more information, about Schematics access and permissions, see
         [Schematics service access roles and required
        permissions](https://cloud.ibm.com/docs/schematics?topic=schematics-access#access-roles).

        :param str type: (optional) Resource type (cluster, vsi, icd, vpc).
        :param str name: (optional) Resource query name.
        :param List[ResourceQuery] queries: (optional)
        :param dict headers: A `dict` containing the request headers
        :return: A `DetailedResponse` containing the result, headers and HTTP status code.
        :rtype: DetailedResponse with `dict` result representing a `ResourceQueryRecord` object
        """

        if queries is not None:
            queries = [convert_model(x) for x in queries]
        headers = {}
        sdk_headers = get_sdk_headers(
            service_name=self.DEFAULT_SERVICE_NAME,
            service_version='V1',
            operation_id='create_resource_query',
        )
        headers.update(sdk_headers)

        data = {
            'type': type,
            'name': name,
            'queries': queries,
        }
        data = {k: v for (k, v) in data.items() if v is not None}
        data = json.dumps(data)
        headers['content-type'] = 'application/json'

        if 'headers' in kwargs:
            headers.update(kwargs.get('headers'))
            del kwargs['headers']
        headers['Accept'] = 'application/json'

        url = '/v2/resources_query'
        request = self.prepare_request(
            method='POST',
            url=url,
            headers=headers,
            data=data,
        )

        response = self.send(request, **kwargs)
        return response

    def get_resources_query(
        self,
        query_id: str,
        **kwargs,
    ) -> DetailedResponse:
        """
        Get resources query.

        Use this API to retrieve the information resource query by Id.  For more
        information, about resource query commands, refer to  [ibmcloud schematics
        resource query
        get](https://cloud.ibm.com/docs/schematics?topic=schematics-schematics-cli-reference#schematics-get-rq).
        <h3>Authorization</h3>
         Schematics support generic authorization for its resources.
         For more information, about Schematics access and permissions, see
         [Schematics service access roles and required
        permissions](https://cloud.ibm.com/docs/schematics?topic=schematics-access#access-roles).

        :param str query_id: Resource query Id.  Use `GET /v2/resource_query` API
               to look up the Resource query definition Ids  in your IBM Cloud account.
        :param dict headers: A `dict` containing the request headers
        :return: A `DetailedResponse` containing the result, headers and HTTP status code.
        :rtype: DetailedResponse with `dict` result representing a `ResourceQueryRecord` object
        """

        if not query_id:
            raise ValueError('query_id must be provided')
        headers = {}
        sdk_headers = get_sdk_headers(
            service_name=self.DEFAULT_SERVICE_NAME,
            service_version='V1',
            operation_id='get_resources_query',
        )
        headers.update(sdk_headers)

        if 'headers' in kwargs:
            headers.update(kwargs.get('headers'))
            del kwargs['headers']
        headers['Accept'] = 'application/json'

        path_param_keys = ['query_id']
        path_param_values = self.encode_path_vars(query_id)
        path_param_dict = dict(zip(path_param_keys, path_param_values))
        url = '/v2/resources_query/{query_id}'.format(**path_param_dict)
        request = self.prepare_request(
            method='GET',
            url=url,
            headers=headers,
        )

        response = self.send(request, **kwargs)
        return response

    def replace_resources_query(
        self,
        query_id: str,
        *,
        type: Optional[str] = None,
        name: Optional[str] = None,
        queries: Optional[List['ResourceQuery']] = None,
        **kwargs,
    ) -> DetailedResponse:
        """
        Update resources query definition.

        Use this API to update the resource query definition used to build  the dynamic
        inventory for the Schematics Action.  For more information, about resource query
        commands, refer to [ibmcloud schematics resource query
        update](https://cloud.ibm.com/docs/schematics?topic=schematics-schematics-cli-reference#schematics-update-rq).
        **Note** you cannot update the location and region, resource group  once a
        resource query is created. Also, make sure your IP addresses  are in the
        [allowlist](https://cloud.ibm.com/docs/schematics?topic=schematics-allowed-ipaddresses).
        <h3>Authorization</h3>
         Schematics support generic authorization for its resources.
         For more information, about Schematics access and permissions, see
         [Schematics service access roles and required
        permissions](https://cloud.ibm.com/docs/schematics?topic=schematics-access#access-roles).

        :param str query_id: Resource query Id.  Use `GET /v2/resource_query` API
               to look up the Resource query definition Ids  in your IBM Cloud account.
        :param str type: (optional) Resource type (cluster, vsi, icd, vpc).
        :param str name: (optional) Resource query name.
        :param List[ResourceQuery] queries: (optional)
        :param dict headers: A `dict` containing the request headers
        :return: A `DetailedResponse` containing the result, headers and HTTP status code.
        :rtype: DetailedResponse with `dict` result representing a `ResourceQueryRecord` object
        """

        if not query_id:
            raise ValueError('query_id must be provided')
        if queries is not None:
            queries = [convert_model(x) for x in queries]
        headers = {}
        sdk_headers = get_sdk_headers(
            service_name=self.DEFAULT_SERVICE_NAME,
            service_version='V1',
            operation_id='replace_resources_query',
        )
        headers.update(sdk_headers)

        data = {
            'type': type,
            'name': name,
            'queries': queries,
        }
        data = {k: v for (k, v) in data.items() if v is not None}
        data = json.dumps(data)
        headers['content-type'] = 'application/json'

        if 'headers' in kwargs:
            headers.update(kwargs.get('headers'))
            del kwargs['headers']
        headers['Accept'] = 'application/json'

        path_param_keys = ['query_id']
        path_param_values = self.encode_path_vars(query_id)
        path_param_dict = dict(zip(path_param_keys, path_param_values))
        url = '/v2/resources_query/{query_id}'.format(**path_param_dict)
        request = self.prepare_request(
            method='PUT',
            url=url,
            headers=headers,
            data=data,
        )

        response = self.send(request, **kwargs)
        return response

    def execute_resource_query(
        self,
        query_id: str,
        **kwargs,
    ) -> DetailedResponse:
        """
        Run the resource query.

        Run the resource query.

        :param str query_id: Resource query Id.  Use `GET /v2/resource_query` API
               to look up the Resource query definition Ids  in your IBM Cloud account.
        :param dict headers: A `dict` containing the request headers
        :return: A `DetailedResponse` containing the result, headers and HTTP status code.
        :rtype: DetailedResponse with `dict` result representing a `ResourceQueryResponseRecord` object
        """

        if not query_id:
            raise ValueError('query_id must be provided')
        headers = {}
        sdk_headers = get_sdk_headers(
            service_name=self.DEFAULT_SERVICE_NAME,
            service_version='V1',
            operation_id='execute_resource_query',
        )
        headers.update(sdk_headers)

        if 'headers' in kwargs:
            headers.update(kwargs.get('headers'))
            del kwargs['headers']
        headers['Accept'] = 'application/json'

        path_param_keys = ['query_id']
        path_param_values = self.encode_path_vars(query_id)
        path_param_dict = dict(zip(path_param_keys, path_param_values))
        url = '/v2/resources_query/{query_id}'.format(**path_param_dict)
        request = self.prepare_request(
            method='POST',
            url=url,
            headers=headers,
        )

        response = self.send(request, **kwargs)
        return response

    def delete_resources_query(
        self,
        query_id: str,
        *,
        force: Optional[bool] = None,
        propagate: Optional[bool] = None,
        **kwargs,
    ) -> DetailedResponse:
        """
        Delete resources query.

        Use this API to delete the resource query definition by Id.  For more information,
        about resource query commands, refer to  [ibmcloud schematics resource query
        delete](https://cloud.ibm.com/docs/schematics?topic=schematics-schematics-cli-reference#schematics-delete-resource-query).
        <h3>Authorization</h3>
         Schematics support generic authorization for its resources.
         For more information, about Schematics access and permissions, see
         [Schematics service access roles and required
        permissions](https://cloud.ibm.com/docs/schematics?topic=schematics-access#access-roles).

        :param str query_id: Resource query Id.  Use `GET /v2/resource_query` API
               to look up the Resource query definition Ids  in your IBM Cloud account.
        :param bool force: (optional) Equivalent to -force options in the command
               line.
        :param bool propagate: (optional) Auto propagate the chaange or deletion to
               the dependent resources.
        :param dict headers: A `dict` containing the request headers
        :return: A `DetailedResponse` containing the result, headers and HTTP status code.
        :rtype: DetailedResponse
        """

        if not query_id:
            raise ValueError('query_id must be provided')
        headers = {
            'force': force,
            'propagate': propagate,
        }
        sdk_headers = get_sdk_headers(
            service_name=self.DEFAULT_SERVICE_NAME,
            service_version='V1',
            operation_id='delete_resources_query',
        )
        headers.update(sdk_headers)

        if 'headers' in kwargs:
            headers.update(kwargs.get('headers'))
            del kwargs['headers']

        path_param_keys = ['query_id']
        path_param_values = self.encode_path_vars(query_id)
        path_param_dict = dict(zip(path_param_keys, path_param_values))
        url = '/v2/resources_query/{query_id}'.format(**path_param_dict)
        request = self.prepare_request(
            method='DELETE',
            url=url,
            headers=headers,
        )

        response = self.send(request, **kwargs)
        return response

    #########################
    # agent
    #########################

    def list_agent(
        self,
        *,
        offset: Optional[int] = None,
        limit: Optional[int] = None,
        profile: Optional[str] = None,
        filter: Optional[str] = None,
        **kwargs,
    ) -> DetailedResponse:
        """
        Get all registered/unregistered agents in the Account.

        Get all registered or unregistered agents, in the Account.
           <h3>Authorization</h3>
           Schematics support generic authorization for its resources.
           For more information, about Schematics access and permissions, see [Schematics
        service access
           roles and required
        permissions](https://cloud.ibm.com/docs/schematics?topic=schematics-access#access-roles).

        :param int offset: (optional) The starting position of the item in the list
               of items. For example, if you have three workspaces in your account, the
               first workspace is assigned position number 0, the second workspace is
               assigned position number 1, and so forth. If you have 6 workspaces and you
               want to list the details for workspaces `2-6`, enter 1. To limit the number
               of workspaces that is returned, use the `limit` option in addition to the
               `offset` option. Negative numbers are not supported and are ignored.
        :param int limit: (optional) The maximum number of items that you want to
               list. The number must be a positive integer between 1 and 2000. If no value
               is provided, 100 is used by default.
        :param str profile: (optional) Level of details returned by the get method.
        :param str filter: (optional) Use `new` to get all unregistered agents; use
               `saved` to get all registered agents.
        :param dict headers: A `dict` containing the request headers
        :return: A `DetailedResponse` containing the result, headers and HTTP status code.
        :rtype: DetailedResponse with `dict` result representing a `AgentList` object

        Deprecated: this method is deprecated and may be removed in a future release.
        """

        logging.warning('A deprecated operation has been invoked: list_agent')

        headers = {}
        sdk_headers = get_sdk_headers(
            service_name=self.DEFAULT_SERVICE_NAME,
            service_version='V1',
            operation_id='list_agent',
        )
        headers.update(sdk_headers)

        params = {
            'offset': offset,
            'limit': limit,
            'profile': profile,
            'filter': filter,
        }

        if 'headers' in kwargs:
            headers.update(kwargs.get('headers'))
            del kwargs['headers']
        headers['Accept'] = 'application/json'

        url = '/v2/settings/agents'
        request = self.prepare_request(
            method='GET',
            url=url,
            headers=headers,
            params=params,
        )

        response = self.send(request, **kwargs)
        return response

    def register_agent(
        self,
        name: str,
        agent_location: str,
        location: str,
        profile_id: str,
        *,
        description: Optional[str] = None,
        resource_group: Optional[str] = None,
        tags: Optional[List[str]] = None,
        user_state: Optional['AgentUserState'] = None,
        **kwargs,
    ) -> DetailedResponse:
        """
        Register the agent with schematics.

        Register the agent with schematics
           <h3>Authorization</h3>
           Schematics support generic authorization for its resources.
           For more information, about Schematics access and permissions, see [Schematics
        service access
           roles and required
        permissions](https://cloud.ibm.com/docs/schematics?topic=schematics-access#access-roles).

        :param str name: The name of the agent (must be unique, for an account).
        :param str agent_location: The location where agent is deployed in the user
               environment.
        :param str location: List of locations supported by IBM Cloud Schematics
               service.  While creating your workspace or action, choose the right region,
               since it cannot be changed.  Note, this does not limit the location of the
               IBM Cloud resources, provisioned using Schematics.
        :param str profile_id: The IAM trusted profile id, used by the Agent
               instance.
        :param str description: (optional) Agent description.
        :param str resource_group: (optional) The resource-group name for the
               agent.  By default, Agent will be registered in Default Resource Group.
        :param List[str] tags: (optional) Tags for the agent.
        :param AgentUserState user_state: (optional) User defined status of the
               agent.
        :param dict headers: A `dict` containing the request headers
        :return: A `DetailedResponse` containing the result, headers and HTTP status code.
        :rtype: DetailedResponse with `dict` result representing a `Agent` object

        Deprecated: this method is deprecated and may be removed in a future release.
        """

        logging.warning('A deprecated operation has been invoked: register_agent')

        if name is None:
            raise ValueError('name must be provided')
        if agent_location is None:
            raise ValueError('agent_location must be provided')
        if location is None:
            raise ValueError('location must be provided')
        if profile_id is None:
            raise ValueError('profile_id must be provided')
        if user_state is not None:
            user_state = convert_model(user_state)
        headers = {}
        sdk_headers = get_sdk_headers(
            service_name=self.DEFAULT_SERVICE_NAME,
            service_version='V1',
            operation_id='register_agent',
        )
        headers.update(sdk_headers)

        data = {
            'name': name,
            'agent_location': agent_location,
            'location': location,
            'profile_id': profile_id,
            'description': description,
            'resource_group': resource_group,
            'tags': tags,
            'user_state': user_state,
        }
        data = {k: v for (k, v) in data.items() if v is not None}
        data = json.dumps(data)
        headers['content-type'] = 'application/json'

        if 'headers' in kwargs:
            headers.update(kwargs.get('headers'))
            del kwargs['headers']
        headers['Accept'] = 'application/json'

        url = '/v2/settings/agents'
        request = self.prepare_request(
            method='POST',
            url=url,
            headers=headers,
            data=data,
        )

        response = self.send(request, **kwargs)
        return response

    def get_agent(
        self,
        agent_id: str,
        *,
        profile: Optional[str] = None,
        **kwargs,
    ) -> DetailedResponse:
        """
        Get the registered agent details.

        Reterive list the registered agent details
           <h3>Authorization</h3>
           Schematics support generic authorization for its resources.
           For more information, about Schematics access and permissions, see [Schematics
        service access
           roles and required
        permissions](https://cloud.ibm.com/docs/schematics?topic=schematics-access#access-roles).

        :param str agent_id: Agent ID to get the details of agent.
        :param str profile: (optional) Level of details returned by the get method.
        :param dict headers: A `dict` containing the request headers
        :return: A `DetailedResponse` containing the result, headers and HTTP status code.
        :rtype: DetailedResponse with `dict` result representing a `Agent` object

        Deprecated: this method is deprecated and may be removed in a future release.
        """

        logging.warning('A deprecated operation has been invoked: get_agent')

        if not agent_id:
            raise ValueError('agent_id must be provided')
        headers = {}
        sdk_headers = get_sdk_headers(
            service_name=self.DEFAULT_SERVICE_NAME,
            service_version='V1',
            operation_id='get_agent',
        )
        headers.update(sdk_headers)

        params = {
            'profile': profile,
        }

        if 'headers' in kwargs:
            headers.update(kwargs.get('headers'))
            del kwargs['headers']
        headers['Accept'] = 'application/json'

        path_param_keys = ['agent_id']
        path_param_values = self.encode_path_vars(agent_id)
        path_param_dict = dict(zip(path_param_keys, path_param_values))
        url = '/v2/settings/agents/{agent_id}'.format(**path_param_dict)
        request = self.prepare_request(
            method='GET',
            url=url,
            headers=headers,
            params=params,
        )

        response = self.send(request, **kwargs)
        return response

    def delete_agent(
        self,
        agent_id: str,
        **kwargs,
    ) -> DetailedResponse:
        """
        Deregister the agent.

        Deregistering an agent.
           <h3>Authorization</h3>
           Schematics support generic authorization for its resources.
           For more information, about Schematics access and permissions, see [Schematics
        service access
           roles and required
        permissions](https://cloud.ibm.com/docs/schematics?topic=schematics-access#access-roles).

        :param str agent_id: Agent ID to get the details of agent.
        :param dict headers: A `dict` containing the request headers
        :return: A `DetailedResponse` containing the result, headers and HTTP status code.
        :rtype: DetailedResponse

        Deprecated: this method is deprecated and may be removed in a future release.
        """

        logging.warning('A deprecated operation has been invoked: delete_agent')

        if not agent_id:
            raise ValueError('agent_id must be provided')
        headers = {}
        sdk_headers = get_sdk_headers(
            service_name=self.DEFAULT_SERVICE_NAME,
            service_version='V1',
            operation_id='delete_agent',
        )
        headers.update(sdk_headers)

        if 'headers' in kwargs:
            headers.update(kwargs.get('headers'))
            del kwargs['headers']

        path_param_keys = ['agent_id']
        path_param_values = self.encode_path_vars(agent_id)
        path_param_dict = dict(zip(path_param_keys, path_param_values))
        url = '/v2/settings/agents/{agent_id}'.format(**path_param_dict)
        request = self.prepare_request(
            method='DELETE',
            url=url,
            headers=headers,
        )

        response = self.send(request, **kwargs)
        return response

    def update_agent_registration(
        self,
        agent_id: str,
        name: str,
        agent_location: str,
        location: str,
        profile_id: str,
        *,
        description: Optional[str] = None,
        resource_group: Optional[str] = None,
        tags: Optional[List[str]] = None,
        user_state: Optional['AgentUserState'] = None,
        **kwargs,
    ) -> DetailedResponse:
        """
        Update the agent registration.

        Update the agent registeration.
           <h3>Authorization</h3>
           Schematics support generic authorization for its resources.
           For more information, about Schematics access and permissions, see [Schematics
        service access
           roles and required
        permissions](https://cloud.ibm.com/docs/schematics?topic=schematics-access#access-roles).

        :param str agent_id: Agent ID to get the details of agent.
        :param str name: The name of the agent (must be unique, for an account).
        :param str agent_location: The location where agent is deployed in the user
               environment.
        :param str location: List of locations supported by IBM Cloud Schematics
               service.  While creating your workspace or action, choose the right region,
               since it cannot be changed.  Note, this does not limit the location of the
               IBM Cloud resources, provisioned using Schematics.
        :param str profile_id: The IAM trusted profile id, used by the Agent
               instance.
        :param str description: (optional) Agent description.
        :param str resource_group: (optional) The resource-group name for the
               agent.  By default, Agent will be registered in Default Resource Group.
        :param List[str] tags: (optional) Tags for the agent.
        :param AgentUserState user_state: (optional) User defined status of the
               agent.
        :param dict headers: A `dict` containing the request headers
        :return: A `DetailedResponse` containing the result, headers and HTTP status code.
        :rtype: DetailedResponse with `dict` result representing a `Agent` object

        Deprecated: this method is deprecated and may be removed in a future release.
        """

        logging.warning('A deprecated operation has been invoked: update_agent_registration')

        if not agent_id:
            raise ValueError('agent_id must be provided')
        if name is None:
            raise ValueError('name must be provided')
        if agent_location is None:
            raise ValueError('agent_location must be provided')
        if location is None:
            raise ValueError('location must be provided')
        if profile_id is None:
            raise ValueError('profile_id must be provided')
        if user_state is not None:
            user_state = convert_model(user_state)
        headers = {}
        sdk_headers = get_sdk_headers(
            service_name=self.DEFAULT_SERVICE_NAME,
            service_version='V1',
            operation_id='update_agent_registration',
        )
        headers.update(sdk_headers)

        data = {
            'name': name,
            'agent_location': agent_location,
            'location': location,
            'profile_id': profile_id,
            'description': description,
            'resource_group': resource_group,
            'tags': tags,
            'user_state': user_state,
        }
        data = {k: v for (k, v) in data.items() if v is not None}
        data = json.dumps(data)
        headers['content-type'] = 'application/json'

        if 'headers' in kwargs:
            headers.update(kwargs.get('headers'))
            del kwargs['headers']
        headers['Accept'] = 'application/json'

        path_param_keys = ['agent_id']
        path_param_values = self.encode_path_vars(agent_id)
        path_param_dict = dict(zip(path_param_keys, path_param_values))
        url = '/v2/settings/agents/{agent_id}'.format(**path_param_dict)
        request = self.prepare_request(
            method='PATCH',
            url=url,
            headers=headers,
            data=data,
        )

        response = self.send(request, **kwargs)
        return response

    def list_agent_data(
        self,
        *,
        offset: Optional[int] = None,
        limit: Optional[int] = None,
        profile: Optional[str] = None,
        filter: Optional[str] = None,
        **kwargs,
    ) -> DetailedResponse:
        """
        List agents.

        Retrieve a list of Schematics agents from your IBM Cloud account that you have
        access to. The list of agents that is returned depends on the API endpoint that
        you use. For example, if you use an API endpoint for a geography, such as North
        America, only agents that are created in `us-south or `us-east` are returned. For
        more information about frequently asked questions, see
        [FAQ](https://cloud.ibm.com/docs/schematics?topic=schematics-faqs-agent) and
        [Troubleshooting
        guide](https://cloud.ibm.com/docs/schematics?topic=schematics-agent-crn-not-found).
        For more information about supported API endpoints, see [API
        endpoint](https://cloud.ibm.com/apidocs/schematics/schematics#api-endpoints).
           <h3>Authorization</h3>
           Schematics support generic authorization for its resources.
           For more information, about Schematics access and permissions, see [Schematics
        service access
           roles and required
        permissions](https://cloud.ibm.com/docs/schematics?topic=schematics-access#access-roles).

        :param int offset: (optional) The starting position of the item in the list
               of items. For example, if you have three workspaces in your account, the
               first workspace is assigned position number 0, the second workspace is
               assigned position number 1, and so forth. If you have 6 workspaces and you
               want to list the details for workspaces `2-6`, enter 1. To limit the number
               of workspaces that is returned, use the `limit` option in addition to the
               `offset` option. Negative numbers are not supported and are ignored.
        :param int limit: (optional) The maximum number of items that you want to
               list. The number must be a positive integer between 1 and 2000. If no value
               is provided, 100 is used by default.
        :param str profile: (optional) Level of details returned by the get method.
        :param str filter: (optional) Use `new` to get all unregistered agents; use
               `saved` to get all registered agents.
        :param dict headers: A `dict` containing the request headers
        :return: A `DetailedResponse` containing the result, headers and HTTP status code.
        :rtype: DetailedResponse with `dict` result representing a `AgentDataList` object
        """

        headers = {}
        sdk_headers = get_sdk_headers(
            service_name=self.DEFAULT_SERVICE_NAME,
            service_version='V1',
            operation_id='list_agent_data',
        )
        headers.update(sdk_headers)

        params = {
            'offset': offset,
            'limit': limit,
            'profile': profile,
            'filter': filter,
        }

        if 'headers' in kwargs:
            headers.update(kwargs.get('headers'))
            del kwargs['headers']
        headers['Accept'] = 'application/json'

        url = '/v2/agents'
        request = self.prepare_request(
            method='GET',
            url=url,
            headers=headers,
            params=params,
        )

        response = self.send(request, **kwargs)
        return response

    def create_agent_data(
        self,
        name: str,
        resource_group: str,
        version: str,
        schematics_location: str,
        agent_location: str,
        agent_infrastructure: 'AgentInfrastructure',
        *,
        description: Optional[str] = None,
        tags: Optional[List[str]] = None,
        agent_metadata: Optional[List['AgentMetadataInfo']] = None,
        agent_inputs: Optional[List['VariableData']] = None,
        user_state: Optional['AgentUserState'] = None,
        agent_kpi: Optional['AgentKPIData'] = None,
        **kwargs,
    ) -> DetailedResponse:
        """
        Create an agent.

        Subsequently, create an agent definition to manage the agent deployment with the
        agent configuration that will be used to deploy your agent to its target location.
        **Getting API endpoint**:-
        * The Schematics API endpoint that you use to create the agent determines where
        your Schematics agent run and your data is stored. For more information about
        supported API endpoints, see [API
        endpoints](https://cloud.ibm.com/apidocs/schematics/schematics#api-endpoints). *
        If you use the API endpoint for a geography and not a specific location, such as
        North America, you can specify the location in your API request body. * If you do
        not specify the location in the request body, Schematics determines your agent
        location based on availability. * If you use an API endpoint for a specific
        location, such as Frankfurt, the location that you enter in your API request body
        must match your API endpoint. * You also have the option to not specify a location
        in your API request body if you use a location-specific API endpoint. * Follow the
        [steps](https://cloud.ibm.com/docs/schematics?topic=schematics-setup-api#cs_api)
        to retrieve your IAM access token and authenticate with IBM Cloud Schematics by
        using the API. * For more information about frequently asked questions, see
        [FAQ](https://cloud.ibm.com/docs/schematics?topic=schematics-faqs-agent) and
        [Troubleshooting
        guide](https://cloud.ibm.com/docs/schematics?topic=schematics-agent-crn-not-found).
           <h3>Authorization</h3>
           Schematics support generic authorization for its resources.
           For more information, about Schematics access and permissions, see [Schematics
        service access
           roles and required
        permissions](https://cloud.ibm.com/docs/schematics?topic=schematics-access#access-roles).

        :param str name: The name of the agent (must be unique, for an account).
        :param str resource_group: The resource-group name for the agent.  By
               default, agent will be registered in Default Resource Group.
        :param str version: Agent version.
        :param str schematics_location: List of locations supported by IBM Cloud
               Schematics service.  While creating your workspace or action, choose the
               right region, since it cannot be changed.  Note, this does not limit the
               location of the IBM Cloud resources, provisioned using Schematics.
        :param str agent_location: The location where agent is deployed in the user
               environment.
        :param AgentInfrastructure agent_infrastructure: The infrastructure
               parameters used by the agent.
        :param str description: (optional) Agent description.
        :param List[str] tags: (optional) Tags for the agent.
        :param List[AgentMetadataInfo] agent_metadata: (optional) The metadata of
               an agent.
        :param List[VariableData] agent_inputs: (optional) Additional input
               variables for the agent.
        :param AgentUserState user_state: (optional) User defined status of the
               agent.
        :param AgentKPIData agent_kpi: (optional) Schematics Agent key performance
               indicators.
        :param dict headers: A `dict` containing the request headers
        :return: A `DetailedResponse` containing the result, headers and HTTP status code.
        :rtype: DetailedResponse with `dict` result representing a `AgentData` object
        """

        if name is None:
            raise ValueError('name must be provided')
        if resource_group is None:
            raise ValueError('resource_group must be provided')
        if version is None:
            raise ValueError('version must be provided')
        if schematics_location is None:
            raise ValueError('schematics_location must be provided')
        if agent_location is None:
            raise ValueError('agent_location must be provided')
        if agent_infrastructure is None:
            raise ValueError('agent_infrastructure must be provided')
        agent_infrastructure = convert_model(agent_infrastructure)
        if agent_metadata is not None:
            agent_metadata = [convert_model(x) for x in agent_metadata]
        if agent_inputs is not None:
            agent_inputs = [convert_model(x) for x in agent_inputs]
        if user_state is not None:
            user_state = convert_model(user_state)
        if agent_kpi is not None:
            agent_kpi = convert_model(agent_kpi)
        headers = {}
        sdk_headers = get_sdk_headers(
            service_name=self.DEFAULT_SERVICE_NAME,
            service_version='V1',
            operation_id='create_agent_data',
        )
        headers.update(sdk_headers)

        data = {
            'name': name,
            'resource_group': resource_group,
            'version': version,
            'schematics_location': schematics_location,
            'agent_location': agent_location,
            'agent_infrastructure': agent_infrastructure,
            'description': description,
            'tags': tags,
            'agent_metadata': agent_metadata,
            'agent_inputs': agent_inputs,
            'user_state': user_state,
            'agent_kpi': agent_kpi,
        }
        data = {k: v for (k, v) in data.items() if v is not None}
        data = json.dumps(data)
        headers['content-type'] = 'application/json'

        if 'headers' in kwargs:
            headers.update(kwargs.get('headers'))
            del kwargs['headers']
        headers['Accept'] = 'application/json'

        url = '/v2/agents'
        request = self.prepare_request(
            method='POST',
            url=url,
            headers=headers,
            data=data,
        )

        response = self.send(request, **kwargs)
        return response

    def get_agent_data(
        self,
        agent_id: str,
        *,
        profile: Optional[str] = None,
        **kwargs,
    ) -> DetailedResponse:
        """
        Get agent details.

        Retrieve a detailed configuration of an agent with a specific agent ID. The agent
        that is returned depends on the API endpoint that you use. For example, if you use
        an API endpoint for a geography, such as North America, only agents that are
        created in `us-south or `us-east` are returned. For more information about
        frequently asked questions, see
        [FAQ](https://cloud.ibm.com/docs/schematics?topic=schematics-faqs-agent) and
        [Troubleshooting
        guide](https://cloud.ibm.com/docs/schematics?topic=schematics-agent-crn-not-found).
        For more information about supported API endpoints, see [API
        endpoint](https://cloud.ibm.com/apidocs/schematics/schematics#api-endpoints).
           <h3>Authorization</h3>
           Schematics support generic authorization for its resources.
           For more information, about Schematics access and permissions, see [Schematics
        service access
           roles and required
        permissions](https://cloud.ibm.com/docs/schematics?topic=schematics-access#access-roles).

        :param str agent_id: Agent ID to get the details of agent.
        :param str profile: (optional) Level of details returned by the get method.
        :param dict headers: A `dict` containing the request headers
        :return: A `DetailedResponse` containing the result, headers and HTTP status code.
        :rtype: DetailedResponse with `dict` result representing a `AgentData` object
        """

        if not agent_id:
            raise ValueError('agent_id must be provided')
        headers = {}
        sdk_headers = get_sdk_headers(
            service_name=self.DEFAULT_SERVICE_NAME,
            service_version='V1',
            operation_id='get_agent_data',
        )
        headers.update(sdk_headers)

        params = {
            'profile': profile,
        }

        if 'headers' in kwargs:
            headers.update(kwargs.get('headers'))
            del kwargs['headers']
        headers['Accept'] = 'application/json'

        path_param_keys = ['agent_id']
        path_param_values = self.encode_path_vars(agent_id)
        path_param_dict = dict(zip(path_param_keys, path_param_values))
        url = '/v2/agents/{agent_id}'.format(**path_param_dict)
        request = self.prepare_request(
            method='GET',
            url=url,
            headers=headers,
            params=params,
        )

        response = self.send(request, **kwargs)
        return response

    def update_agent_data(
        self,
        agent_id: str,
        name: str,
        resource_group: str,
        version: str,
        schematics_location: str,
        agent_location: str,
        agent_infrastructure: 'AgentInfrastructure',
        *,
        description: Optional[str] = None,
        tags: Optional[List[str]] = None,
        agent_metadata: Optional[List['AgentMetadataInfo']] = None,
        agent_inputs: Optional[List['VariableData']] = None,
        user_state: Optional['AgentUserState'] = None,
        agent_kpi: Optional['AgentKPIData'] = None,
        refresh_token: Optional[str] = None,
        **kwargs,
    ) -> DetailedResponse:
        """
        Update agent.

        Use update agent API to update or replace the entire agent. For more information
        about steps to apply `UPDATE` and `PUT` command, see [Deploying
        agent](https://cloud.ibm.com/docs/schematics?topic=schematics-deploy-agent-overview&interface=api).
        For more information about supported API endpoints, see [API
        endpoint](https://cloud.ibm.com/apidocs/schematics/schematics#api-endpoints).
           <h3>Authorization</h3>
           Schematics support generic authorization for its resources.
           For more information, about Schematics access and permissions, see [Schematics
        service access
           roles and required
        permissions](https://cloud.ibm.com/docs/schematics?topic=schematics-access#access-roles).

        :param str agent_id: Agent ID to get the details of agent.
        :param str name: The name of the agent (must be unique, for an account).
        :param str resource_group: The resource-group name for the agent.  By
               default, agent will be registered in Default Resource Group.
        :param str version: Agent version.
        :param str schematics_location: List of locations supported by IBM Cloud
               Schematics service.  While creating your workspace or action, choose the
               right region, since it cannot be changed.  Note, this does not limit the
               location of the IBM Cloud resources, provisioned using Schematics.
        :param str agent_location: The location where agent is deployed in the user
               environment.
        :param AgentInfrastructure agent_infrastructure: The infrastructure
               parameters used by the agent.
        :param str description: (optional) Agent description.
        :param List[str] tags: (optional) Tags for the agent.
        :param List[AgentMetadataInfo] agent_metadata: (optional) The metadata of
               an agent.
        :param List[VariableData] agent_inputs: (optional) Additional input
               variables for the agent.
        :param AgentUserState user_state: (optional) User defined status of the
               agent.
        :param AgentKPIData agent_kpi: (optional) Schematics Agent key performance
               indicators.
        :param str refresh_token: (optional) This IAM token is required only when
               trying to update an agent from one version to other.
                 **Retrieving refresh token**:
                 * Use `export IBMCLOUD_API_KEY=<ibmcloud_api_key>`, and execute `curl -X
               POST "https://iam.cloud.ibm.com/identity/token" -H "Content-Type:
               application/x-www-form-urlencoded" -d
               "grant_type=urn:ibm:params:oauth:grant-type:apikey&apikey=$IBMCLOUD_API_KEY"
               -u bx:bx`.
                 * For more information, about creating IAM access token and API Docs,
               refer, [IAM access
               token](/apidocs/iam-identity-token-api#gettoken-password) and [Create API
               key](/apidocs/iam-identity-token-api#create-api-key).
                 **Limitation**:
                 * If the token is expired, you can use `refresh token` to get a new IAM
               access token.
                 * The `refresh_token` parameter cannot be used to retrieve a new IAM
               access token.
                 * When the IAM access token is about to expire, use the API key to create
               a new access token.
        :param dict headers: A `dict` containing the request headers
        :return: A `DetailedResponse` containing the result, headers and HTTP status code.
        :rtype: DetailedResponse with `dict` result representing a `AgentData` object
        """

        if not agent_id:
            raise ValueError('agent_id must be provided')
        if name is None:
            raise ValueError('name must be provided')
        if resource_group is None:
            raise ValueError('resource_group must be provided')
        if version is None:
            raise ValueError('version must be provided')
        if schematics_location is None:
            raise ValueError('schematics_location must be provided')
        if agent_location is None:
            raise ValueError('agent_location must be provided')
        if agent_infrastructure is None:
            raise ValueError('agent_infrastructure must be provided')
        agent_infrastructure = convert_model(agent_infrastructure)
        if agent_metadata is not None:
            agent_metadata = [convert_model(x) for x in agent_metadata]
        if agent_inputs is not None:
            agent_inputs = [convert_model(x) for x in agent_inputs]
        if user_state is not None:
            user_state = convert_model(user_state)
        if agent_kpi is not None:
            agent_kpi = convert_model(agent_kpi)
        headers = {
            'refresh_token': refresh_token,
        }
        sdk_headers = get_sdk_headers(
            service_name=self.DEFAULT_SERVICE_NAME,
            service_version='V1',
            operation_id='update_agent_data',
        )
        headers.update(sdk_headers)

        data = {
            'name': name,
            'resource_group': resource_group,
            'version': version,
            'schematics_location': schematics_location,
            'agent_location': agent_location,
            'agent_infrastructure': agent_infrastructure,
            'description': description,
            'tags': tags,
            'agent_metadata': agent_metadata,
            'agent_inputs': agent_inputs,
            'user_state': user_state,
            'agent_kpi': agent_kpi,
        }
        data = {k: v for (k, v) in data.items() if v is not None}
        data = json.dumps(data)
        headers['content-type'] = 'application/json'

        if 'headers' in kwargs:
            headers.update(kwargs.get('headers'))
            del kwargs['headers']
        headers['Accept'] = 'application/json'

        path_param_keys = ['agent_id']
        path_param_values = self.encode_path_vars(agent_id)
        path_param_dict = dict(zip(path_param_keys, path_param_values))
        url = '/v2/agents/{agent_id}'.format(**path_param_dict)
        request = self.prepare_request(
            method='PUT',
            url=url,
            headers=headers,
            data=data,
        )

        response = self.send(request, **kwargs)
        return response

    def delete_agent_data(
        self,
        agent_id: str,
        *,
        force: Optional[bool] = None,
        **kwargs,
    ) -> DetailedResponse:
        """
        Delete agent.

        Use this API to disable and delete the agent. Follow the
        [steps](https://cloud.ibm.com/docs/schematics?topic=schematics-setup-api#cs_api)
        to retrieve your IAM access token and authenticate with IBM Cloud Schematics by
        using the API. For more information about frequently asked questions, see
        [FAQ](/docs/schematics?topic=schematics-faqs-agent) and [Troubleshooting
        guide](https://cloud.ibm.com/docs/schematics?topic=schematics-agent-crn-not-found).
           <h3>Authorization</h3>
           Schematics support generic authorization for its resources.
           For more information, about Schematics access and permissions, see [Schematics
        service access
           roles and required
        permissions](https://cloud.ibm.com/docs/schematics?topic=schematics-access#access-roles).

        :param str agent_id: Agent ID to get the details of agent.
        :param bool force: (optional) Equivalent to -force options in the command
               line, default is false.
        :param dict headers: A `dict` containing the request headers
        :return: A `DetailedResponse` containing the result, headers and HTTP status code.
        :rtype: DetailedResponse
        """

        if not agent_id:
            raise ValueError('agent_id must be provided')
        headers = {}
        sdk_headers = get_sdk_headers(
            service_name=self.DEFAULT_SERVICE_NAME,
            service_version='V1',
            operation_id='delete_agent_data',
        )
        headers.update(sdk_headers)

        params = {
            'force': force,
        }

        if 'headers' in kwargs:
            headers.update(kwargs.get('headers'))
            del kwargs['headers']

        path_param_keys = ['agent_id']
        path_param_values = self.encode_path_vars(agent_id)
        path_param_dict = dict(zip(path_param_keys, path_param_values))
        url = '/v2/agents/{agent_id}'.format(**path_param_dict)
        request = self.prepare_request(
            method='DELETE',
            url=url,
            headers=headers,
            params=params,
        )

        response = self.send(request, **kwargs)
        return response

    def get_agent_versions(
        self,
        **kwargs,
    ) -> DetailedResponse:
        """
        Get agent versions.

        Retrieve the list of agent version's available to be deployed. For more
        information about supported API endpoints, see [API
        endpoint](https://cloud.ibm.com/apidocs/schematics/schematics#api-endpoints).
           <h3>Authorization</h3>
           Schematics support generic authorization for its resources.
           For more information, about Schematics access and permissions, see [Schematics
        service access
           roles and required
        permissions](https://cloud.ibm.com/docs/schematics?topic=schematics-access#access-roles).

        :param dict headers: A `dict` containing the request headers
        :return: A `DetailedResponse` containing the result, headers and HTTP status code.
        :rtype: DetailedResponse with `dict` result representing a `AgentVersions` object
        """

        headers = {}
        sdk_headers = get_sdk_headers(
            service_name=self.DEFAULT_SERVICE_NAME,
            service_version='V1',
            operation_id='get_agent_versions',
        )
        headers.update(sdk_headers)

        if 'headers' in kwargs:
            headers.update(kwargs.get('headers'))
            del kwargs['headers']
        headers['Accept'] = 'application/json'

        url = '/v2/agents/versions'
        request = self.prepare_request(
            method='GET',
            url=url,
            headers=headers,
        )

        response = self.send(request, **kwargs)
        return response

    def get_prs_agent_job(
        self,
        agent_id: str,
        **kwargs,
    ) -> DetailedResponse:
        """
        Get pre-requisite scanner job status.

        Use get pre-requisite scanner job status API for deploying an agent by using the
        `agent_id`, `job_id`. The API results the status as **pending**, **in-progress**,
        **success**, or **failed** in a string format. For more information about
        supported API endpoints, see [API
        endpoint](https://cloud.ibm.com/apidocs/schematics/schematics#api-endpoints).
        <h3>Authorization</h3>
          Schematics support generic authorization for its resources. For more
        information, about Schematics access and permissions, see [Schematics service
        access
           roles and required
        permissions](https://cloud.ibm.com/docs/schematics?topic=schematics-access#access-roles).

        :param str agent_id: Agent ID to get the details of agent.
        :param dict headers: A `dict` containing the request headers
        :return: A `DetailedResponse` containing the result, headers and HTTP status code.
        :rtype: DetailedResponse with `dict` result representing a `AgentPRSJob` object
        """

        if not agent_id:
            raise ValueError('agent_id must be provided')
        headers = {}
        sdk_headers = get_sdk_headers(
            service_name=self.DEFAULT_SERVICE_NAME,
            service_version='V1',
            operation_id='get_prs_agent_job',
        )
        headers.update(sdk_headers)

        if 'headers' in kwargs:
            headers.update(kwargs.get('headers'))
            del kwargs['headers']
        headers['Accept'] = 'application/json'

        path_param_keys = ['agent_id']
        path_param_values = self.encode_path_vars(agent_id)
        path_param_dict = dict(zip(path_param_keys, path_param_values))
        url = '/v2/agents/{agent_id}/prs'.format(**path_param_dict)
        request = self.prepare_request(
            method='GET',
            url=url,
            headers=headers,
        )

        response = self.send(request, **kwargs)
        return response

    def prs_agent_job(
        self,
        agent_id: str,
        *,
        force: Optional[bool] = None,
        **kwargs,
    ) -> DetailedResponse:
        """
        Run pre-requisite scanner job.

        Use run pre-requisite scanner job API before deploying an agent. The API results
        the agent `prs` job updation time with the E-mail address and the status in a
        string format. For more information about supported API endpoints, see [API
        endpoint](/apidocs/schematics/schematics#api-endpoints).
        <h3>Authorization</h3> Schematics support generic authorization for its resources.
        For more information, about Schematics access and permissions, see [Schematics
        service access
           roles and required
        permissions](https://cloud.ibm.com/docs/schematics?topic=schematics-access#access-roles).

        :param str agent_id: Agent ID to get the details of agent.
        :param bool force: (optional) Equivalent to -force options in the command
               line, default is false.
        :param dict headers: A `dict` containing the request headers
        :return: A `DetailedResponse` containing the result, headers and HTTP status code.
        :rtype: DetailedResponse with `dict` result representing a `AgentPRSJob` object
        """

        if not agent_id:
            raise ValueError('agent_id must be provided')
        headers = {}
        sdk_headers = get_sdk_headers(
            service_name=self.DEFAULT_SERVICE_NAME,
            service_version='V1',
            operation_id='prs_agent_job',
        )
        headers.update(sdk_headers)

        params = {
            'force': force,
        }

        if 'headers' in kwargs:
            headers.update(kwargs.get('headers'))
            del kwargs['headers']
        headers['Accept'] = 'application/json'

        path_param_keys = ['agent_id']
        path_param_values = self.encode_path_vars(agent_id)
        path_param_dict = dict(zip(path_param_keys, path_param_values))
        url = '/v2/agents/{agent_id}/prs'.format(**path_param_dict)
        request = self.prepare_request(
            method='PUT',
            url=url,
            headers=headers,
            params=params,
        )

        response = self.send(request, **kwargs)
        return response

    def get_health_check_agent_job(
        self,
        agent_id: str,
        **kwargs,
    ) -> DetailedResponse:
        """
        Get agent health check job.

        Use get agent health check job API to retrieve the agent health check job status
        based on the agent ID. For more information about supported API endpoints, see
        [API endpoint](/apidocs/schematics/schematics#api-endpoints).
        <h3>Authorization</h3>
         Schematics support generic authorization for its resources. For more information,
        about Schematics access and permissions, see [Schematics service access
           roles and required
        permissions](https://cloud.ibm.com/docs/schematics?topic=schematics-access#access-roles).

        :param str agent_id: Agent ID to get the details of agent.
        :param dict headers: A `dict` containing the request headers
        :return: A `DetailedResponse` containing the result, headers and HTTP status code.
        :rtype: DetailedResponse with `dict` result representing a `AgentHealthJob` object
        """

        if not agent_id:
            raise ValueError('agent_id must be provided')
        headers = {}
        sdk_headers = get_sdk_headers(
            service_name=self.DEFAULT_SERVICE_NAME,
            service_version='V1',
            operation_id='get_health_check_agent_job',
        )
        headers.update(sdk_headers)

        if 'headers' in kwargs:
            headers.update(kwargs.get('headers'))
            del kwargs['headers']
        headers['Accept'] = 'application/json'

        path_param_keys = ['agent_id']
        path_param_values = self.encode_path_vars(agent_id)
        path_param_dict = dict(zip(path_param_keys, path_param_values))
        url = '/v2/agents/{agent_id}/health'.format(**path_param_dict)
        request = self.prepare_request(
            method='GET',
            url=url,
            headers=headers,
        )

        response = self.send(request, **kwargs)
        return response

    def health_check_agent_job(
        self,
        agent_id: str,
        *,
        force: Optional[bool] = None,
        **kwargs,
    ) -> DetailedResponse:
        """
        Run agent health check.

        Use run agent health check job API to execute an agent health check job based on
        the agent ID. For more information about supported API endpoints, see [API
        endpoint](https://cloud.ibm.com/apidocs/schematics/schematics#api-endpoints).
        <h3>Authorization</h3> Schematics support generic authorization for its resources.
        For more information, about Schematics access and permissions, see [Schematics
        service access
           roles and required
        permissions](https://cloud.ibm.com/docs/schematics?topic=schematics-access#access-roles).

        :param str agent_id: Agent ID to get the details of agent.
        :param bool force: (optional) Equivalent to -force options in the command
               line, default is false.
        :param dict headers: A `dict` containing the request headers
        :return: A `DetailedResponse` containing the result, headers and HTTP status code.
        :rtype: DetailedResponse with `dict` result representing a `AgentHealthJob` object
        """

        if not agent_id:
            raise ValueError('agent_id must be provided')
        headers = {}
        sdk_headers = get_sdk_headers(
            service_name=self.DEFAULT_SERVICE_NAME,
            service_version='V1',
            operation_id='health_check_agent_job',
        )
        headers.update(sdk_headers)

        params = {
            'force': force,
        }

        if 'headers' in kwargs:
            headers.update(kwargs.get('headers'))
            del kwargs['headers']
        headers['Accept'] = 'application/json'

        path_param_keys = ['agent_id']
        path_param_values = self.encode_path_vars(agent_id)
        path_param_dict = dict(zip(path_param_keys, path_param_values))
        url = '/v2/agents/{agent_id}/health'.format(**path_param_dict)
        request = self.prepare_request(
            method='PUT',
            url=url,
            headers=headers,
            params=params,
        )

        response = self.send(request, **kwargs)
        return response

    def get_deploy_agent_job(
        self,
        agent_id: str,
        **kwargs,
    ) -> DetailedResponse:
        """
        Get agent deployment job.

        Use get agent deployment job API to retrieve the agent deployment job status based
        on the agent ID. For more information about supported API endpoints, see [API
        endpoint](https://cloud.ibm.com/apidocs/schematics/schematics#api-endpoints).
        <h3>Authorization</h3> Schematics support generic authorization for its resources.
        For more information, about Schematics access and permissions, see [Schematics
        service access
           roles and required
        permissions](https://cloud.ibm.com/docs/schematics?topic=schematics-access#access-roles).

        :param str agent_id: Agent ID to get the details of agent.
        :param dict headers: A `dict` containing the request headers
        :return: A `DetailedResponse` containing the result, headers and HTTP status code.
        :rtype: DetailedResponse with `dict` result representing a `AgentDeployJob` object
        """

        if not agent_id:
            raise ValueError('agent_id must be provided')
        headers = {}
        sdk_headers = get_sdk_headers(
            service_name=self.DEFAULT_SERVICE_NAME,
            service_version='V1',
            operation_id='get_deploy_agent_job',
        )
        headers.update(sdk_headers)

        if 'headers' in kwargs:
            headers.update(kwargs.get('headers'))
            del kwargs['headers']
        headers['Accept'] = 'application/json'

        path_param_keys = ['agent_id']
        path_param_values = self.encode_path_vars(agent_id)
        path_param_dict = dict(zip(path_param_keys, path_param_values))
        url = '/v2/agents/{agent_id}/deploy'.format(**path_param_dict)
        request = self.prepare_request(
            method='GET',
            url=url,
            headers=headers,
        )

        response = self.send(request, **kwargs)
        return response

    def deploy_agent_job(
        self,
        agent_id: str,
        *,
        force: Optional[bool] = None,
        **kwargs,
    ) -> DetailedResponse:
        """
        Run the agent deployment job.

        Use run agent deployment job API to execute the agent deployment job based on the
        agent ID. For more information about supported API endpoints, see [API
        endpoint](https://cloud.ibm.com/apidocs/schematics/schematics#api-endpoints).
        <h3>Authorization</h3> Schematics support generic authorization for its resources.
        For more information, about Schematics access and permissions, see [Schematics
        service access
           roles and required
        permissions](https://cloud.ibm.com/docs/schematics?topic=schematics-access#access-roles).

        :param str agent_id: Agent ID to get the details of agent.
        :param bool force: (optional) Equivalent to -force options in the command
               line, default is false.
        :param dict headers: A `dict` containing the request headers
        :return: A `DetailedResponse` containing the result, headers and HTTP status code.
        :rtype: DetailedResponse with `dict` result representing a `AgentDeployJob` object
        """

        if not agent_id:
            raise ValueError('agent_id must be provided')
        headers = {}
        sdk_headers = get_sdk_headers(
            service_name=self.DEFAULT_SERVICE_NAME,
            service_version='V1',
            operation_id='deploy_agent_job',
        )
        headers.update(sdk_headers)

        params = {
            'force': force,
        }

        if 'headers' in kwargs:
            headers.update(kwargs.get('headers'))
            del kwargs['headers']
        headers['Accept'] = 'application/json'

        path_param_keys = ['agent_id']
        path_param_values = self.encode_path_vars(agent_id)
        path_param_dict = dict(zip(path_param_keys, path_param_values))
        url = '/v2/agents/{agent_id}/deploy'.format(**path_param_dict)
        request = self.prepare_request(
            method='PUT',
            url=url,
            headers=headers,
            params=params,
        )

        response = self.send(request, **kwargs)
        return response

    def delete_agent_resources(
        self,
        agent_id: str,
        refresh_token: str,
        **kwargs,
    ) -> DetailedResponse:
        """
        Delete resources provisioned by agent.

        Use this API to destroy the resources provisioned for running an agent.

        :param str agent_id: Agent ID to get the details of agent.
        :param str refresh_token: The IAM refresh token for the user or service
               identity.
                 **Retrieving refresh token**:
                 * Use `export IBMCLOUD_API_KEY=<ibmcloud_api_key>`, and execute `curl -X
               POST "https://iam.cloud.ibm.com/identity/token" -H "Content-Type:
               application/x-www-form-urlencoded" -d
               "grant_type=urn:ibm:params:oauth:grant-type:apikey&apikey=$IBMCLOUD_API_KEY"
               -u bx:bx`.
                 * For more information, about creating IAM access token and API Docs,
               refer, [IAM access
               token](/apidocs/iam-identity-token-api#gettoken-password) and [Create API
               key](/apidocs/iam-identity-token-api#create-api-key).
                 **Limitation**:
                 * If the token is expired, you can use `refresh token` to get a new IAM
               access token.
                 * The `refresh_token` parameter cannot be used to retrieve a new IAM
               access token.
                 * When the IAM access token is about to expire, use the API key to create
               a new access token.
        :param dict headers: A `dict` containing the request headers
        :return: A `DetailedResponse` containing the result, headers and HTTP status code.
        :rtype: DetailedResponse
        """

        if not agent_id:
            raise ValueError('agent_id must be provided')
        if not refresh_token:
            raise ValueError('refresh_token must be provided')
        headers = {
            'refresh_token': refresh_token,
        }
        sdk_headers = get_sdk_headers(
            service_name=self.DEFAULT_SERVICE_NAME,
            service_version='V1',
            operation_id='delete_agent_resources',
        )
        headers.update(sdk_headers)

        if 'headers' in kwargs:
            headers.update(kwargs.get('headers'))
            del kwargs['headers']

        path_param_keys = ['agent_id']
        path_param_values = self.encode_path_vars(agent_id)
        path_param_dict = dict(zip(path_param_keys, path_param_values))
        url = '/v2/agents/{agent_id}/resources'.format(**path_param_dict)
        request = self.prepare_request(
            method='DELETE',
            url=url,
            headers=headers,
        )

        response = self.send(request, **kwargs)
        return response

    #########################
    # settings-kms
    #########################

    def get_kms_settings(
        self,
        location: str,
        **kwargs,
    ) -> DetailedResponse:
        """
        Get a KMS settings.

        Retrieve the kms instance that is integrated with Schematics for the **byok** and
        **kyok**. For each geographic location supported in Schematics we can have
        different kms settings. For example `US` and `EU` will have different kms
        settings.
        <h3>Authorization</h3>
         Schematics support generic authorization for its resources.
         For more information, about Schematics access and permissions, see
         [Schematics service access roles and required
        permissions](https://cloud.ibm.com/docs/schematics?topic=schematics-access#access-roles).

        :param str location: The location of the Resource.
        :param dict headers: A `dict` containing the request headers
        :return: A `DetailedResponse` containing the result, headers and HTTP status code.
        :rtype: DetailedResponse with `dict` result representing a `KMSSettings` object
        """

        if not location:
            raise ValueError('location must be provided')
        headers = {}
        sdk_headers = get_sdk_headers(
            service_name=self.DEFAULT_SERVICE_NAME,
            service_version='V1',
            operation_id='get_kms_settings',
        )
        headers.update(sdk_headers)

        params = {
            'location': location,
        }

        if 'headers' in kwargs:
            headers.update(kwargs.get('headers'))
            del kwargs['headers']
        headers['Accept'] = 'application/json'

        url = '/v2/settings/kms'
        request = self.prepare_request(
            method='GET',
            url=url,
            headers=headers,
            params=params,
        )

        response = self.send(request, **kwargs)
        return response

    def update_kms_settings(
        self,
        *,
        location: Optional[str] = None,
        encryption_scheme: Optional[str] = None,
        resource_group: Optional[str] = None,
        primary_crk: Optional['KMSSettingsPrimaryCrk'] = None,
        secondary_crk: Optional['KMSSettingsSecondaryCrk'] = None,
        **kwargs,
    ) -> DetailedResponse:
        """
        Update a KMS settings.

        Replace or Update kms settings for a given location can be updated.
        **Note** you can update the kms settings only once. For example, if you use an API
        endpoint for a geography, such as North America, only kms settings for that region
        can be retrieved.
        <h3>Authorization</h3>
         Schematics support generic authorization for its resources.
         For more information, about Schematics access and permissions, see
         [Schematics service access roles and required
        permissions](https://cloud.ibm.com/docs/schematics?topic=schematics-access#access-roles).

        :param str location: (optional) The location to integrate kms instance. For
               example, location can be `US` and `EU`.
        :param str encryption_scheme: (optional) The encryption scheme values.
               **Allowable values** [`byok`,`kyok`].
        :param str resource_group: (optional) The kms instance resource group to
               integrate.
        :param KMSSettingsPrimaryCrk primary_crk: (optional) The primary kms
               instance details.
        :param KMSSettingsSecondaryCrk secondary_crk: (optional) The secondary kms
               instance details.
        :param dict headers: A `dict` containing the request headers
        :return: A `DetailedResponse` containing the result, headers and HTTP status code.
        :rtype: DetailedResponse with `dict` result representing a `KMSSettings` object
        """

        if primary_crk is not None:
            primary_crk = convert_model(primary_crk)
        if secondary_crk is not None:
            secondary_crk = convert_model(secondary_crk)
        headers = {}
        sdk_headers = get_sdk_headers(
            service_name=self.DEFAULT_SERVICE_NAME,
            service_version='V1',
            operation_id='update_kms_settings',
        )
        headers.update(sdk_headers)

        data = {
            'location': location,
            'encryption_scheme': encryption_scheme,
            'resource_group': resource_group,
            'primary_crk': primary_crk,
            'secondary_crk': secondary_crk,
        }
        data = {k: v for (k, v) in data.items() if v is not None}
        data = json.dumps(data)
        headers['content-type'] = 'application/json'

        if 'headers' in kwargs:
            headers.update(kwargs.get('headers'))
            del kwargs['headers']
        headers['Accept'] = 'application/json'

        url = '/v2/settings/kms'
        request = self.prepare_request(
            method='PUT',
            url=url,
            headers=headers,
            data=data,
        )

        response = self.send(request, **kwargs)
        return response

    def list_kms(
        self,
        encryption_scheme: str,
        location: str,
        *,
        resource_group: Optional[str] = None,
        limit: Optional[int] = None,
        sort: Optional[str] = None,
        **kwargs,
    ) -> DetailedResponse:
        """
        List KMS instances.

        Lists the kms instances of your IBM Cloud account to find your Key Protect or
        Hyper Protect Crypto Services by using the location and encrypted scheme.
         <h3>Authorization</h3>
         Schematics support generic authorization for its resources.
         For more information, about Schematics access and permissions, see
         [Schematics service access roles and required
        permissions](https://cloud.ibm.com/docs/schematics?topic=schematics-access#access-roles).

        :param str encryption_scheme: The encryption scheme to be used.
        :param str location: The location of the Resource.
        :param str resource_group: (optional) The resource group (by default, fetch
               from all resource groups) name or ID.
        :param int limit: (optional) The maximum number of items that you want to
               list. The number must be a positive integer between 1 and 2000. If no value
               is provided, 100 is used by default.
        :param str sort: (optional) Name of the field to sort-by;  Use the '.'
               character to delineate sub-resources and sub-fields (eg. owner.last_name).
               Prepend the field with '+' or '-', indicating 'ascending' or 'descending'
               (default is ascending)   Ignore unrecognized or unsupported sort field.
        :param dict headers: A `dict` containing the request headers
        :return: A `DetailedResponse` containing the result, headers and HTTP status code.
        :rtype: DetailedResponse with `dict` result representing a `KMSDiscovery` object
        """

        if not encryption_scheme:
            raise ValueError('encryption_scheme must be provided')
        if not location:
            raise ValueError('location must be provided')
        headers = {}
        sdk_headers = get_sdk_headers(
            service_name=self.DEFAULT_SERVICE_NAME,
            service_version='V1',
            operation_id='list_kms',
        )
        headers.update(sdk_headers)

        params = {
            'encryption_scheme': encryption_scheme,
            'location': location,
            'resource_group': resource_group,
            'limit': limit,
            'sort': sort,
        }

        if 'headers' in kwargs:
            headers.update(kwargs.get('headers'))
            del kwargs['headers']
        headers['Accept'] = 'application/json'

        url = '/v2/settings/kms_instances'
        request = self.prepare_request(
            method='GET',
            url=url,
            headers=headers,
            params=params,
        )

        response = self.send(request, **kwargs)
        return response

    #########################
    # policy
    #########################

    def list_policy(
        self,
        *,
        offset: Optional[int] = None,
        limit: Optional[int] = None,
        profile: Optional[str] = None,
        **kwargs,
    ) -> DetailedResponse:
        """
        List policies.

        Retrieve a list of all policies from the account that you have access. the list of
        policies that is returned depends on the API endpoint that you use. For example,
        if you use an API endpoint for a geography, such as North America, only policies
        that are created in `us-south` or `us-east` are returned. For more information
        about supported API endpoints, see [API
        endpoint](https://cloud.ibm.com/apidocs/schematics/schematics#api-endpoints).
           <h3>Authorization</h3>
           Schematics support generic authorization for its resources.
           For more information, about Schematics access and permissions, see [Schematics
        service access
           roles and required
        permissions](https://cloud.ibm.com/docs/schematics?topic=schematics-access#access-roles).

        :param int offset: (optional) The starting position of the item in the list
               of items. For example, if you have three workspaces in your account, the
               first workspace is assigned position number 0, the second workspace is
               assigned position number 1, and so forth. If you have 6 workspaces and you
               want to list the details for workspaces `2-6`, enter 1. To limit the number
               of workspaces that is returned, use the `limit` option in addition to the
               `offset` option. Negative numbers are not supported and are ignored.
        :param int limit: (optional) The maximum number of items that you want to
               list. The number must be a positive integer between 1 and 2000. If no value
               is provided, 100 is used by default.
        :param str profile: (optional) Level of details returned by the get method.
        :param dict headers: A `dict` containing the request headers
        :return: A `DetailedResponse` containing the result, headers and HTTP status code.
        :rtype: DetailedResponse with `dict` result representing a `PolicyList` object
        """

        headers = {}
        sdk_headers = get_sdk_headers(
            service_name=self.DEFAULT_SERVICE_NAME,
            service_version='V1',
            operation_id='list_policy',
        )
        headers.update(sdk_headers)

        params = {
            'offset': offset,
            'limit': limit,
            'profile': profile,
        }

        if 'headers' in kwargs:
            headers.update(kwargs.get('headers'))
            del kwargs['headers']
        headers['Accept'] = 'application/json'

        url = '/v2/settings/policies'
        request = self.prepare_request(
            method='GET',
            url=url,
            headers=headers,
            params=params,
        )

        response = self.send(request, **kwargs)
        return response

    def create_policy(
        self,
        *,
        name: Optional[str] = None,
        description: Optional[str] = None,
        resource_group: Optional[str] = None,
        tags: Optional[List[str]] = None,
        location: Optional[str] = None,
        state: Optional['UserState'] = None,
        kind: Optional[str] = None,
        target: Optional['PolicyObjects'] = None,
        parameter: Optional['PolicyParameter'] = None,
        scoped_resources: Optional[List['ScopedResource']] = None,
        **kwargs,
    ) -> DetailedResponse:
        """
        Create a policy account.

        Use this API to create a policy using Schematics to select one or more Schematics
        objects (such as, Workspaces, Action) to deliver targeted Schematics feature. For
        more information about frequently asked questions, see
        [FAQ](https://cloud.ibm.com/docs/schematics?topic=schematics-faqs-agent) and
        [Troubleshooting
        guide](https://cloud.ibm.com/docs/schematics?topic=schematics-agent-crn-not-found).
           <h3>Authorization</h3>
           Schematics support generic authorization for its resources.
           For more information, about Schematics access and permissions, see [Schematics
        service access
           roles and required
        permissions](https://cloud.ibm.com/docs/schematics?topic=schematics-access#access-roles).

        :param str name: (optional) Name of Schematics customization policy.
        :param str description: (optional) The description of Schematics
               customization policy.
        :param str resource_group: (optional) The resource group name for the
               policy.  By default, Policy will be created in `default` Resource Group.
        :param List[str] tags: (optional) Tags for the Schematics customization
               policy.
        :param str location: (optional) List of locations supported by IBM Cloud
               Schematics service.  While creating your workspace or action, choose the
               right region, since it cannot be changed.  Note, this does not limit the
               location of the IBM Cloud resources, provisioned using Schematics.
        :param UserState state: (optional) User defined status of the Schematics
               object.
        :param str kind: (optional) Policy kind or categories for managing and
               deriving policy decision
                 * `agent_assignment_policy` Agent assignment policy for job execution.
        :param PolicyObjects target: (optional) The objects for the Schematics
               policy.
        :param PolicyParameter parameter: (optional) The parameter to tune the
               Schematics policy.
        :param List[ScopedResource] scoped_resources: (optional) List of scoped
               Schematics resources targeted by the policy.
        :param dict headers: A `dict` containing the request headers
        :return: A `DetailedResponse` containing the result, headers and HTTP status code.
        :rtype: DetailedResponse with `dict` result representing a `Policy` object
        """

        if state is not None:
            state = convert_model(state)
        if target is not None:
            target = convert_model(target)
        if parameter is not None:
            parameter = convert_model(parameter)
        if scoped_resources is not None:
            scoped_resources = [convert_model(x) for x in scoped_resources]
        headers = {}
        sdk_headers = get_sdk_headers(
            service_name=self.DEFAULT_SERVICE_NAME,
            service_version='V1',
            operation_id='create_policy',
        )
        headers.update(sdk_headers)

        data = {
            'name': name,
            'description': description,
            'resource_group': resource_group,
            'tags': tags,
            'location': location,
            'state': state,
            'kind': kind,
            'target': target,
            'parameter': parameter,
            'scoped_resources': scoped_resources,
        }
        data = {k: v for (k, v) in data.items() if v is not None}
        data = json.dumps(data)
        headers['content-type'] = 'application/json'

        if 'headers' in kwargs:
            headers.update(kwargs.get('headers'))
            del kwargs['headers']
        headers['Accept'] = 'application/json'

        url = '/v2/settings/policies'
        request = self.prepare_request(
            method='POST',
            url=url,
            headers=headers,
            data=data,
        )

        response = self.send(request, **kwargs)
        return response

    def get_policy(
        self,
        policy_id: str,
        *,
        profile: Optional[str] = None,
        **kwargs,
    ) -> DetailedResponse:
        """
        Get policy.

        Retrieve the detailed information of a policy details identified by `policy_id`.
        For more information about frequently asked questions, see
        [FAQ](https://cloud.ibm.com/docs/schematics?topic=schematics-faqs-agent) and
        [Troubleshooting
        guide](https://cloud.ibm.com/docs/schematics?topic=schematics-agent-crn-not-found).
        For more information about supported API endpoints, see [API
        endpoint](https://cloud.ibm.com/apidocs/schematics/schematics#api-endpoints).
           <h3>Authorization</h3>
           Schematics support generic authorization for its resources.
           For more information, about Schematics access and permissions, see [Schematics
        service access
           roles and required
        permissions](https://cloud.ibm.com/docs/schematics?topic=schematics-access#access-roles).

        :param str policy_id: ID to get the details of policy.
        :param str profile: (optional) Level of details returned by the get method.
        :param dict headers: A `dict` containing the request headers
        :return: A `DetailedResponse` containing the result, headers and HTTP status code.
        :rtype: DetailedResponse with `dict` result representing a `Policy` object
        """

        if not policy_id:
            raise ValueError('policy_id must be provided')
        headers = {}
        sdk_headers = get_sdk_headers(
            service_name=self.DEFAULT_SERVICE_NAME,
            service_version='V1',
            operation_id='get_policy',
        )
        headers.update(sdk_headers)

        params = {
            'profile': profile,
        }

        if 'headers' in kwargs:
            headers.update(kwargs.get('headers'))
            del kwargs['headers']
        headers['Accept'] = 'application/json'

        path_param_keys = ['policy_id']
        path_param_values = self.encode_path_vars(policy_id)
        path_param_dict = dict(zip(path_param_keys, path_param_values))
        url = '/v2/settings/policies/{policy_id}'.format(**path_param_dict)
        request = self.prepare_request(
            method='GET',
            url=url,
            headers=headers,
            params=params,
        )

        response = self.send(request, **kwargs)
        return response

    def delete_policy(
        self,
        policy_id: str,
        **kwargs,
    ) -> DetailedResponse:
        """
        Delete policy.

        Use this API to delete the policy. Follow the
        [steps](https://cloud.ibm.com/docs/schematics?topic=schematics-setup-api#cs_api)
        to retrieve your IAM access token and authenticate with IBM Cloud Schematics by
        using the API. For more information about frequently asked questions, see
        [FAQ](https://cloud.ibm.com/docs/schematics?topic=schematics-faqs-agent) and
        [Troubleshooting
        guide](https://cloud.ibm.com/docs/schematics?topic=schematics-agent-crn-not-found).
           <h3>Authorization</h3>
           Schematics support generic authorization for its resources.
           For more information, about Schematics access and permissions, see [Schematics
        service access
           roles and required
        permissions](https://cloud.ibm.com/docs/schematics?topic=schematics-access#access-roles).

        :param str policy_id: ID to get the details of policy.
        :param dict headers: A `dict` containing the request headers
        :return: A `DetailedResponse` containing the result, headers and HTTP status code.
        :rtype: DetailedResponse
        """

        if not policy_id:
            raise ValueError('policy_id must be provided')
        headers = {}
        sdk_headers = get_sdk_headers(
            service_name=self.DEFAULT_SERVICE_NAME,
            service_version='V1',
            operation_id='delete_policy',
        )
        headers.update(sdk_headers)

        if 'headers' in kwargs:
            headers.update(kwargs.get('headers'))
            del kwargs['headers']

        path_param_keys = ['policy_id']
        path_param_values = self.encode_path_vars(policy_id)
        path_param_dict = dict(zip(path_param_keys, path_param_values))
        url = '/v2/settings/policies/{policy_id}'.format(**path_param_dict)
        request = self.prepare_request(
            method='DELETE',
            url=url,
            headers=headers,
        )

        response = self.send(request, **kwargs)
        return response

    def update_policy(
        self,
        policy_id: str,
        *,
        name: Optional[str] = None,
        description: Optional[str] = None,
        resource_group: Optional[str] = None,
        tags: Optional[List[str]] = None,
        location: Optional[str] = None,
        state: Optional['UserState'] = None,
        kind: Optional[str] = None,
        target: Optional['PolicyObjects'] = None,
        parameter: Optional['PolicyParameter'] = None,
        scoped_resources: Optional[List['ScopedResource']] = None,
        **kwargs,
    ) -> DetailedResponse:
        """
        Update policy.

        Use update policy API to update or replace the policy details by using policy ID.
        For more information about supported API endpoints, see [API
        endpoint](https://cloud.ibm.com/apidocs/schematics/schematics#api-endpoints).
        Follow the
        [steps](https://cloud.ibm.com/docs/schematics?topic=schematics-setup-api#cs_api)
        to retrieve your IAM access token and authenticate with IBM Cloud Schematics by
        using the API. For more information about frequently asked questions, see
        [FAQ](https://cloud.ibm.com/docs/schematics?topic=schematics-faqs-agent) and
        [Troubleshooting
        guide](https://cloud.ibm.com/docs/schematics?topic=schematics-agent-crn-not-found).
           <h3>Authorization</h3>
           Schematics support generic authorization for its resources.
           For more information, about Schematics access and permissions, see [Schematics
        service access
           roles and required
        permissions](https://cloud.ibm.com/docs/schematics?topic=schematics-access#access-roles).

        :param str policy_id: ID to get the details of policy.
        :param str name: (optional) Name of Schematics customization policy.
        :param str description: (optional) The description of Schematics
               customization policy.
        :param str resource_group: (optional) The resource group name for the
               policy.  By default, Policy will be created in `default` Resource Group.
        :param List[str] tags: (optional) Tags for the Schematics customization
               policy.
        :param str location: (optional) List of locations supported by IBM Cloud
               Schematics service.  While creating your workspace or action, choose the
               right region, since it cannot be changed.  Note, this does not limit the
               location of the IBM Cloud resources, provisioned using Schematics.
        :param UserState state: (optional) User defined status of the Schematics
               object.
        :param str kind: (optional) Policy kind or categories for managing and
               deriving policy decision
                 * `agent_assignment_policy` Agent assignment policy for job execution.
        :param PolicyObjects target: (optional) The objects for the Schematics
               policy.
        :param PolicyParameter parameter: (optional) The parameter to tune the
               Schematics policy.
        :param List[ScopedResource] scoped_resources: (optional) List of scoped
               Schematics resources targeted by the policy.
        :param dict headers: A `dict` containing the request headers
        :return: A `DetailedResponse` containing the result, headers and HTTP status code.
        :rtype: DetailedResponse with `dict` result representing a `Policy` object
        """

        if not policy_id:
            raise ValueError('policy_id must be provided')
        if state is not None:
            state = convert_model(state)
        if target is not None:
            target = convert_model(target)
        if parameter is not None:
            parameter = convert_model(parameter)
        if scoped_resources is not None:
            scoped_resources = [convert_model(x) for x in scoped_resources]
        headers = {}
        sdk_headers = get_sdk_headers(
            service_name=self.DEFAULT_SERVICE_NAME,
            service_version='V1',
            operation_id='update_policy',
        )
        headers.update(sdk_headers)

        data = {
            'name': name,
            'description': description,
            'resource_group': resource_group,
            'tags': tags,
            'location': location,
            'state': state,
            'kind': kind,
            'target': target,
            'parameter': parameter,
            'scoped_resources': scoped_resources,
        }
        data = {k: v for (k, v) in data.items() if v is not None}
        data = json.dumps(data)
        headers['content-type'] = 'application/json'

        if 'headers' in kwargs:
            headers.update(kwargs.get('headers'))
            del kwargs['headers']
        headers['Accept'] = 'application/json'

        path_param_keys = ['policy_id']
        path_param_values = self.encode_path_vars(policy_id)
        path_param_dict = dict(zip(path_param_keys, path_param_values))
        url = '/v2/settings/policies/{policy_id}'.format(**path_param_dict)
        request = self.prepare_request(
            method='PATCH',
            url=url,
            headers=headers,
            data=data,
        )

        response = self.send(request, **kwargs)
        return response


class ListWorkspacesEnums:
    """
    Enums for list_workspaces parameters.
    """

    class Profile(str, Enum):
        """
        Level of details returned by the get method.
        """

        IDS = 'ids'
        SUMMARY = 'summary'


class GetWorkspaceReadmeEnums:
    """
    Enums for get_workspace_readme parameters.
    """

    class Formatted(str, Enum):
        """
        The format of the readme file.  Value ''markdown'' will give markdown, otherwise
        html.
        """

        MARKDOWN = 'markdown'
        HTML = 'html'


class ListActionsEnums:
    """
    Enums for list_actions parameters.
    """

    class Profile(str, Enum):
        """
        Level of details returned by the get method.
        """

        IDS = 'ids'
        SUMMARY = 'summary'


class GetActionEnums:
    """
    Enums for get_action parameters.
    """

    class Profile(str, Enum):
        """
        Level of details returned by the get method.
        """

        SUMMARY = 'summary'
        DETAILED = 'detailed'
        IDS = 'ids'


class ListJobsEnums:
    """
    Enums for list_jobs parameters.
    """

    class Profile(str, Enum):
        """
        Level of details returned by the get method.
        """

        IDS = 'ids'
        SUMMARY = 'summary'

    class Resource(str, Enum):
        """
        Name of the resource (workspaces, actions, environment or controls).
        """

        WORKSPACES = 'workspaces'
        ACTION = 'action'
        ACTIONS = 'actions'
        ENVIRONMENT = 'environment'

    class List(str, Enum):
        """
        list jobs.
        """

        ALL = 'all'


class GetJobEnums:
    """
    Enums for get_job parameters.
    """

    class Profile(str, Enum):
        """
        Level of details returned by the get method.
        """

        SUMMARY = 'summary'
        DETAILED = 'detailed'
        IDS = 'ids'


class GetJobFilesEnums:
    """
    Enums for get_job_files parameters.
    """

    class FileType(str, Enum):
        """
        The type of file you want to download eg.state_file, plan_json.
        """

        TEMPLATE_REPO = 'template_repo'
        README_FILE = 'readme_file'
        LOG_FILE = 'log_file'
        STATE_FILE = 'state_file'
        PLAN_JSON = 'plan_json'


class ListInventoriesEnums:
    """
    Enums for list_inventories parameters.
    """

    class Profile(str, Enum):
        """
        Level of details returned by the get method.
        """

        IDS = 'ids'
        SUMMARY = 'summary'


class GetInventoryEnums:
    """
    Enums for get_inventory parameters.
    """

    class Profile(str, Enum):
        """
        Level of details returned by the get method.
        """

        SUMMARY = 'summary'
        DETAILED = 'detailed'
        IDS = 'ids'


class ListResourceQueryEnums:
    """
    Enums for list_resource_query parameters.
    """

    class Profile(str, Enum):
        """
        Level of details returned by the get method.
        """

        IDS = 'ids'
        SUMMARY = 'summary'


class ListAgentEnums:
    """
    Enums for list_agent parameters.
    """

    class Profile(str, Enum):
        """
        Level of details returned by the get method.
        """

        SUMMARY = 'summary'
        DETAILED = 'detailed'
        IDS = 'ids'

    class Filter(str, Enum):
        """
        Use `new` to get all unregistered agents; use `saved` to get all registered
        agents.
        """

        ALL = 'all'
        NEW = 'new'
        SAVED = 'saved'


class GetAgentEnums:
    """
    Enums for get_agent parameters.
    """

    class Profile(str, Enum):
        """
        Level of details returned by the get method.
        """

        SUMMARY = 'summary'
        DETAILED = 'detailed'
        IDS = 'ids'


class ListAgentDataEnums:
    """
    Enums for list_agent_data parameters.
    """

    class Profile(str, Enum):
        """
        Level of details returned by the get method.
        """

        SUMMARY = 'summary'
        DETAILED = 'detailed'
        IDS = 'ids'

    class Filter(str, Enum):
        """
        Use `new` to get all unregistered agents; use `saved` to get all registered
        agents.
        """

        ALL = 'all'
        NEW = 'new'
        SAVED = 'saved'


class GetAgentDataEnums:
    """
    Enums for get_agent_data parameters.
    """

    class Profile(str, Enum):
        """
        Level of details returned by the get method.
        """

        SUMMARY = 'summary'
        DETAILED = 'detailed'
        IDS = 'ids'


class ListPolicyEnums:
    """
    Enums for list_policy parameters.
    """

    class Profile(str, Enum):
        """
        Level of details returned by the get method.
        """

        SUMMARY = 'summary'
        DETAILED = 'detailed'
        IDS = 'ids'


class GetPolicyEnums:
    """
    Enums for get_policy parameters.
    """

    class Profile(str, Enum):
        """
        Level of details returned by the get method.
        """

        SUMMARY = 'summary'
        DETAILED = 'detailed'
        IDS = 'ids'


##############################################################################
# Models
##############################################################################


class Action:
    """
    Complete Action details with user inputs and system generated data.

    :param str name: (optional) The unique name of your action. The name can be up
          to 128 characters long and can include alphanumeric characters, spaces, dashes,
          and underscores. **Example** you can use the name to stop action.
    :param str description: (optional) Action description.
    :param str location: (optional) List of locations supported by IBM Cloud
          Schematics service.  While creating your workspace or action, choose the right
          region, since it cannot be changed.  Note, this does not limit the location of
          the IBM Cloud resources, provisioned using Schematics.
    :param str resource_group: (optional) Resource-group name for an action. By
          default, an action is created in `Default` resource group.
    :param str bastion_connection_type: (optional) Type of connection to be used
          when connecting to bastion host.  If the `inventory_connection_type=winrm`, then
          `bastion_connection_type` is not supported.
    :param str inventory_connection_type: (optional) Type of connection to be used
          when connecting to remote host.  **Note** Currently, WinRM supports only Windows
          system with the public IPs and do not support Bastion host.
    :param List[str] tags: (optional) Action tags.
    :param UserState user_state: (optional) User defined status of the Schematics
          object.
    :param str source_readme_url: (optional) URL of the `README` file, for the
          source URL.
    :param ExternalSource source: (optional) Source of templates, playbooks, or
          controls.
    :param str source_type: (optional) Type of source for the Template.
    :param str command_parameter: (optional) Schematics job command parameter
          (playbook-name).
    :param str inventory: (optional) Target inventory record ID, used by the action
          or ansible playbook.
    :param List[CredentialVariableData] credentials: (optional) credentials of the
          Action.
    :param BastionResourceDefinition bastion: (optional) Describes a bastion
          resource.
    :param CredentialVariableData bastion_credential: (optional) User editable
          credential variable data and system generated reference to the value.
    :param str targets_ini: (optional) Inventory of host and host group for the
          playbook in `INI` file format. For example, `"targets_ini": "[webserverhost]
           172.22.192.6
           [dbhost]
           172.22.192.5"`. For more information, about an inventory host group syntax, see
          [Inventory host
          groups](https://cloud.ibm.com/docs/schematics?topic=schematics-schematics-cli-reference#schematics-inventory-host-grps).
    :param List[VariableData] inputs: (optional) Input variables for the Action.
    :param List[VariableData] outputs: (optional) Output variables for the Action.
    :param List[VariableData] settings: (optional) Environment variables for the
          Action.
    :param str id: (optional) Action ID.
    :param str crn: (optional) Action Cloud Resource Name.
    :param str account: (optional) Action account ID.
    :param datetime source_created_at: (optional) Action Playbook Source creation
          time.
    :param str source_created_by: (optional) E-mail address of user who created the
          Action Playbook Source.
    :param datetime source_updated_at: (optional) The action playbook updation time.
    :param str source_updated_by: (optional) E-mail address of user who updated the
          action playbook source.
    :param datetime created_at: (optional) Action creation time.
    :param str created_by: (optional) E-mail address of the user who created an
          action.
    :param datetime updated_at: (optional) Action updation time.
    :param str updated_by: (optional) E-mail address of the user who updated an
          action.
    :param ActionState state: (optional) Computed state of the Action.
    :param List[str] playbook_names: (optional) Playbook names retrieved from the
          repository.
    :param SystemLock sys_lock: (optional) System lock status.
    :param str git_token_ref: (optional) secrets manager reference to git token.
    :param EncryptionInfo encryption: (optional) Encryption details about the
          workspace such as scheme (byok/kyok) and key CRN.
    """

    def __init__(
        self,
        *,
        name: Optional[str] = None,
        description: Optional[str] = None,
        location: Optional[str] = None,
        resource_group: Optional[str] = None,
        bastion_connection_type: Optional[str] = None,
        inventory_connection_type: Optional[str] = None,
        tags: Optional[List[str]] = None,
        user_state: Optional['UserState'] = None,
        source_readme_url: Optional[str] = None,
        source: Optional['ExternalSource'] = None,
        source_type: Optional[str] = None,
        command_parameter: Optional[str] = None,
        inventory: Optional[str] = None,
        credentials: Optional[List['CredentialVariableData']] = None,
        bastion: Optional['BastionResourceDefinition'] = None,
        bastion_credential: Optional['CredentialVariableData'] = None,
        targets_ini: Optional[str] = None,
        inputs: Optional[List['VariableData']] = None,
        outputs: Optional[List['VariableData']] = None,
        settings: Optional[List['VariableData']] = None,
        id: Optional[str] = None,
        crn: Optional[str] = None,
        account: Optional[str] = None,
        source_created_at: Optional[datetime] = None,
        source_created_by: Optional[str] = None,
        source_updated_at: Optional[datetime] = None,
        source_updated_by: Optional[str] = None,
        created_at: Optional[datetime] = None,
        created_by: Optional[str] = None,
        updated_at: Optional[datetime] = None,
        updated_by: Optional[str] = None,
        state: Optional['ActionState'] = None,
        playbook_names: Optional[List[str]] = None,
        sys_lock: Optional['SystemLock'] = None,
        git_token_ref: Optional[str] = None,
        encryption: Optional['EncryptionInfo'] = None,
    ) -> None:
        """
        Initialize a Action object.

        :param str name: (optional) The unique name of your action. The name can be
               up to 128 characters long and can include alphanumeric characters, spaces,
               dashes, and underscores. **Example** you can use the name to stop action.
        :param str description: (optional) Action description.
        :param str location: (optional) List of locations supported by IBM Cloud
               Schematics service.  While creating your workspace or action, choose the
               right region, since it cannot be changed.  Note, this does not limit the
               location of the IBM Cloud resources, provisioned using Schematics.
        :param str resource_group: (optional) Resource-group name for an action. By
               default, an action is created in `Default` resource group.
        :param str bastion_connection_type: (optional) Type of connection to be
               used when connecting to bastion host.  If the
               `inventory_connection_type=winrm`, then `bastion_connection_type` is not
               supported.
        :param str inventory_connection_type: (optional) Type of connection to be
               used when connecting to remote host.  **Note** Currently, WinRM supports
               only Windows system with the public IPs and do not support Bastion host.
        :param List[str] tags: (optional) Action tags.
        :param UserState user_state: (optional) User defined status of the
               Schematics object.
        :param str source_readme_url: (optional) URL of the `README` file, for the
               source URL.
        :param ExternalSource source: (optional) Source of templates, playbooks, or
               controls.
        :param str source_type: (optional) Type of source for the Template.
        :param str command_parameter: (optional) Schematics job command parameter
               (playbook-name).
        :param str inventory: (optional) Target inventory record ID, used by the
               action or ansible playbook.
        :param List[CredentialVariableData] credentials: (optional) credentials of
               the Action.
        :param BastionResourceDefinition bastion: (optional) Describes a bastion
               resource.
        :param CredentialVariableData bastion_credential: (optional) User editable
               credential variable data and system generated reference to the value.
        :param str targets_ini: (optional) Inventory of host and host group for the
               playbook in `INI` file format. For example, `"targets_ini":
               "[webserverhost]
                172.22.192.6
                [dbhost]
                172.22.192.5"`. For more information, about an inventory host group
               syntax, see [Inventory host
               groups](https://cloud.ibm.com/docs/schematics?topic=schematics-schematics-cli-reference#schematics-inventory-host-grps).
        :param List[VariableData] inputs: (optional) Input variables for the
               Action.
        :param List[VariableData] outputs: (optional) Output variables for the
               Action.
        :param List[VariableData] settings: (optional) Environment variables for
               the Action.
        """
        self.name = name
        self.description = description
        self.location = location
        self.resource_group = resource_group
        self.bastion_connection_type = bastion_connection_type
        self.inventory_connection_type = inventory_connection_type
        self.tags = tags
        self.user_state = user_state
        self.source_readme_url = source_readme_url
        self.source = source
        self.source_type = source_type
        self.command_parameter = command_parameter
        self.inventory = inventory
        self.credentials = credentials
        self.bastion = bastion
        self.bastion_credential = bastion_credential
        self.targets_ini = targets_ini
        self.inputs = inputs
        self.outputs = outputs
        self.settings = settings
        self.id = id
        self.crn = crn
        self.account = account
        self.source_created_at = source_created_at
        self.source_created_by = source_created_by
        self.source_updated_at = source_updated_at
        self.source_updated_by = source_updated_by
        self.created_at = created_at
        self.created_by = created_by
        self.updated_at = updated_at
        self.updated_by = updated_by
        self.state = state
        self.playbook_names = playbook_names
        self.sys_lock = sys_lock
        self.git_token_ref = git_token_ref
        self.encryption = encryption

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'Action':
        """Initialize a Action object from a json dictionary."""
        args = {}
        if (name := _dict.get('name')) is not None:
            args['name'] = name
        if (description := _dict.get('description')) is not None:
            args['description'] = description
        if (location := _dict.get('location')) is not None:
            args['location'] = location
        if (resource_group := _dict.get('resource_group')) is not None:
            args['resource_group'] = resource_group
        if (bastion_connection_type := _dict.get('bastion_connection_type')) is not None:
            args['bastion_connection_type'] = bastion_connection_type
        if (inventory_connection_type := _dict.get('inventory_connection_type')) is not None:
            args['inventory_connection_type'] = inventory_connection_type
        if (tags := _dict.get('tags')) is not None:
            args['tags'] = tags
        if (user_state := _dict.get('user_state')) is not None:
            args['user_state'] = UserState.from_dict(user_state)
        if (source_readme_url := _dict.get('source_readme_url')) is not None:
            args['source_readme_url'] = source_readme_url
        if (source := _dict.get('source')) is not None:
            args['source'] = ExternalSource.from_dict(source)
        if (source_type := _dict.get('source_type')) is not None:
            args['source_type'] = source_type
        if (command_parameter := _dict.get('command_parameter')) is not None:
            args['command_parameter'] = command_parameter
        if (inventory := _dict.get('inventory')) is not None:
            args['inventory'] = inventory
        if (credentials := _dict.get('credentials')) is not None:
            args['credentials'] = [CredentialVariableData.from_dict(v) for v in credentials]
        if (bastion := _dict.get('bastion')) is not None:
            args['bastion'] = BastionResourceDefinition.from_dict(bastion)
        if (bastion_credential := _dict.get('bastion_credential')) is not None:
            args['bastion_credential'] = CredentialVariableData.from_dict(bastion_credential)
        if (targets_ini := _dict.get('targets_ini')) is not None:
            args['targets_ini'] = targets_ini
        if (inputs := _dict.get('inputs')) is not None:
            args['inputs'] = [VariableData.from_dict(v) for v in inputs]
        if (outputs := _dict.get('outputs')) is not None:
            args['outputs'] = [VariableData.from_dict(v) for v in outputs]
        if (settings := _dict.get('settings')) is not None:
            args['settings'] = [VariableData.from_dict(v) for v in settings]
        if (id := _dict.get('id')) is not None:
            args['id'] = id
        if (crn := _dict.get('crn')) is not None:
            args['crn'] = crn
        if (account := _dict.get('account')) is not None:
            args['account'] = account
        if (source_created_at := _dict.get('source_created_at')) is not None:
            args['source_created_at'] = string_to_datetime(source_created_at)
        if (source_created_by := _dict.get('source_created_by')) is not None:
            args['source_created_by'] = source_created_by
        if (source_updated_at := _dict.get('source_updated_at')) is not None:
            args['source_updated_at'] = string_to_datetime(source_updated_at)
        if (source_updated_by := _dict.get('source_updated_by')) is not None:
            args['source_updated_by'] = source_updated_by
        if (created_at := _dict.get('created_at')) is not None:
            args['created_at'] = string_to_datetime(created_at)
        if (created_by := _dict.get('created_by')) is not None:
            args['created_by'] = created_by
        if (updated_at := _dict.get('updated_at')) is not None:
            args['updated_at'] = string_to_datetime(updated_at)
        if (updated_by := _dict.get('updated_by')) is not None:
            args['updated_by'] = updated_by
        if (state := _dict.get('state')) is not None:
            args['state'] = ActionState.from_dict(state)
        if (playbook_names := _dict.get('playbook_names')) is not None:
            args['playbook_names'] = playbook_names
        if (sys_lock := _dict.get('sys_lock')) is not None:
            args['sys_lock'] = SystemLock.from_dict(sys_lock)
        if (git_token_ref := _dict.get('git_token_ref')) is not None:
            args['git_token_ref'] = git_token_ref
        if (encryption := _dict.get('encryption')) is not None:
            args['encryption'] = EncryptionInfo.from_dict(encryption)
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a Action object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'name') and self.name is not None:
            _dict['name'] = self.name
        if hasattr(self, 'description') and self.description is not None:
            _dict['description'] = self.description
        if hasattr(self, 'location') and self.location is not None:
            _dict['location'] = self.location
        if hasattr(self, 'resource_group') and self.resource_group is not None:
            _dict['resource_group'] = self.resource_group
        if hasattr(self, 'bastion_connection_type') and self.bastion_connection_type is not None:
            _dict['bastion_connection_type'] = self.bastion_connection_type
        if hasattr(self, 'inventory_connection_type') and self.inventory_connection_type is not None:
            _dict['inventory_connection_type'] = self.inventory_connection_type
        if hasattr(self, 'tags') and self.tags is not None:
            _dict['tags'] = self.tags
        if hasattr(self, 'user_state') and self.user_state is not None:
            if isinstance(self.user_state, dict):
                _dict['user_state'] = self.user_state
            else:
                _dict['user_state'] = self.user_state.to_dict()
        if hasattr(self, 'source_readme_url') and self.source_readme_url is not None:
            _dict['source_readme_url'] = self.source_readme_url
        if hasattr(self, 'source') and self.source is not None:
            if isinstance(self.source, dict):
                _dict['source'] = self.source
            else:
                _dict['source'] = self.source.to_dict()
        if hasattr(self, 'source_type') and self.source_type is not None:
            _dict['source_type'] = self.source_type
        if hasattr(self, 'command_parameter') and self.command_parameter is not None:
            _dict['command_parameter'] = self.command_parameter
        if hasattr(self, 'inventory') and self.inventory is not None:
            _dict['inventory'] = self.inventory
        if hasattr(self, 'credentials') and self.credentials is not None:
            credentials_list = []
            for v in self.credentials:
                if isinstance(v, dict):
                    credentials_list.append(v)
                else:
                    credentials_list.append(v.to_dict())
            _dict['credentials'] = credentials_list
        if hasattr(self, 'bastion') and self.bastion is not None:
            if isinstance(self.bastion, dict):
                _dict['bastion'] = self.bastion
            else:
                _dict['bastion'] = self.bastion.to_dict()
        if hasattr(self, 'bastion_credential') and self.bastion_credential is not None:
            if isinstance(self.bastion_credential, dict):
                _dict['bastion_credential'] = self.bastion_credential
            else:
                _dict['bastion_credential'] = self.bastion_credential.to_dict()
        if hasattr(self, 'targets_ini') and self.targets_ini is not None:
            _dict['targets_ini'] = self.targets_ini
        if hasattr(self, 'inputs') and self.inputs is not None:
            inputs_list = []
            for v in self.inputs:
                if isinstance(v, dict):
                    inputs_list.append(v)
                else:
                    inputs_list.append(v.to_dict())
            _dict['inputs'] = inputs_list
        if hasattr(self, 'outputs') and self.outputs is not None:
            outputs_list = []
            for v in self.outputs:
                if isinstance(v, dict):
                    outputs_list.append(v)
                else:
                    outputs_list.append(v.to_dict())
            _dict['outputs'] = outputs_list
        if hasattr(self, 'settings') and self.settings is not None:
            settings_list = []
            for v in self.settings:
                if isinstance(v, dict):
                    settings_list.append(v)
                else:
                    settings_list.append(v.to_dict())
            _dict['settings'] = settings_list
        if hasattr(self, 'id') and getattr(self, 'id') is not None:
            _dict['id'] = getattr(self, 'id')
        if hasattr(self, 'crn') and getattr(self, 'crn') is not None:
            _dict['crn'] = getattr(self, 'crn')
        if hasattr(self, 'account') and getattr(self, 'account') is not None:
            _dict['account'] = getattr(self, 'account')
        if hasattr(self, 'source_created_at') and getattr(self, 'source_created_at') is not None:
            _dict['source_created_at'] = datetime_to_string(getattr(self, 'source_created_at'))
        if hasattr(self, 'source_created_by') and getattr(self, 'source_created_by') is not None:
            _dict['source_created_by'] = getattr(self, 'source_created_by')
        if hasattr(self, 'source_updated_at') and getattr(self, 'source_updated_at') is not None:
            _dict['source_updated_at'] = datetime_to_string(getattr(self, 'source_updated_at'))
        if hasattr(self, 'source_updated_by') and getattr(self, 'source_updated_by') is not None:
            _dict['source_updated_by'] = getattr(self, 'source_updated_by')
        if hasattr(self, 'created_at') and getattr(self, 'created_at') is not None:
            _dict['created_at'] = datetime_to_string(getattr(self, 'created_at'))
        if hasattr(self, 'created_by') and getattr(self, 'created_by') is not None:
            _dict['created_by'] = getattr(self, 'created_by')
        if hasattr(self, 'updated_at') and getattr(self, 'updated_at') is not None:
            _dict['updated_at'] = datetime_to_string(getattr(self, 'updated_at'))
        if hasattr(self, 'updated_by') and getattr(self, 'updated_by') is not None:
            _dict['updated_by'] = getattr(self, 'updated_by')
        if hasattr(self, 'state') and getattr(self, 'state') is not None:
            if isinstance(getattr(self, 'state'), dict):
                _dict['state'] = getattr(self, 'state')
            else:
                _dict['state'] = getattr(self, 'state').to_dict()
        if hasattr(self, 'playbook_names') and getattr(self, 'playbook_names') is not None:
            _dict['playbook_names'] = getattr(self, 'playbook_names')
        if hasattr(self, 'sys_lock') and getattr(self, 'sys_lock') is not None:
            if isinstance(getattr(self, 'sys_lock'), dict):
                _dict['sys_lock'] = getattr(self, 'sys_lock')
            else:
                _dict['sys_lock'] = getattr(self, 'sys_lock').to_dict()
        if hasattr(self, 'git_token_ref') and getattr(self, 'git_token_ref') is not None:
            _dict['git_token_ref'] = getattr(self, 'git_token_ref')
        if hasattr(self, 'encryption') and getattr(self, 'encryption') is not None:
            if isinstance(getattr(self, 'encryption'), dict):
                _dict['encryption'] = getattr(self, 'encryption')
            else:
                _dict['encryption'] = getattr(self, 'encryption').to_dict()
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this Action object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'Action') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'Action') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

    class LocationEnum(str, Enum):
        """
        List of locations supported by IBM Cloud Schematics service.  While creating your
        workspace or action, choose the right region, since it cannot be changed.  Note,
        this does not limit the location of the IBM Cloud resources, provisioned using
        Schematics.
        """

        US_SOUTH = 'us-south'
        US_EAST = 'us-east'
        EU_GB = 'eu-gb'
        EU_DE = 'eu-de'

    class BastionConnectionTypeEnum(str, Enum):
        """
        Type of connection to be used when connecting to bastion host.  If the
        `inventory_connection_type=winrm`, then `bastion_connection_type` is not
        supported.
        """

        SSH = 'ssh'

    class InventoryConnectionTypeEnum(str, Enum):
        """
        Type of connection to be used when connecting to remote host.  **Note** Currently,
        WinRM supports only Windows system with the public IPs and do not support Bastion
        host.
        """

        SSH = 'ssh'
        WINRM = 'winrm'

    class SourceTypeEnum(str, Enum):
        """
        Type of source for the Template.
        """

        LOCAL = 'local'
        GIT_HUB = 'git_hub'
        GIT_HUB_ENTERPRISE = 'git_hub_enterprise'
        GIT_LAB = 'git_lab'
        IBM_GIT_LAB = 'ibm_git_lab'
        IBM_CLOUD_CATALOG = 'ibm_cloud_catalog'


class ActionList:
    """
    List of Action definition response.

    :param int total_count: (optional) Total number of records.
    :param int limit: Number of records returned.
    :param int offset: Skipped number of records.
    :param List[ActionLite] actions: (optional) List of action records.
    """

    def __init__(
        self,
        limit: int,
        offset: int,
        *,
        total_count: Optional[int] = None,
        actions: Optional[List['ActionLite']] = None,
    ) -> None:
        """
        Initialize a ActionList object.

        :param int limit: Number of records returned.
        :param int offset: Skipped number of records.
        :param int total_count: (optional) Total number of records.
        :param List[ActionLite] actions: (optional) List of action records.
        """
        self.total_count = total_count
        self.limit = limit
        self.offset = offset
        self.actions = actions

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'ActionList':
        """Initialize a ActionList object from a json dictionary."""
        args = {}
        if (total_count := _dict.get('total_count')) is not None:
            args['total_count'] = total_count
        if (limit := _dict.get('limit')) is not None:
            args['limit'] = limit
        else:
            raise ValueError('Required property \'limit\' not present in ActionList JSON')
        if (offset := _dict.get('offset')) is not None:
            args['offset'] = offset
        else:
            raise ValueError('Required property \'offset\' not present in ActionList JSON')
        if (actions := _dict.get('actions')) is not None:
            args['actions'] = [ActionLite.from_dict(v) for v in actions]
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a ActionList object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'total_count') and self.total_count is not None:
            _dict['total_count'] = self.total_count
        if hasattr(self, 'limit') and self.limit is not None:
            _dict['limit'] = self.limit
        if hasattr(self, 'offset') and self.offset is not None:
            _dict['offset'] = self.offset
        if hasattr(self, 'actions') and self.actions is not None:
            actions_list = []
            for v in self.actions:
                if isinstance(v, dict):
                    actions_list.append(v)
                else:
                    actions_list.append(v.to_dict())
            _dict['actions'] = actions_list
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this ActionList object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'ActionList') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'ActionList') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other


class ActionLite:
    """
    Action summary profile with user inputs and system generated data.

    :param str name: (optional) Action name (unique for an account).
    :param str description: (optional) Action description.
    :param str id: (optional) Action Id.
    :param str crn: (optional) Action Cloud Resource Name.
    :param str location: (optional) List of locations supported by IBM Cloud
          Schematics service.  While creating your workspace or action, choose the right
          region, since it cannot be changed.  Note, this does not limit the location of
          the IBM Cloud resources, provisioned using Schematics.
    :param str resource_group: (optional) Resource-group name for the Action.  By
          default, Action will be created in Default Resource Group.
    :param str namespace: (optional) name of the namespace.
    :param List[str] tags: (optional) Action tags.
    :param str playbook_name: (optional) Name of the selected playbook.
    :param UserState user_state: (optional) User defined status of the Schematics
          object.
    :param ActionLiteState state: (optional) Computed state of the Action.
    :param SystemLock sys_lock: (optional) System lock status.
    :param datetime created_at: (optional) Action creation time.
    :param str created_by: (optional) Email address of user who created the action.
    :param datetime updated_at: (optional) Action updation time.
    :param str updated_by: (optional) Email address of user who updated the action.
    :param AgentInfo agent: (optional) Agent name, Agent id and associated policy ID
          information.
    :param EncryptionInfo encryption: (optional) Encryption details about the
          workspace such as scheme (byok/kyok) and key CRN.
    """

    def __init__(
        self,
        *,
        name: Optional[str] = None,
        description: Optional[str] = None,
        id: Optional[str] = None,
        crn: Optional[str] = None,
        location: Optional[str] = None,
        resource_group: Optional[str] = None,
        namespace: Optional[str] = None,
        tags: Optional[List[str]] = None,
        playbook_name: Optional[str] = None,
        user_state: Optional['UserState'] = None,
        state: Optional['ActionLiteState'] = None,
        sys_lock: Optional['SystemLock'] = None,
        created_at: Optional[datetime] = None,
        created_by: Optional[str] = None,
        updated_at: Optional[datetime] = None,
        updated_by: Optional[str] = None,
        agent: Optional['AgentInfo'] = None,
        encryption: Optional['EncryptionInfo'] = None,
    ) -> None:
        """
        Initialize a ActionLite object.

        :param str name: (optional) Action name (unique for an account).
        :param str description: (optional) Action description.
        :param str location: (optional) List of locations supported by IBM Cloud
               Schematics service.  While creating your workspace or action, choose the
               right region, since it cannot be changed.  Note, this does not limit the
               location of the IBM Cloud resources, provisioned using Schematics.
        :param UserState user_state: (optional) User defined status of the
               Schematics object.
        :param AgentInfo agent: (optional) Agent name, Agent id and associated
               policy ID information.
        """
        self.name = name
        self.description = description
        self.id = id
        self.crn = crn
        self.location = location
        self.resource_group = resource_group
        self.namespace = namespace
        self.tags = tags
        self.playbook_name = playbook_name
        self.user_state = user_state
        self.state = state
        self.sys_lock = sys_lock
        self.created_at = created_at
        self.created_by = created_by
        self.updated_at = updated_at
        self.updated_by = updated_by
        self.agent = agent
        self.encryption = encryption

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'ActionLite':
        """Initialize a ActionLite object from a json dictionary."""
        args = {}
        if (name := _dict.get('name')) is not None:
            args['name'] = name
        if (description := _dict.get('description')) is not None:
            args['description'] = description
        if (id := _dict.get('id')) is not None:
            args['id'] = id
        if (crn := _dict.get('crn')) is not None:
            args['crn'] = crn
        if (location := _dict.get('location')) is not None:
            args['location'] = location
        if (resource_group := _dict.get('resource_group')) is not None:
            args['resource_group'] = resource_group
        if (namespace := _dict.get('namespace')) is not None:
            args['namespace'] = namespace
        if (tags := _dict.get('tags')) is not None:
            args['tags'] = tags
        if (playbook_name := _dict.get('playbook_name')) is not None:
            args['playbook_name'] = playbook_name
        if (user_state := _dict.get('user_state')) is not None:
            args['user_state'] = UserState.from_dict(user_state)
        if (state := _dict.get('state')) is not None:
            args['state'] = ActionLiteState.from_dict(state)
        if (sys_lock := _dict.get('sys_lock')) is not None:
            args['sys_lock'] = SystemLock.from_dict(sys_lock)
        if (created_at := _dict.get('created_at')) is not None:
            args['created_at'] = string_to_datetime(created_at)
        if (created_by := _dict.get('created_by')) is not None:
            args['created_by'] = created_by
        if (updated_at := _dict.get('updated_at')) is not None:
            args['updated_at'] = string_to_datetime(updated_at)
        if (updated_by := _dict.get('updated_by')) is not None:
            args['updated_by'] = updated_by
        if (agent := _dict.get('agent')) is not None:
            args['agent'] = AgentInfo.from_dict(agent)
        if (encryption := _dict.get('encryption')) is not None:
            args['encryption'] = EncryptionInfo.from_dict(encryption)
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a ActionLite object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'name') and self.name is not None:
            _dict['name'] = self.name
        if hasattr(self, 'description') and self.description is not None:
            _dict['description'] = self.description
        if hasattr(self, 'id') and getattr(self, 'id') is not None:
            _dict['id'] = getattr(self, 'id')
        if hasattr(self, 'crn') and getattr(self, 'crn') is not None:
            _dict['crn'] = getattr(self, 'crn')
        if hasattr(self, 'location') and self.location is not None:
            _dict['location'] = self.location
        if hasattr(self, 'resource_group') and getattr(self, 'resource_group') is not None:
            _dict['resource_group'] = getattr(self, 'resource_group')
        if hasattr(self, 'namespace') and getattr(self, 'namespace') is not None:
            _dict['namespace'] = getattr(self, 'namespace')
        if hasattr(self, 'tags') and getattr(self, 'tags') is not None:
            _dict['tags'] = getattr(self, 'tags')
        if hasattr(self, 'playbook_name') and getattr(self, 'playbook_name') is not None:
            _dict['playbook_name'] = getattr(self, 'playbook_name')
        if hasattr(self, 'user_state') and self.user_state is not None:
            if isinstance(self.user_state, dict):
                _dict['user_state'] = self.user_state
            else:
                _dict['user_state'] = self.user_state.to_dict()
        if hasattr(self, 'state') and getattr(self, 'state') is not None:
            if isinstance(getattr(self, 'state'), dict):
                _dict['state'] = getattr(self, 'state')
            else:
                _dict['state'] = getattr(self, 'state').to_dict()
        if hasattr(self, 'sys_lock') and getattr(self, 'sys_lock') is not None:
            if isinstance(getattr(self, 'sys_lock'), dict):
                _dict['sys_lock'] = getattr(self, 'sys_lock')
            else:
                _dict['sys_lock'] = getattr(self, 'sys_lock').to_dict()
        if hasattr(self, 'created_at') and getattr(self, 'created_at') is not None:
            _dict['created_at'] = datetime_to_string(getattr(self, 'created_at'))
        if hasattr(self, 'created_by') and getattr(self, 'created_by') is not None:
            _dict['created_by'] = getattr(self, 'created_by')
        if hasattr(self, 'updated_at') and getattr(self, 'updated_at') is not None:
            _dict['updated_at'] = datetime_to_string(getattr(self, 'updated_at'))
        if hasattr(self, 'updated_by') and getattr(self, 'updated_by') is not None:
            _dict['updated_by'] = getattr(self, 'updated_by')
        if hasattr(self, 'agent') and self.agent is not None:
            if isinstance(self.agent, dict):
                _dict['agent'] = self.agent
            else:
                _dict['agent'] = self.agent.to_dict()
        if hasattr(self, 'encryption') and getattr(self, 'encryption') is not None:
            if isinstance(getattr(self, 'encryption'), dict):
                _dict['encryption'] = getattr(self, 'encryption')
            else:
                _dict['encryption'] = getattr(self, 'encryption').to_dict()
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this ActionLite object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'ActionLite') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'ActionLite') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

    class LocationEnum(str, Enum):
        """
        List of locations supported by IBM Cloud Schematics service.  While creating your
        workspace or action, choose the right region, since it cannot be changed.  Note,
        this does not limit the location of the IBM Cloud resources, provisioned using
        Schematics.
        """

        US_SOUTH = 'us-south'
        US_EAST = 'us-east'
        EU_GB = 'eu-gb'
        EU_DE = 'eu-de'


class ActionLiteState:
    """
    Computed state of the Action.

    :param str status_code: (optional) Status of automation (workspace or action).
    :param str status_message: (optional) Automation status message - to be
          displayed along with the status_code.
    """

    def __init__(
        self,
        *,
        status_code: Optional[str] = None,
        status_message: Optional[str] = None,
    ) -> None:
        """
        Initialize a ActionLiteState object.

        :param str status_code: (optional) Status of automation (workspace or
               action).
        :param str status_message: (optional) Automation status message - to be
               displayed along with the status_code.
        """
        self.status_code = status_code
        self.status_message = status_message

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'ActionLiteState':
        """Initialize a ActionLiteState object from a json dictionary."""
        args = {}
        if (status_code := _dict.get('status_code')) is not None:
            args['status_code'] = status_code
        if (status_message := _dict.get('status_message')) is not None:
            args['status_message'] = status_message
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a ActionLiteState object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'status_code') and self.status_code is not None:
            _dict['status_code'] = self.status_code
        if hasattr(self, 'status_message') and self.status_message is not None:
            _dict['status_message'] = self.status_message
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this ActionLiteState object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'ActionLiteState') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'ActionLiteState') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

    class StatusCodeEnum(str, Enum):
        """
        Status of automation (workspace or action).
        """

        NORMAL = 'normal'
        PENDING = 'pending'
        DISABLED = 'disabled'
        CRITICAL = 'critical'


class ActionState:
    """
    Computed state of the Action.

    :param str status_code: (optional) Status of automation (workspace or action).
    :param str status_job_id: (optional) Job id reference for this status.
    :param str status_message: (optional) Automation status message - to be
          displayed along with the status_code.
    """

    def __init__(
        self,
        *,
        status_code: Optional[str] = None,
        status_job_id: Optional[str] = None,
        status_message: Optional[str] = None,
    ) -> None:
        """
        Initialize a ActionState object.

        :param str status_code: (optional) Status of automation (workspace or
               action).
        :param str status_job_id: (optional) Job id reference for this status.
        :param str status_message: (optional) Automation status message - to be
               displayed along with the status_code.
        """
        self.status_code = status_code
        self.status_job_id = status_job_id
        self.status_message = status_message

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'ActionState':
        """Initialize a ActionState object from a json dictionary."""
        args = {}
        if (status_code := _dict.get('status_code')) is not None:
            args['status_code'] = status_code
        if (status_job_id := _dict.get('status_job_id')) is not None:
            args['status_job_id'] = status_job_id
        if (status_message := _dict.get('status_message')) is not None:
            args['status_message'] = status_message
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a ActionState object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'status_code') and self.status_code is not None:
            _dict['status_code'] = self.status_code
        if hasattr(self, 'status_job_id') and self.status_job_id is not None:
            _dict['status_job_id'] = self.status_job_id
        if hasattr(self, 'status_message') and self.status_message is not None:
            _dict['status_message'] = self.status_message
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this ActionState object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'ActionState') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'ActionState') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

    class StatusCodeEnum(str, Enum):
        """
        Status of automation (workspace or action).
        """

        NORMAL = 'normal'
        PENDING = 'pending'
        DISABLED = 'disabled'
        CRITICAL = 'critical'


class Agent:
    """
    The agent registration details, with user inputs and system generated data.

    :param str name: The name of the agent (must be unique, for an account).
    :param str description: (optional) Agent description.
    :param str resource_group: (optional) The resource-group name for the agent.  By
          default, Agent will be registered in Default Resource Group.
    :param List[str] tags: (optional) Tags for the agent.
    :param str agent_location: The location where agent is deployed in the user
          environment.
    :param str location: List of locations supported by IBM Cloud Schematics
          service.  While creating your workspace or action, choose the right region,
          since it cannot be changed.  Note, this does not limit the location of the IBM
          Cloud resources, provisioned using Schematics.
    :param str profile_id: The IAM trusted profile id, used by the Agent instance.
    :param str agent_crn: (optional) The Agent crn, obtained from the Schematics
          Agent deployment configuration.
    :param str id: (optional) The Agent registration id.
    :param datetime registered_at: (optional) The Agent registration date-time.
    :param str registered_by: (optional) The email address of an user who registered
          the Agent.
    :param datetime updated_at: (optional) The Agent registration updation time.
    :param str updated_by: (optional) Email address of user who updated the Agent
          registration.
    :param AgentUserState user_state: (optional) User defined status of the agent.
    :param ConnectionState connection_state: (optional) Connection status of the
          agent.
    :param AgentSystemState system_state: (optional) Computed state of the agent.
    """

    def __init__(
        self,
        name: str,
        agent_location: str,
        location: str,
        profile_id: str,
        *,
        description: Optional[str] = None,
        resource_group: Optional[str] = None,
        tags: Optional[List[str]] = None,
        agent_crn: Optional[str] = None,
        id: Optional[str] = None,
        registered_at: Optional[datetime] = None,
        registered_by: Optional[str] = None,
        updated_at: Optional[datetime] = None,
        updated_by: Optional[str] = None,
        user_state: Optional['AgentUserState'] = None,
        connection_state: Optional['ConnectionState'] = None,
        system_state: Optional['AgentSystemState'] = None,
    ) -> None:
        """
        Initialize a Agent object.

        :param str name: The name of the agent (must be unique, for an account).
        :param str agent_location: The location where agent is deployed in the user
               environment.
        :param str location: List of locations supported by IBM Cloud Schematics
               service.  While creating your workspace or action, choose the right region,
               since it cannot be changed.  Note, this does not limit the location of the
               IBM Cloud resources, provisioned using Schematics.
        :param str profile_id: The IAM trusted profile id, used by the Agent
               instance.
        :param str description: (optional) Agent description.
        :param str resource_group: (optional) The resource-group name for the
               agent.  By default, Agent will be registered in Default Resource Group.
        :param List[str] tags: (optional) Tags for the agent.
        :param AgentUserState user_state: (optional) User defined status of the
               agent.
        """
        self.name = name
        self.description = description
        self.resource_group = resource_group
        self.tags = tags
        self.agent_location = agent_location
        self.location = location
        self.profile_id = profile_id
        self.agent_crn = agent_crn
        self.id = id
        self.registered_at = registered_at
        self.registered_by = registered_by
        self.updated_at = updated_at
        self.updated_by = updated_by
        self.user_state = user_state
        self.connection_state = connection_state
        self.system_state = system_state

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'Agent':
        """Initialize a Agent object from a json dictionary."""
        args = {}
        if (name := _dict.get('name')) is not None:
            args['name'] = name
        else:
            raise ValueError('Required property \'name\' not present in Agent JSON')
        if (description := _dict.get('description')) is not None:
            args['description'] = description
        if (resource_group := _dict.get('resource_group')) is not None:
            args['resource_group'] = resource_group
        if (tags := _dict.get('tags')) is not None:
            args['tags'] = tags
        if (agent_location := _dict.get('agent_location')) is not None:
            args['agent_location'] = agent_location
        else:
            raise ValueError('Required property \'agent_location\' not present in Agent JSON')
        if (location := _dict.get('location')) is not None:
            args['location'] = location
        else:
            raise ValueError('Required property \'location\' not present in Agent JSON')
        if (profile_id := _dict.get('profile_id')) is not None:
            args['profile_id'] = profile_id
        else:
            raise ValueError('Required property \'profile_id\' not present in Agent JSON')
        if (agent_crn := _dict.get('agent_crn')) is not None:
            args['agent_crn'] = agent_crn
        if (id := _dict.get('id')) is not None:
            args['id'] = id
        if (registered_at := _dict.get('registered_at')) is not None:
            args['registered_at'] = string_to_datetime(registered_at)
        if (registered_by := _dict.get('registered_by')) is not None:
            args['registered_by'] = registered_by
        if (updated_at := _dict.get('updated_at')) is not None:
            args['updated_at'] = string_to_datetime(updated_at)
        if (updated_by := _dict.get('updated_by')) is not None:
            args['updated_by'] = updated_by
        if (user_state := _dict.get('user_state')) is not None:
            args['user_state'] = AgentUserState.from_dict(user_state)
        if (connection_state := _dict.get('connection_state')) is not None:
            args['connection_state'] = ConnectionState.from_dict(connection_state)
        if (system_state := _dict.get('system_state')) is not None:
            args['system_state'] = AgentSystemState.from_dict(system_state)
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a Agent object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'name') and self.name is not None:
            _dict['name'] = self.name
        if hasattr(self, 'description') and self.description is not None:
            _dict['description'] = self.description
        if hasattr(self, 'resource_group') and self.resource_group is not None:
            _dict['resource_group'] = self.resource_group
        if hasattr(self, 'tags') and self.tags is not None:
            _dict['tags'] = self.tags
        if hasattr(self, 'agent_location') and self.agent_location is not None:
            _dict['agent_location'] = self.agent_location
        if hasattr(self, 'location') and self.location is not None:
            _dict['location'] = self.location
        if hasattr(self, 'profile_id') and self.profile_id is not None:
            _dict['profile_id'] = self.profile_id
        if hasattr(self, 'agent_crn') and getattr(self, 'agent_crn') is not None:
            _dict['agent_crn'] = getattr(self, 'agent_crn')
        if hasattr(self, 'id') and getattr(self, 'id') is not None:
            _dict['id'] = getattr(self, 'id')
        if hasattr(self, 'registered_at') and getattr(self, 'registered_at') is not None:
            _dict['registered_at'] = datetime_to_string(getattr(self, 'registered_at'))
        if hasattr(self, 'registered_by') and getattr(self, 'registered_by') is not None:
            _dict['registered_by'] = getattr(self, 'registered_by')
        if hasattr(self, 'updated_at') and getattr(self, 'updated_at') is not None:
            _dict['updated_at'] = datetime_to_string(getattr(self, 'updated_at'))
        if hasattr(self, 'updated_by') and getattr(self, 'updated_by') is not None:
            _dict['updated_by'] = getattr(self, 'updated_by')
        if hasattr(self, 'user_state') and self.user_state is not None:
            if isinstance(self.user_state, dict):
                _dict['user_state'] = self.user_state
            else:
                _dict['user_state'] = self.user_state.to_dict()
        if hasattr(self, 'connection_state') and getattr(self, 'connection_state') is not None:
            if isinstance(getattr(self, 'connection_state'), dict):
                _dict['connection_state'] = getattr(self, 'connection_state')
            else:
                _dict['connection_state'] = getattr(self, 'connection_state').to_dict()
        if hasattr(self, 'system_state') and getattr(self, 'system_state') is not None:
            if isinstance(getattr(self, 'system_state'), dict):
                _dict['system_state'] = getattr(self, 'system_state')
            else:
                _dict['system_state'] = getattr(self, 'system_state').to_dict()
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this Agent object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'Agent') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'Agent') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

    class LocationEnum(str, Enum):
        """
        List of locations supported by IBM Cloud Schematics service.  While creating your
        workspace or action, choose the right region, since it cannot be changed.  Note,
        this does not limit the location of the IBM Cloud resources, provisioned using
        Schematics.
        """

        US_SOUTH = 'us-south'
        US_EAST = 'us-east'
        EU_GB = 'eu-gb'
        EU_DE = 'eu-de'


class AgentAssignmentPolicyParameter:
    """
    Parameters for the `agent_assignment_policy`.

    :param str selector_kind: (optional) Types of schematics object selector.
    :param List[str] selector_ids: (optional) The static selectors of schematics
          object ids (workspace or action) for the Schematics policy.
    :param List[PolicyObjectSelector] selector_scope: (optional) The selectors to
          dynamically list of schematics object ids (workspace or action) for the
          Schematics policy.
    """

    def __init__(
        self,
        *,
        selector_kind: Optional[str] = None,
        selector_ids: Optional[List[str]] = None,
        selector_scope: Optional[List['PolicyObjectSelector']] = None,
    ) -> None:
        """
        Initialize a AgentAssignmentPolicyParameter object.

        :param str selector_kind: (optional) Types of schematics object selector.
        :param List[str] selector_ids: (optional) The static selectors of
               schematics object ids (workspace or action) for the Schematics policy.
        :param List[PolicyObjectSelector] selector_scope: (optional) The selectors
               to dynamically list of schematics object ids (workspace or action) for the
               Schematics policy.
        """
        self.selector_kind = selector_kind
        self.selector_ids = selector_ids
        self.selector_scope = selector_scope

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'AgentAssignmentPolicyParameter':
        """Initialize a AgentAssignmentPolicyParameter object from a json dictionary."""
        args = {}
        if (selector_kind := _dict.get('selector_kind')) is not None:
            args['selector_kind'] = selector_kind
        if (selector_ids := _dict.get('selector_ids')) is not None:
            args['selector_ids'] = selector_ids
        if (selector_scope := _dict.get('selector_scope')) is not None:
            args['selector_scope'] = [PolicyObjectSelector.from_dict(v) for v in selector_scope]
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a AgentAssignmentPolicyParameter object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'selector_kind') and self.selector_kind is not None:
            _dict['selector_kind'] = self.selector_kind
        if hasattr(self, 'selector_ids') and self.selector_ids is not None:
            _dict['selector_ids'] = self.selector_ids
        if hasattr(self, 'selector_scope') and self.selector_scope is not None:
            selector_scope_list = []
            for v in self.selector_scope:
                if isinstance(v, dict):
                    selector_scope_list.append(v)
                else:
                    selector_scope_list.append(v.to_dict())
            _dict['selector_scope'] = selector_scope_list
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this AgentAssignmentPolicyParameter object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'AgentAssignmentPolicyParameter') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'AgentAssignmentPolicyParameter') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

    class SelectorKindEnum(str, Enum):
        """
        Types of schematics object selector.
        """

        IDS = 'ids'
        SCOPED = 'scoped'


class AgentData:
    """
    The agent details, with user inputs and system generated data.

    :param str name: The name of the agent (must be unique, for an account).
    :param str description: (optional) Agent description.
    :param str resource_group: The resource-group name for the agent.  By default,
          agent will be registered in Default Resource Group.
    :param List[str] tags: (optional) Tags for the agent.
    :param str version: Agent version.
    :param str schematics_location: List of locations supported by IBM Cloud
          Schematics service.  While creating your workspace or action, choose the right
          region, since it cannot be changed.  Note, this does not limit the location of
          the IBM Cloud resources, provisioned using Schematics.
    :param str agent_location: The location where agent is deployed in the user
          environment.
    :param AgentInfrastructure agent_infrastructure: The infrastructure parameters
          used by the agent.
    :param List[AgentMetadataInfo] agent_metadata: (optional) The metadata of an
          agent.
    :param List[VariableData] agent_inputs: (optional) Additional input variables
          for the agent.
    :param AgentUserState user_state: (optional) User defined status of the agent.
    :param str agent_crn: (optional) The agent crn, obtained from the Schematics
          agent deployment configuration.
    :param str id: (optional) The agent resource id.
    :param datetime created_at: (optional) The agent creation date-time.
    :param str creation_by: (optional) The email address of an user who created the
          agent.
    :param datetime updated_at: (optional) The agent registration updation time.
    :param str updated_by: (optional) Email address of user who updated the agent
          registration.
    :param AgentSystemStatus system_state: (optional) Computed state of the agent.
    :param AgentKPIData agent_kpi: (optional) Schematics Agent key performance
          indicators.
    :param AgentDataRecentPrsJob recent_prs_job: (optional) Run a pre-requisite
          scanner for deploying agent.
    :param AgentDataRecentDeployJob recent_deploy_job: (optional) Post-installations
          checks for Agent health.
    :param AgentDataRecentHealthJob recent_health_job: (optional) Agent health
          check.
    :param AgentDataRecentDestroyJob recent_destroy_job: (optional) destroy resource
          provisoned by agent deploy method.
    :param EncryptionInfo encryption: (optional) Encryption details about the
          workspace such as scheme (byok/kyok) and key CRN.
    """

    def __init__(
        self,
        name: str,
        resource_group: str,
        version: str,
        schematics_location: str,
        agent_location: str,
        agent_infrastructure: 'AgentInfrastructure',
        *,
        description: Optional[str] = None,
        tags: Optional[List[str]] = None,
        agent_metadata: Optional[List['AgentMetadataInfo']] = None,
        agent_inputs: Optional[List['VariableData']] = None,
        user_state: Optional['AgentUserState'] = None,
        agent_crn: Optional[str] = None,
        id: Optional[str] = None,
        created_at: Optional[datetime] = None,
        creation_by: Optional[str] = None,
        updated_at: Optional[datetime] = None,
        updated_by: Optional[str] = None,
        system_state: Optional['AgentSystemStatus'] = None,
        agent_kpi: Optional['AgentKPIData'] = None,
        recent_prs_job: Optional['AgentDataRecentPrsJob'] = None,
        recent_deploy_job: Optional['AgentDataRecentDeployJob'] = None,
        recent_health_job: Optional['AgentDataRecentHealthJob'] = None,
        recent_destroy_job: Optional['AgentDataRecentDestroyJob'] = None,
        encryption: Optional['EncryptionInfo'] = None,
    ) -> None:
        """
        Initialize a AgentData object.

        :param str name: The name of the agent (must be unique, for an account).
        :param str resource_group: The resource-group name for the agent.  By
               default, agent will be registered in Default Resource Group.
        :param str version: Agent version.
        :param str schematics_location: List of locations supported by IBM Cloud
               Schematics service.  While creating your workspace or action, choose the
               right region, since it cannot be changed.  Note, this does not limit the
               location of the IBM Cloud resources, provisioned using Schematics.
        :param str agent_location: The location where agent is deployed in the user
               environment.
        :param AgentInfrastructure agent_infrastructure: The infrastructure
               parameters used by the agent.
        :param str description: (optional) Agent description.
        :param List[str] tags: (optional) Tags for the agent.
        :param List[AgentMetadataInfo] agent_metadata: (optional) The metadata of
               an agent.
        :param List[VariableData] agent_inputs: (optional) Additional input
               variables for the agent.
        :param AgentUserState user_state: (optional) User defined status of the
               agent.
        :param AgentKPIData agent_kpi: (optional) Schematics Agent key performance
               indicators.
        """
        self.name = name
        self.description = description
        self.resource_group = resource_group
        self.tags = tags
        self.version = version
        self.schematics_location = schematics_location
        self.agent_location = agent_location
        self.agent_infrastructure = agent_infrastructure
        self.agent_metadata = agent_metadata
        self.agent_inputs = agent_inputs
        self.user_state = user_state
        self.agent_crn = agent_crn
        self.id = id
        self.created_at = created_at
        self.creation_by = creation_by
        self.updated_at = updated_at
        self.updated_by = updated_by
        self.system_state = system_state
        self.agent_kpi = agent_kpi
        self.recent_prs_job = recent_prs_job
        self.recent_deploy_job = recent_deploy_job
        self.recent_health_job = recent_health_job
        self.recent_destroy_job = recent_destroy_job
        self.encryption = encryption

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'AgentData':
        """Initialize a AgentData object from a json dictionary."""
        args = {}
        if (name := _dict.get('name')) is not None:
            args['name'] = name
        else:
            raise ValueError('Required property \'name\' not present in AgentData JSON')
        if (description := _dict.get('description')) is not None:
            args['description'] = description
        if (resource_group := _dict.get('resource_group')) is not None:
            args['resource_group'] = resource_group
        else:
            raise ValueError('Required property \'resource_group\' not present in AgentData JSON')
        if (tags := _dict.get('tags')) is not None:
            args['tags'] = tags
        if (version := _dict.get('version')) is not None:
            args['version'] = version
        else:
            raise ValueError('Required property \'version\' not present in AgentData JSON')
        if (schematics_location := _dict.get('schematics_location')) is not None:
            args['schematics_location'] = schematics_location
        else:
            raise ValueError('Required property \'schematics_location\' not present in AgentData JSON')
        if (agent_location := _dict.get('agent_location')) is not None:
            args['agent_location'] = agent_location
        else:
            raise ValueError('Required property \'agent_location\' not present in AgentData JSON')
        if (agent_infrastructure := _dict.get('agent_infrastructure')) is not None:
            args['agent_infrastructure'] = AgentInfrastructure.from_dict(agent_infrastructure)
        else:
            raise ValueError('Required property \'agent_infrastructure\' not present in AgentData JSON')
        if (agent_metadata := _dict.get('agent_metadata')) is not None:
            args['agent_metadata'] = [AgentMetadataInfo.from_dict(v) for v in agent_metadata]
        if (agent_inputs := _dict.get('agent_inputs')) is not None:
            args['agent_inputs'] = [VariableData.from_dict(v) for v in agent_inputs]
        if (user_state := _dict.get('user_state')) is not None:
            args['user_state'] = AgentUserState.from_dict(user_state)
        if (agent_crn := _dict.get('agent_crn')) is not None:
            args['agent_crn'] = agent_crn
        if (id := _dict.get('id')) is not None:
            args['id'] = id
        if (created_at := _dict.get('created_at')) is not None:
            args['created_at'] = string_to_datetime(created_at)
        if (creation_by := _dict.get('creation_by')) is not None:
            args['creation_by'] = creation_by
        if (updated_at := _dict.get('updated_at')) is not None:
            args['updated_at'] = string_to_datetime(updated_at)
        if (updated_by := _dict.get('updated_by')) is not None:
            args['updated_by'] = updated_by
        if (system_state := _dict.get('system_state')) is not None:
            args['system_state'] = AgentSystemStatus.from_dict(system_state)
        if (agent_kpi := _dict.get('agent_kpi')) is not None:
            args['agent_kpi'] = AgentKPIData.from_dict(agent_kpi)
        if (recent_prs_job := _dict.get('recent_prs_job')) is not None:
            args['recent_prs_job'] = AgentDataRecentPrsJob.from_dict(recent_prs_job)
        if (recent_deploy_job := _dict.get('recent_deploy_job')) is not None:
            args['recent_deploy_job'] = AgentDataRecentDeployJob.from_dict(recent_deploy_job)
        if (recent_health_job := _dict.get('recent_health_job')) is not None:
            args['recent_health_job'] = AgentDataRecentHealthJob.from_dict(recent_health_job)
        if (recent_destroy_job := _dict.get('recent_destroy_job')) is not None:
            args['recent_destroy_job'] = AgentDataRecentDestroyJob.from_dict(recent_destroy_job)
        if (encryption := _dict.get('encryption')) is not None:
            args['encryption'] = EncryptionInfo.from_dict(encryption)
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a AgentData object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'name') and self.name is not None:
            _dict['name'] = self.name
        if hasattr(self, 'description') and self.description is not None:
            _dict['description'] = self.description
        if hasattr(self, 'resource_group') and self.resource_group is not None:
            _dict['resource_group'] = self.resource_group
        if hasattr(self, 'tags') and self.tags is not None:
            _dict['tags'] = self.tags
        if hasattr(self, 'version') and self.version is not None:
            _dict['version'] = self.version
        if hasattr(self, 'schematics_location') and self.schematics_location is not None:
            _dict['schematics_location'] = self.schematics_location
        if hasattr(self, 'agent_location') and self.agent_location is not None:
            _dict['agent_location'] = self.agent_location
        if hasattr(self, 'agent_infrastructure') and self.agent_infrastructure is not None:
            if isinstance(self.agent_infrastructure, dict):
                _dict['agent_infrastructure'] = self.agent_infrastructure
            else:
                _dict['agent_infrastructure'] = self.agent_infrastructure.to_dict()
        if hasattr(self, 'agent_metadata') and self.agent_metadata is not None:
            agent_metadata_list = []
            for v in self.agent_metadata:
                if isinstance(v, dict):
                    agent_metadata_list.append(v)
                else:
                    agent_metadata_list.append(v.to_dict())
            _dict['agent_metadata'] = agent_metadata_list
        if hasattr(self, 'agent_inputs') and self.agent_inputs is not None:
            agent_inputs_list = []
            for v in self.agent_inputs:
                if isinstance(v, dict):
                    agent_inputs_list.append(v)
                else:
                    agent_inputs_list.append(v.to_dict())
            _dict['agent_inputs'] = agent_inputs_list
        if hasattr(self, 'user_state') and self.user_state is not None:
            if isinstance(self.user_state, dict):
                _dict['user_state'] = self.user_state
            else:
                _dict['user_state'] = self.user_state.to_dict()
        if hasattr(self, 'agent_crn') and getattr(self, 'agent_crn') is not None:
            _dict['agent_crn'] = getattr(self, 'agent_crn')
        if hasattr(self, 'id') and getattr(self, 'id') is not None:
            _dict['id'] = getattr(self, 'id')
        if hasattr(self, 'created_at') and getattr(self, 'created_at') is not None:
            _dict['created_at'] = datetime_to_string(getattr(self, 'created_at'))
        if hasattr(self, 'creation_by') and getattr(self, 'creation_by') is not None:
            _dict['creation_by'] = getattr(self, 'creation_by')
        if hasattr(self, 'updated_at') and getattr(self, 'updated_at') is not None:
            _dict['updated_at'] = datetime_to_string(getattr(self, 'updated_at'))
        if hasattr(self, 'updated_by') and getattr(self, 'updated_by') is not None:
            _dict['updated_by'] = getattr(self, 'updated_by')
        if hasattr(self, 'system_state') and getattr(self, 'system_state') is not None:
            if isinstance(getattr(self, 'system_state'), dict):
                _dict['system_state'] = getattr(self, 'system_state')
            else:
                _dict['system_state'] = getattr(self, 'system_state').to_dict()
        if hasattr(self, 'agent_kpi') and self.agent_kpi is not None:
            if isinstance(self.agent_kpi, dict):
                _dict['agent_kpi'] = self.agent_kpi
            else:
                _dict['agent_kpi'] = self.agent_kpi.to_dict()
        if hasattr(self, 'recent_prs_job') and getattr(self, 'recent_prs_job') is not None:
            if isinstance(getattr(self, 'recent_prs_job'), dict):
                _dict['recent_prs_job'] = getattr(self, 'recent_prs_job')
            else:
                _dict['recent_prs_job'] = getattr(self, 'recent_prs_job').to_dict()
        if hasattr(self, 'recent_deploy_job') and getattr(self, 'recent_deploy_job') is not None:
            if isinstance(getattr(self, 'recent_deploy_job'), dict):
                _dict['recent_deploy_job'] = getattr(self, 'recent_deploy_job')
            else:
                _dict['recent_deploy_job'] = getattr(self, 'recent_deploy_job').to_dict()
        if hasattr(self, 'recent_health_job') and getattr(self, 'recent_health_job') is not None:
            if isinstance(getattr(self, 'recent_health_job'), dict):
                _dict['recent_health_job'] = getattr(self, 'recent_health_job')
            else:
                _dict['recent_health_job'] = getattr(self, 'recent_health_job').to_dict()
        if hasattr(self, 'recent_destroy_job') and getattr(self, 'recent_destroy_job') is not None:
            if isinstance(getattr(self, 'recent_destroy_job'), dict):
                _dict['recent_destroy_job'] = getattr(self, 'recent_destroy_job')
            else:
                _dict['recent_destroy_job'] = getattr(self, 'recent_destroy_job').to_dict()
        if hasattr(self, 'encryption') and getattr(self, 'encryption') is not None:
            if isinstance(getattr(self, 'encryption'), dict):
                _dict['encryption'] = getattr(self, 'encryption')
            else:
                _dict['encryption'] = getattr(self, 'encryption').to_dict()
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this AgentData object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'AgentData') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'AgentData') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

    class SchematicsLocationEnum(str, Enum):
        """
        List of locations supported by IBM Cloud Schematics service.  While creating your
        workspace or action, choose the right region, since it cannot be changed.  Note,
        this does not limit the location of the IBM Cloud resources, provisioned using
        Schematics.
        """

        US_SOUTH = 'us-south'
        US_EAST = 'us-east'
        EU_GB = 'eu-gb'
        EU_DE = 'eu-de'


class AgentDataList:
    """
    The list of agents.

    :param int total_count: (optional) The total number of records.
    :param int limit: (optional) The number of records returned.
    :param int offset: The skipped number of records.
    :param List[AgentDataLite] agents: (optional) The list of agents in the account.
    """

    def __init__(
        self,
        offset: int,
        *,
        total_count: Optional[int] = None,
        limit: Optional[int] = None,
        agents: Optional[List['AgentDataLite']] = None,
    ) -> None:
        """
        Initialize a AgentDataList object.

        :param int offset: The skipped number of records.
        :param List[AgentDataLite] agents: (optional) The list of agents in the
               account.
        """
        self.total_count = total_count
        self.limit = limit
        self.offset = offset
        self.agents = agents

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'AgentDataList':
        """Initialize a AgentDataList object from a json dictionary."""
        args = {}
        if (total_count := _dict.get('total_count')) is not None:
            args['total_count'] = total_count
        if (limit := _dict.get('limit')) is not None:
            args['limit'] = limit
        if (offset := _dict.get('offset')) is not None:
            args['offset'] = offset
        else:
            raise ValueError('Required property \'offset\' not present in AgentDataList JSON')
        if (agents := _dict.get('agents')) is not None:
            args['agents'] = [AgentDataLite.from_dict(v) for v in agents]
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a AgentDataList object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'total_count') and getattr(self, 'total_count') is not None:
            _dict['total_count'] = getattr(self, 'total_count')
        if hasattr(self, 'limit') and getattr(self, 'limit') is not None:
            _dict['limit'] = getattr(self, 'limit')
        if hasattr(self, 'offset') and self.offset is not None:
            _dict['offset'] = self.offset
        if hasattr(self, 'agents') and self.agents is not None:
            agents_list = []
            for v in self.agents:
                if isinstance(v, dict):
                    agents_list.append(v)
                else:
                    agents_list.append(v.to_dict())
            _dict['agents'] = agents_list
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this AgentDataList object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'AgentDataList') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'AgentDataList') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other


class AgentDataLite:
    """
    The agent details for a list view.

    :param str name: (optional) The name of the agent (must be unique, for an
          account).
    :param str description: (optional) Agent description.
    :param str resource_group: (optional) The resource-group name for the agent.  By
          default, agent will be registered in Default Resource Group.
    :param List[str] tags: (optional) Tags for the agent.
    :param str version: (optional) The agent version.
    :param str schematics_location: (optional) List of locations supported by IBM
          Cloud Schematics service.  While creating your workspace or action, choose the
          right region, since it cannot be changed.  Note, this does not limit the
          location of the IBM Cloud resources, provisioned using Schematics.
    :param str agent_location: (optional) The location where agent is deployed in
          the user environment.
    :param List[AgentMetadataInfo] agent_metadata: (optional) The metadata of an
          agent.
    :param AgentUserState user_state: (optional) User defined status of the agent.
    :param str agent_crn: (optional) The agent crn, obtained from the Schematics
          agent deployment configuration.
    :param str id: (optional) The agent resource id.
    :param datetime created_at: (optional) The agent creation date-time.
    :param str creation_by: (optional) The email address of an user who created the
          agent.
    :param datetime updated_at: (optional) The agent registration updation time.
    :param str updated_by: (optional) Email address of user who updated the agent
          registration.
    :param AgentSystemStatus system_state: (optional) Computed state of the agent.
    :param AgentKPIDataLite agent_kpi: (optional) Schematics Agent key performance
          indicators' summary.
    """

    def __init__(
        self,
        *,
        name: Optional[str] = None,
        description: Optional[str] = None,
        resource_group: Optional[str] = None,
        tags: Optional[List[str]] = None,
        version: Optional[str] = None,
        schematics_location: Optional[str] = None,
        agent_location: Optional[str] = None,
        agent_metadata: Optional[List['AgentMetadataInfo']] = None,
        user_state: Optional['AgentUserState'] = None,
        agent_crn: Optional[str] = None,
        id: Optional[str] = None,
        created_at: Optional[datetime] = None,
        creation_by: Optional[str] = None,
        updated_at: Optional[datetime] = None,
        updated_by: Optional[str] = None,
        system_state: Optional['AgentSystemStatus'] = None,
        agent_kpi: Optional['AgentKPIDataLite'] = None,
    ) -> None:
        """
        Initialize a AgentDataLite object.

        :param str name: (optional) The name of the agent (must be unique, for an
               account).
        :param str description: (optional) Agent description.
        :param str resource_group: (optional) The resource-group name for the
               agent.  By default, agent will be registered in Default Resource Group.
        :param List[str] tags: (optional) Tags for the agent.
        :param str version: (optional) The agent version.
        :param str schematics_location: (optional) List of locations supported by
               IBM Cloud Schematics service.  While creating your workspace or action,
               choose the right region, since it cannot be changed.  Note, this does not
               limit the location of the IBM Cloud resources, provisioned using
               Schematics.
        :param str agent_location: (optional) The location where agent is deployed
               in the user environment.
        :param List[AgentMetadataInfo] agent_metadata: (optional) The metadata of
               an agent.
        :param AgentUserState user_state: (optional) User defined status of the
               agent.
        :param AgentKPIDataLite agent_kpi: (optional) Schematics Agent key
               performance indicators' summary.
        """
        self.name = name
        self.description = description
        self.resource_group = resource_group
        self.tags = tags
        self.version = version
        self.schematics_location = schematics_location
        self.agent_location = agent_location
        self.agent_metadata = agent_metadata
        self.user_state = user_state
        self.agent_crn = agent_crn
        self.id = id
        self.created_at = created_at
        self.creation_by = creation_by
        self.updated_at = updated_at
        self.updated_by = updated_by
        self.system_state = system_state
        self.agent_kpi = agent_kpi

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'AgentDataLite':
        """Initialize a AgentDataLite object from a json dictionary."""
        args = {}
        if (name := _dict.get('name')) is not None:
            args['name'] = name
        if (description := _dict.get('description')) is not None:
            args['description'] = description
        if (resource_group := _dict.get('resource_group')) is not None:
            args['resource_group'] = resource_group
        if (tags := _dict.get('tags')) is not None:
            args['tags'] = tags
        if (version := _dict.get('version')) is not None:
            args['version'] = version
        if (schematics_location := _dict.get('schematics_location')) is not None:
            args['schematics_location'] = schematics_location
        if (agent_location := _dict.get('agent_location')) is not None:
            args['agent_location'] = agent_location
        if (agent_metadata := _dict.get('agent_metadata')) is not None:
            args['agent_metadata'] = [AgentMetadataInfo.from_dict(v) for v in agent_metadata]
        if (user_state := _dict.get('user_state')) is not None:
            args['user_state'] = AgentUserState.from_dict(user_state)
        if (agent_crn := _dict.get('agent_crn')) is not None:
            args['agent_crn'] = agent_crn
        if (id := _dict.get('id')) is not None:
            args['id'] = id
        if (created_at := _dict.get('created_at')) is not None:
            args['created_at'] = string_to_datetime(created_at)
        if (creation_by := _dict.get('creation_by')) is not None:
            args['creation_by'] = creation_by
        if (updated_at := _dict.get('updated_at')) is not None:
            args['updated_at'] = string_to_datetime(updated_at)
        if (updated_by := _dict.get('updated_by')) is not None:
            args['updated_by'] = updated_by
        if (system_state := _dict.get('system_state')) is not None:
            args['system_state'] = AgentSystemStatus.from_dict(system_state)
        if (agent_kpi := _dict.get('agent_kpi')) is not None:
            args['agent_kpi'] = AgentKPIDataLite.from_dict(agent_kpi)
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a AgentDataLite object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'name') and self.name is not None:
            _dict['name'] = self.name
        if hasattr(self, 'description') and self.description is not None:
            _dict['description'] = self.description
        if hasattr(self, 'resource_group') and self.resource_group is not None:
            _dict['resource_group'] = self.resource_group
        if hasattr(self, 'tags') and self.tags is not None:
            _dict['tags'] = self.tags
        if hasattr(self, 'version') and self.version is not None:
            _dict['version'] = self.version
        if hasattr(self, 'schematics_location') and self.schematics_location is not None:
            _dict['schematics_location'] = self.schematics_location
        if hasattr(self, 'agent_location') and self.agent_location is not None:
            _dict['agent_location'] = self.agent_location
        if hasattr(self, 'agent_metadata') and self.agent_metadata is not None:
            agent_metadata_list = []
            for v in self.agent_metadata:
                if isinstance(v, dict):
                    agent_metadata_list.append(v)
                else:
                    agent_metadata_list.append(v.to_dict())
            _dict['agent_metadata'] = agent_metadata_list
        if hasattr(self, 'user_state') and self.user_state is not None:
            if isinstance(self.user_state, dict):
                _dict['user_state'] = self.user_state
            else:
                _dict['user_state'] = self.user_state.to_dict()
        if hasattr(self, 'agent_crn') and getattr(self, 'agent_crn') is not None:
            _dict['agent_crn'] = getattr(self, 'agent_crn')
        if hasattr(self, 'id') and getattr(self, 'id') is not None:
            _dict['id'] = getattr(self, 'id')
        if hasattr(self, 'created_at') and getattr(self, 'created_at') is not None:
            _dict['created_at'] = datetime_to_string(getattr(self, 'created_at'))
        if hasattr(self, 'creation_by') and getattr(self, 'creation_by') is not None:
            _dict['creation_by'] = getattr(self, 'creation_by')
        if hasattr(self, 'updated_at') and getattr(self, 'updated_at') is not None:
            _dict['updated_at'] = datetime_to_string(getattr(self, 'updated_at'))
        if hasattr(self, 'updated_by') and getattr(self, 'updated_by') is not None:
            _dict['updated_by'] = getattr(self, 'updated_by')
        if hasattr(self, 'system_state') and getattr(self, 'system_state') is not None:
            if isinstance(getattr(self, 'system_state'), dict):
                _dict['system_state'] = getattr(self, 'system_state')
            else:
                _dict['system_state'] = getattr(self, 'system_state').to_dict()
        if hasattr(self, 'agent_kpi') and self.agent_kpi is not None:
            if isinstance(self.agent_kpi, dict):
                _dict['agent_kpi'] = self.agent_kpi
            else:
                _dict['agent_kpi'] = self.agent_kpi.to_dict()
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this AgentDataLite object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'AgentDataLite') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'AgentDataLite') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

    class SchematicsLocationEnum(str, Enum):
        """
        List of locations supported by IBM Cloud Schematics service.  While creating your
        workspace or action, choose the right region, since it cannot be changed.  Note,
        this does not limit the location of the IBM Cloud resources, provisioned using
        Schematics.
        """

        US_SOUTH = 'us-south'
        US_EAST = 'us-east'
        EU_GB = 'eu-gb'
        EU_DE = 'eu-de'


class AgentDataRecentDeployJob:
    """
    Post-installations checks for Agent health.

    :param str agent_id: (optional) Id of the agent.
    :param str job_id: (optional) Job Id.
    :param datetime updated_at: (optional) The agent deploy job updation time.
    :param str updated_by: (optional) Email address of user who ran the agent deploy
          job.
    :param bool is_redeployed: (optional) True, when the same version of the agent
          was redeployed.
    :param str agent_version: (optional) Agent version.
    :param str status_code: (optional) Status of Jobs.
    :param str status_message: (optional) The outcome of the agent deployment job,
          in a formatted log string.
    :param str log_url: (optional) URL to the full agent deployment job logs.
    """

    def __init__(
        self,
        *,
        agent_id: Optional[str] = None,
        job_id: Optional[str] = None,
        updated_at: Optional[datetime] = None,
        updated_by: Optional[str] = None,
        is_redeployed: Optional[bool] = None,
        agent_version: Optional[str] = None,
        status_code: Optional[str] = None,
        status_message: Optional[str] = None,
        log_url: Optional[str] = None,
    ) -> None:
        """
        Initialize a AgentDataRecentDeployJob object.

        :param str agent_id: (optional) Id of the agent.
        :param str job_id: (optional) Job Id.
        :param bool is_redeployed: (optional) True, when the same version of the
               agent was redeployed.
        :param str status_code: (optional) Status of Jobs.
        :param str status_message: (optional) The outcome of the agent deployment
               job, in a formatted log string.
        :param str log_url: (optional) URL to the full agent deployment job logs.
        """
        self.agent_id = agent_id
        self.job_id = job_id
        self.updated_at = updated_at
        self.updated_by = updated_by
        self.is_redeployed = is_redeployed
        self.agent_version = agent_version
        self.status_code = status_code
        self.status_message = status_message
        self.log_url = log_url

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'AgentDataRecentDeployJob':
        """Initialize a AgentDataRecentDeployJob object from a json dictionary."""
        args = {}
        if (agent_id := _dict.get('agent_id')) is not None:
            args['agent_id'] = agent_id
        if (job_id := _dict.get('job_id')) is not None:
            args['job_id'] = job_id
        if (updated_at := _dict.get('updated_at')) is not None:
            args['updated_at'] = string_to_datetime(updated_at)
        if (updated_by := _dict.get('updated_by')) is not None:
            args['updated_by'] = updated_by
        if (is_redeployed := _dict.get('is_redeployed')) is not None:
            args['is_redeployed'] = is_redeployed
        if (agent_version := _dict.get('agent_version')) is not None:
            args['agent_version'] = agent_version
        if (status_code := _dict.get('status_code')) is not None:
            args['status_code'] = status_code
        if (status_message := _dict.get('status_message')) is not None:
            args['status_message'] = status_message
        if (log_url := _dict.get('log_url')) is not None:
            args['log_url'] = log_url
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a AgentDataRecentDeployJob object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'agent_id') and self.agent_id is not None:
            _dict['agent_id'] = self.agent_id
        if hasattr(self, 'job_id') and self.job_id is not None:
            _dict['job_id'] = self.job_id
        if hasattr(self, 'updated_at') and getattr(self, 'updated_at') is not None:
            _dict['updated_at'] = datetime_to_string(getattr(self, 'updated_at'))
        if hasattr(self, 'updated_by') and getattr(self, 'updated_by') is not None:
            _dict['updated_by'] = getattr(self, 'updated_by')
        if hasattr(self, 'is_redeployed') and self.is_redeployed is not None:
            _dict['is_redeployed'] = self.is_redeployed
        if hasattr(self, 'agent_version') and getattr(self, 'agent_version') is not None:
            _dict['agent_version'] = getattr(self, 'agent_version')
        if hasattr(self, 'status_code') and self.status_code is not None:
            _dict['status_code'] = self.status_code
        if hasattr(self, 'status_message') and self.status_message is not None:
            _dict['status_message'] = self.status_message
        if hasattr(self, 'log_url') and self.log_url is not None:
            _dict['log_url'] = self.log_url
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this AgentDataRecentDeployJob object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'AgentDataRecentDeployJob') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'AgentDataRecentDeployJob') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

    class StatusCodeEnum(str, Enum):
        """
        Status of Jobs.
        """

        JOB_PENDING = 'job_pending'
        JOB_IN_PROGRESS = 'job_in_progress'
        JOB_FINISHED = 'job_finished'
        JOB_FAILED = 'job_failed'
        JOB_CANCELLED = 'job_cancelled'
        JOB_STOPPED = 'job_stopped'
        JOB_STOP_IN_PROGRESS = 'job_stop_in_progress'
        JOB_READY_TO_EXECUTE = 'job_ready_to_execute'


class AgentDataRecentDestroyJob:
    """
    destroy resource provisoned by agent deploy method.

    :param str agent_id: (optional) Id of the agent.
    :param str job_id: (optional) Job Id.
    :param datetime updated_at: (optional) The agent resources destroy job updation
          time.
    :param str updated_by: (optional) Email address of user who ran the agent
          resources destroy job.
    :param str agent_version: (optional) Agent version.
    :param str status_code: (optional) Status of Jobs.
    :param str status_message: (optional) The outcome of the agent resources destroy
          job, in a formatted log string.
    :param str log_url: (optional) URL to the full agent resources destroy job logs.
    """

    def __init__(
        self,
        *,
        agent_id: Optional[str] = None,
        job_id: Optional[str] = None,
        updated_at: Optional[datetime] = None,
        updated_by: Optional[str] = None,
        agent_version: Optional[str] = None,
        status_code: Optional[str] = None,
        status_message: Optional[str] = None,
        log_url: Optional[str] = None,
    ) -> None:
        """
        Initialize a AgentDataRecentDestroyJob object.

        :param str agent_id: (optional) Id of the agent.
        :param str job_id: (optional) Job Id.
        :param str status_code: (optional) Status of Jobs.
        :param str status_message: (optional) The outcome of the agent resources
               destroy job, in a formatted log string.
        :param str log_url: (optional) URL to the full agent resources destroy job
               logs.
        """
        self.agent_id = agent_id
        self.job_id = job_id
        self.updated_at = updated_at
        self.updated_by = updated_by
        self.agent_version = agent_version
        self.status_code = status_code
        self.status_message = status_message
        self.log_url = log_url

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'AgentDataRecentDestroyJob':
        """Initialize a AgentDataRecentDestroyJob object from a json dictionary."""
        args = {}
        if (agent_id := _dict.get('agent_id')) is not None:
            args['agent_id'] = agent_id
        if (job_id := _dict.get('job_id')) is not None:
            args['job_id'] = job_id
        if (updated_at := _dict.get('updated_at')) is not None:
            args['updated_at'] = string_to_datetime(updated_at)
        if (updated_by := _dict.get('updated_by')) is not None:
            args['updated_by'] = updated_by
        if (agent_version := _dict.get('agent_version')) is not None:
            args['agent_version'] = agent_version
        if (status_code := _dict.get('status_code')) is not None:
            args['status_code'] = status_code
        if (status_message := _dict.get('status_message')) is not None:
            args['status_message'] = status_message
        if (log_url := _dict.get('log_url')) is not None:
            args['log_url'] = log_url
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a AgentDataRecentDestroyJob object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'agent_id') and self.agent_id is not None:
            _dict['agent_id'] = self.agent_id
        if hasattr(self, 'job_id') and self.job_id is not None:
            _dict['job_id'] = self.job_id
        if hasattr(self, 'updated_at') and getattr(self, 'updated_at') is not None:
            _dict['updated_at'] = datetime_to_string(getattr(self, 'updated_at'))
        if hasattr(self, 'updated_by') and getattr(self, 'updated_by') is not None:
            _dict['updated_by'] = getattr(self, 'updated_by')
        if hasattr(self, 'agent_version') and getattr(self, 'agent_version') is not None:
            _dict['agent_version'] = getattr(self, 'agent_version')
        if hasattr(self, 'status_code') and self.status_code is not None:
            _dict['status_code'] = self.status_code
        if hasattr(self, 'status_message') and self.status_message is not None:
            _dict['status_message'] = self.status_message
        if hasattr(self, 'log_url') and self.log_url is not None:
            _dict['log_url'] = self.log_url
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this AgentDataRecentDestroyJob object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'AgentDataRecentDestroyJob') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'AgentDataRecentDestroyJob') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

    class StatusCodeEnum(str, Enum):
        """
        Status of Jobs.
        """

        JOB_PENDING = 'job_pending'
        JOB_IN_PROGRESS = 'job_in_progress'
        JOB_FINISHED = 'job_finished'
        JOB_FAILED = 'job_failed'
        JOB_CANCELLED = 'job_cancelled'
        JOB_STOPPED = 'job_stopped'
        JOB_STOP_IN_PROGRESS = 'job_stop_in_progress'
        JOB_READY_TO_EXECUTE = 'job_ready_to_execute'


class AgentDataRecentHealthJob:
    """
    Agent health check.

    :param str agent_id: (optional) Id of the agent.
    :param str job_id: (optional) Job Id.
    :param datetime updated_at: (optional) The agent health check job updation time.
    :param str updated_by: (optional) Email address of user who ran the agent health
          check job.
    :param str agent_version: (optional) Agent version.
    :param str status_code: (optional) Status of Jobs.
    :param str status_message: (optional) The outcome of the health-check job, in a
          formatted log string.
    :param str log_url: (optional) URL to the full health-check job logs.
    """

    def __init__(
        self,
        *,
        agent_id: Optional[str] = None,
        job_id: Optional[str] = None,
        updated_at: Optional[datetime] = None,
        updated_by: Optional[str] = None,
        agent_version: Optional[str] = None,
        status_code: Optional[str] = None,
        status_message: Optional[str] = None,
        log_url: Optional[str] = None,
    ) -> None:
        """
        Initialize a AgentDataRecentHealthJob object.

        :param str agent_id: (optional) Id of the agent.
        :param str job_id: (optional) Job Id.
        :param str status_code: (optional) Status of Jobs.
        :param str status_message: (optional) The outcome of the health-check job,
               in a formatted log string.
        :param str log_url: (optional) URL to the full health-check job logs.
        """
        self.agent_id = agent_id
        self.job_id = job_id
        self.updated_at = updated_at
        self.updated_by = updated_by
        self.agent_version = agent_version
        self.status_code = status_code
        self.status_message = status_message
        self.log_url = log_url

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'AgentDataRecentHealthJob':
        """Initialize a AgentDataRecentHealthJob object from a json dictionary."""
        args = {}
        if (agent_id := _dict.get('agent_id')) is not None:
            args['agent_id'] = agent_id
        if (job_id := _dict.get('job_id')) is not None:
            args['job_id'] = job_id
        if (updated_at := _dict.get('updated_at')) is not None:
            args['updated_at'] = string_to_datetime(updated_at)
        if (updated_by := _dict.get('updated_by')) is not None:
            args['updated_by'] = updated_by
        if (agent_version := _dict.get('agent_version')) is not None:
            args['agent_version'] = agent_version
        if (status_code := _dict.get('status_code')) is not None:
            args['status_code'] = status_code
        if (status_message := _dict.get('status_message')) is not None:
            args['status_message'] = status_message
        if (log_url := _dict.get('log_url')) is not None:
            args['log_url'] = log_url
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a AgentDataRecentHealthJob object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'agent_id') and self.agent_id is not None:
            _dict['agent_id'] = self.agent_id
        if hasattr(self, 'job_id') and self.job_id is not None:
            _dict['job_id'] = self.job_id
        if hasattr(self, 'updated_at') and getattr(self, 'updated_at') is not None:
            _dict['updated_at'] = datetime_to_string(getattr(self, 'updated_at'))
        if hasattr(self, 'updated_by') and getattr(self, 'updated_by') is not None:
            _dict['updated_by'] = getattr(self, 'updated_by')
        if hasattr(self, 'agent_version') and getattr(self, 'agent_version') is not None:
            _dict['agent_version'] = getattr(self, 'agent_version')
        if hasattr(self, 'status_code') and self.status_code is not None:
            _dict['status_code'] = self.status_code
        if hasattr(self, 'status_message') and self.status_message is not None:
            _dict['status_message'] = self.status_message
        if hasattr(self, 'log_url') and self.log_url is not None:
            _dict['log_url'] = self.log_url
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this AgentDataRecentHealthJob object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'AgentDataRecentHealthJob') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'AgentDataRecentHealthJob') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

    class StatusCodeEnum(str, Enum):
        """
        Status of Jobs.
        """

        JOB_PENDING = 'job_pending'
        JOB_IN_PROGRESS = 'job_in_progress'
        JOB_FINISHED = 'job_finished'
        JOB_FAILED = 'job_failed'
        JOB_CANCELLED = 'job_cancelled'
        JOB_STOPPED = 'job_stopped'
        JOB_STOP_IN_PROGRESS = 'job_stop_in_progress'
        JOB_READY_TO_EXECUTE = 'job_ready_to_execute'


class AgentDataRecentPrsJob:
    """
    Run a pre-requisite scanner for deploying agent.

    :param str agent_id: (optional) Id of the agent.
    :param str job_id: (optional) Job Id.
    :param datetime updated_at: (optional) The agent prs job updation time.
    :param str updated_by: (optional) Email address of user who ran the agent prs
          job.
    :param str agent_version: (optional) Agent version.
    :param str status_code: (optional) Status of Jobs.
    :param str status_message: (optional) The outcome of the pre-requisite scanner
          job, in a formatted log string.
    :param str log_url: (optional) URL to the full pre-requisite scanner job logs.
    """

    def __init__(
        self,
        *,
        agent_id: Optional[str] = None,
        job_id: Optional[str] = None,
        updated_at: Optional[datetime] = None,
        updated_by: Optional[str] = None,
        agent_version: Optional[str] = None,
        status_code: Optional[str] = None,
        status_message: Optional[str] = None,
        log_url: Optional[str] = None,
    ) -> None:
        """
        Initialize a AgentDataRecentPrsJob object.

        :param str agent_id: (optional) Id of the agent.
        :param str job_id: (optional) Job Id.
        :param str status_code: (optional) Status of Jobs.
        :param str status_message: (optional) The outcome of the pre-requisite
               scanner job, in a formatted log string.
        :param str log_url: (optional) URL to the full pre-requisite scanner job
               logs.
        """
        self.agent_id = agent_id
        self.job_id = job_id
        self.updated_at = updated_at
        self.updated_by = updated_by
        self.agent_version = agent_version
        self.status_code = status_code
        self.status_message = status_message
        self.log_url = log_url

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'AgentDataRecentPrsJob':
        """Initialize a AgentDataRecentPrsJob object from a json dictionary."""
        args = {}
        if (agent_id := _dict.get('agent_id')) is not None:
            args['agent_id'] = agent_id
        if (job_id := _dict.get('job_id')) is not None:
            args['job_id'] = job_id
        if (updated_at := _dict.get('updated_at')) is not None:
            args['updated_at'] = string_to_datetime(updated_at)
        if (updated_by := _dict.get('updated_by')) is not None:
            args['updated_by'] = updated_by
        if (agent_version := _dict.get('agent_version')) is not None:
            args['agent_version'] = agent_version
        if (status_code := _dict.get('status_code')) is not None:
            args['status_code'] = status_code
        if (status_message := _dict.get('status_message')) is not None:
            args['status_message'] = status_message
        if (log_url := _dict.get('log_url')) is not None:
            args['log_url'] = log_url
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a AgentDataRecentPrsJob object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'agent_id') and self.agent_id is not None:
            _dict['agent_id'] = self.agent_id
        if hasattr(self, 'job_id') and self.job_id is not None:
            _dict['job_id'] = self.job_id
        if hasattr(self, 'updated_at') and getattr(self, 'updated_at') is not None:
            _dict['updated_at'] = datetime_to_string(getattr(self, 'updated_at'))
        if hasattr(self, 'updated_by') and getattr(self, 'updated_by') is not None:
            _dict['updated_by'] = getattr(self, 'updated_by')
        if hasattr(self, 'agent_version') and getattr(self, 'agent_version') is not None:
            _dict['agent_version'] = getattr(self, 'agent_version')
        if hasattr(self, 'status_code') and self.status_code is not None:
            _dict['status_code'] = self.status_code
        if hasattr(self, 'status_message') and self.status_message is not None:
            _dict['status_message'] = self.status_message
        if hasattr(self, 'log_url') and self.log_url is not None:
            _dict['log_url'] = self.log_url
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this AgentDataRecentPrsJob object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'AgentDataRecentPrsJob') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'AgentDataRecentPrsJob') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

    class StatusCodeEnum(str, Enum):
        """
        Status of Jobs.
        """

        JOB_PENDING = 'job_pending'
        JOB_IN_PROGRESS = 'job_in_progress'
        JOB_FINISHED = 'job_finished'
        JOB_FAILED = 'job_failed'
        JOB_CANCELLED = 'job_cancelled'
        JOB_STOPPED = 'job_stopped'
        JOB_STOP_IN_PROGRESS = 'job_stop_in_progress'
        JOB_READY_TO_EXECUTE = 'job_ready_to_execute'


class AgentDeployJob:
    """
    Post-installations checks for Agent health.

    :param str agent_id: (optional) Id of the agent.
    :param str job_id: (optional) Job Id.
    :param datetime updated_at: (optional) The agent deploy job updation time.
    :param str updated_by: (optional) Email address of user who ran the agent deploy
          job.
    :param bool is_redeployed: (optional) True, when the same version of the agent
          was redeployed.
    :param str agent_version: (optional) Agent version.
    :param str status_code: (optional) Status of Jobs.
    :param str status_message: (optional) The outcome of the agent deployment job,
          in a formatted log string.
    :param str log_url: (optional) URL to the full agent deployment job logs.
    """

    def __init__(
        self,
        *,
        agent_id: Optional[str] = None,
        job_id: Optional[str] = None,
        updated_at: Optional[datetime] = None,
        updated_by: Optional[str] = None,
        is_redeployed: Optional[bool] = None,
        agent_version: Optional[str] = None,
        status_code: Optional[str] = None,
        status_message: Optional[str] = None,
        log_url: Optional[str] = None,
    ) -> None:
        """
        Initialize a AgentDeployJob object.

        :param str agent_id: (optional) Id of the agent.
        :param str job_id: (optional) Job Id.
        :param bool is_redeployed: (optional) True, when the same version of the
               agent was redeployed.
        :param str status_code: (optional) Status of Jobs.
        :param str status_message: (optional) The outcome of the agent deployment
               job, in a formatted log string.
        :param str log_url: (optional) URL to the full agent deployment job logs.
        """
        self.agent_id = agent_id
        self.job_id = job_id
        self.updated_at = updated_at
        self.updated_by = updated_by
        self.is_redeployed = is_redeployed
        self.agent_version = agent_version
        self.status_code = status_code
        self.status_message = status_message
        self.log_url = log_url

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'AgentDeployJob':
        """Initialize a AgentDeployJob object from a json dictionary."""
        args = {}
        if (agent_id := _dict.get('agent_id')) is not None:
            args['agent_id'] = agent_id
        if (job_id := _dict.get('job_id')) is not None:
            args['job_id'] = job_id
        if (updated_at := _dict.get('updated_at')) is not None:
            args['updated_at'] = string_to_datetime(updated_at)
        if (updated_by := _dict.get('updated_by')) is not None:
            args['updated_by'] = updated_by
        if (is_redeployed := _dict.get('is_redeployed')) is not None:
            args['is_redeployed'] = is_redeployed
        if (agent_version := _dict.get('agent_version')) is not None:
            args['agent_version'] = agent_version
        if (status_code := _dict.get('status_code')) is not None:
            args['status_code'] = status_code
        if (status_message := _dict.get('status_message')) is not None:
            args['status_message'] = status_message
        if (log_url := _dict.get('log_url')) is not None:
            args['log_url'] = log_url
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a AgentDeployJob object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'agent_id') and self.agent_id is not None:
            _dict['agent_id'] = self.agent_id
        if hasattr(self, 'job_id') and self.job_id is not None:
            _dict['job_id'] = self.job_id
        if hasattr(self, 'updated_at') and getattr(self, 'updated_at') is not None:
            _dict['updated_at'] = datetime_to_string(getattr(self, 'updated_at'))
        if hasattr(self, 'updated_by') and getattr(self, 'updated_by') is not None:
            _dict['updated_by'] = getattr(self, 'updated_by')
        if hasattr(self, 'is_redeployed') and self.is_redeployed is not None:
            _dict['is_redeployed'] = self.is_redeployed
        if hasattr(self, 'agent_version') and getattr(self, 'agent_version') is not None:
            _dict['agent_version'] = getattr(self, 'agent_version')
        if hasattr(self, 'status_code') and self.status_code is not None:
            _dict['status_code'] = self.status_code
        if hasattr(self, 'status_message') and self.status_message is not None:
            _dict['status_message'] = self.status_message
        if hasattr(self, 'log_url') and self.log_url is not None:
            _dict['log_url'] = self.log_url
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this AgentDeployJob object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'AgentDeployJob') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'AgentDeployJob') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

    class StatusCodeEnum(str, Enum):
        """
        Status of Jobs.
        """

        JOB_PENDING = 'job_pending'
        JOB_IN_PROGRESS = 'job_in_progress'
        JOB_FINISHED = 'job_finished'
        JOB_FAILED = 'job_failed'
        JOB_CANCELLED = 'job_cancelled'
        JOB_STOPPED = 'job_stopped'
        JOB_STOP_IN_PROGRESS = 'job_stop_in_progress'
        JOB_READY_TO_EXECUTE = 'job_ready_to_execute'


class AgentHealthJob:
    """
    Agent health check.

    :param str agent_id: (optional) Id of the agent.
    :param str job_id: (optional) Job Id.
    :param datetime updated_at: (optional) The agent health check job updation time.
    :param str updated_by: (optional) Email address of user who ran the agent health
          check job.
    :param str agent_version: (optional) Agent version.
    :param str status_code: (optional) Status of Jobs.
    :param str status_message: (optional) The outcome of the health-check job, in a
          formatted log string.
    :param str log_url: (optional) URL to the full health-check job logs.
    """

    def __init__(
        self,
        *,
        agent_id: Optional[str] = None,
        job_id: Optional[str] = None,
        updated_at: Optional[datetime] = None,
        updated_by: Optional[str] = None,
        agent_version: Optional[str] = None,
        status_code: Optional[str] = None,
        status_message: Optional[str] = None,
        log_url: Optional[str] = None,
    ) -> None:
        """
        Initialize a AgentHealthJob object.

        :param str agent_id: (optional) Id of the agent.
        :param str job_id: (optional) Job Id.
        :param str status_code: (optional) Status of Jobs.
        :param str status_message: (optional) The outcome of the health-check job,
               in a formatted log string.
        :param str log_url: (optional) URL to the full health-check job logs.
        """
        self.agent_id = agent_id
        self.job_id = job_id
        self.updated_at = updated_at
        self.updated_by = updated_by
        self.agent_version = agent_version
        self.status_code = status_code
        self.status_message = status_message
        self.log_url = log_url

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'AgentHealthJob':
        """Initialize a AgentHealthJob object from a json dictionary."""
        args = {}
        if (agent_id := _dict.get('agent_id')) is not None:
            args['agent_id'] = agent_id
        if (job_id := _dict.get('job_id')) is not None:
            args['job_id'] = job_id
        if (updated_at := _dict.get('updated_at')) is not None:
            args['updated_at'] = string_to_datetime(updated_at)
        if (updated_by := _dict.get('updated_by')) is not None:
            args['updated_by'] = updated_by
        if (agent_version := _dict.get('agent_version')) is not None:
            args['agent_version'] = agent_version
        if (status_code := _dict.get('status_code')) is not None:
            args['status_code'] = status_code
        if (status_message := _dict.get('status_message')) is not None:
            args['status_message'] = status_message
        if (log_url := _dict.get('log_url')) is not None:
            args['log_url'] = log_url
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a AgentHealthJob object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'agent_id') and self.agent_id is not None:
            _dict['agent_id'] = self.agent_id
        if hasattr(self, 'job_id') and self.job_id is not None:
            _dict['job_id'] = self.job_id
        if hasattr(self, 'updated_at') and getattr(self, 'updated_at') is not None:
            _dict['updated_at'] = datetime_to_string(getattr(self, 'updated_at'))
        if hasattr(self, 'updated_by') and getattr(self, 'updated_by') is not None:
            _dict['updated_by'] = getattr(self, 'updated_by')
        if hasattr(self, 'agent_version') and getattr(self, 'agent_version') is not None:
            _dict['agent_version'] = getattr(self, 'agent_version')
        if hasattr(self, 'status_code') and self.status_code is not None:
            _dict['status_code'] = self.status_code
        if hasattr(self, 'status_message') and self.status_message is not None:
            _dict['status_message'] = self.status_message
        if hasattr(self, 'log_url') and self.log_url is not None:
            _dict['log_url'] = self.log_url
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this AgentHealthJob object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'AgentHealthJob') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'AgentHealthJob') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

    class StatusCodeEnum(str, Enum):
        """
        Status of Jobs.
        """

        JOB_PENDING = 'job_pending'
        JOB_IN_PROGRESS = 'job_in_progress'
        JOB_FINISHED = 'job_finished'
        JOB_FAILED = 'job_failed'
        JOB_CANCELLED = 'job_cancelled'
        JOB_STOPPED = 'job_stopped'
        JOB_STOP_IN_PROGRESS = 'job_stop_in_progress'
        JOB_READY_TO_EXECUTE = 'job_ready_to_execute'


class AgentInfo:
    """
    Agent name, Agent id and associated policy ID information.

    :param str id: (optional) ID of the Agent bound to the schematics object
          (workspace, action).
    :param str name: (optional) Name of the Agent bound to the schematics object.
    :param str assignment_policy_id: (optional) ID of the agent assignment policy,
          that is used to bind the Agent to schematics object.
    """

    def __init__(
        self,
        *,
        id: Optional[str] = None,
        name: Optional[str] = None,
        assignment_policy_id: Optional[str] = None,
    ) -> None:
        """
        Initialize a AgentInfo object.

        :param str id: (optional) ID of the Agent bound to the schematics object
               (workspace, action).
        :param str name: (optional) Name of the Agent bound to the schematics
               object.
        :param str assignment_policy_id: (optional) ID of the agent assignment
               policy, that is used to bind the Agent to schematics object.
        """
        self.id = id
        self.name = name
        self.assignment_policy_id = assignment_policy_id

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'AgentInfo':
        """Initialize a AgentInfo object from a json dictionary."""
        args = {}
        if (id := _dict.get('id')) is not None:
            args['id'] = id
        if (name := _dict.get('name')) is not None:
            args['name'] = name
        if (assignment_policy_id := _dict.get('assignment_policy_id')) is not None:
            args['assignment_policy_id'] = assignment_policy_id
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a AgentInfo object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'id') and self.id is not None:
            _dict['id'] = self.id
        if hasattr(self, 'name') and self.name is not None:
            _dict['name'] = self.name
        if hasattr(self, 'assignment_policy_id') and self.assignment_policy_id is not None:
            _dict['assignment_policy_id'] = self.assignment_policy_id
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this AgentInfo object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'AgentInfo') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'AgentInfo') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other


class AgentInfrastructure:
    """
    The infrastructure parameters used by the agent.

    :param str infra_type: (optional) Type of target agent infrastructure.
    :param str cluster_id: (optional) The cluster ID where agent services will be
          running.
    :param str cluster_resource_group: (optional) The resource group of the cluster
          (is it required?).
    :param str cos_instance_name: (optional) The COS instance name to store the
          agent logs.
    :param str cos_bucket_name: (optional) The COS bucket name used to store the
          logs.
    :param str cos_bucket_region: (optional) The COS bucket region.
    """

    def __init__(
        self,
        *,
        infra_type: Optional[str] = None,
        cluster_id: Optional[str] = None,
        cluster_resource_group: Optional[str] = None,
        cos_instance_name: Optional[str] = None,
        cos_bucket_name: Optional[str] = None,
        cos_bucket_region: Optional[str] = None,
    ) -> None:
        """
        Initialize a AgentInfrastructure object.

        :param str infra_type: (optional) Type of target agent infrastructure.
        :param str cluster_id: (optional) The cluster ID where agent services will
               be running.
        :param str cluster_resource_group: (optional) The resource group of the
               cluster (is it required?).
        :param str cos_instance_name: (optional) The COS instance name to store the
               agent logs.
        :param str cos_bucket_name: (optional) The COS bucket name used to store
               the logs.
        :param str cos_bucket_region: (optional) The COS bucket region.
        """
        self.infra_type = infra_type
        self.cluster_id = cluster_id
        self.cluster_resource_group = cluster_resource_group
        self.cos_instance_name = cos_instance_name
        self.cos_bucket_name = cos_bucket_name
        self.cos_bucket_region = cos_bucket_region

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'AgentInfrastructure':
        """Initialize a AgentInfrastructure object from a json dictionary."""
        args = {}
        if (infra_type := _dict.get('infra_type')) is not None:
            args['infra_type'] = infra_type
        if (cluster_id := _dict.get('cluster_id')) is not None:
            args['cluster_id'] = cluster_id
        if (cluster_resource_group := _dict.get('cluster_resource_group')) is not None:
            args['cluster_resource_group'] = cluster_resource_group
        if (cos_instance_name := _dict.get('cos_instance_name')) is not None:
            args['cos_instance_name'] = cos_instance_name
        if (cos_bucket_name := _dict.get('cos_bucket_name')) is not None:
            args['cos_bucket_name'] = cos_bucket_name
        if (cos_bucket_region := _dict.get('cos_bucket_region')) is not None:
            args['cos_bucket_region'] = cos_bucket_region
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a AgentInfrastructure object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'infra_type') and self.infra_type is not None:
            _dict['infra_type'] = self.infra_type
        if hasattr(self, 'cluster_id') and self.cluster_id is not None:
            _dict['cluster_id'] = self.cluster_id
        if hasattr(self, 'cluster_resource_group') and self.cluster_resource_group is not None:
            _dict['cluster_resource_group'] = self.cluster_resource_group
        if hasattr(self, 'cos_instance_name') and self.cos_instance_name is not None:
            _dict['cos_instance_name'] = self.cos_instance_name
        if hasattr(self, 'cos_bucket_name') and self.cos_bucket_name is not None:
            _dict['cos_bucket_name'] = self.cos_bucket_name
        if hasattr(self, 'cos_bucket_region') and self.cos_bucket_region is not None:
            _dict['cos_bucket_region'] = self.cos_bucket_region
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this AgentInfrastructure object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'AgentInfrastructure') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'AgentInfrastructure') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

    class InfraTypeEnum(str, Enum):
        """
        Type of target agent infrastructure.
        """

        IBM_KUBERNETES = 'ibm_kubernetes'
        IBM_OPENSHIFT = 'ibm_openshift'
        IBM_SATELLITE = 'ibm_satellite'


class AgentKPIData:
    """
    Schematics Agent key performance indicators.

    :param str availability_indicator: (optional) Overall availability indicator
          reported by the agent.
    :param str lifecycle_indicator: (optional) Overall lifecycle indicator reported
          by the agents.
    :param str percent_usage_indicator: (optional) Percentage usage of the agent
          resources.
    :param List[object] application_indicators: (optional) Agent application key
          performance indicators.
    :param List[object] infra_indicators: (optional) Agent infrastructure key
          performance indicators.
    """

    def __init__(
        self,
        *,
        availability_indicator: Optional[str] = None,
        lifecycle_indicator: Optional[str] = None,
        percent_usage_indicator: Optional[str] = None,
        application_indicators: Optional[List[object]] = None,
        infra_indicators: Optional[List[object]] = None,
    ) -> None:
        """
        Initialize a AgentKPIData object.

        :param str availability_indicator: (optional) Overall availability
               indicator reported by the agent.
        :param str lifecycle_indicator: (optional) Overall lifecycle indicator
               reported by the agents.
        :param str percent_usage_indicator: (optional) Percentage usage of the
               agent resources.
        :param List[object] application_indicators: (optional) Agent application
               key performance indicators.
        :param List[object] infra_indicators: (optional) Agent infrastructure key
               performance indicators.
        """
        self.availability_indicator = availability_indicator
        self.lifecycle_indicator = lifecycle_indicator
        self.percent_usage_indicator = percent_usage_indicator
        self.application_indicators = application_indicators
        self.infra_indicators = infra_indicators

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'AgentKPIData':
        """Initialize a AgentKPIData object from a json dictionary."""
        args = {}
        if (availability_indicator := _dict.get('availability_indicator')) is not None:
            args['availability_indicator'] = availability_indicator
        if (lifecycle_indicator := _dict.get('lifecycle_indicator')) is not None:
            args['lifecycle_indicator'] = lifecycle_indicator
        if (percent_usage_indicator := _dict.get('percent_usage_indicator')) is not None:
            args['percent_usage_indicator'] = percent_usage_indicator
        if (application_indicators := _dict.get('application_indicators')) is not None:
            args['application_indicators'] = application_indicators
        if (infra_indicators := _dict.get('infra_indicators')) is not None:
            args['infra_indicators'] = infra_indicators
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a AgentKPIData object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'availability_indicator') and self.availability_indicator is not None:
            _dict['availability_indicator'] = self.availability_indicator
        if hasattr(self, 'lifecycle_indicator') and self.lifecycle_indicator is not None:
            _dict['lifecycle_indicator'] = self.lifecycle_indicator
        if hasattr(self, 'percent_usage_indicator') and self.percent_usage_indicator is not None:
            _dict['percent_usage_indicator'] = self.percent_usage_indicator
        if hasattr(self, 'application_indicators') and self.application_indicators is not None:
            _dict['application_indicators'] = self.application_indicators
        if hasattr(self, 'infra_indicators') and self.infra_indicators is not None:
            _dict['infra_indicators'] = self.infra_indicators
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this AgentKPIData object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'AgentKPIData') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'AgentKPIData') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

    class AvailabilityIndicatorEnum(str, Enum):
        """
        Overall availability indicator reported by the agent.
        """

        AVAILABLE = 'available'
        UNAVAILABLE = 'unavailable'
        ERROR = 'error'

    class LifecycleIndicatorEnum(str, Enum):
        """
        Overall lifecycle indicator reported by the agents.
        """

        CONSISTENT = 'consistent'
        INCONSISTENT = 'inconsistent'
        OBSELETE = 'obselete'


class AgentKPIDataLite:
    """
    Schematics Agent key performance indicators' summary.

    :param str availability_indicator: (optional) Overall availability indicator
          reported by the agent.
    :param str lifecycle_indicator: (optional) Overall lifecycle indicator reported
          by the agents.
    :param str percent_usage_indicator: (optional) Percentage usage of the agent
          resources.
    """

    def __init__(
        self,
        *,
        availability_indicator: Optional[str] = None,
        lifecycle_indicator: Optional[str] = None,
        percent_usage_indicator: Optional[str] = None,
    ) -> None:
        """
        Initialize a AgentKPIDataLite object.

        :param str availability_indicator: (optional) Overall availability
               indicator reported by the agent.
        :param str lifecycle_indicator: (optional) Overall lifecycle indicator
               reported by the agents.
        :param str percent_usage_indicator: (optional) Percentage usage of the
               agent resources.
        """
        self.availability_indicator = availability_indicator
        self.lifecycle_indicator = lifecycle_indicator
        self.percent_usage_indicator = percent_usage_indicator

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'AgentKPIDataLite':
        """Initialize a AgentKPIDataLite object from a json dictionary."""
        args = {}
        if (availability_indicator := _dict.get('availability_indicator')) is not None:
            args['availability_indicator'] = availability_indicator
        if (lifecycle_indicator := _dict.get('lifecycle_indicator')) is not None:
            args['lifecycle_indicator'] = lifecycle_indicator
        if (percent_usage_indicator := _dict.get('percent_usage_indicator')) is not None:
            args['percent_usage_indicator'] = percent_usage_indicator
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a AgentKPIDataLite object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'availability_indicator') and self.availability_indicator is not None:
            _dict['availability_indicator'] = self.availability_indicator
        if hasattr(self, 'lifecycle_indicator') and self.lifecycle_indicator is not None:
            _dict['lifecycle_indicator'] = self.lifecycle_indicator
        if hasattr(self, 'percent_usage_indicator') and self.percent_usage_indicator is not None:
            _dict['percent_usage_indicator'] = self.percent_usage_indicator
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this AgentKPIDataLite object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'AgentKPIDataLite') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'AgentKPIDataLite') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

    class AvailabilityIndicatorEnum(str, Enum):
        """
        Overall availability indicator reported by the agent.
        """

        AVAILABLE = 'available'
        UNAVAILABLE = 'unavailable'
        ERROR = 'error'

    class LifecycleIndicatorEnum(str, Enum):
        """
        Overall lifecycle indicator reported by the agents.
        """

        CONSISTENT = 'consistent'
        INCONSISTENT = 'inconsistent'
        OBSELETE = 'obselete'


class AgentList:
    """
    The list of agent details.

    :param int total_count: (optional) The total number of records.
    :param int limit: (optional) The number of records returned.
    :param int offset: The skipped number of records.
    :param List[Agent] agents: (optional) The list of agents in the account.
    """

    def __init__(
        self,
        offset: int,
        *,
        total_count: Optional[int] = None,
        limit: Optional[int] = None,
        agents: Optional[List['Agent']] = None,
    ) -> None:
        """
        Initialize a AgentList object.

        :param int offset: The skipped number of records.
        :param List[Agent] agents: (optional) The list of agents in the account.
        """
        self.total_count = total_count
        self.limit = limit
        self.offset = offset
        self.agents = agents

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'AgentList':
        """Initialize a AgentList object from a json dictionary."""
        args = {}
        if (total_count := _dict.get('total_count')) is not None:
            args['total_count'] = total_count
        if (limit := _dict.get('limit')) is not None:
            args['limit'] = limit
        if (offset := _dict.get('offset')) is not None:
            args['offset'] = offset
        else:
            raise ValueError('Required property \'offset\' not present in AgentList JSON')
        if (agents := _dict.get('agents')) is not None:
            args['agents'] = [Agent.from_dict(v) for v in agents]
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a AgentList object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'total_count') and getattr(self, 'total_count') is not None:
            _dict['total_count'] = getattr(self, 'total_count')
        if hasattr(self, 'limit') and getattr(self, 'limit') is not None:
            _dict['limit'] = getattr(self, 'limit')
        if hasattr(self, 'offset') and self.offset is not None:
            _dict['offset'] = self.offset
        if hasattr(self, 'agents') and self.agents is not None:
            agents_list = []
            for v in self.agents:
                if isinstance(v, dict):
                    agents_list.append(v)
                else:
                    agents_list.append(v.to_dict())
            _dict['agents'] = agents_list
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this AgentList object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'AgentList') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'AgentList') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other


class AgentMetadataInfo:
    """
    AgentMetadataInfo.

    :param str name: (optional) Name of the metadata.
    :param List[str] value: (optional) Value of the metadata name.
    """

    def __init__(
        self,
        *,
        name: Optional[str] = None,
        value: Optional[List[str]] = None,
    ) -> None:
        """
        Initialize a AgentMetadataInfo object.

        :param str name: (optional) Name of the metadata.
        :param List[str] value: (optional) Value of the metadata name.
        """
        self.name = name
        self.value = value

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'AgentMetadataInfo':
        """Initialize a AgentMetadataInfo object from a json dictionary."""
        args = {}
        if (name := _dict.get('name')) is not None:
            args['name'] = name
        if (value := _dict.get('value')) is not None:
            args['value'] = value
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a AgentMetadataInfo object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'name') and self.name is not None:
            _dict['name'] = self.name
        if hasattr(self, 'value') and self.value is not None:
            _dict['value'] = self.value
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this AgentMetadataInfo object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'AgentMetadataInfo') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'AgentMetadataInfo') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other


class AgentPRSJob:
    """
    Run a pre-requisite scanner for deploying agent.

    :param str agent_id: (optional) Id of the agent.
    :param str job_id: (optional) Job Id.
    :param datetime updated_at: (optional) The agent prs job updation time.
    :param str updated_by: (optional) Email address of user who ran the agent prs
          job.
    :param str agent_version: (optional) Agent version.
    :param str status_code: (optional) Status of Jobs.
    :param str status_message: (optional) The outcome of the pre-requisite scanner
          job, in a formatted log string.
    :param str log_url: (optional) URL to the full pre-requisite scanner job logs.
    """

    def __init__(
        self,
        *,
        agent_id: Optional[str] = None,
        job_id: Optional[str] = None,
        updated_at: Optional[datetime] = None,
        updated_by: Optional[str] = None,
        agent_version: Optional[str] = None,
        status_code: Optional[str] = None,
        status_message: Optional[str] = None,
        log_url: Optional[str] = None,
    ) -> None:
        """
        Initialize a AgentPRSJob object.

        :param str agent_id: (optional) Id of the agent.
        :param str job_id: (optional) Job Id.
        :param str status_code: (optional) Status of Jobs.
        :param str status_message: (optional) The outcome of the pre-requisite
               scanner job, in a formatted log string.
        :param str log_url: (optional) URL to the full pre-requisite scanner job
               logs.
        """
        self.agent_id = agent_id
        self.job_id = job_id
        self.updated_at = updated_at
        self.updated_by = updated_by
        self.agent_version = agent_version
        self.status_code = status_code
        self.status_message = status_message
        self.log_url = log_url

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'AgentPRSJob':
        """Initialize a AgentPRSJob object from a json dictionary."""
        args = {}
        if (agent_id := _dict.get('agent_id')) is not None:
            args['agent_id'] = agent_id
        if (job_id := _dict.get('job_id')) is not None:
            args['job_id'] = job_id
        if (updated_at := _dict.get('updated_at')) is not None:
            args['updated_at'] = string_to_datetime(updated_at)
        if (updated_by := _dict.get('updated_by')) is not None:
            args['updated_by'] = updated_by
        if (agent_version := _dict.get('agent_version')) is not None:
            args['agent_version'] = agent_version
        if (status_code := _dict.get('status_code')) is not None:
            args['status_code'] = status_code
        if (status_message := _dict.get('status_message')) is not None:
            args['status_message'] = status_message
        if (log_url := _dict.get('log_url')) is not None:
            args['log_url'] = log_url
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a AgentPRSJob object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'agent_id') and self.agent_id is not None:
            _dict['agent_id'] = self.agent_id
        if hasattr(self, 'job_id') and self.job_id is not None:
            _dict['job_id'] = self.job_id
        if hasattr(self, 'updated_at') and getattr(self, 'updated_at') is not None:
            _dict['updated_at'] = datetime_to_string(getattr(self, 'updated_at'))
        if hasattr(self, 'updated_by') and getattr(self, 'updated_by') is not None:
            _dict['updated_by'] = getattr(self, 'updated_by')
        if hasattr(self, 'agent_version') and getattr(self, 'agent_version') is not None:
            _dict['agent_version'] = getattr(self, 'agent_version')
        if hasattr(self, 'status_code') and self.status_code is not None:
            _dict['status_code'] = self.status_code
        if hasattr(self, 'status_message') and self.status_message is not None:
            _dict['status_message'] = self.status_message
        if hasattr(self, 'log_url') and self.log_url is not None:
            _dict['log_url'] = self.log_url
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this AgentPRSJob object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'AgentPRSJob') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'AgentPRSJob') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

    class StatusCodeEnum(str, Enum):
        """
        Status of Jobs.
        """

        JOB_PENDING = 'job_pending'
        JOB_IN_PROGRESS = 'job_in_progress'
        JOB_FINISHED = 'job_finished'
        JOB_FAILED = 'job_failed'
        JOB_CANCELLED = 'job_cancelled'
        JOB_STOPPED = 'job_stopped'
        JOB_STOP_IN_PROGRESS = 'job_stop_in_progress'
        JOB_READY_TO_EXECUTE = 'job_ready_to_execute'


class AgentSystemStatus:
    """
    Computed state of the agent.

    :param str status_code: (optional) Agent Status.
    :param str status_message: (optional) The agent status message.
    """

    def __init__(
        self,
        *,
        status_code: Optional[str] = None,
        status_message: Optional[str] = None,
    ) -> None:
        """
        Initialize a AgentSystemStatus object.

        :param str status_code: (optional) Agent Status.
        :param str status_message: (optional) The agent status message.
        """
        self.status_code = status_code
        self.status_message = status_message

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'AgentSystemStatus':
        """Initialize a AgentSystemStatus object from a json dictionary."""
        args = {}
        if (status_code := _dict.get('status_code')) is not None:
            args['status_code'] = status_code
        if (status_message := _dict.get('status_message')) is not None:
            args['status_message'] = status_message
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a AgentSystemStatus object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'status_code') and self.status_code is not None:
            _dict['status_code'] = self.status_code
        if hasattr(self, 'status_message') and self.status_message is not None:
            _dict['status_message'] = self.status_message
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this AgentSystemStatus object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'AgentSystemStatus') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'AgentSystemStatus') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

    class StatusCodeEnum(str, Enum):
        """
        Agent Status.
        """

        ERROR = 'error'
        NORMAL = 'normal'
        IN_PROGRESS = 'in_progress'
        PENDING = 'pending'
        DRAFT = 'draft'


class AgentUserState:
    """
    User defined status of the agent.

    :param str state: (optional) User-defined states
            * `enable`  Agent is enabled by the user.
            * `disable` Agent is disbaled by the user.
    :param str set_by: (optional) Name of the User who set the state of the Object.
    :param datetime set_at: (optional) When the User who set the state of the
          Object.
    """

    def __init__(
        self,
        *,
        state: Optional[str] = None,
        set_by: Optional[str] = None,
        set_at: Optional[datetime] = None,
    ) -> None:
        """
        Initialize a AgentUserState object.

        :param str state: (optional) User-defined states
                 * `enable`  Agent is enabled by the user.
                 * `disable` Agent is disbaled by the user.
        """
        self.state = state
        self.set_by = set_by
        self.set_at = set_at

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'AgentUserState':
        """Initialize a AgentUserState object from a json dictionary."""
        args = {}
        if (state := _dict.get('state')) is not None:
            args['state'] = state
        if (set_by := _dict.get('set_by')) is not None:
            args['set_by'] = set_by
        if (set_at := _dict.get('set_at')) is not None:
            args['set_at'] = string_to_datetime(set_at)
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a AgentUserState object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'state') and self.state is not None:
            _dict['state'] = self.state
        if hasattr(self, 'set_by') and getattr(self, 'set_by') is not None:
            _dict['set_by'] = getattr(self, 'set_by')
        if hasattr(self, 'set_at') and getattr(self, 'set_at') is not None:
            _dict['set_at'] = datetime_to_string(getattr(self, 'set_at'))
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this AgentUserState object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'AgentUserState') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'AgentUserState') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

    class StateEnum(str, Enum):
        """
        User-defined states
          * `enable`  Agent is enabled by the user.
          * `disable` Agent is disbaled by the user.
        """

        ENABLE = 'enable'
        DISABLE = 'disable'


class AgentVersionInfo:
    """
    An item in list of all the versions available.

    :param str display_name: (optional) The display name of the agent version.
    :param str agent_version: (optional) The version of the agent.
    """

    def __init__(
        self,
        *,
        display_name: Optional[str] = None,
        agent_version: Optional[str] = None,
    ) -> None:
        """
        Initialize a AgentVersionInfo object.

        :param str display_name: (optional) The display name of the agent version.
        :param str agent_version: (optional) The version of the agent.
        """
        self.display_name = display_name
        self.agent_version = agent_version

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'AgentVersionInfo':
        """Initialize a AgentVersionInfo object from a json dictionary."""
        args = {}
        if (display_name := _dict.get('display_name')) is not None:
            args['display_name'] = display_name
        if (agent_version := _dict.get('agent_version')) is not None:
            args['agent_version'] = agent_version
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a AgentVersionInfo object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'display_name') and self.display_name is not None:
            _dict['display_name'] = self.display_name
        if hasattr(self, 'agent_version') and self.agent_version is not None:
            _dict['agent_version'] = self.agent_version
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this AgentVersionInfo object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'AgentVersionInfo') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'AgentVersionInfo') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other


class AgentVersions:
    """
    Agent versions available to be deployed.

    :param List[AgentVersionInfo] supported_agent_versions: (optional) list of the
          versions supported.
    """

    def __init__(
        self,
        *,
        supported_agent_versions: Optional[List['AgentVersionInfo']] = None,
    ) -> None:
        """
        Initialize a AgentVersions object.

        :param List[AgentVersionInfo] supported_agent_versions: (optional) list of
               the versions supported.
        """
        self.supported_agent_versions = supported_agent_versions

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'AgentVersions':
        """Initialize a AgentVersions object from a json dictionary."""
        args = {}
        if (supported_agent_versions := _dict.get('supported_agent_versions')) is not None:
            args['supported_agent_versions'] = [AgentVersionInfo.from_dict(v) for v in supported_agent_versions]
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a AgentVersions object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'supported_agent_versions') and self.supported_agent_versions is not None:
            supported_agent_versions_list = []
            for v in self.supported_agent_versions:
                if isinstance(v, dict):
                    supported_agent_versions_list.append(v)
                else:
                    supported_agent_versions_list.append(v.to_dict())
            _dict['supported_agent_versions'] = supported_agent_versions_list
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this AgentVersions object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'AgentVersions') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'AgentVersions') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other


class AgentSystemState:
    """
    Computed state of the agent.

    :param str state: (optional) Agent Status.
    :param str message: (optional) The Agent status message.
    """

    def __init__(
        self,
        *,
        state: Optional[str] = None,
        message: Optional[str] = None,
    ) -> None:
        """
        Initialize a AgentSystemState object.

        :param str state: (optional) Agent Status.
        :param str message: (optional) The Agent status message.
        """
        self.state = state
        self.message = message

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'AgentSystemState':
        """Initialize a AgentSystemState object from a json dictionary."""
        args = {}
        if (state := _dict.get('state')) is not None:
            args['state'] = state
        if (message := _dict.get('message')) is not None:
            args['message'] = message
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a AgentSystemState object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'state') and self.state is not None:
            _dict['state'] = self.state
        if hasattr(self, 'message') and self.message is not None:
            _dict['message'] = self.message
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this AgentSystemState object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'AgentSystemState') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'AgentSystemState') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

    class StateEnum(str, Enum):
        """
        Agent Status.
        """

        ERROR = 'error'
        NORMAL = 'normal'
        IN_PROGRESS = 'in_progress'
        PENDING = 'pending'
        DRAFT = 'draft'


class BastionResourceDefinition:
    """
    Describes a bastion resource.

    :param str name: (optional) Bastion Name; the name must be unique.
    :param str host: (optional) Reference to the Inventory resource definition.
    """

    def __init__(
        self,
        *,
        name: Optional[str] = None,
        host: Optional[str] = None,
    ) -> None:
        """
        Initialize a BastionResourceDefinition object.

        :param str name: (optional) Bastion Name; the name must be unique.
        :param str host: (optional) Reference to the Inventory resource definition.
        """
        self.name = name
        self.host = host

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'BastionResourceDefinition':
        """Initialize a BastionResourceDefinition object from a json dictionary."""
        args = {}
        if (name := _dict.get('name')) is not None:
            args['name'] = name
        if (host := _dict.get('host')) is not None:
            args['host'] = host
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a BastionResourceDefinition object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'name') and self.name is not None:
            _dict['name'] = self.name
        if hasattr(self, 'host') and self.host is not None:
            _dict['host'] = self.host
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this BastionResourceDefinition object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'BastionResourceDefinition') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'BastionResourceDefinition') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other


class CartOrderData:
    """
    Schematics Cart Order Data.

    :param str name: (optional) Name of the property.
    :param str value: (optional) Value of the property.
    :param str type: (optional) Type of the values(string, int etc).
    :param List[str] usage_kind: (optional) List of usage kind how the cart data can
          be used.
    """

    def __init__(
        self,
        *,
        name: Optional[str] = None,
        value: Optional[str] = None,
        type: Optional[str] = None,
        usage_kind: Optional[List[str]] = None,
    ) -> None:
        """
        Initialize a CartOrderData object.

        :param str name: (optional) Name of the property.
        :param str value: (optional) Value of the property.
        :param str type: (optional) Type of the values(string, int etc).
        :param List[str] usage_kind: (optional) List of usage kind how the cart
               data can be used.
        """
        self.name = name
        self.value = value
        self.type = type
        self.usage_kind = usage_kind

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'CartOrderData':
        """Initialize a CartOrderData object from a json dictionary."""
        args = {}
        if (name := _dict.get('name')) is not None:
            args['name'] = name
        if (value := _dict.get('value')) is not None:
            args['value'] = value
        if (type := _dict.get('type')) is not None:
            args['type'] = type
        if (usage_kind := _dict.get('usage_kind')) is not None:
            args['usage_kind'] = usage_kind
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a CartOrderData object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'name') and self.name is not None:
            _dict['name'] = self.name
        if hasattr(self, 'value') and self.value is not None:
            _dict['value'] = self.value
        if hasattr(self, 'type') and self.type is not None:
            _dict['type'] = self.type
        if hasattr(self, 'usage_kind') and self.usage_kind is not None:
            _dict['usage_kind'] = self.usage_kind
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this CartOrderData object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'CartOrderData') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'CartOrderData') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

    class UsageKindEnum(str, Enum):
        """
        Options how the cart order data can be used.
        """

        SERVICETAGS = 'servicetags'


class CatalogRef:
    """
    Information about the software template that you chose from the IBM Cloud catalog.
    This information is returned for IBM Cloud catalog offerings only.

    :param bool dry_run: (optional) Dry run.
    :param str owning_account: (optional) Owning account ID of the catalog.
    :param str item_icon_url: (optional) The URL to the icon of the software
          template in the IBM Cloud catalog.
    :param str item_id: (optional) The ID of the software template that you chose to
          install from the IBM Cloud catalog. This software is provisioned with
          Schematics.
    :param str item_name: (optional) The name of the software that you chose to
          install from the IBM Cloud catalog.
    :param str item_readme_url: (optional) The URL to the readme file of the
          software template in the IBM Cloud catalog.
    :param str item_url: (optional) The URL to the software template in the IBM
          Cloud catalog.
    :param str launch_url: (optional) The URL to the dashboard to access your
          software.
    :param str offering_version: (optional) The version of the software template
          that you chose to install from the IBM Cloud catalog.
    :param List[ServiceExtensions] service_extensions: (optional)
    """

    def __init__(
        self,
        *,
        dry_run: Optional[bool] = None,
        owning_account: Optional[str] = None,
        item_icon_url: Optional[str] = None,
        item_id: Optional[str] = None,
        item_name: Optional[str] = None,
        item_readme_url: Optional[str] = None,
        item_url: Optional[str] = None,
        launch_url: Optional[str] = None,
        offering_version: Optional[str] = None,
        service_extensions: Optional[List['ServiceExtensions']] = None,
    ) -> None:
        """
        Initialize a CatalogRef object.

        :param bool dry_run: (optional) Dry run.
        :param str owning_account: (optional) Owning account ID of the catalog.
        :param str item_icon_url: (optional) The URL to the icon of the software
               template in the IBM Cloud catalog.
        :param str item_id: (optional) The ID of the software template that you
               chose to install from the IBM Cloud catalog. This software is provisioned
               with Schematics.
        :param str item_name: (optional) The name of the software that you chose to
               install from the IBM Cloud catalog.
        :param str item_readme_url: (optional) The URL to the readme file of the
               software template in the IBM Cloud catalog.
        :param str item_url: (optional) The URL to the software template in the IBM
               Cloud catalog.
        :param str launch_url: (optional) The URL to the dashboard to access your
               software.
        :param str offering_version: (optional) The version of the software
               template that you chose to install from the IBM Cloud catalog.
        :param List[ServiceExtensions] service_extensions: (optional)
        """
        self.dry_run = dry_run
        self.owning_account = owning_account
        self.item_icon_url = item_icon_url
        self.item_id = item_id
        self.item_name = item_name
        self.item_readme_url = item_readme_url
        self.item_url = item_url
        self.launch_url = launch_url
        self.offering_version = offering_version
        self.service_extensions = service_extensions

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'CatalogRef':
        """Initialize a CatalogRef object from a json dictionary."""
        args = {}
        if (dry_run := _dict.get('dry_run')) is not None:
            args['dry_run'] = dry_run
        if (owning_account := _dict.get('owning_account')) is not None:
            args['owning_account'] = owning_account
        if (item_icon_url := _dict.get('item_icon_url')) is not None:
            args['item_icon_url'] = item_icon_url
        if (item_id := _dict.get('item_id')) is not None:
            args['item_id'] = item_id
        if (item_name := _dict.get('item_name')) is not None:
            args['item_name'] = item_name
        if (item_readme_url := _dict.get('item_readme_url')) is not None:
            args['item_readme_url'] = item_readme_url
        if (item_url := _dict.get('item_url')) is not None:
            args['item_url'] = item_url
        if (launch_url := _dict.get('launch_url')) is not None:
            args['launch_url'] = launch_url
        if (offering_version := _dict.get('offering_version')) is not None:
            args['offering_version'] = offering_version
        if (service_extensions := _dict.get('service_extensions')) is not None:
            args['service_extensions'] = [ServiceExtensions.from_dict(v) for v in service_extensions]
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a CatalogRef object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'dry_run') and self.dry_run is not None:
            _dict['dry_run'] = self.dry_run
        if hasattr(self, 'owning_account') and self.owning_account is not None:
            _dict['owning_account'] = self.owning_account
        if hasattr(self, 'item_icon_url') and self.item_icon_url is not None:
            _dict['item_icon_url'] = self.item_icon_url
        if hasattr(self, 'item_id') and self.item_id is not None:
            _dict['item_id'] = self.item_id
        if hasattr(self, 'item_name') and self.item_name is not None:
            _dict['item_name'] = self.item_name
        if hasattr(self, 'item_readme_url') and self.item_readme_url is not None:
            _dict['item_readme_url'] = self.item_readme_url
        if hasattr(self, 'item_url') and self.item_url is not None:
            _dict['item_url'] = self.item_url
        if hasattr(self, 'launch_url') and self.launch_url is not None:
            _dict['launch_url'] = self.launch_url
        if hasattr(self, 'offering_version') and self.offering_version is not None:
            _dict['offering_version'] = self.offering_version
        if hasattr(self, 'service_extensions') and self.service_extensions is not None:
            service_extensions_list = []
            for v in self.service_extensions:
                if isinstance(v, dict):
                    service_extensions_list.append(v)
                else:
                    service_extensions_list.append(v.to_dict())
            _dict['service_extensions'] = service_extensions_list
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this CatalogRef object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'CatalogRef') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'CatalogRef') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other


class CatalogSource:
    """
    The connection details to the IBM Cloud Catalog source.

    :param str catalog_name: (optional) The name of the private catalog.
    :param str catalog_id: (optional) The ID of a private catalog.
    :param str offering_name: (optional) The name of an offering in the IBM Cloud
          Catalog.
    :param str offering_version: (optional) The version of the software template
          that you chose to install from the IBM Cloud catalog.
    :param str offering_kind: (optional) The type of an offering, in the IBM Cloud
          Catalog.
    :param str offering_target_kind: (optional) Offering Target Kind.
    :param str offering_id: (optional) The ID of an offering in the IBM Cloud
          Catalog.
    :param str offering_version_id: (optional) The ID of an offering version the IBM
          Cloud Catalog.
    :param str offering_version_flavour_name: (optional) Offering version flavour
          name.
    :param str offering_repo_url: (optional) The repository URL of an offering, in
          the IBM Cloud Catalog.
    :param str offering_provisioner_working_directory: (optional) Root folder name
          in .tgz file.
    :param bool dry_run: (optional) Dry run.
    :param str owning_account: (optional) Owning account ID of the catalog.
    :param str item_icon_url: (optional) The URL to the icon of the software
          template in the IBM Cloud catalog.
    :param str item_id: (optional) The ID of the software template that you chose to
          install from the IBM Cloud catalog. This software is provisioned with
          Schematics.
    :param str item_name: (optional) The name of the software that you chose to
          install from the IBM Cloud catalog.
    :param str item_readme_url: (optional) The URL to the readme file of the
          software template in the IBM Cloud catalog.
    :param str item_url: (optional) The URL to the software template in the IBM
          Cloud catalog.
    :param str launch_url: (optional) The URL to the dashboard to access your
          software.
    """

    def __init__(
        self,
        *,
        catalog_name: Optional[str] = None,
        catalog_id: Optional[str] = None,
        offering_name: Optional[str] = None,
        offering_version: Optional[str] = None,
        offering_kind: Optional[str] = None,
        offering_target_kind: Optional[str] = None,
        offering_id: Optional[str] = None,
        offering_version_id: Optional[str] = None,
        offering_version_flavour_name: Optional[str] = None,
        offering_repo_url: Optional[str] = None,
        offering_provisioner_working_directory: Optional[str] = None,
        dry_run: Optional[bool] = None,
        owning_account: Optional[str] = None,
        item_icon_url: Optional[str] = None,
        item_id: Optional[str] = None,
        item_name: Optional[str] = None,
        item_readme_url: Optional[str] = None,
        item_url: Optional[str] = None,
        launch_url: Optional[str] = None,
    ) -> None:
        """
        Initialize a CatalogSource object.

        :param str catalog_name: (optional) The name of the private catalog.
        :param str catalog_id: (optional) The ID of a private catalog.
        :param str offering_name: (optional) The name of an offering in the IBM
               Cloud Catalog.
        :param str offering_version: (optional) The version of the software
               template that you chose to install from the IBM Cloud catalog.
        :param str offering_kind: (optional) The type of an offering, in the IBM
               Cloud Catalog.
        :param str offering_target_kind: (optional) Offering Target Kind.
        :param str offering_id: (optional) The ID of an offering in the IBM Cloud
               Catalog.
        :param str offering_version_id: (optional) The ID of an offering version
               the IBM Cloud Catalog.
        :param str offering_version_flavour_name: (optional) Offering version
               flavour name.
        :param str offering_repo_url: (optional) The repository URL of an offering,
               in the IBM Cloud Catalog.
        :param str offering_provisioner_working_directory: (optional) Root folder
               name in .tgz file.
        :param bool dry_run: (optional) Dry run.
        :param str owning_account: (optional) Owning account ID of the catalog.
        :param str item_icon_url: (optional) The URL to the icon of the software
               template in the IBM Cloud catalog.
        :param str item_id: (optional) The ID of the software template that you
               chose to install from the IBM Cloud catalog. This software is provisioned
               with Schematics.
        :param str item_name: (optional) The name of the software that you chose to
               install from the IBM Cloud catalog.
        :param str item_readme_url: (optional) The URL to the readme file of the
               software template in the IBM Cloud catalog.
        :param str item_url: (optional) The URL to the software template in the IBM
               Cloud catalog.
        :param str launch_url: (optional) The URL to the dashboard to access your
               software.
        """
        self.catalog_name = catalog_name
        self.catalog_id = catalog_id
        self.offering_name = offering_name
        self.offering_version = offering_version
        self.offering_kind = offering_kind
        self.offering_target_kind = offering_target_kind
        self.offering_id = offering_id
        self.offering_version_id = offering_version_id
        self.offering_version_flavour_name = offering_version_flavour_name
        self.offering_repo_url = offering_repo_url
        self.offering_provisioner_working_directory = offering_provisioner_working_directory
        self.dry_run = dry_run
        self.owning_account = owning_account
        self.item_icon_url = item_icon_url
        self.item_id = item_id
        self.item_name = item_name
        self.item_readme_url = item_readme_url
        self.item_url = item_url
        self.launch_url = launch_url

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'CatalogSource':
        """Initialize a CatalogSource object from a json dictionary."""
        args = {}
        if (catalog_name := _dict.get('catalog_name')) is not None:
            args['catalog_name'] = catalog_name
        if (catalog_id := _dict.get('catalog_id')) is not None:
            args['catalog_id'] = catalog_id
        if (offering_name := _dict.get('offering_name')) is not None:
            args['offering_name'] = offering_name
        if (offering_version := _dict.get('offering_version')) is not None:
            args['offering_version'] = offering_version
        if (offering_kind := _dict.get('offering_kind')) is not None:
            args['offering_kind'] = offering_kind
        if (offering_target_kind := _dict.get('offering_target_kind')) is not None:
            args['offering_target_kind'] = offering_target_kind
        if (offering_id := _dict.get('offering_id')) is not None:
            args['offering_id'] = offering_id
        if (offering_version_id := _dict.get('offering_version_id')) is not None:
            args['offering_version_id'] = offering_version_id
        if (offering_version_flavour_name := _dict.get('offering_version_flavour_name')) is not None:
            args['offering_version_flavour_name'] = offering_version_flavour_name
        if (offering_repo_url := _dict.get('offering_repo_url')) is not None:
            args['offering_repo_url'] = offering_repo_url
        if (offering_provisioner_working_directory := _dict.get('offering_provisioner_working_directory')) is not None:
            args['offering_provisioner_working_directory'] = offering_provisioner_working_directory
        if (dry_run := _dict.get('dry_run')) is not None:
            args['dry_run'] = dry_run
        if (owning_account := _dict.get('owning_account')) is not None:
            args['owning_account'] = owning_account
        if (item_icon_url := _dict.get('item_icon_url')) is not None:
            args['item_icon_url'] = item_icon_url
        if (item_id := _dict.get('item_id')) is not None:
            args['item_id'] = item_id
        if (item_name := _dict.get('item_name')) is not None:
            args['item_name'] = item_name
        if (item_readme_url := _dict.get('item_readme_url')) is not None:
            args['item_readme_url'] = item_readme_url
        if (item_url := _dict.get('item_url')) is not None:
            args['item_url'] = item_url
        if (launch_url := _dict.get('launch_url')) is not None:
            args['launch_url'] = launch_url
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a CatalogSource object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'catalog_name') and self.catalog_name is not None:
            _dict['catalog_name'] = self.catalog_name
        if hasattr(self, 'catalog_id') and self.catalog_id is not None:
            _dict['catalog_id'] = self.catalog_id
        if hasattr(self, 'offering_name') and self.offering_name is not None:
            _dict['offering_name'] = self.offering_name
        if hasattr(self, 'offering_version') and self.offering_version is not None:
            _dict['offering_version'] = self.offering_version
        if hasattr(self, 'offering_kind') and self.offering_kind is not None:
            _dict['offering_kind'] = self.offering_kind
        if hasattr(self, 'offering_target_kind') and self.offering_target_kind is not None:
            _dict['offering_target_kind'] = self.offering_target_kind
        if hasattr(self, 'offering_id') and self.offering_id is not None:
            _dict['offering_id'] = self.offering_id
        if hasattr(self, 'offering_version_id') and self.offering_version_id is not None:
            _dict['offering_version_id'] = self.offering_version_id
        if hasattr(self, 'offering_version_flavour_name') and self.offering_version_flavour_name is not None:
            _dict['offering_version_flavour_name'] = self.offering_version_flavour_name
        if hasattr(self, 'offering_repo_url') and self.offering_repo_url is not None:
            _dict['offering_repo_url'] = self.offering_repo_url
        if (
            hasattr(self, 'offering_provisioner_working_directory')
            and self.offering_provisioner_working_directory is not None
        ):
            _dict['offering_provisioner_working_directory'] = self.offering_provisioner_working_directory
        if hasattr(self, 'dry_run') and self.dry_run is not None:
            _dict['dry_run'] = self.dry_run
        if hasattr(self, 'owning_account') and self.owning_account is not None:
            _dict['owning_account'] = self.owning_account
        if hasattr(self, 'item_icon_url') and self.item_icon_url is not None:
            _dict['item_icon_url'] = self.item_icon_url
        if hasattr(self, 'item_id') and self.item_id is not None:
            _dict['item_id'] = self.item_id
        if hasattr(self, 'item_name') and self.item_name is not None:
            _dict['item_name'] = self.item_name
        if hasattr(self, 'item_readme_url') and self.item_readme_url is not None:
            _dict['item_readme_url'] = self.item_readme_url
        if hasattr(self, 'item_url') and self.item_url is not None:
            _dict['item_url'] = self.item_url
        if hasattr(self, 'launch_url') and self.launch_url is not None:
            _dict['launch_url'] = self.launch_url
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this CatalogSource object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'CatalogSource') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'CatalogSource') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other


class CommandsInfo:
    """
    Workspace commands run as part of the job.

    :param str name: (optional) Name of the command.
    :param str outcome: (optional) outcome of the command.
    """

    def __init__(
        self,
        *,
        name: Optional[str] = None,
        outcome: Optional[str] = None,
    ) -> None:
        """
        Initialize a CommandsInfo object.

        :param str name: (optional) Name of the command.
        :param str outcome: (optional) outcome of the command.
        """
        self.name = name
        self.outcome = outcome

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'CommandsInfo':
        """Initialize a CommandsInfo object from a json dictionary."""
        args = {}
        if (name := _dict.get('name')) is not None:
            args['name'] = name
        if (outcome := _dict.get('outcome')) is not None:
            args['outcome'] = outcome
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a CommandsInfo object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'name') and self.name is not None:
            _dict['name'] = self.name
        if hasattr(self, 'outcome') and self.outcome is not None:
            _dict['outcome'] = self.outcome
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this CommandsInfo object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'CommandsInfo') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'CommandsInfo') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other


class ConnectionState:
    """
    Connection status of the agent.

    :param str state: (optional) Agent Connection Status
            * `Connected` When Schematics is able to connect to the agent.
            * `Disconnected` When Schematics is able not connect to the agent.
    :param datetime checked_at: (optional) When the connection state is modified.
    """

    def __init__(
        self,
        *,
        state: Optional[str] = None,
        checked_at: Optional[datetime] = None,
    ) -> None:
        """
        Initialize a ConnectionState object.

        :param str state: (optional) Agent Connection Status
                 * `Connected` When Schematics is able to connect to the agent.
                 * `Disconnected` When Schematics is able not connect to the agent.
        :param datetime checked_at: (optional) When the connection state is
               modified.
        """
        self.state = state
        self.checked_at = checked_at

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'ConnectionState':
        """Initialize a ConnectionState object from a json dictionary."""
        args = {}
        if (state := _dict.get('state')) is not None:
            args['state'] = state
        if (checked_at := _dict.get('checked_at')) is not None:
            args['checked_at'] = string_to_datetime(checked_at)
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a ConnectionState object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'state') and self.state is not None:
            _dict['state'] = self.state
        if hasattr(self, 'checked_at') and self.checked_at is not None:
            _dict['checked_at'] = datetime_to_string(self.checked_at)
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this ConnectionState object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'ConnectionState') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'ConnectionState') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

    class StateEnum(str, Enum):
        """
        Agent Connection Status
          * `Connected` When Schematics is able to connect to the agent.
          * `Disconnected` When Schematics is able not connect to the agent.
        """

        CONNECTED = 'Connected'
        DISCONNECTED = 'Disconnected'


class CredentialVariableData:
    """
    User editable credential variable data and system generated reference to the value.

    :param str name: (optional) The name of the credential variable.
    :param str value: (optional) The credential value for the variable or reference
          to the value. **Note** The SSH key should contain three `\n` in the SSH key
          value as shown in the example for CLI or API calls. When using Bastion from API
          you need to add SSH key in both `credentials` and `bastion_credentials`.
    :param bool use_default: (optional) True, will ignore the data in the value
          attribute, instead the data in metadata.default_value will be used.
    :param CredentialVariableMetadata metadata: (optional) An user editable metadata
          for the credential variables.
    :param str link: (optional) The reference link to the variable value By default
          the expression points to `$self.value`.
    """

    def __init__(
        self,
        *,
        name: Optional[str] = None,
        value: Optional[str] = None,
        use_default: Optional[bool] = None,
        metadata: Optional['CredentialVariableMetadata'] = None,
        link: Optional[str] = None,
    ) -> None:
        """
        Initialize a CredentialVariableData object.

        :param str name: (optional) The name of the credential variable.
        :param str value: (optional) The credential value for the variable or
               reference to the value. **Note** The SSH key should contain three `\n` in
               the SSH key value as shown in the example for CLI or API calls. When using
               Bastion from API you need to add SSH key in both `credentials` and
               `bastion_credentials`.
        :param bool use_default: (optional) True, will ignore the data in the value
               attribute, instead the data in metadata.default_value will be used.
        :param CredentialVariableMetadata metadata: (optional) An user editable
               metadata for the credential variables.
        """
        self.name = name
        self.value = value
        self.use_default = use_default
        self.metadata = metadata
        self.link = link

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'CredentialVariableData':
        """Initialize a CredentialVariableData object from a json dictionary."""
        args = {}
        if (name := _dict.get('name')) is not None:
            args['name'] = name
        if (value := _dict.get('value')) is not None:
            args['value'] = value
        if (use_default := _dict.get('use_default')) is not None:
            args['use_default'] = use_default
        if (metadata := _dict.get('metadata')) is not None:
            args['metadata'] = CredentialVariableMetadata.from_dict(metadata)
        if (link := _dict.get('link')) is not None:
            args['link'] = link
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a CredentialVariableData object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'name') and self.name is not None:
            _dict['name'] = self.name
        if hasattr(self, 'value') and self.value is not None:
            _dict['value'] = self.value
        if hasattr(self, 'use_default') and self.use_default is not None:
            _dict['use_default'] = self.use_default
        if hasattr(self, 'metadata') and self.metadata is not None:
            if isinstance(self.metadata, dict):
                _dict['metadata'] = self.metadata
            else:
                _dict['metadata'] = self.metadata.to_dict()
        if hasattr(self, 'link') and getattr(self, 'link') is not None:
            _dict['link'] = getattr(self, 'link')
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this CredentialVariableData object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'CredentialVariableData') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'CredentialVariableData') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other


class CredentialVariableMetadata:
    """
    An user editable metadata for the credential variables.

    :param str type: (optional) Type of the variable.
    :param List[str] aliases: (optional) The list of aliases for the variable name.
    :param str description: (optional) The description of the meta data.
    :param str cloud_data_type: (optional) Cloud data type of the credential
          variable. eg. api_key, iam_token, profile_id.
    :param str default_value: (optional) Default value for the variable only if the
          override value is not specified.
    :param str link_status: (optional) The status of the link.
    :param bool immutable: (optional) Is the variable readonly ?.
    :param bool hidden: (optional) If **true**, the variable is not displayed on UI
          or Command line.
    :param bool required: (optional) If the variable required?.
    :param int position: (optional) The relative position of this variable in a
          list.
    :param str group_by: (optional) The display name of the group this variable
          belongs to.
    :param str source: (optional) The source of this meta-data.
    """

    def __init__(
        self,
        *,
        type: Optional[str] = None,
        aliases: Optional[List[str]] = None,
        description: Optional[str] = None,
        cloud_data_type: Optional[str] = None,
        default_value: Optional[str] = None,
        link_status: Optional[str] = None,
        immutable: Optional[bool] = None,
        hidden: Optional[bool] = None,
        required: Optional[bool] = None,
        position: Optional[int] = None,
        group_by: Optional[str] = None,
        source: Optional[str] = None,
    ) -> None:
        """
        Initialize a CredentialVariableMetadata object.

        :param str type: (optional) Type of the variable.
        :param List[str] aliases: (optional) The list of aliases for the variable
               name.
        :param str description: (optional) The description of the meta data.
        :param str cloud_data_type: (optional) Cloud data type of the credential
               variable. eg. api_key, iam_token, profile_id.
        :param str default_value: (optional) Default value for the variable only if
               the override value is not specified.
        :param str link_status: (optional) The status of the link.
        :param bool immutable: (optional) Is the variable readonly ?.
        :param bool hidden: (optional) If **true**, the variable is not displayed
               on UI or Command line.
        :param bool required: (optional) If the variable required?.
        :param int position: (optional) The relative position of this variable in a
               list.
        :param str group_by: (optional) The display name of the group this variable
               belongs to.
        :param str source: (optional) The source of this meta-data.
        """
        self.type = type
        self.aliases = aliases
        self.description = description
        self.cloud_data_type = cloud_data_type
        self.default_value = default_value
        self.link_status = link_status
        self.immutable = immutable
        self.hidden = hidden
        self.required = required
        self.position = position
        self.group_by = group_by
        self.source = source

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'CredentialVariableMetadata':
        """Initialize a CredentialVariableMetadata object from a json dictionary."""
        args = {}
        if (type := _dict.get('type')) is not None:
            args['type'] = type
        if (aliases := _dict.get('aliases')) is not None:
            args['aliases'] = aliases
        if (description := _dict.get('description')) is not None:
            args['description'] = description
        if (cloud_data_type := _dict.get('cloud_data_type')) is not None:
            args['cloud_data_type'] = cloud_data_type
        if (default_value := _dict.get('default_value')) is not None:
            args['default_value'] = default_value
        if (link_status := _dict.get('link_status')) is not None:
            args['link_status'] = link_status
        if (immutable := _dict.get('immutable')) is not None:
            args['immutable'] = immutable
        if (hidden := _dict.get('hidden')) is not None:
            args['hidden'] = hidden
        if (required := _dict.get('required')) is not None:
            args['required'] = required
        if (position := _dict.get('position')) is not None:
            args['position'] = position
        if (group_by := _dict.get('group_by')) is not None:
            args['group_by'] = group_by
        if (source := _dict.get('source')) is not None:
            args['source'] = source
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a CredentialVariableMetadata object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'type') and self.type is not None:
            _dict['type'] = self.type
        if hasattr(self, 'aliases') and self.aliases is not None:
            _dict['aliases'] = self.aliases
        if hasattr(self, 'description') and self.description is not None:
            _dict['description'] = self.description
        if hasattr(self, 'cloud_data_type') and self.cloud_data_type is not None:
            _dict['cloud_data_type'] = self.cloud_data_type
        if hasattr(self, 'default_value') and self.default_value is not None:
            _dict['default_value'] = self.default_value
        if hasattr(self, 'link_status') and self.link_status is not None:
            _dict['link_status'] = self.link_status
        if hasattr(self, 'immutable') and self.immutable is not None:
            _dict['immutable'] = self.immutable
        if hasattr(self, 'hidden') and self.hidden is not None:
            _dict['hidden'] = self.hidden
        if hasattr(self, 'required') and self.required is not None:
            _dict['required'] = self.required
        if hasattr(self, 'position') and self.position is not None:
            _dict['position'] = self.position
        if hasattr(self, 'group_by') and self.group_by is not None:
            _dict['group_by'] = self.group_by
        if hasattr(self, 'source') and self.source is not None:
            _dict['source'] = self.source
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this CredentialVariableMetadata object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'CredentialVariableMetadata') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'CredentialVariableMetadata') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

    class TypeEnum(str, Enum):
        """
        Type of the variable.
        """

        STRING = 'string'
        LINK = 'link'

    class LinkStatusEnum(str, Enum):
        """
        The status of the link.
        """

        NORMAL = 'normal'
        BROKEN = 'broken'


class Dependencies:
    """
    Workspace dependencies.

    :param List[str] parents: (optional) List of workspace parents CRN identifiers.
    :param List[str] children: (optional) List of workspace children CRN
          identifiers.
    """

    def __init__(
        self,
        *,
        parents: Optional[List[str]] = None,
        children: Optional[List[str]] = None,
    ) -> None:
        """
        Initialize a Dependencies object.

        :param List[str] parents: (optional) List of workspace parents CRN
               identifiers.
        :param List[str] children: (optional) List of workspace children CRN
               identifiers.
        """
        self.parents = parents
        self.children = children

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'Dependencies':
        """Initialize a Dependencies object from a json dictionary."""
        args = {}
        if (parents := _dict.get('parents')) is not None:
            args['parents'] = parents
        if (children := _dict.get('children')) is not None:
            args['children'] = children
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a Dependencies object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'parents') and self.parents is not None:
            _dict['parents'] = self.parents
        if hasattr(self, 'children') and self.children is not None:
            _dict['children'] = self.children
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this Dependencies object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'Dependencies') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'Dependencies') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other


class EncryptionInfo:
    """
    Encryption details about the workspace such as scheme (byok/kyok) and key CRN.

    :param str crn: (optional) Key CRN.
    :param str scheme: (optional) Encryption scheme.
    """

    def __init__(
        self,
        *,
        crn: Optional[str] = None,
        scheme: Optional[str] = None,
    ) -> None:
        """
        Initialize a EncryptionInfo object.

        :param str crn: (optional) Key CRN.
        :param str scheme: (optional) Encryption scheme.
        """
        self.crn = crn
        self.scheme = scheme

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'EncryptionInfo':
        """Initialize a EncryptionInfo object from a json dictionary."""
        args = {}
        if (crn := _dict.get('crn')) is not None:
            args['crn'] = crn
        if (scheme := _dict.get('scheme')) is not None:
            args['scheme'] = scheme
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a EncryptionInfo object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'crn') and self.crn is not None:
            _dict['crn'] = self.crn
        if hasattr(self, 'scheme') and self.scheme is not None:
            _dict['scheme'] = self.scheme
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this EncryptionInfo object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'EncryptionInfo') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'EncryptionInfo') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other


class EnvVariableRequestMap:
    """
    One variable is a map where one entry is there with key as name of the env var and the
    value as value.

    :param bool hidden: (optional) Environment variable is hidden.
    :param str name: (optional) Environment variable name.
    :param bool secure: (optional) Environment variable is secure.
    :param str value: (optional) Value for environment variable.
    """

    def __init__(
        self,
        *,
        hidden: Optional[bool] = None,
        name: Optional[str] = None,
        secure: Optional[bool] = None,
        value: Optional[str] = None,
    ) -> None:
        """
        Initialize a EnvVariableRequestMap object.

        :param bool hidden: (optional) Environment variable is hidden.
        :param str name: (optional) Environment variable name.
        :param bool secure: (optional) Environment variable is secure.
        :param str value: (optional) Value for environment variable.
        """
        self.hidden = hidden
        self.name = name
        self.secure = secure
        self.value = value

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'EnvVariableRequestMap':
        """Initialize a EnvVariableRequestMap object from a json dictionary."""
        args = {}
        if (hidden := _dict.get('hidden')) is not None:
            args['hidden'] = hidden
        if (name := _dict.get('name')) is not None:
            args['name'] = name
        if (secure := _dict.get('secure')) is not None:
            args['secure'] = secure
        if (value := _dict.get('value')) is not None:
            args['value'] = value
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a EnvVariableRequestMap object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'hidden') and self.hidden is not None:
            _dict['hidden'] = self.hidden
        if hasattr(self, 'name') and self.name is not None:
            _dict['name'] = self.name
        if hasattr(self, 'secure') and self.secure is not None:
            _dict['secure'] = self.secure
        if hasattr(self, 'value') and self.value is not None:
            _dict['value'] = self.value
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this EnvVariableRequestMap object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'EnvVariableRequestMap') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'EnvVariableRequestMap') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other


class EnvVariableResponse:
    """
    List of environment values.

    :param bool hidden: (optional) Environment variable is hidden.
    :param str name: (optional) Environment variable name.
    :param bool secure: (optional) Environment variable is secure.
    :param str value: (optional) Value for environment variable.
    """

    def __init__(
        self,
        *,
        hidden: Optional[bool] = None,
        name: Optional[str] = None,
        secure: Optional[bool] = None,
        value: Optional[str] = None,
    ) -> None:
        """
        Initialize a EnvVariableResponse object.

        :param bool hidden: (optional) Environment variable is hidden.
        :param str name: (optional) Environment variable name.
        :param bool secure: (optional) Environment variable is secure.
        :param str value: (optional) Value for environment variable.
        """
        self.hidden = hidden
        self.name = name
        self.secure = secure
        self.value = value

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'EnvVariableResponse':
        """Initialize a EnvVariableResponse object from a json dictionary."""
        args = {}
        if (hidden := _dict.get('hidden')) is not None:
            args['hidden'] = hidden
        if (name := _dict.get('name')) is not None:
            args['name'] = name
        if (secure := _dict.get('secure')) is not None:
            args['secure'] = secure
        if (value := _dict.get('value')) is not None:
            args['value'] = value
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a EnvVariableResponse object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'hidden') and self.hidden is not None:
            _dict['hidden'] = self.hidden
        if hasattr(self, 'name') and self.name is not None:
            _dict['name'] = self.name
        if hasattr(self, 'secure') and self.secure is not None:
            _dict['secure'] = self.secure
        if hasattr(self, 'value') and self.value is not None:
            _dict['value'] = self.value
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this EnvVariableResponse object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'EnvVariableResponse') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'EnvVariableResponse') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other


class EnvironmentValuesMetadata:
    """
    Environment variables metadata.

    :param bool hidden: (optional) Environment variable is hidden.
    :param str name: (optional) Environment variable name.
    :param bool secure: (optional) Environment variable is secure.
    """

    def __init__(
        self,
        *,
        hidden: Optional[bool] = None,
        name: Optional[str] = None,
        secure: Optional[bool] = None,
    ) -> None:
        """
        Initialize a EnvironmentValuesMetadata object.

        :param bool hidden: (optional) Environment variable is hidden.
        :param str name: (optional) Environment variable name.
        :param bool secure: (optional) Environment variable is secure.
        """
        self.hidden = hidden
        self.name = name
        self.secure = secure

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'EnvironmentValuesMetadata':
        """Initialize a EnvironmentValuesMetadata object from a json dictionary."""
        args = {}
        if (hidden := _dict.get('hidden')) is not None:
            args['hidden'] = hidden
        if (name := _dict.get('name')) is not None:
            args['name'] = name
        if (secure := _dict.get('secure')) is not None:
            args['secure'] = secure
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a EnvironmentValuesMetadata object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'hidden') and self.hidden is not None:
            _dict['hidden'] = self.hidden
        if hasattr(self, 'name') and self.name is not None:
            _dict['name'] = self.name
        if hasattr(self, 'secure') and self.secure is not None:
            _dict['secure'] = self.secure
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this EnvironmentValuesMetadata object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'EnvironmentValuesMetadata') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'EnvironmentValuesMetadata') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other


class ExternalSource:
    """
    Source of templates, playbooks, or controls.

    :param str source_type: Type of source for the Template.
    :param GitSource git: (optional) The connection details to the Git source
          repository.
    :param CatalogSource catalog: (optional) The connection details to the IBM Cloud
          Catalog source.
    """

    def __init__(
        self,
        source_type: str,
        *,
        git: Optional['GitSource'] = None,
        catalog: Optional['CatalogSource'] = None,
    ) -> None:
        """
        Initialize a ExternalSource object.

        :param str source_type: Type of source for the Template.
        :param GitSource git: (optional) The connection details to the Git source
               repository.
        :param CatalogSource catalog: (optional) The connection details to the IBM
               Cloud Catalog source.
        """
        self.source_type = source_type
        self.git = git
        self.catalog = catalog

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'ExternalSource':
        """Initialize a ExternalSource object from a json dictionary."""
        args = {}
        if (source_type := _dict.get('source_type')) is not None:
            args['source_type'] = source_type
        else:
            raise ValueError('Required property \'source_type\' not present in ExternalSource JSON')
        if (git := _dict.get('git')) is not None:
            args['git'] = GitSource.from_dict(git)
        if (catalog := _dict.get('catalog')) is not None:
            args['catalog'] = CatalogSource.from_dict(catalog)
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a ExternalSource object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'source_type') and self.source_type is not None:
            _dict['source_type'] = self.source_type
        if hasattr(self, 'git') and self.git is not None:
            if isinstance(self.git, dict):
                _dict['git'] = self.git
            else:
                _dict['git'] = self.git.to_dict()
        if hasattr(self, 'catalog') and self.catalog is not None:
            if isinstance(self.catalog, dict):
                _dict['catalog'] = self.catalog
            else:
                _dict['catalog'] = self.catalog.to_dict()
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this ExternalSource object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'ExternalSource') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'ExternalSource') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

    class SourceTypeEnum(str, Enum):
        """
        Type of source for the Template.
        """

        LOCAL = 'local'
        GIT_HUB = 'git_hub'
        GIT_HUB_ENTERPRISE = 'git_hub_enterprise'
        GIT_LAB = 'git_lab'
        IBM_GIT_LAB = 'ibm_git_lab'
        IBM_CLOUD_CATALOG = 'ibm_cloud_catalog'


class GitSource:
    """
    The connection details to the Git source repository.

    :param str computed_git_repo_url: (optional) The complete URL which is computed
          by the **git_repo_url**, **git_repo_folder**, and **branch**.
    :param str git_repo_url: (optional) The URL to the Git repository that can be
          used to clone the template.
    :param str git_token: (optional) The Personal Access Token (PAT) to connect to
          the Git URLs.
    :param str git_repo_folder: (optional) The name of the folder in the Git
          repository, that contains the template.
    :param str git_release: (optional) The name of the release tag that are used to
          fetch the Git repository.
    :param str git_branch: (optional) The name of the branch that are used to fetch
          the Git repository.
    :param str git_commit: (optional) The git commit hash used to fetch the
          repository.
    :param str git_commit_timestamp: (optional) The timestamp of the git commit hash
          used to fetch the repository.
    """

    def __init__(
        self,
        *,
        computed_git_repo_url: Optional[str] = None,
        git_repo_url: Optional[str] = None,
        git_token: Optional[str] = None,
        git_repo_folder: Optional[str] = None,
        git_release: Optional[str] = None,
        git_branch: Optional[str] = None,
        git_commit: Optional[str] = None,
        git_commit_timestamp: Optional[str] = None,
    ) -> None:
        """
        Initialize a GitSource object.

        :param str computed_git_repo_url: (optional) The complete URL which is
               computed by the **git_repo_url**, **git_repo_folder**, and **branch**.
        :param str git_repo_url: (optional) The URL to the Git repository that can
               be used to clone the template.
        :param str git_token: (optional) The Personal Access Token (PAT) to connect
               to the Git URLs.
        :param str git_repo_folder: (optional) The name of the folder in the Git
               repository, that contains the template.
        :param str git_release: (optional) The name of the release tag that are
               used to fetch the Git repository.
        :param str git_branch: (optional) The name of the branch that are used to
               fetch the Git repository.
        """
        self.computed_git_repo_url = computed_git_repo_url
        self.git_repo_url = git_repo_url
        self.git_token = git_token
        self.git_repo_folder = git_repo_folder
        self.git_release = git_release
        self.git_branch = git_branch
        self.git_commit = git_commit
        self.git_commit_timestamp = git_commit_timestamp

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'GitSource':
        """Initialize a GitSource object from a json dictionary."""
        args = {}
        if (computed_git_repo_url := _dict.get('computed_git_repo_url')) is not None:
            args['computed_git_repo_url'] = computed_git_repo_url
        if (git_repo_url := _dict.get('git_repo_url')) is not None:
            args['git_repo_url'] = git_repo_url
        if (git_token := _dict.get('git_token')) is not None:
            args['git_token'] = git_token
        if (git_repo_folder := _dict.get('git_repo_folder')) is not None:
            args['git_repo_folder'] = git_repo_folder
        if (git_release := _dict.get('git_release')) is not None:
            args['git_release'] = git_release
        if (git_branch := _dict.get('git_branch')) is not None:
            args['git_branch'] = git_branch
        if (git_commit := _dict.get('git_commit')) is not None:
            args['git_commit'] = git_commit
        if (git_commit_timestamp := _dict.get('git_commit_timestamp')) is not None:
            args['git_commit_timestamp'] = git_commit_timestamp
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a GitSource object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'computed_git_repo_url') and self.computed_git_repo_url is not None:
            _dict['computed_git_repo_url'] = self.computed_git_repo_url
        if hasattr(self, 'git_repo_url') and self.git_repo_url is not None:
            _dict['git_repo_url'] = self.git_repo_url
        if hasattr(self, 'git_token') and self.git_token is not None:
            _dict['git_token'] = self.git_token
        if hasattr(self, 'git_repo_folder') and self.git_repo_folder is not None:
            _dict['git_repo_folder'] = self.git_repo_folder
        if hasattr(self, 'git_release') and self.git_release is not None:
            _dict['git_release'] = self.git_release
        if hasattr(self, 'git_branch') and self.git_branch is not None:
            _dict['git_branch'] = self.git_branch
        if hasattr(self, 'git_commit') and getattr(self, 'git_commit') is not None:
            _dict['git_commit'] = getattr(self, 'git_commit')
        if hasattr(self, 'git_commit_timestamp') and getattr(self, 'git_commit_timestamp') is not None:
            _dict['git_commit_timestamp'] = getattr(self, 'git_commit_timestamp')
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this GitSource object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'GitSource') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'GitSource') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other


class InjectTerraformTemplateInnerTftParametersItem:
    """
    InjectTerraformTemplateInnerTftParametersItem.

    :param str name: (optional) Key name to replace.
    :param str value: (optional) Value to replace.
    """

    def __init__(
        self,
        *,
        name: Optional[str] = None,
        value: Optional[str] = None,
    ) -> None:
        """
        Initialize a InjectTerraformTemplateInnerTftParametersItem object.

        :param str name: (optional) Key name to replace.
        :param str value: (optional) Value to replace.
        """
        self.name = name
        self.value = value

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'InjectTerraformTemplateInnerTftParametersItem':
        """Initialize a InjectTerraformTemplateInnerTftParametersItem object from a json dictionary."""
        args = {}
        if (name := _dict.get('name')) is not None:
            args['name'] = name
        if (value := _dict.get('value')) is not None:
            args['value'] = value
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a InjectTerraformTemplateInnerTftParametersItem object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'name') and self.name is not None:
            _dict['name'] = self.name
        if hasattr(self, 'value') and self.value is not None:
            _dict['value'] = self.value
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this InjectTerraformTemplateInnerTftParametersItem object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'InjectTerraformTemplateInnerTftParametersItem') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'InjectTerraformTemplateInnerTftParametersItem') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other


class InjectTerraformTemplateInner:
    """
    InjectTerraformTemplateInner.

    :param str tft_git_url: (optional) Git repo url hosting terraform template
          files.
    :param str tft_git_token: (optional) Token to access the git repository
          (Optional).
    :param str tft_prefix: (optional) Optional prefix word to append to files
          (Optional).
    :param str injection_type: (optional) Injection type. Default is 'override'.
    :param str tft_name: (optional) Terraform template name. Maps to folder name in
          git repo.
    :param List[InjectTerraformTemplateInnerTftParametersItem] tft_parameters:
          (optional)
    """

    def __init__(
        self,
        *,
        tft_git_url: Optional[str] = None,
        tft_git_token: Optional[str] = None,
        tft_prefix: Optional[str] = None,
        injection_type: Optional[str] = None,
        tft_name: Optional[str] = None,
        tft_parameters: Optional[List['InjectTerraformTemplateInnerTftParametersItem']] = None,
    ) -> None:
        """
        Initialize a InjectTerraformTemplateInner object.

        :param str tft_git_url: (optional) Git repo url hosting terraform template
               files.
        :param str tft_git_token: (optional) Token to access the git repository
               (Optional).
        :param str tft_prefix: (optional) Optional prefix word to append to files
               (Optional).
        :param str injection_type: (optional) Injection type. Default is
               'override'.
        :param str tft_name: (optional) Terraform template name. Maps to folder
               name in git repo.
        :param List[InjectTerraformTemplateInnerTftParametersItem] tft_parameters:
               (optional)
        """
        self.tft_git_url = tft_git_url
        self.tft_git_token = tft_git_token
        self.tft_prefix = tft_prefix
        self.injection_type = injection_type
        self.tft_name = tft_name
        self.tft_parameters = tft_parameters

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'InjectTerraformTemplateInner':
        """Initialize a InjectTerraformTemplateInner object from a json dictionary."""
        args = {}
        if (tft_git_url := _dict.get('tft_git_url')) is not None:
            args['tft_git_url'] = tft_git_url
        if (tft_git_token := _dict.get('tft_git_token')) is not None:
            args['tft_git_token'] = tft_git_token
        if (tft_prefix := _dict.get('tft_prefix')) is not None:
            args['tft_prefix'] = tft_prefix
        if (injection_type := _dict.get('injection_type')) is not None:
            args['injection_type'] = injection_type
        if (tft_name := _dict.get('tft_name')) is not None:
            args['tft_name'] = tft_name
        if (tft_parameters := _dict.get('tft_parameters')) is not None:
            args['tft_parameters'] = [
                InjectTerraformTemplateInnerTftParametersItem.from_dict(v) for v in tft_parameters
            ]
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a InjectTerraformTemplateInner object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'tft_git_url') and self.tft_git_url is not None:
            _dict['tft_git_url'] = self.tft_git_url
        if hasattr(self, 'tft_git_token') and self.tft_git_token is not None:
            _dict['tft_git_token'] = self.tft_git_token
        if hasattr(self, 'tft_prefix') and self.tft_prefix is not None:
            _dict['tft_prefix'] = self.tft_prefix
        if hasattr(self, 'injection_type') and self.injection_type is not None:
            _dict['injection_type'] = self.injection_type
        if hasattr(self, 'tft_name') and self.tft_name is not None:
            _dict['tft_name'] = self.tft_name
        if hasattr(self, 'tft_parameters') and self.tft_parameters is not None:
            tft_parameters_list = []
            for v in self.tft_parameters:
                if isinstance(v, dict):
                    tft_parameters_list.append(v)
                else:
                    tft_parameters_list.append(v.to_dict())
            _dict['tft_parameters'] = tft_parameters_list
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this InjectTerraformTemplateInner object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'InjectTerraformTemplateInner') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'InjectTerraformTemplateInner') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other


class InventoryResourceRecord:
    """
    Complete inventory definition details.

    :param str name: (optional) The unique name of your Inventory.  The name can be
          up to 128 characters long and can include alphanumeric  characters, spaces,
          dashes, and underscores.
    :param str id: (optional) Inventory id.
    :param str description: (optional) The description of your Inventory.  The
          description can be up to 2048 characters long in size.
    :param str location: (optional) List of locations supported by IBM Cloud
          Schematics service.  While creating your workspace or action, choose the right
          region, since it cannot be changed.  Note, this does not limit the location of
          the IBM Cloud resources, provisioned using Schematics.
    :param str resource_group: (optional) Resource-group name for the Inventory
          definition.  By default, Inventory will be created in Default Resource Group.
    :param datetime created_at: (optional) Inventory creation time.
    :param str created_by: (optional) Email address of user who created the
          Inventory.
    :param datetime updated_at: (optional) Inventory updation time.
    :param str updated_by: (optional) Email address of user who updated the
          Inventory.
    :param str inventories_ini: (optional) Input inventory of host and host group
          for the playbook,  in the .ini file format.
    :param List[str] resource_queries: (optional) Input resource queries that is
          used to dynamically generate  the inventory of host and host group for the
          playbook.
    """

    def __init__(
        self,
        *,
        name: Optional[str] = None,
        id: Optional[str] = None,
        description: Optional[str] = None,
        location: Optional[str] = None,
        resource_group: Optional[str] = None,
        created_at: Optional[datetime] = None,
        created_by: Optional[str] = None,
        updated_at: Optional[datetime] = None,
        updated_by: Optional[str] = None,
        inventories_ini: Optional[str] = None,
        resource_queries: Optional[List[str]] = None,
    ) -> None:
        """
        Initialize a InventoryResourceRecord object.

        :param str name: (optional) The unique name of your Inventory.  The name
               can be up to 128 characters long and can include alphanumeric  characters,
               spaces, dashes, and underscores.
        :param str description: (optional) The description of your Inventory.  The
               description can be up to 2048 characters long in size.
        :param str location: (optional) List of locations supported by IBM Cloud
               Schematics service.  While creating your workspace or action, choose the
               right region, since it cannot be changed.  Note, this does not limit the
               location of the IBM Cloud resources, provisioned using Schematics.
        :param str resource_group: (optional) Resource-group name for the Inventory
               definition.  By default, Inventory will be created in Default Resource
               Group.
        :param str inventories_ini: (optional) Input inventory of host and host
               group for the playbook,  in the .ini file format.
        :param List[str] resource_queries: (optional) Input resource queries that
               is used to dynamically generate  the inventory of host and host group for
               the playbook.
        """
        self.name = name
        self.id = id
        self.description = description
        self.location = location
        self.resource_group = resource_group
        self.created_at = created_at
        self.created_by = created_by
        self.updated_at = updated_at
        self.updated_by = updated_by
        self.inventories_ini = inventories_ini
        self.resource_queries = resource_queries

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'InventoryResourceRecord':
        """Initialize a InventoryResourceRecord object from a json dictionary."""
        args = {}
        if (name := _dict.get('name')) is not None:
            args['name'] = name
        if (id := _dict.get('id')) is not None:
            args['id'] = id
        if (description := _dict.get('description')) is not None:
            args['description'] = description
        if (location := _dict.get('location')) is not None:
            args['location'] = location
        if (resource_group := _dict.get('resource_group')) is not None:
            args['resource_group'] = resource_group
        if (created_at := _dict.get('created_at')) is not None:
            args['created_at'] = string_to_datetime(created_at)
        if (created_by := _dict.get('created_by')) is not None:
            args['created_by'] = created_by
        if (updated_at := _dict.get('updated_at')) is not None:
            args['updated_at'] = string_to_datetime(updated_at)
        if (updated_by := _dict.get('updated_by')) is not None:
            args['updated_by'] = updated_by
        if (inventories_ini := _dict.get('inventories_ini')) is not None:
            args['inventories_ini'] = inventories_ini
        if (resource_queries := _dict.get('resource_queries')) is not None:
            args['resource_queries'] = resource_queries
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a InventoryResourceRecord object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'name') and self.name is not None:
            _dict['name'] = self.name
        if hasattr(self, 'id') and getattr(self, 'id') is not None:
            _dict['id'] = getattr(self, 'id')
        if hasattr(self, 'description') and self.description is not None:
            _dict['description'] = self.description
        if hasattr(self, 'location') and self.location is not None:
            _dict['location'] = self.location
        if hasattr(self, 'resource_group') and self.resource_group is not None:
            _dict['resource_group'] = self.resource_group
        if hasattr(self, 'created_at') and getattr(self, 'created_at') is not None:
            _dict['created_at'] = datetime_to_string(getattr(self, 'created_at'))
        if hasattr(self, 'created_by') and getattr(self, 'created_by') is not None:
            _dict['created_by'] = getattr(self, 'created_by')
        if hasattr(self, 'updated_at') and getattr(self, 'updated_at') is not None:
            _dict['updated_at'] = datetime_to_string(getattr(self, 'updated_at'))
        if hasattr(self, 'updated_by') and getattr(self, 'updated_by') is not None:
            _dict['updated_by'] = getattr(self, 'updated_by')
        if hasattr(self, 'inventories_ini') and self.inventories_ini is not None:
            _dict['inventories_ini'] = self.inventories_ini
        if hasattr(self, 'resource_queries') and self.resource_queries is not None:
            _dict['resource_queries'] = self.resource_queries
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this InventoryResourceRecord object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'InventoryResourceRecord') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'InventoryResourceRecord') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

    class LocationEnum(str, Enum):
        """
        List of locations supported by IBM Cloud Schematics service.  While creating your
        workspace or action, choose the right region, since it cannot be changed.  Note,
        this does not limit the location of the IBM Cloud resources, provisioned using
        Schematics.
        """

        US_SOUTH = 'us-south'
        US_EAST = 'us-east'
        EU_GB = 'eu-gb'
        EU_DE = 'eu-de'


class InventoryResourceRecordList:
    """
    List of Inventory definition records.

    :param int total_count: (optional) Total number of records.
    :param int limit: Number of records returned.
    :param int offset: Skipped number of records.
    :param List[InventoryResourceRecord] inventories: (optional) List of inventory
          definition records.
    """

    def __init__(
        self,
        limit: int,
        offset: int,
        *,
        total_count: Optional[int] = None,
        inventories: Optional[List['InventoryResourceRecord']] = None,
    ) -> None:
        """
        Initialize a InventoryResourceRecordList object.

        :param int limit: Number of records returned.
        :param int offset: Skipped number of records.
        :param int total_count: (optional) Total number of records.
        :param List[InventoryResourceRecord] inventories: (optional) List of
               inventory definition records.
        """
        self.total_count = total_count
        self.limit = limit
        self.offset = offset
        self.inventories = inventories

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'InventoryResourceRecordList':
        """Initialize a InventoryResourceRecordList object from a json dictionary."""
        args = {}
        if (total_count := _dict.get('total_count')) is not None:
            args['total_count'] = total_count
        if (limit := _dict.get('limit')) is not None:
            args['limit'] = limit
        else:
            raise ValueError('Required property \'limit\' not present in InventoryResourceRecordList JSON')
        if (offset := _dict.get('offset')) is not None:
            args['offset'] = offset
        else:
            raise ValueError('Required property \'offset\' not present in InventoryResourceRecordList JSON')
        if (inventories := _dict.get('inventories')) is not None:
            args['inventories'] = [InventoryResourceRecord.from_dict(v) for v in inventories]
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a InventoryResourceRecordList object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'total_count') and self.total_count is not None:
            _dict['total_count'] = self.total_count
        if hasattr(self, 'limit') and self.limit is not None:
            _dict['limit'] = self.limit
        if hasattr(self, 'offset') and self.offset is not None:
            _dict['offset'] = self.offset
        if hasattr(self, 'inventories') and self.inventories is not None:
            inventories_list = []
            for v in self.inventories:
                if isinstance(v, dict):
                    inventories_list.append(v)
                else:
                    inventories_list.append(v.to_dict())
            _dict['inventories'] = inventories_list
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this InventoryResourceRecordList object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'InventoryResourceRecordList') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'InventoryResourceRecordList') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other


class Job:
    """
    Complete Job with user inputs and system generated data.

    :param str command_object: (optional) Name of the Schematics automation
          resource.
    :param str command_object_id: (optional) Job command object id (workspace-id,
          action-id).
    :param str command_name: (optional) Schematics job command name.
    :param str command_parameter: (optional) Schematics job command parameter
          (playbook-name).
    :param List[str] command_options: (optional) Command line options for the
          command.
    :param List[VariableData] inputs: (optional) Job inputs used by Action or
          Workspace.
    :param List[VariableData] settings: (optional) Environment variables used by the
          Job while performing Action or Workspace.
    :param List[str] tags: (optional) User defined tags, while running the job.
    :param str id: (optional) Job ID.
    :param str name: (optional) Job name, uniquely derived from the related
          Workspace or Action.
    :param str description: (optional) The description of your job is derived from
          the related action or workspace.  The description can be up to 2048 characters
          long in size.
    :param str location: (optional) List of locations supported by IBM Cloud
          Schematics service.  While creating your workspace or action, choose the right
          region, since it cannot be changed.  Note, this does not limit the location of
          the IBM Cloud resources, provisioned using Schematics.
    :param str resource_group: (optional) Resource-group name derived from the
          related Workspace or Action.
    :param datetime submitted_at: (optional) Job submission time.
    :param str submitted_by: (optional) Email address of user who submitted the job.
    :param datetime start_at: (optional) Job start time.
    :param datetime end_at: (optional) Job end time.
    :param str duration: (optional) Duration of job execution; example 40 sec.
    :param JobStatus status: (optional) Job Status.
    :param List[CartOrderData] cart_order_data: (optional) Contains the cart order
          data which can be used for different purpose for eg. service tagging.
    :param JobData data: (optional) Job data.
    :param BastionResourceDefinition bastion: (optional) Describes a bastion
          resource.
    :param JobLogSummary log_summary: (optional) Job log summary record.
    :param str log_store_url: (optional) Job log store URL.
    :param str state_store_url: (optional) Job state store URL.
    :param str results_url: (optional) Job results store URL.
    :param datetime updated_at: (optional) Job status updation timestamp.
    :param str job_runner_id: (optional) ID of the Job Runner.
    :param AgentInfo agent: (optional) Agent name, Agent id and associated policy ID
          information.
    """

    def __init__(
        self,
        *,
        command_object: Optional[str] = None,
        command_object_id: Optional[str] = None,
        command_name: Optional[str] = None,
        command_parameter: Optional[str] = None,
        command_options: Optional[List[str]] = None,
        inputs: Optional[List['VariableData']] = None,
        settings: Optional[List['VariableData']] = None,
        tags: Optional[List[str]] = None,
        id: Optional[str] = None,
        name: Optional[str] = None,
        description: Optional[str] = None,
        location: Optional[str] = None,
        resource_group: Optional[str] = None,
        submitted_at: Optional[datetime] = None,
        submitted_by: Optional[str] = None,
        start_at: Optional[datetime] = None,
        end_at: Optional[datetime] = None,
        duration: Optional[str] = None,
        status: Optional['JobStatus'] = None,
        cart_order_data: Optional[List['CartOrderData']] = None,
        data: Optional['JobData'] = None,
        bastion: Optional['BastionResourceDefinition'] = None,
        log_summary: Optional['JobLogSummary'] = None,
        log_store_url: Optional[str] = None,
        state_store_url: Optional[str] = None,
        results_url: Optional[str] = None,
        updated_at: Optional[datetime] = None,
        job_runner_id: Optional[str] = None,
        agent: Optional['AgentInfo'] = None,
    ) -> None:
        """
        Initialize a Job object.

        :param str command_object: (optional) Name of the Schematics automation
               resource.
        :param str command_object_id: (optional) Job command object id
               (workspace-id, action-id).
        :param str command_name: (optional) Schematics job command name.
        :param str command_parameter: (optional) Schematics job command parameter
               (playbook-name).
        :param List[str] command_options: (optional) Command line options for the
               command.
        :param List[VariableData] inputs: (optional) Job inputs used by Action or
               Workspace.
        :param List[VariableData] settings: (optional) Environment variables used
               by the Job while performing Action or Workspace.
        :param List[str] tags: (optional) User defined tags, while running the job.
        :param str location: (optional) List of locations supported by IBM Cloud
               Schematics service.  While creating your workspace or action, choose the
               right region, since it cannot be changed.  Note, this does not limit the
               location of the IBM Cloud resources, provisioned using Schematics.
        :param JobStatus status: (optional) Job Status.
        :param List[CartOrderData] cart_order_data: (optional) Contains the cart
               order data which can be used for different purpose for eg. service tagging.
        :param JobData data: (optional) Job data.
        :param BastionResourceDefinition bastion: (optional) Describes a bastion
               resource.
        :param JobLogSummary log_summary: (optional) Job log summary record.
        :param AgentInfo agent: (optional) Agent name, Agent id and associated
               policy ID information.
        """
        self.command_object = command_object
        self.command_object_id = command_object_id
        self.command_name = command_name
        self.command_parameter = command_parameter
        self.command_options = command_options
        self.inputs = inputs
        self.settings = settings
        self.tags = tags
        self.id = id
        self.name = name
        self.description = description
        self.location = location
        self.resource_group = resource_group
        self.submitted_at = submitted_at
        self.submitted_by = submitted_by
        self.start_at = start_at
        self.end_at = end_at
        self.duration = duration
        self.status = status
        self.cart_order_data = cart_order_data
        self.data = data
        self.bastion = bastion
        self.log_summary = log_summary
        self.log_store_url = log_store_url
        self.state_store_url = state_store_url
        self.results_url = results_url
        self.updated_at = updated_at
        self.job_runner_id = job_runner_id
        self.agent = agent

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'Job':
        """Initialize a Job object from a json dictionary."""
        args = {}
        if (command_object := _dict.get('command_object')) is not None:
            args['command_object'] = command_object
        if (command_object_id := _dict.get('command_object_id')) is not None:
            args['command_object_id'] = command_object_id
        if (command_name := _dict.get('command_name')) is not None:
            args['command_name'] = command_name
        if (command_parameter := _dict.get('command_parameter')) is not None:
            args['command_parameter'] = command_parameter
        if (command_options := _dict.get('command_options')) is not None:
            args['command_options'] = command_options
        if (inputs := _dict.get('inputs')) is not None:
            args['inputs'] = [VariableData.from_dict(v) for v in inputs]
        if (settings := _dict.get('settings')) is not None:
            args['settings'] = [VariableData.from_dict(v) for v in settings]
        if (tags := _dict.get('tags')) is not None:
            args['tags'] = tags
        if (id := _dict.get('id')) is not None:
            args['id'] = id
        if (name := _dict.get('name')) is not None:
            args['name'] = name
        if (description := _dict.get('description')) is not None:
            args['description'] = description
        if (location := _dict.get('location')) is not None:
            args['location'] = location
        if (resource_group := _dict.get('resource_group')) is not None:
            args['resource_group'] = resource_group
        if (submitted_at := _dict.get('submitted_at')) is not None:
            args['submitted_at'] = string_to_datetime(submitted_at)
        if (submitted_by := _dict.get('submitted_by')) is not None:
            args['submitted_by'] = submitted_by
        if (start_at := _dict.get('start_at')) is not None:
            args['start_at'] = string_to_datetime(start_at)
        if (end_at := _dict.get('end_at')) is not None:
            args['end_at'] = string_to_datetime(end_at)
        if (duration := _dict.get('duration')) is not None:
            args['duration'] = duration
        if (status := _dict.get('status')) is not None:
            args['status'] = JobStatus.from_dict(status)
        if (cart_order_data := _dict.get('cart_order_data')) is not None:
            args['cart_order_data'] = [CartOrderData.from_dict(v) for v in cart_order_data]
        if (data := _dict.get('data')) is not None:
            args['data'] = JobData.from_dict(data)
        if (bastion := _dict.get('bastion')) is not None:
            args['bastion'] = BastionResourceDefinition.from_dict(bastion)
        if (log_summary := _dict.get('log_summary')) is not None:
            args['log_summary'] = JobLogSummary.from_dict(log_summary)
        if (log_store_url := _dict.get('log_store_url')) is not None:
            args['log_store_url'] = log_store_url
        if (state_store_url := _dict.get('state_store_url')) is not None:
            args['state_store_url'] = state_store_url
        if (results_url := _dict.get('results_url')) is not None:
            args['results_url'] = results_url
        if (updated_at := _dict.get('updated_at')) is not None:
            args['updated_at'] = string_to_datetime(updated_at)
        if (job_runner_id := _dict.get('job_runner_id')) is not None:
            args['job_runner_id'] = job_runner_id
        if (agent := _dict.get('agent')) is not None:
            args['agent'] = AgentInfo.from_dict(agent)
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a Job object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'command_object') and self.command_object is not None:
            _dict['command_object'] = self.command_object
        if hasattr(self, 'command_object_id') and self.command_object_id is not None:
            _dict['command_object_id'] = self.command_object_id
        if hasattr(self, 'command_name') and self.command_name is not None:
            _dict['command_name'] = self.command_name
        if hasattr(self, 'command_parameter') and self.command_parameter is not None:
            _dict['command_parameter'] = self.command_parameter
        if hasattr(self, 'command_options') and self.command_options is not None:
            _dict['command_options'] = self.command_options
        if hasattr(self, 'inputs') and self.inputs is not None:
            inputs_list = []
            for v in self.inputs:
                if isinstance(v, dict):
                    inputs_list.append(v)
                else:
                    inputs_list.append(v.to_dict())
            _dict['inputs'] = inputs_list
        if hasattr(self, 'settings') and self.settings is not None:
            settings_list = []
            for v in self.settings:
                if isinstance(v, dict):
                    settings_list.append(v)
                else:
                    settings_list.append(v.to_dict())
            _dict['settings'] = settings_list
        if hasattr(self, 'tags') and self.tags is not None:
            _dict['tags'] = self.tags
        if hasattr(self, 'id') and getattr(self, 'id') is not None:
            _dict['id'] = getattr(self, 'id')
        if hasattr(self, 'name') and getattr(self, 'name') is not None:
            _dict['name'] = getattr(self, 'name')
        if hasattr(self, 'description') and getattr(self, 'description') is not None:
            _dict['description'] = getattr(self, 'description')
        if hasattr(self, 'location') and self.location is not None:
            _dict['location'] = self.location
        if hasattr(self, 'resource_group') and getattr(self, 'resource_group') is not None:
            _dict['resource_group'] = getattr(self, 'resource_group')
        if hasattr(self, 'submitted_at') and getattr(self, 'submitted_at') is not None:
            _dict['submitted_at'] = datetime_to_string(getattr(self, 'submitted_at'))
        if hasattr(self, 'submitted_by') and getattr(self, 'submitted_by') is not None:
            _dict['submitted_by'] = getattr(self, 'submitted_by')
        if hasattr(self, 'start_at') and getattr(self, 'start_at') is not None:
            _dict['start_at'] = datetime_to_string(getattr(self, 'start_at'))
        if hasattr(self, 'end_at') and getattr(self, 'end_at') is not None:
            _dict['end_at'] = datetime_to_string(getattr(self, 'end_at'))
        if hasattr(self, 'duration') and getattr(self, 'duration') is not None:
            _dict['duration'] = getattr(self, 'duration')
        if hasattr(self, 'status') and self.status is not None:
            if isinstance(self.status, dict):
                _dict['status'] = self.status
            else:
                _dict['status'] = self.status.to_dict()
        if hasattr(self, 'cart_order_data') and self.cart_order_data is not None:
            cart_order_data_list = []
            for v in self.cart_order_data:
                if isinstance(v, dict):
                    cart_order_data_list.append(v)
                else:
                    cart_order_data_list.append(v.to_dict())
            _dict['cart_order_data'] = cart_order_data_list
        if hasattr(self, 'data') and self.data is not None:
            if isinstance(self.data, dict):
                _dict['data'] = self.data
            else:
                _dict['data'] = self.data.to_dict()
        if hasattr(self, 'bastion') and self.bastion is not None:
            if isinstance(self.bastion, dict):
                _dict['bastion'] = self.bastion
            else:
                _dict['bastion'] = self.bastion.to_dict()
        if hasattr(self, 'log_summary') and self.log_summary is not None:
            if isinstance(self.log_summary, dict):
                _dict['log_summary'] = self.log_summary
            else:
                _dict['log_summary'] = self.log_summary.to_dict()
        if hasattr(self, 'log_store_url') and getattr(self, 'log_store_url') is not None:
            _dict['log_store_url'] = getattr(self, 'log_store_url')
        if hasattr(self, 'state_store_url') and getattr(self, 'state_store_url') is not None:
            _dict['state_store_url'] = getattr(self, 'state_store_url')
        if hasattr(self, 'results_url') and getattr(self, 'results_url') is not None:
            _dict['results_url'] = getattr(self, 'results_url')
        if hasattr(self, 'updated_at') and getattr(self, 'updated_at') is not None:
            _dict['updated_at'] = datetime_to_string(getattr(self, 'updated_at'))
        if hasattr(self, 'job_runner_id') and getattr(self, 'job_runner_id') is not None:
            _dict['job_runner_id'] = getattr(self, 'job_runner_id')
        if hasattr(self, 'agent') and self.agent is not None:
            if isinstance(self.agent, dict):
                _dict['agent'] = self.agent
            else:
                _dict['agent'] = self.agent.to_dict()
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this Job object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'Job') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'Job') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

    class CommandObjectEnum(str, Enum):
        """
        Name of the Schematics automation resource.
        """

        WORKSPACE = 'workspace'
        ACTION = 'action'
        SYSTEM = 'system'
        ENVIRONMENT = 'environment'

    class CommandNameEnum(str, Enum):
        """
        Schematics job command name.
        """

        WORKSPACE_PLAN = 'workspace_plan'
        WORKSPACE_APPLY = 'workspace_apply'
        WORKSPACE_DESTROY = 'workspace_destroy'
        WORKSPACE_REFRESH = 'workspace_refresh'
        ANSIBLE_PLAYBOOK_RUN = 'ansible_playbook_run'
        ANSIBLE_PLAYBOOK_CHECK = 'ansible_playbook_check'
        CREATE_ACTION = 'create_action'
        PUT_ACTION = 'put_action'
        PATCH_ACTION = 'patch_action'
        DELETE_ACTION = 'delete_action'
        SYSTEM_KEY_ENABLE = 'system_key_enable'
        SYSTEM_KEY_DELETE = 'system_key_delete'
        SYSTEM_KEY_DISABLE = 'system_key_disable'
        SYSTEM_KEY_ROTATE = 'system_key_rotate'
        SYSTEM_KEY_RESTORE = 'system_key_restore'
        CREATE_WORKSPACE = 'create_workspace'
        PUT_WORKSPACE = 'put_workspace'
        PATCH_WORKSPACE = 'patch_workspace'
        DELETE_WORKSPACE = 'delete_workspace'
        CREATE_CART = 'create_cart'
        REPOSITORY_PROCESS = 'repository_process'
        TERRAFORM_COMMANDS = 'terraform_commands'

    class LocationEnum(str, Enum):
        """
        List of locations supported by IBM Cloud Schematics service.  While creating your
        workspace or action, choose the right region, since it cannot be changed.  Note,
        this does not limit the location of the IBM Cloud resources, provisioned using
        Schematics.
        """

        US_SOUTH = 'us-south'
        US_EAST = 'us-east'
        EU_GB = 'eu-gb'
        EU_DE = 'eu-de'


class JobData:
    """
    Job data.

    :param str job_type: Type of Job.
    :param JobDataWorkspace workspace_job_data: (optional) Workspace Job data.
    :param JobDataAction action_job_data: (optional) Action Job data.
    :param JobDataSystem system_job_data: (optional) Controls Job data.
    :param JobDataFlow flow_job_data: (optional) Flow Job data.
    """

    def __init__(
        self,
        job_type: str,
        *,
        workspace_job_data: Optional['JobDataWorkspace'] = None,
        action_job_data: Optional['JobDataAction'] = None,
        system_job_data: Optional['JobDataSystem'] = None,
        flow_job_data: Optional['JobDataFlow'] = None,
    ) -> None:
        """
        Initialize a JobData object.

        :param str job_type: Type of Job.
        :param JobDataWorkspace workspace_job_data: (optional) Workspace Job data.
        :param JobDataAction action_job_data: (optional) Action Job data.
        :param JobDataSystem system_job_data: (optional) Controls Job data.
        :param JobDataFlow flow_job_data: (optional) Flow Job data.
        """
        self.job_type = job_type
        self.workspace_job_data = workspace_job_data
        self.action_job_data = action_job_data
        self.system_job_data = system_job_data
        self.flow_job_data = flow_job_data

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'JobData':
        """Initialize a JobData object from a json dictionary."""
        args = {}
        if (job_type := _dict.get('job_type')) is not None:
            args['job_type'] = job_type
        else:
            raise ValueError('Required property \'job_type\' not present in JobData JSON')
        if (workspace_job_data := _dict.get('workspace_job_data')) is not None:
            args['workspace_job_data'] = JobDataWorkspace.from_dict(workspace_job_data)
        if (action_job_data := _dict.get('action_job_data')) is not None:
            args['action_job_data'] = JobDataAction.from_dict(action_job_data)
        if (system_job_data := _dict.get('system_job_data')) is not None:
            args['system_job_data'] = JobDataSystem.from_dict(system_job_data)
        if (flow_job_data := _dict.get('flow_job_data')) is not None:
            args['flow_job_data'] = JobDataFlow.from_dict(flow_job_data)
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a JobData object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'job_type') and self.job_type is not None:
            _dict['job_type'] = self.job_type
        if hasattr(self, 'workspace_job_data') and self.workspace_job_data is not None:
            if isinstance(self.workspace_job_data, dict):
                _dict['workspace_job_data'] = self.workspace_job_data
            else:
                _dict['workspace_job_data'] = self.workspace_job_data.to_dict()
        if hasattr(self, 'action_job_data') and self.action_job_data is not None:
            if isinstance(self.action_job_data, dict):
                _dict['action_job_data'] = self.action_job_data
            else:
                _dict['action_job_data'] = self.action_job_data.to_dict()
        if hasattr(self, 'system_job_data') and self.system_job_data is not None:
            if isinstance(self.system_job_data, dict):
                _dict['system_job_data'] = self.system_job_data
            else:
                _dict['system_job_data'] = self.system_job_data.to_dict()
        if hasattr(self, 'flow_job_data') and self.flow_job_data is not None:
            if isinstance(self.flow_job_data, dict):
                _dict['flow_job_data'] = self.flow_job_data
            else:
                _dict['flow_job_data'] = self.flow_job_data.to_dict()
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this JobData object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'JobData') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'JobData') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

    class JobTypeEnum(str, Enum):
        """
        Type of Job.
        """

        REPO_DOWNLOAD_JOB = 'repo_download_job'
        WORKSPACE_JOB = 'workspace_job'
        ACTION_JOB = 'action_job'
        SYSTEM_JOB = 'system_job'
        FLOW_JOB = 'flow-job'


class JobDataAction:
    """
    Action Job data.

    :param str action_name: (optional) Flow name.
    :param List[VariableData] inputs: (optional) Input variables data used by the
          Action Job.
    :param List[VariableData] outputs: (optional) Output variables data from the
          Action Job.
    :param List[VariableData] settings: (optional) Environment variables used by all
          the templates in the Action.
    :param datetime updated_at: (optional) Job status updation timestamp.
    :param InventoryResourceRecord inventory_record: (optional) Complete inventory
          definition details.
    :param str materialized_inventory: (optional) Materialized inventory details
          used by the Action Job, in .ini format.
    """

    def __init__(
        self,
        *,
        action_name: Optional[str] = None,
        inputs: Optional[List['VariableData']] = None,
        outputs: Optional[List['VariableData']] = None,
        settings: Optional[List['VariableData']] = None,
        updated_at: Optional[datetime] = None,
        inventory_record: Optional['InventoryResourceRecord'] = None,
        materialized_inventory: Optional[str] = None,
    ) -> None:
        """
        Initialize a JobDataAction object.

        :param str action_name: (optional) Flow name.
        :param List[VariableData] inputs: (optional) Input variables data used by
               the Action Job.
        :param List[VariableData] outputs: (optional) Output variables data from
               the Action Job.
        :param List[VariableData] settings: (optional) Environment variables used
               by all the templates in the Action.
        :param datetime updated_at: (optional) Job status updation timestamp.
        :param InventoryResourceRecord inventory_record: (optional) Complete
               inventory definition details.
        :param str materialized_inventory: (optional) Materialized inventory
               details used by the Action Job, in .ini format.
        """
        self.action_name = action_name
        self.inputs = inputs
        self.outputs = outputs
        self.settings = settings
        self.updated_at = updated_at
        self.inventory_record = inventory_record
        self.materialized_inventory = materialized_inventory

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'JobDataAction':
        """Initialize a JobDataAction object from a json dictionary."""
        args = {}
        if (action_name := _dict.get('action_name')) is not None:
            args['action_name'] = action_name
        if (inputs := _dict.get('inputs')) is not None:
            args['inputs'] = [VariableData.from_dict(v) for v in inputs]
        if (outputs := _dict.get('outputs')) is not None:
            args['outputs'] = [VariableData.from_dict(v) for v in outputs]
        if (settings := _dict.get('settings')) is not None:
            args['settings'] = [VariableData.from_dict(v) for v in settings]
        if (updated_at := _dict.get('updated_at')) is not None:
            args['updated_at'] = string_to_datetime(updated_at)
        if (inventory_record := _dict.get('inventory_record')) is not None:
            args['inventory_record'] = InventoryResourceRecord.from_dict(inventory_record)
        if (materialized_inventory := _dict.get('materialized_inventory')) is not None:
            args['materialized_inventory'] = materialized_inventory
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a JobDataAction object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'action_name') and self.action_name is not None:
            _dict['action_name'] = self.action_name
        if hasattr(self, 'inputs') and self.inputs is not None:
            inputs_list = []
            for v in self.inputs:
                if isinstance(v, dict):
                    inputs_list.append(v)
                else:
                    inputs_list.append(v.to_dict())
            _dict['inputs'] = inputs_list
        if hasattr(self, 'outputs') and self.outputs is not None:
            outputs_list = []
            for v in self.outputs:
                if isinstance(v, dict):
                    outputs_list.append(v)
                else:
                    outputs_list.append(v.to_dict())
            _dict['outputs'] = outputs_list
        if hasattr(self, 'settings') and self.settings is not None:
            settings_list = []
            for v in self.settings:
                if isinstance(v, dict):
                    settings_list.append(v)
                else:
                    settings_list.append(v.to_dict())
            _dict['settings'] = settings_list
        if hasattr(self, 'updated_at') and self.updated_at is not None:
            _dict['updated_at'] = datetime_to_string(self.updated_at)
        if hasattr(self, 'inventory_record') and self.inventory_record is not None:
            if isinstance(self.inventory_record, dict):
                _dict['inventory_record'] = self.inventory_record
            else:
                _dict['inventory_record'] = self.inventory_record.to_dict()
        if hasattr(self, 'materialized_inventory') and self.materialized_inventory is not None:
            _dict['materialized_inventory'] = self.materialized_inventory
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this JobDataAction object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'JobDataAction') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'JobDataAction') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other


class JobDataFlow:
    """
    Flow Job data.

    :param str flow_id: (optional) Flow ID.
    :param str flow_name: (optional) Flow Name.
    :param List[JobDataWorkItem] workitems: (optional) Job data used by each
          workitem Job.
    :param datetime updated_at: (optional) Job status updation timestamp.
    """

    def __init__(
        self,
        *,
        flow_id: Optional[str] = None,
        flow_name: Optional[str] = None,
        workitems: Optional[List['JobDataWorkItem']] = None,
        updated_at: Optional[datetime] = None,
    ) -> None:
        """
        Initialize a JobDataFlow object.

        :param str flow_id: (optional) Flow ID.
        :param str flow_name: (optional) Flow Name.
        :param List[JobDataWorkItem] workitems: (optional) Job data used by each
               workitem Job.
        :param datetime updated_at: (optional) Job status updation timestamp.
        """
        self.flow_id = flow_id
        self.flow_name = flow_name
        self.workitems = workitems
        self.updated_at = updated_at

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'JobDataFlow':
        """Initialize a JobDataFlow object from a json dictionary."""
        args = {}
        if (flow_id := _dict.get('flow_id')) is not None:
            args['flow_id'] = flow_id
        if (flow_name := _dict.get('flow_name')) is not None:
            args['flow_name'] = flow_name
        if (workitems := _dict.get('workitems')) is not None:
            args['workitems'] = [JobDataWorkItem.from_dict(v) for v in workitems]
        if (updated_at := _dict.get('updated_at')) is not None:
            args['updated_at'] = string_to_datetime(updated_at)
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a JobDataFlow object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'flow_id') and self.flow_id is not None:
            _dict['flow_id'] = self.flow_id
        if hasattr(self, 'flow_name') and self.flow_name is not None:
            _dict['flow_name'] = self.flow_name
        if hasattr(self, 'workitems') and self.workitems is not None:
            workitems_list = []
            for v in self.workitems:
                if isinstance(v, dict):
                    workitems_list.append(v)
                else:
                    workitems_list.append(v.to_dict())
            _dict['workitems'] = workitems_list
        if hasattr(self, 'updated_at') and self.updated_at is not None:
            _dict['updated_at'] = datetime_to_string(self.updated_at)
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this JobDataFlow object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'JobDataFlow') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'JobDataFlow') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other


class JobDataSystem:
    """
    Controls Job data.

    :param str key_id: (optional) Key ID for which key event is generated.
    :param List[str] schematics_resource_id: (optional) List of the schematics
          resource id.
    :param datetime updated_at: (optional) Job status updation timestamp.
    """

    def __init__(
        self,
        *,
        key_id: Optional[str] = None,
        schematics_resource_id: Optional[List[str]] = None,
        updated_at: Optional[datetime] = None,
    ) -> None:
        """
        Initialize a JobDataSystem object.

        :param str key_id: (optional) Key ID for which key event is generated.
        :param List[str] schematics_resource_id: (optional) List of the schematics
               resource id.
        :param datetime updated_at: (optional) Job status updation timestamp.
        """
        self.key_id = key_id
        self.schematics_resource_id = schematics_resource_id
        self.updated_at = updated_at

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'JobDataSystem':
        """Initialize a JobDataSystem object from a json dictionary."""
        args = {}
        if (key_id := _dict.get('key_id')) is not None:
            args['key_id'] = key_id
        if (schematics_resource_id := _dict.get('schematics_resource_id')) is not None:
            args['schematics_resource_id'] = schematics_resource_id
        if (updated_at := _dict.get('updated_at')) is not None:
            args['updated_at'] = string_to_datetime(updated_at)
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a JobDataSystem object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'key_id') and self.key_id is not None:
            _dict['key_id'] = self.key_id
        if hasattr(self, 'schematics_resource_id') and self.schematics_resource_id is not None:
            _dict['schematics_resource_id'] = self.schematics_resource_id
        if hasattr(self, 'updated_at') and self.updated_at is not None:
            _dict['updated_at'] = datetime_to_string(self.updated_at)
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this JobDataSystem object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'JobDataSystem') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'JobDataSystem') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other


class JobDataTemplate:
    """
    Template Job data.

    :param str template_id: (optional) Template Id.
    :param str template_name: (optional) Template name.
    :param int flow_index: (optional) Index of the template in the Flow.
    :param List[VariableData] inputs: (optional) Job inputs used by the Templates.
    :param List[VariableData] outputs: (optional) Job output from the Templates.
    :param List[VariableData] settings: (optional) Environment variables used by the
          template.
    :param datetime updated_at: (optional) Job status updation timestamp.
    """

    def __init__(
        self,
        *,
        template_id: Optional[str] = None,
        template_name: Optional[str] = None,
        flow_index: Optional[int] = None,
        inputs: Optional[List['VariableData']] = None,
        outputs: Optional[List['VariableData']] = None,
        settings: Optional[List['VariableData']] = None,
        updated_at: Optional[datetime] = None,
    ) -> None:
        """
        Initialize a JobDataTemplate object.

        :param str template_id: (optional) Template Id.
        :param str template_name: (optional) Template name.
        :param int flow_index: (optional) Index of the template in the Flow.
        :param List[VariableData] inputs: (optional) Job inputs used by the
               Templates.
        :param List[VariableData] outputs: (optional) Job output from the
               Templates.
        :param List[VariableData] settings: (optional) Environment variables used
               by the template.
        :param datetime updated_at: (optional) Job status updation timestamp.
        """
        self.template_id = template_id
        self.template_name = template_name
        self.flow_index = flow_index
        self.inputs = inputs
        self.outputs = outputs
        self.settings = settings
        self.updated_at = updated_at

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'JobDataTemplate':
        """Initialize a JobDataTemplate object from a json dictionary."""
        args = {}
        if (template_id := _dict.get('template_id')) is not None:
            args['template_id'] = template_id
        if (template_name := _dict.get('template_name')) is not None:
            args['template_name'] = template_name
        if (flow_index := _dict.get('flow_index')) is not None:
            args['flow_index'] = flow_index
        if (inputs := _dict.get('inputs')) is not None:
            args['inputs'] = [VariableData.from_dict(v) for v in inputs]
        if (outputs := _dict.get('outputs')) is not None:
            args['outputs'] = [VariableData.from_dict(v) for v in outputs]
        if (settings := _dict.get('settings')) is not None:
            args['settings'] = [VariableData.from_dict(v) for v in settings]
        if (updated_at := _dict.get('updated_at')) is not None:
            args['updated_at'] = string_to_datetime(updated_at)
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a JobDataTemplate object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'template_id') and self.template_id is not None:
            _dict['template_id'] = self.template_id
        if hasattr(self, 'template_name') and self.template_name is not None:
            _dict['template_name'] = self.template_name
        if hasattr(self, 'flow_index') and self.flow_index is not None:
            _dict['flow_index'] = self.flow_index
        if hasattr(self, 'inputs') and self.inputs is not None:
            inputs_list = []
            for v in self.inputs:
                if isinstance(v, dict):
                    inputs_list.append(v)
                else:
                    inputs_list.append(v.to_dict())
            _dict['inputs'] = inputs_list
        if hasattr(self, 'outputs') and self.outputs is not None:
            outputs_list = []
            for v in self.outputs:
                if isinstance(v, dict):
                    outputs_list.append(v)
                else:
                    outputs_list.append(v.to_dict())
            _dict['outputs'] = outputs_list
        if hasattr(self, 'settings') and self.settings is not None:
            settings_list = []
            for v in self.settings:
                if isinstance(v, dict):
                    settings_list.append(v)
                else:
                    settings_list.append(v.to_dict())
            _dict['settings'] = settings_list
        if hasattr(self, 'updated_at') and self.updated_at is not None:
            _dict['updated_at'] = datetime_to_string(self.updated_at)
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this JobDataTemplate object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'JobDataTemplate') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'JobDataTemplate') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other


class JobDataWorkItem:
    """
    Environment work items.

    :param str command_object_id: (optional) command object id.
    :param str command_object_name: (optional) command object name.
    :param str layers: (optional) layer name.
    :param str source_type: (optional) Type of source for the Template.
    :param ExternalSource source: (optional) Source of templates, playbooks, or
          controls.
    :param List[VariableData] inputs: (optional) Input variables data for the
          workItem used in FlowJob.
    :param List[VariableData] outputs: (optional) Output variables for the workItem.
    :param List[VariableData] settings: (optional) Environment variables for the
          workItem.
    :param JobDataWorkItemLastJob last_job: (optional) Status of the last job
          executed by the workitem.
    :param datetime updated_at: (optional) Job status updation timestamp.
    """

    def __init__(
        self,
        *,
        command_object_id: Optional[str] = None,
        command_object_name: Optional[str] = None,
        layers: Optional[str] = None,
        source_type: Optional[str] = None,
        source: Optional['ExternalSource'] = None,
        inputs: Optional[List['VariableData']] = None,
        outputs: Optional[List['VariableData']] = None,
        settings: Optional[List['VariableData']] = None,
        last_job: Optional['JobDataWorkItemLastJob'] = None,
        updated_at: Optional[datetime] = None,
    ) -> None:
        """
        Initialize a JobDataWorkItem object.

        :param str command_object_id: (optional) command object id.
        :param str command_object_name: (optional) command object name.
        :param str layers: (optional) layer name.
        :param str source_type: (optional) Type of source for the Template.
        :param ExternalSource source: (optional) Source of templates, playbooks, or
               controls.
        :param List[VariableData] inputs: (optional) Input variables data for the
               workItem used in FlowJob.
        :param List[VariableData] outputs: (optional) Output variables for the
               workItem.
        :param List[VariableData] settings: (optional) Environment variables for
               the workItem.
        :param JobDataWorkItemLastJob last_job: (optional) Status of the last job
               executed by the workitem.
        :param datetime updated_at: (optional) Job status updation timestamp.
        """
        self.command_object_id = command_object_id
        self.command_object_name = command_object_name
        self.layers = layers
        self.source_type = source_type
        self.source = source
        self.inputs = inputs
        self.outputs = outputs
        self.settings = settings
        self.last_job = last_job
        self.updated_at = updated_at

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'JobDataWorkItem':
        """Initialize a JobDataWorkItem object from a json dictionary."""
        args = {}
        if (command_object_id := _dict.get('command_object_id')) is not None:
            args['command_object_id'] = command_object_id
        if (command_object_name := _dict.get('command_object_name')) is not None:
            args['command_object_name'] = command_object_name
        if (layers := _dict.get('layers')) is not None:
            args['layers'] = layers
        if (source_type := _dict.get('source_type')) is not None:
            args['source_type'] = source_type
        if (source := _dict.get('source')) is not None:
            args['source'] = ExternalSource.from_dict(source)
        if (inputs := _dict.get('inputs')) is not None:
            args['inputs'] = [VariableData.from_dict(v) for v in inputs]
        if (outputs := _dict.get('outputs')) is not None:
            args['outputs'] = [VariableData.from_dict(v) for v in outputs]
        if (settings := _dict.get('settings')) is not None:
            args['settings'] = [VariableData.from_dict(v) for v in settings]
        if (last_job := _dict.get('last_job')) is not None:
            args['last_job'] = JobDataWorkItemLastJob.from_dict(last_job)
        if (updated_at := _dict.get('updated_at')) is not None:
            args['updated_at'] = string_to_datetime(updated_at)
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a JobDataWorkItem object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'command_object_id') and self.command_object_id is not None:
            _dict['command_object_id'] = self.command_object_id
        if hasattr(self, 'command_object_name') and self.command_object_name is not None:
            _dict['command_object_name'] = self.command_object_name
        if hasattr(self, 'layers') and self.layers is not None:
            _dict['layers'] = self.layers
        if hasattr(self, 'source_type') and self.source_type is not None:
            _dict['source_type'] = self.source_type
        if hasattr(self, 'source') and self.source is not None:
            if isinstance(self.source, dict):
                _dict['source'] = self.source
            else:
                _dict['source'] = self.source.to_dict()
        if hasattr(self, 'inputs') and self.inputs is not None:
            inputs_list = []
            for v in self.inputs:
                if isinstance(v, dict):
                    inputs_list.append(v)
                else:
                    inputs_list.append(v.to_dict())
            _dict['inputs'] = inputs_list
        if hasattr(self, 'outputs') and self.outputs is not None:
            outputs_list = []
            for v in self.outputs:
                if isinstance(v, dict):
                    outputs_list.append(v)
                else:
                    outputs_list.append(v.to_dict())
            _dict['outputs'] = outputs_list
        if hasattr(self, 'settings') and self.settings is not None:
            settings_list = []
            for v in self.settings:
                if isinstance(v, dict):
                    settings_list.append(v)
                else:
                    settings_list.append(v.to_dict())
            _dict['settings'] = settings_list
        if hasattr(self, 'last_job') and self.last_job is not None:
            if isinstance(self.last_job, dict):
                _dict['last_job'] = self.last_job
            else:
                _dict['last_job'] = self.last_job.to_dict()
        if hasattr(self, 'updated_at') and self.updated_at is not None:
            _dict['updated_at'] = datetime_to_string(self.updated_at)
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this JobDataWorkItem object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'JobDataWorkItem') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'JobDataWorkItem') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

    class SourceTypeEnum(str, Enum):
        """
        Type of source for the Template.
        """

        LOCAL = 'local'
        GIT_HUB = 'git_hub'
        GIT_HUB_ENTERPRISE = 'git_hub_enterprise'
        GIT_LAB = 'git_lab'
        IBM_GIT_LAB = 'ibm_git_lab'
        IBM_CLOUD_CATALOG = 'ibm_cloud_catalog'


class JobDataWorkItemLastJob:
    """
    Status of the last job executed by the workitem.

    :param str command_object: (optional) Name of the Schematics automation
          resource.
    :param str command_object_name: (optional) command object name
          (workspace_name/action_name).
    :param str command_object_id: (optional) Workitem command object id, maps to
          workspace_id or action_id.
    :param str command_name: (optional) Schematics job command name.
    :param str job_id: (optional) Workspace job id.
    :param str job_status: (optional) Status of Jobs.
    """

    def __init__(
        self,
        *,
        command_object: Optional[str] = None,
        command_object_name: Optional[str] = None,
        command_object_id: Optional[str] = None,
        command_name: Optional[str] = None,
        job_id: Optional[str] = None,
        job_status: Optional[str] = None,
    ) -> None:
        """
        Initialize a JobDataWorkItemLastJob object.

        :param str command_object: (optional) Name of the Schematics automation
               resource.
        :param str command_object_name: (optional) command object name
               (workspace_name/action_name).
        :param str command_object_id: (optional) Workitem command object id, maps
               to workspace_id or action_id.
        :param str command_name: (optional) Schematics job command name.
        :param str job_id: (optional) Workspace job id.
        :param str job_status: (optional) Status of Jobs.
        """
        self.command_object = command_object
        self.command_object_name = command_object_name
        self.command_object_id = command_object_id
        self.command_name = command_name
        self.job_id = job_id
        self.job_status = job_status

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'JobDataWorkItemLastJob':
        """Initialize a JobDataWorkItemLastJob object from a json dictionary."""
        args = {}
        if (command_object := _dict.get('command_object')) is not None:
            args['command_object'] = command_object
        if (command_object_name := _dict.get('command_object_name')) is not None:
            args['command_object_name'] = command_object_name
        if (command_object_id := _dict.get('command_object_id')) is not None:
            args['command_object_id'] = command_object_id
        if (command_name := _dict.get('command_name')) is not None:
            args['command_name'] = command_name
        if (job_id := _dict.get('job_id')) is not None:
            args['job_id'] = job_id
        if (job_status := _dict.get('job_status')) is not None:
            args['job_status'] = job_status
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a JobDataWorkItemLastJob object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'command_object') and self.command_object is not None:
            _dict['command_object'] = self.command_object
        if hasattr(self, 'command_object_name') and self.command_object_name is not None:
            _dict['command_object_name'] = self.command_object_name
        if hasattr(self, 'command_object_id') and self.command_object_id is not None:
            _dict['command_object_id'] = self.command_object_id
        if hasattr(self, 'command_name') and self.command_name is not None:
            _dict['command_name'] = self.command_name
        if hasattr(self, 'job_id') and self.job_id is not None:
            _dict['job_id'] = self.job_id
        if hasattr(self, 'job_status') and self.job_status is not None:
            _dict['job_status'] = self.job_status
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this JobDataWorkItemLastJob object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'JobDataWorkItemLastJob') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'JobDataWorkItemLastJob') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

    class CommandObjectEnum(str, Enum):
        """
        Name of the Schematics automation resource.
        """

        WORKSPACE = 'workspace'
        ACTION = 'action'
        SYSTEM = 'system'
        ENVIRONMENT = 'environment'

    class CommandNameEnum(str, Enum):
        """
        Schematics job command name.
        """

        WORKSPACE_PLAN = 'workspace_plan'
        WORKSPACE_APPLY = 'workspace_apply'
        WORKSPACE_DESTROY = 'workspace_destroy'
        WORKSPACE_REFRESH = 'workspace_refresh'
        ANSIBLE_PLAYBOOK_RUN = 'ansible_playbook_run'
        ANSIBLE_PLAYBOOK_CHECK = 'ansible_playbook_check'
        CREATE_ACTION = 'create_action'
        PUT_ACTION = 'put_action'
        PATCH_ACTION = 'patch_action'
        DELETE_ACTION = 'delete_action'
        SYSTEM_KEY_ENABLE = 'system_key_enable'
        SYSTEM_KEY_DELETE = 'system_key_delete'
        SYSTEM_KEY_DISABLE = 'system_key_disable'
        SYSTEM_KEY_ROTATE = 'system_key_rotate'
        SYSTEM_KEY_RESTORE = 'system_key_restore'
        CREATE_WORKSPACE = 'create_workspace'
        PUT_WORKSPACE = 'put_workspace'
        PATCH_WORKSPACE = 'patch_workspace'
        DELETE_WORKSPACE = 'delete_workspace'
        CREATE_CART = 'create_cart'
        REPOSITORY_PROCESS = 'repository_process'
        TERRAFORM_COMMANDS = 'terraform_commands'

    class JobStatusEnum(str, Enum):
        """
        Status of Jobs.
        """

        JOB_PENDING = 'job_pending'
        JOB_IN_PROGRESS = 'job_in_progress'
        JOB_FINISHED = 'job_finished'
        JOB_FAILED = 'job_failed'
        JOB_CANCELLED = 'job_cancelled'
        JOB_STOPPED = 'job_stopped'
        JOB_STOP_IN_PROGRESS = 'job_stop_in_progress'
        JOB_READY_TO_EXECUTE = 'job_ready_to_execute'


class JobDataWorkspace:
    """
    Workspace Job data.

    :param str workspace_name: (optional) Workspace name.
    :param str flow_id: (optional) Flow Id.
    :param str flow_name: (optional) Flow name.
    :param List[VariableData] inputs: (optional) Input variables data used by the
          Workspace Job.
    :param List[VariableData] outputs: (optional) Output variables data from the
          Workspace Job.
    :param List[VariableData] settings: (optional) Environment variables used by all
          the templates in the Workspace.
    :param List[JobDataTemplate] template_data: (optional) Input / output data of
          the Template in the Workspace Job.
    :param datetime updated_at: (optional) Job status updation timestamp.
    """

    def __init__(
        self,
        *,
        workspace_name: Optional[str] = None,
        flow_id: Optional[str] = None,
        flow_name: Optional[str] = None,
        inputs: Optional[List['VariableData']] = None,
        outputs: Optional[List['VariableData']] = None,
        settings: Optional[List['VariableData']] = None,
        template_data: Optional[List['JobDataTemplate']] = None,
        updated_at: Optional[datetime] = None,
    ) -> None:
        """
        Initialize a JobDataWorkspace object.

        :param str workspace_name: (optional) Workspace name.
        :param str flow_id: (optional) Flow Id.
        :param str flow_name: (optional) Flow name.
        :param List[VariableData] inputs: (optional) Input variables data used by
               the Workspace Job.
        :param List[VariableData] outputs: (optional) Output variables data from
               the Workspace Job.
        :param List[VariableData] settings: (optional) Environment variables used
               by all the templates in the Workspace.
        :param List[JobDataTemplate] template_data: (optional) Input / output data
               of the Template in the Workspace Job.
        :param datetime updated_at: (optional) Job status updation timestamp.
        """
        self.workspace_name = workspace_name
        self.flow_id = flow_id
        self.flow_name = flow_name
        self.inputs = inputs
        self.outputs = outputs
        self.settings = settings
        self.template_data = template_data
        self.updated_at = updated_at

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'JobDataWorkspace':
        """Initialize a JobDataWorkspace object from a json dictionary."""
        args = {}
        if (workspace_name := _dict.get('workspace_name')) is not None:
            args['workspace_name'] = workspace_name
        if (flow_id := _dict.get('flow_id')) is not None:
            args['flow_id'] = flow_id
        if (flow_name := _dict.get('flow_name')) is not None:
            args['flow_name'] = flow_name
        if (inputs := _dict.get('inputs')) is not None:
            args['inputs'] = [VariableData.from_dict(v) for v in inputs]
        if (outputs := _dict.get('outputs')) is not None:
            args['outputs'] = [VariableData.from_dict(v) for v in outputs]
        if (settings := _dict.get('settings')) is not None:
            args['settings'] = [VariableData.from_dict(v) for v in settings]
        if (template_data := _dict.get('template_data')) is not None:
            args['template_data'] = [JobDataTemplate.from_dict(v) for v in template_data]
        if (updated_at := _dict.get('updated_at')) is not None:
            args['updated_at'] = string_to_datetime(updated_at)
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a JobDataWorkspace object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'workspace_name') and self.workspace_name is not None:
            _dict['workspace_name'] = self.workspace_name
        if hasattr(self, 'flow_id') and self.flow_id is not None:
            _dict['flow_id'] = self.flow_id
        if hasattr(self, 'flow_name') and self.flow_name is not None:
            _dict['flow_name'] = self.flow_name
        if hasattr(self, 'inputs') and self.inputs is not None:
            inputs_list = []
            for v in self.inputs:
                if isinstance(v, dict):
                    inputs_list.append(v)
                else:
                    inputs_list.append(v.to_dict())
            _dict['inputs'] = inputs_list
        if hasattr(self, 'outputs') and self.outputs is not None:
            outputs_list = []
            for v in self.outputs:
                if isinstance(v, dict):
                    outputs_list.append(v)
                else:
                    outputs_list.append(v.to_dict())
            _dict['outputs'] = outputs_list
        if hasattr(self, 'settings') and self.settings is not None:
            settings_list = []
            for v in self.settings:
                if isinstance(v, dict):
                    settings_list.append(v)
                else:
                    settings_list.append(v.to_dict())
            _dict['settings'] = settings_list
        if hasattr(self, 'template_data') and self.template_data is not None:
            template_data_list = []
            for v in self.template_data:
                if isinstance(v, dict):
                    template_data_list.append(v)
                else:
                    template_data_list.append(v.to_dict())
            _dict['template_data'] = template_data_list
        if hasattr(self, 'updated_at') and self.updated_at is not None:
            _dict['updated_at'] = datetime_to_string(self.updated_at)
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this JobDataWorkspace object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'JobDataWorkspace') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'JobDataWorkspace') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other


class JobFileContent:
    """
    JobFileContent.

    :param str file_name: (optional) Name of the file.
    :param str file_content: (optional) Content of the file, generated by the job.
    """

    def __init__(
        self,
        *,
        file_name: Optional[str] = None,
        file_content: Optional[str] = None,
    ) -> None:
        """
        Initialize a JobFileContent object.

        :param str file_name: (optional) Name of the file.
        :param str file_content: (optional) Content of the file, generated by the
               job.
        """
        self.file_name = file_name
        self.file_content = file_content

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'JobFileContent':
        """Initialize a JobFileContent object from a json dictionary."""
        args = {}
        if (file_name := _dict.get('file_name')) is not None:
            args['file_name'] = file_name
        if (file_content := _dict.get('file_content')) is not None:
            args['file_content'] = file_content
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a JobFileContent object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'file_name') and self.file_name is not None:
            _dict['file_name'] = self.file_name
        if hasattr(self, 'file_content') and self.file_content is not None:
            _dict['file_content'] = self.file_content
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this JobFileContent object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'JobFileContent') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'JobFileContent') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other


class JobFileData:
    """
    Output files from the Job record.

    :param str job_id: (optional) Job Id.
    :param str job_name: (optional) Job name, uniquely derived from the related
          Workspace and Action.
    :param List[JobFileDataSummary] summary: (optional) Summary metadata in the
          output files.
    :param str file_type: (optional) The type of output file generated by the Job.
    :param str file_content: (optional) Content of the file, generated by the job.
    :param List[JobFileContent] additional_files: (optional) Content of the
          additional files, generated by the child job.
    :param datetime updated_at: (optional) Job file updation timestamp.
    """

    def __init__(
        self,
        *,
        job_id: Optional[str] = None,
        job_name: Optional[str] = None,
        summary: Optional[List['JobFileDataSummary']] = None,
        file_type: Optional[str] = None,
        file_content: Optional[str] = None,
        additional_files: Optional[List['JobFileContent']] = None,
        updated_at: Optional[datetime] = None,
    ) -> None:
        """
        Initialize a JobFileData object.

        :param str job_id: (optional) Job Id.
        :param str job_name: (optional) Job name, uniquely derived from the related
               Workspace and Action.
        :param List[JobFileDataSummary] summary: (optional) Summary metadata in the
               output files.
        :param str file_type: (optional) The type of output file generated by the
               Job.
        :param str file_content: (optional) Content of the file, generated by the
               job.
        :param List[JobFileContent] additional_files: (optional) Content of the
               additional files, generated by the child job.
        :param datetime updated_at: (optional) Job file updation timestamp.
        """
        self.job_id = job_id
        self.job_name = job_name
        self.summary = summary
        self.file_type = file_type
        self.file_content = file_content
        self.additional_files = additional_files
        self.updated_at = updated_at

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'JobFileData':
        """Initialize a JobFileData object from a json dictionary."""
        args = {}
        if (job_id := _dict.get('job_id')) is not None:
            args['job_id'] = job_id
        if (job_name := _dict.get('job_name')) is not None:
            args['job_name'] = job_name
        if (summary := _dict.get('summary')) is not None:
            args['summary'] = [JobFileDataSummary.from_dict(v) for v in summary]
        if (file_type := _dict.get('file_type')) is not None:
            args['file_type'] = file_type
        if (file_content := _dict.get('file_content')) is not None:
            args['file_content'] = file_content
        if (additional_files := _dict.get('additional_files')) is not None:
            args['additional_files'] = [JobFileContent.from_dict(v) for v in additional_files]
        if (updated_at := _dict.get('updated_at')) is not None:
            args['updated_at'] = string_to_datetime(updated_at)
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a JobFileData object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'job_id') and self.job_id is not None:
            _dict['job_id'] = self.job_id
        if hasattr(self, 'job_name') and self.job_name is not None:
            _dict['job_name'] = self.job_name
        if hasattr(self, 'summary') and self.summary is not None:
            summary_list = []
            for v in self.summary:
                if isinstance(v, dict):
                    summary_list.append(v)
                else:
                    summary_list.append(v.to_dict())
            _dict['summary'] = summary_list
        if hasattr(self, 'file_type') and self.file_type is not None:
            _dict['file_type'] = self.file_type
        if hasattr(self, 'file_content') and self.file_content is not None:
            _dict['file_content'] = self.file_content
        if hasattr(self, 'additional_files') and self.additional_files is not None:
            additional_files_list = []
            for v in self.additional_files:
                if isinstance(v, dict):
                    additional_files_list.append(v)
                else:
                    additional_files_list.append(v.to_dict())
            _dict['additional_files'] = additional_files_list
        if hasattr(self, 'updated_at') and self.updated_at is not None:
            _dict['updated_at'] = datetime_to_string(self.updated_at)
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this JobFileData object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'JobFileData') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'JobFileData') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

    class FileTypeEnum(str, Enum):
        """
        The type of output file generated by the Job.
        """

        STATE_FILE = 'state_file'
        PLAN_JSON = 'plan_json'
        QUOTE_JSON = 'quote_json'
        DRAFT_PLAN_JSON = 'draft_plan_json'
        GIT_FILES = 'git_files'
        COST_JSON = 'cost_json'
        LOG_INSIGHTS_FILE = 'log_insights_file'


class JobFileDataSummary:
    """
    JobFileDataSummary.

    :param str name: (optional) Summary feature name.
    :param str type: (optional) Summary feature type.
    :param str value: (optional) Summary feature value.
    """

    def __init__(
        self,
        *,
        name: Optional[str] = None,
        type: Optional[str] = None,
        value: Optional[str] = None,
    ) -> None:
        """
        Initialize a JobFileDataSummary object.

        :param str name: (optional) Summary feature name.
        :param str type: (optional) Summary feature type.
        :param str value: (optional) Summary feature value.
        """
        self.name = name
        self.type = type
        self.value = value

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'JobFileDataSummary':
        """Initialize a JobFileDataSummary object from a json dictionary."""
        args = {}
        if (name := _dict.get('name')) is not None:
            args['name'] = name
        if (type := _dict.get('type')) is not None:
            args['type'] = type
        if (value := _dict.get('value')) is not None:
            args['value'] = value
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a JobFileDataSummary object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'name') and self.name is not None:
            _dict['name'] = self.name
        if hasattr(self, 'type') and self.type is not None:
            _dict['type'] = self.type
        if hasattr(self, 'value') and self.value is not None:
            _dict['value'] = self.value
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this JobFileDataSummary object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'JobFileDataSummary') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'JobFileDataSummary') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

    class TypeEnum(str, Enum):
        """
        Summary feature type.
        """

        NUMBER = 'number'
        STRING = 'string'


class JobList:
    """
    List of Job details.

    :param int total_count: (optional) Total number of records.
    :param int limit: Number of records returned.
    :param int offset: Skipped number of records.
    :param List[JobLite] jobs: (optional) List of job records.
    """

    def __init__(
        self,
        limit: int,
        offset: int,
        *,
        total_count: Optional[int] = None,
        jobs: Optional[List['JobLite']] = None,
    ) -> None:
        """
        Initialize a JobList object.

        :param int limit: Number of records returned.
        :param int offset: Skipped number of records.
        :param int total_count: (optional) Total number of records.
        :param List[JobLite] jobs: (optional) List of job records.
        """
        self.total_count = total_count
        self.limit = limit
        self.offset = offset
        self.jobs = jobs

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'JobList':
        """Initialize a JobList object from a json dictionary."""
        args = {}
        if (total_count := _dict.get('total_count')) is not None:
            args['total_count'] = total_count
        if (limit := _dict.get('limit')) is not None:
            args['limit'] = limit
        else:
            raise ValueError('Required property \'limit\' not present in JobList JSON')
        if (offset := _dict.get('offset')) is not None:
            args['offset'] = offset
        else:
            raise ValueError('Required property \'offset\' not present in JobList JSON')
        if (jobs := _dict.get('jobs')) is not None:
            args['jobs'] = [JobLite.from_dict(v) for v in jobs]
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a JobList object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'total_count') and self.total_count is not None:
            _dict['total_count'] = self.total_count
        if hasattr(self, 'limit') and self.limit is not None:
            _dict['limit'] = self.limit
        if hasattr(self, 'offset') and self.offset is not None:
            _dict['offset'] = self.offset
        if hasattr(self, 'jobs') and self.jobs is not None:
            jobs_list = []
            for v in self.jobs:
                if isinstance(v, dict):
                    jobs_list.append(v)
                else:
                    jobs_list.append(v.to_dict())
            _dict['jobs'] = jobs_list
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this JobList object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'JobList') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'JobList') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other


class JobLite:
    """
    Job summary profile with system generated data.

    :param str id: (optional) Job ID.
    :param str name: (optional) Job name, uniquely derived from the related
          Workspace or Action.
    :param str description: (optional) Job description derived from the related
          Workspace or Action.
    :param str command_object: (optional) Name of the Schematics automation
          resource.
    :param str command_object_id: (optional) Job command object id (workspace-id,
          action-id).
    :param str command_name: (optional) Schematics job command name.
    :param List[str] tags: (optional) User defined tags, while running the job.
    :param str location: (optional) List of locations supported by IBM Cloud
          Schematics service.  While creating your workspace or action, choose the right
          region, since it cannot be changed.  Note, this does not limit the location of
          the IBM Cloud resources, provisioned using Schematics.
    :param str resource_group: (optional) Resource-group name derived from the
          related Workspace or Action.
    :param datetime submitted_at: (optional) Job submission time.
    :param str submitted_by: (optional) Email address of user who submitted the job.
    :param str duration: (optional) Duration of job execution; example 40 sec.
    :param datetime start_at: (optional) Job start time.
    :param datetime end_at: (optional) Job end time.
    :param JobStatus status: (optional) Job Status.
    :param JobLogSummary log_summary: (optional) Job log summary record.
    :param datetime updated_at: (optional) Job status updation timestamp.
    :param str job_runner_id: (optional) ID of the Job Runner.
    :param AgentInfo agent: (optional) Agent name, Agent id and associated policy ID
          information.
    """

    def __init__(
        self,
        *,
        id: Optional[str] = None,
        name: Optional[str] = None,
        description: Optional[str] = None,
        command_object: Optional[str] = None,
        command_object_id: Optional[str] = None,
        command_name: Optional[str] = None,
        tags: Optional[List[str]] = None,
        location: Optional[str] = None,
        resource_group: Optional[str] = None,
        submitted_at: Optional[datetime] = None,
        submitted_by: Optional[str] = None,
        duration: Optional[str] = None,
        start_at: Optional[datetime] = None,
        end_at: Optional[datetime] = None,
        status: Optional['JobStatus'] = None,
        log_summary: Optional['JobLogSummary'] = None,
        updated_at: Optional[datetime] = None,
        job_runner_id: Optional[str] = None,
        agent: Optional['AgentInfo'] = None,
    ) -> None:
        """
        Initialize a JobLite object.

        :param str id: (optional) Job ID.
        :param str name: (optional) Job name, uniquely derived from the related
               Workspace or Action.
        :param str description: (optional) Job description derived from the related
               Workspace or Action.
        :param str command_object: (optional) Name of the Schematics automation
               resource.
        :param str command_object_id: (optional) Job command object id
               (workspace-id, action-id).
        :param str command_name: (optional) Schematics job command name.
        :param List[str] tags: (optional) User defined tags, while running the job.
        :param str location: (optional) List of locations supported by IBM Cloud
               Schematics service.  While creating your workspace or action, choose the
               right region, since it cannot be changed.  Note, this does not limit the
               location of the IBM Cloud resources, provisioned using Schematics.
        :param str resource_group: (optional) Resource-group name derived from the
               related Workspace or Action.
        :param datetime submitted_at: (optional) Job submission time.
        :param str submitted_by: (optional) Email address of user who submitted the
               job.
        :param str duration: (optional) Duration of job execution; example 40 sec.
        :param datetime start_at: (optional) Job start time.
        :param datetime end_at: (optional) Job end time.
        :param JobStatus status: (optional) Job Status.
        :param JobLogSummary log_summary: (optional) Job log summary record.
        :param datetime updated_at: (optional) Job status updation timestamp.
        :param str job_runner_id: (optional) ID of the Job Runner.
        :param AgentInfo agent: (optional) Agent name, Agent id and associated
               policy ID information.
        """
        self.id = id
        self.name = name
        self.description = description
        self.command_object = command_object
        self.command_object_id = command_object_id
        self.command_name = command_name
        self.tags = tags
        self.location = location
        self.resource_group = resource_group
        self.submitted_at = submitted_at
        self.submitted_by = submitted_by
        self.duration = duration
        self.start_at = start_at
        self.end_at = end_at
        self.status = status
        self.log_summary = log_summary
        self.updated_at = updated_at
        self.job_runner_id = job_runner_id
        self.agent = agent

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'JobLite':
        """Initialize a JobLite object from a json dictionary."""
        args = {}
        if (id := _dict.get('id')) is not None:
            args['id'] = id
        if (name := _dict.get('name')) is not None:
            args['name'] = name
        if (description := _dict.get('description')) is not None:
            args['description'] = description
        if (command_object := _dict.get('command_object')) is not None:
            args['command_object'] = command_object
        if (command_object_id := _dict.get('command_object_id')) is not None:
            args['command_object_id'] = command_object_id
        if (command_name := _dict.get('command_name')) is not None:
            args['command_name'] = command_name
        if (tags := _dict.get('tags')) is not None:
            args['tags'] = tags
        if (location := _dict.get('location')) is not None:
            args['location'] = location
        if (resource_group := _dict.get('resource_group')) is not None:
            args['resource_group'] = resource_group
        if (submitted_at := _dict.get('submitted_at')) is not None:
            args['submitted_at'] = string_to_datetime(submitted_at)
        if (submitted_by := _dict.get('submitted_by')) is not None:
            args['submitted_by'] = submitted_by
        if (duration := _dict.get('duration')) is not None:
            args['duration'] = duration
        if (start_at := _dict.get('start_at')) is not None:
            args['start_at'] = string_to_datetime(start_at)
        if (end_at := _dict.get('end_at')) is not None:
            args['end_at'] = string_to_datetime(end_at)
        if (status := _dict.get('status')) is not None:
            args['status'] = JobStatus.from_dict(status)
        if (log_summary := _dict.get('log_summary')) is not None:
            args['log_summary'] = JobLogSummary.from_dict(log_summary)
        if (updated_at := _dict.get('updated_at')) is not None:
            args['updated_at'] = string_to_datetime(updated_at)
        if (job_runner_id := _dict.get('job_runner_id')) is not None:
            args['job_runner_id'] = job_runner_id
        if (agent := _dict.get('agent')) is not None:
            args['agent'] = AgentInfo.from_dict(agent)
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a JobLite object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'id') and self.id is not None:
            _dict['id'] = self.id
        if hasattr(self, 'name') and self.name is not None:
            _dict['name'] = self.name
        if hasattr(self, 'description') and self.description is not None:
            _dict['description'] = self.description
        if hasattr(self, 'command_object') and self.command_object is not None:
            _dict['command_object'] = self.command_object
        if hasattr(self, 'command_object_id') and self.command_object_id is not None:
            _dict['command_object_id'] = self.command_object_id
        if hasattr(self, 'command_name') and self.command_name is not None:
            _dict['command_name'] = self.command_name
        if hasattr(self, 'tags') and self.tags is not None:
            _dict['tags'] = self.tags
        if hasattr(self, 'location') and self.location is not None:
            _dict['location'] = self.location
        if hasattr(self, 'resource_group') and self.resource_group is not None:
            _dict['resource_group'] = self.resource_group
        if hasattr(self, 'submitted_at') and self.submitted_at is not None:
            _dict['submitted_at'] = datetime_to_string(self.submitted_at)
        if hasattr(self, 'submitted_by') and self.submitted_by is not None:
            _dict['submitted_by'] = self.submitted_by
        if hasattr(self, 'duration') and self.duration is not None:
            _dict['duration'] = self.duration
        if hasattr(self, 'start_at') and self.start_at is not None:
            _dict['start_at'] = datetime_to_string(self.start_at)
        if hasattr(self, 'end_at') and self.end_at is not None:
            _dict['end_at'] = datetime_to_string(self.end_at)
        if hasattr(self, 'status') and self.status is not None:
            if isinstance(self.status, dict):
                _dict['status'] = self.status
            else:
                _dict['status'] = self.status.to_dict()
        if hasattr(self, 'log_summary') and self.log_summary is not None:
            if isinstance(self.log_summary, dict):
                _dict['log_summary'] = self.log_summary
            else:
                _dict['log_summary'] = self.log_summary.to_dict()
        if hasattr(self, 'updated_at') and self.updated_at is not None:
            _dict['updated_at'] = datetime_to_string(self.updated_at)
        if hasattr(self, 'job_runner_id') and self.job_runner_id is not None:
            _dict['job_runner_id'] = self.job_runner_id
        if hasattr(self, 'agent') and self.agent is not None:
            if isinstance(self.agent, dict):
                _dict['agent'] = self.agent
            else:
                _dict['agent'] = self.agent.to_dict()
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this JobLite object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'JobLite') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'JobLite') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

    class CommandObjectEnum(str, Enum):
        """
        Name of the Schematics automation resource.
        """

        WORKSPACE = 'workspace'
        ACTION = 'action'
        SYSTEM = 'system'
        ENVIRONMENT = 'environment'

    class CommandNameEnum(str, Enum):
        """
        Schematics job command name.
        """

        WORKSPACE_PLAN = 'workspace_plan'
        WORKSPACE_APPLY = 'workspace_apply'
        WORKSPACE_DESTROY = 'workspace_destroy'
        WORKSPACE_REFRESH = 'workspace_refresh'
        ANSIBLE_PLAYBOOK_RUN = 'ansible_playbook_run'
        ANSIBLE_PLAYBOOK_CHECK = 'ansible_playbook_check'
        CREATE_ACTION = 'create_action'
        PUT_ACTION = 'put_action'
        PATCH_ACTION = 'patch_action'
        DELETE_ACTION = 'delete_action'
        SYSTEM_KEY_ENABLE = 'system_key_enable'
        SYSTEM_KEY_DELETE = 'system_key_delete'
        SYSTEM_KEY_DISABLE = 'system_key_disable'
        SYSTEM_KEY_ROTATE = 'system_key_rotate'
        SYSTEM_KEY_RESTORE = 'system_key_restore'
        CREATE_WORKSPACE = 'create_workspace'
        PUT_WORKSPACE = 'put_workspace'
        PATCH_WORKSPACE = 'patch_workspace'
        DELETE_WORKSPACE = 'delete_workspace'
        CREATE_CART = 'create_cart'
        REPOSITORY_PROCESS = 'repository_process'
        TERRAFORM_COMMANDS = 'terraform_commands'

    class LocationEnum(str, Enum):
        """
        List of locations supported by IBM Cloud Schematics service.  While creating your
        workspace or action, choose the right region, since it cannot be changed.  Note,
        this does not limit the location of the IBM Cloud resources, provisioned using
        Schematics.
        """

        US_SOUTH = 'us-south'
        US_EAST = 'us-east'
        EU_GB = 'eu-gb'
        EU_DE = 'eu-de'


class JobLog:
    """
    Job Log details.

    :param str job_id: (optional) Job Id.
    :param str job_name: (optional) Job name, uniquely derived from the related
          Workspace, Action or Controls.
    :param JobLogSummary log_summary: (optional) Job log summary record.
    :param str format: (optional) Format of the Log text.
    :param bytes details: (optional) Log text, generated by the Job.
    :param datetime updated_at: (optional) Job status updation timestamp.
    """

    def __init__(
        self,
        *,
        job_id: Optional[str] = None,
        job_name: Optional[str] = None,
        log_summary: Optional['JobLogSummary'] = None,
        format: Optional[str] = None,
        details: Optional[bytes] = None,
        updated_at: Optional[datetime] = None,
    ) -> None:
        """
        Initialize a JobLog object.

        :param str job_id: (optional) Job Id.
        :param str job_name: (optional) Job name, uniquely derived from the related
               Workspace, Action or Controls.
        :param JobLogSummary log_summary: (optional) Job log summary record.
        :param str format: (optional) Format of the Log text.
        :param bytes details: (optional) Log text, generated by the Job.
        :param datetime updated_at: (optional) Job status updation timestamp.
        """
        self.job_id = job_id
        self.job_name = job_name
        self.log_summary = log_summary
        self.format = format
        self.details = details
        self.updated_at = updated_at

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'JobLog':
        """Initialize a JobLog object from a json dictionary."""
        args = {}
        if (job_id := _dict.get('job_id')) is not None:
            args['job_id'] = job_id
        if (job_name := _dict.get('job_name')) is not None:
            args['job_name'] = job_name
        if (log_summary := _dict.get('log_summary')) is not None:
            args['log_summary'] = JobLogSummary.from_dict(log_summary)
        if (format := _dict.get('format')) is not None:
            args['format'] = format
        if (details := _dict.get('details')) is not None:
            args['details'] = base64.b64decode(details)
        if (updated_at := _dict.get('updated_at')) is not None:
            args['updated_at'] = string_to_datetime(updated_at)
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a JobLog object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'job_id') and self.job_id is not None:
            _dict['job_id'] = self.job_id
        if hasattr(self, 'job_name') and self.job_name is not None:
            _dict['job_name'] = self.job_name
        if hasattr(self, 'log_summary') and self.log_summary is not None:
            if isinstance(self.log_summary, dict):
                _dict['log_summary'] = self.log_summary
            else:
                _dict['log_summary'] = self.log_summary.to_dict()
        if hasattr(self, 'format') and self.format is not None:
            _dict['format'] = self.format
        if hasattr(self, 'details') and self.details is not None:
            _dict['details'] = str(base64.b64encode(self.details), 'utf-8')
        if hasattr(self, 'updated_at') and self.updated_at is not None:
            _dict['updated_at'] = datetime_to_string(self.updated_at)
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this JobLog object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'JobLog') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'JobLog') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

    class FormatEnum(str, Enum):
        """
        Format of the Log text.
        """

        JSON = 'json'
        HTML = 'html'
        MARKDOWN = 'markdown'
        RTF = 'rtf'


class JobLogSummary:
    """
    Job log summary record.

    :param str job_id: (optional) Workspace Id.
    :param str job_type: (optional) Type of Job.
    :param datetime log_start_at: (optional) Job log start timestamp.
    :param datetime log_analyzed_till: (optional) Job log update timestamp.
    :param float elapsed_time: (optional) Job log elapsed time (log_analyzed_till -
          log_start_at).
    :param List[JobLogSummaryLogErrors] log_errors: (optional) Job log errors.
    :param JobLogSummaryRepoDownloadJob repo_download_job: (optional) Repo download
          Job log summary.
    :param JobLogSummaryWorkspaceJob workspace_job: (optional) Workspace Job log
          summary.
    :param JobLogSummaryFlowJob flow_job: (optional) Flow Job log summary.
    :param JobLogSummaryActionJob action_job: (optional) Flow Job log summary.
    :param JobLogSummarySystemJob system_job: (optional) System Job log summary.
    """

    def __init__(
        self,
        *,
        job_id: Optional[str] = None,
        job_type: Optional[str] = None,
        log_start_at: Optional[datetime] = None,
        log_analyzed_till: Optional[datetime] = None,
        elapsed_time: Optional[float] = None,
        log_errors: Optional[List['JobLogSummaryLogErrors']] = None,
        repo_download_job: Optional['JobLogSummaryRepoDownloadJob'] = None,
        workspace_job: Optional['JobLogSummaryWorkspaceJob'] = None,
        flow_job: Optional['JobLogSummaryFlowJob'] = None,
        action_job: Optional['JobLogSummaryActionJob'] = None,
        system_job: Optional['JobLogSummarySystemJob'] = None,
    ) -> None:
        """
        Initialize a JobLogSummary object.

        :param str job_type: (optional) Type of Job.
        :param JobLogSummaryRepoDownloadJob repo_download_job: (optional) Repo
               download Job log summary.
        :param JobLogSummaryWorkspaceJob workspace_job: (optional) Workspace Job
               log summary.
        :param JobLogSummaryFlowJob flow_job: (optional) Flow Job log summary.
        :param JobLogSummaryActionJob action_job: (optional) Flow Job log summary.
        :param JobLogSummarySystemJob system_job: (optional) System Job log
               summary.
        """
        self.job_id = job_id
        self.job_type = job_type
        self.log_start_at = log_start_at
        self.log_analyzed_till = log_analyzed_till
        self.elapsed_time = elapsed_time
        self.log_errors = log_errors
        self.repo_download_job = repo_download_job
        self.workspace_job = workspace_job
        self.flow_job = flow_job
        self.action_job = action_job
        self.system_job = system_job

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'JobLogSummary':
        """Initialize a JobLogSummary object from a json dictionary."""
        args = {}
        if (job_id := _dict.get('job_id')) is not None:
            args['job_id'] = job_id
        if (job_type := _dict.get('job_type')) is not None:
            args['job_type'] = job_type
        if (log_start_at := _dict.get('log_start_at')) is not None:
            args['log_start_at'] = string_to_datetime(log_start_at)
        if (log_analyzed_till := _dict.get('log_analyzed_till')) is not None:
            args['log_analyzed_till'] = string_to_datetime(log_analyzed_till)
        if (elapsed_time := _dict.get('elapsed_time')) is not None:
            args['elapsed_time'] = elapsed_time
        if (log_errors := _dict.get('log_errors')) is not None:
            args['log_errors'] = [JobLogSummaryLogErrors.from_dict(v) for v in log_errors]
        if (repo_download_job := _dict.get('repo_download_job')) is not None:
            args['repo_download_job'] = JobLogSummaryRepoDownloadJob.from_dict(repo_download_job)
        if (workspace_job := _dict.get('workspace_job')) is not None:
            args['workspace_job'] = JobLogSummaryWorkspaceJob.from_dict(workspace_job)
        if (flow_job := _dict.get('flow_job')) is not None:
            args['flow_job'] = JobLogSummaryFlowJob.from_dict(flow_job)
        if (action_job := _dict.get('action_job')) is not None:
            args['action_job'] = JobLogSummaryActionJob.from_dict(action_job)
        if (system_job := _dict.get('system_job')) is not None:
            args['system_job'] = JobLogSummarySystemJob.from_dict(system_job)
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a JobLogSummary object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'job_id') and getattr(self, 'job_id') is not None:
            _dict['job_id'] = getattr(self, 'job_id')
        if hasattr(self, 'job_type') and self.job_type is not None:
            _dict['job_type'] = self.job_type
        if hasattr(self, 'log_start_at') and getattr(self, 'log_start_at') is not None:
            _dict['log_start_at'] = datetime_to_string(getattr(self, 'log_start_at'))
        if hasattr(self, 'log_analyzed_till') and getattr(self, 'log_analyzed_till') is not None:
            _dict['log_analyzed_till'] = datetime_to_string(getattr(self, 'log_analyzed_till'))
        if hasattr(self, 'elapsed_time') and getattr(self, 'elapsed_time') is not None:
            _dict['elapsed_time'] = getattr(self, 'elapsed_time')
        if hasattr(self, 'log_errors') and getattr(self, 'log_errors') is not None:
            log_errors_list = []
            for v in getattr(self, 'log_errors'):
                if isinstance(v, dict):
                    log_errors_list.append(v)
                else:
                    log_errors_list.append(v.to_dict())
            _dict['log_errors'] = log_errors_list
        if hasattr(self, 'repo_download_job') and self.repo_download_job is not None:
            if isinstance(self.repo_download_job, dict):
                _dict['repo_download_job'] = self.repo_download_job
            else:
                _dict['repo_download_job'] = self.repo_download_job.to_dict()
        if hasattr(self, 'workspace_job') and self.workspace_job is not None:
            if isinstance(self.workspace_job, dict):
                _dict['workspace_job'] = self.workspace_job
            else:
                _dict['workspace_job'] = self.workspace_job.to_dict()
        if hasattr(self, 'flow_job') and self.flow_job is not None:
            if isinstance(self.flow_job, dict):
                _dict['flow_job'] = self.flow_job
            else:
                _dict['flow_job'] = self.flow_job.to_dict()
        if hasattr(self, 'action_job') and self.action_job is not None:
            if isinstance(self.action_job, dict):
                _dict['action_job'] = self.action_job
            else:
                _dict['action_job'] = self.action_job.to_dict()
        if hasattr(self, 'system_job') and self.system_job is not None:
            if isinstance(self.system_job, dict):
                _dict['system_job'] = self.system_job
            else:
                _dict['system_job'] = self.system_job.to_dict()
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this JobLogSummary object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'JobLogSummary') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'JobLogSummary') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

    class JobTypeEnum(str, Enum):
        """
        Type of Job.
        """

        REPO_DOWNLOAD_JOB = 'repo_download_job'
        WORKSPACE_JOB = 'workspace_job'
        ACTION_JOB = 'action_job'
        SYSTEM_JOB = 'system_job'
        FLOW_JOB = 'flow_job'


class JobLogSummaryWorkitems:
    """
    Job log summary of the flow workitem.

    :param str workspace_id: (optional) workspace ID.
    :param str job_id: (optional) workspace JOB ID.
    :param float resources_add: (optional) Number of resources add.
    :param float resources_modify: (optional) Number of resources modify.
    :param float resources_destroy: (optional) Number of resources destroy.
    :param str log_url: (optional) Log url for job.
    """

    def __init__(
        self,
        *,
        workspace_id: Optional[str] = None,
        job_id: Optional[str] = None,
        resources_add: Optional[float] = None,
        resources_modify: Optional[float] = None,
        resources_destroy: Optional[float] = None,
        log_url: Optional[str] = None,
    ) -> None:
        """
        Initialize a JobLogSummaryWorkitems object.

        :param str workspace_id: (optional) workspace ID.
        :param str job_id: (optional) workspace JOB ID.
        :param str log_url: (optional) Log url for job.
        """
        self.workspace_id = workspace_id
        self.job_id = job_id
        self.resources_add = resources_add
        self.resources_modify = resources_modify
        self.resources_destroy = resources_destroy
        self.log_url = log_url

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'JobLogSummaryWorkitems':
        """Initialize a JobLogSummaryWorkitems object from a json dictionary."""
        args = {}
        if (workspace_id := _dict.get('workspace_id')) is not None:
            args['workspace_id'] = workspace_id
        if (job_id := _dict.get('job_id')) is not None:
            args['job_id'] = job_id
        if (resources_add := _dict.get('resources_add')) is not None:
            args['resources_add'] = resources_add
        if (resources_modify := _dict.get('resources_modify')) is not None:
            args['resources_modify'] = resources_modify
        if (resources_destroy := _dict.get('resources_destroy')) is not None:
            args['resources_destroy'] = resources_destroy
        if (log_url := _dict.get('log_url')) is not None:
            args['log_url'] = log_url
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a JobLogSummaryWorkitems object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'workspace_id') and self.workspace_id is not None:
            _dict['workspace_id'] = self.workspace_id
        if hasattr(self, 'job_id') and self.job_id is not None:
            _dict['job_id'] = self.job_id
        if hasattr(self, 'resources_add') and getattr(self, 'resources_add') is not None:
            _dict['resources_add'] = getattr(self, 'resources_add')
        if hasattr(self, 'resources_modify') and getattr(self, 'resources_modify') is not None:
            _dict['resources_modify'] = getattr(self, 'resources_modify')
        if hasattr(self, 'resources_destroy') and getattr(self, 'resources_destroy') is not None:
            _dict['resources_destroy'] = getattr(self, 'resources_destroy')
        if hasattr(self, 'log_url') and self.log_url is not None:
            _dict['log_url'] = self.log_url
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this JobLogSummaryWorkitems object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'JobLogSummaryWorkitems') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'JobLogSummaryWorkitems') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other


class JobLogSummaryActionJob:
    """
    Flow Job log summary.

    :param float target_count: (optional) number of targets or hosts.
    :param float task_count: (optional) number of tasks in playbook.
    :param float play_count: (optional) number of plays in playbook.
    :param JobLogSummaryActionJobRecap recap: (optional) Recap records.
    """

    def __init__(
        self,
        *,
        target_count: Optional[float] = None,
        task_count: Optional[float] = None,
        play_count: Optional[float] = None,
        recap: Optional['JobLogSummaryActionJobRecap'] = None,
    ) -> None:
        """
        Initialize a JobLogSummaryActionJob object.

        :param JobLogSummaryActionJobRecap recap: (optional) Recap records.
        """
        self.target_count = target_count
        self.task_count = task_count
        self.play_count = play_count
        self.recap = recap

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'JobLogSummaryActionJob':
        """Initialize a JobLogSummaryActionJob object from a json dictionary."""
        args = {}
        if (target_count := _dict.get('target_count')) is not None:
            args['target_count'] = target_count
        if (task_count := _dict.get('task_count')) is not None:
            args['task_count'] = task_count
        if (play_count := _dict.get('play_count')) is not None:
            args['play_count'] = play_count
        if (recap := _dict.get('recap')) is not None:
            args['recap'] = JobLogSummaryActionJobRecap.from_dict(recap)
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a JobLogSummaryActionJob object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'target_count') and getattr(self, 'target_count') is not None:
            _dict['target_count'] = getattr(self, 'target_count')
        if hasattr(self, 'task_count') and getattr(self, 'task_count') is not None:
            _dict['task_count'] = getattr(self, 'task_count')
        if hasattr(self, 'play_count') and getattr(self, 'play_count') is not None:
            _dict['play_count'] = getattr(self, 'play_count')
        if hasattr(self, 'recap') and self.recap is not None:
            if isinstance(self.recap, dict):
                _dict['recap'] = self.recap
            else:
                _dict['recap'] = self.recap.to_dict()
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this JobLogSummaryActionJob object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'JobLogSummaryActionJob') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'JobLogSummaryActionJob') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other


class JobLogSummaryActionJobRecap:
    """
    Recap records.

    :param List[str] target: (optional) List of target or host name.
    :param float ok: (optional) Number of OK.
    :param float changed: (optional) Number of changed.
    :param float failed: (optional) Number of failed.
    :param float skipped: (optional) Number of skipped.
    :param float unreachable: (optional) Number of unreachable.
    """

    def __init__(
        self,
        *,
        target: Optional[List[str]] = None,
        ok: Optional[float] = None,
        changed: Optional[float] = None,
        failed: Optional[float] = None,
        skipped: Optional[float] = None,
        unreachable: Optional[float] = None,
    ) -> None:
        """
        Initialize a JobLogSummaryActionJobRecap object.

        :param List[str] target: (optional) List of target or host name.
        :param float ok: (optional) Number of OK.
        :param float changed: (optional) Number of changed.
        :param float failed: (optional) Number of failed.
        :param float skipped: (optional) Number of skipped.
        :param float unreachable: (optional) Number of unreachable.
        """
        self.target = target
        self.ok = ok
        self.changed = changed
        self.failed = failed
        self.skipped = skipped
        self.unreachable = unreachable

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'JobLogSummaryActionJobRecap':
        """Initialize a JobLogSummaryActionJobRecap object from a json dictionary."""
        args = {}
        if (target := _dict.get('target')) is not None:
            args['target'] = target
        if (ok := _dict.get('ok')) is not None:
            args['ok'] = ok
        if (changed := _dict.get('changed')) is not None:
            args['changed'] = changed
        if (failed := _dict.get('failed')) is not None:
            args['failed'] = failed
        if (skipped := _dict.get('skipped')) is not None:
            args['skipped'] = skipped
        if (unreachable := _dict.get('unreachable')) is not None:
            args['unreachable'] = unreachable
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a JobLogSummaryActionJobRecap object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'target') and self.target is not None:
            _dict['target'] = self.target
        if hasattr(self, 'ok') and self.ok is not None:
            _dict['ok'] = self.ok
        if hasattr(self, 'changed') and self.changed is not None:
            _dict['changed'] = self.changed
        if hasattr(self, 'failed') and self.failed is not None:
            _dict['failed'] = self.failed
        if hasattr(self, 'skipped') and self.skipped is not None:
            _dict['skipped'] = self.skipped
        if hasattr(self, 'unreachable') and self.unreachable is not None:
            _dict['unreachable'] = self.unreachable
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this JobLogSummaryActionJobRecap object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'JobLogSummaryActionJobRecap') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'JobLogSummaryActionJobRecap') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other


class JobLogSummaryFlowJob:
    """
    Flow Job log summary.

    :param float workitems_completed: (optional) Number of workitems completed
          successfully.
    :param float workitems_pending: (optional) Number of workitems pending in the
          flow.
    :param float workitems_failed: (optional) Number of workitems failed.
    :param List[JobLogSummaryWorkitems] workitems: (optional)
    """

    def __init__(
        self,
        *,
        workitems_completed: Optional[float] = None,
        workitems_pending: Optional[float] = None,
        workitems_failed: Optional[float] = None,
        workitems: Optional[List['JobLogSummaryWorkitems']] = None,
    ) -> None:
        """
        Initialize a JobLogSummaryFlowJob object.

        :param List[JobLogSummaryWorkitems] workitems: (optional)
        """
        self.workitems_completed = workitems_completed
        self.workitems_pending = workitems_pending
        self.workitems_failed = workitems_failed
        self.workitems = workitems

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'JobLogSummaryFlowJob':
        """Initialize a JobLogSummaryFlowJob object from a json dictionary."""
        args = {}
        if (workitems_completed := _dict.get('workitems_completed')) is not None:
            args['workitems_completed'] = workitems_completed
        if (workitems_pending := _dict.get('workitems_pending')) is not None:
            args['workitems_pending'] = workitems_pending
        if (workitems_failed := _dict.get('workitems_failed')) is not None:
            args['workitems_failed'] = workitems_failed
        if (workitems := _dict.get('workitems')) is not None:
            args['workitems'] = [JobLogSummaryWorkitems.from_dict(v) for v in workitems]
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a JobLogSummaryFlowJob object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'workitems_completed') and getattr(self, 'workitems_completed') is not None:
            _dict['workitems_completed'] = getattr(self, 'workitems_completed')
        if hasattr(self, 'workitems_pending') and getattr(self, 'workitems_pending') is not None:
            _dict['workitems_pending'] = getattr(self, 'workitems_pending')
        if hasattr(self, 'workitems_failed') and getattr(self, 'workitems_failed') is not None:
            _dict['workitems_failed'] = getattr(self, 'workitems_failed')
        if hasattr(self, 'workitems') and self.workitems is not None:
            workitems_list = []
            for v in self.workitems:
                if isinstance(v, dict):
                    workitems_list.append(v)
                else:
                    workitems_list.append(v.to_dict())
            _dict['workitems'] = workitems_list
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this JobLogSummaryFlowJob object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'JobLogSummaryFlowJob') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'JobLogSummaryFlowJob') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other


class JobLogSummaryLogErrors:
    """
    JobLogSummaryLogErrors.

    :param str error_code: (optional) Error code in the Log.
    :param str error_msg: (optional) Summary error message in the log.
    :param float error_count: (optional) Number of occurrence.
    """

    def __init__(
        self,
        *,
        error_code: Optional[str] = None,
        error_msg: Optional[str] = None,
        error_count: Optional[float] = None,
    ) -> None:
        """
        Initialize a JobLogSummaryLogErrors object.

        :param str error_code: (optional) Error code in the Log.
        :param str error_msg: (optional) Summary error message in the log.
        :param float error_count: (optional) Number of occurrence.
        """
        self.error_code = error_code
        self.error_msg = error_msg
        self.error_count = error_count

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'JobLogSummaryLogErrors':
        """Initialize a JobLogSummaryLogErrors object from a json dictionary."""
        args = {}
        if (error_code := _dict.get('error_code')) is not None:
            args['error_code'] = error_code
        if (error_msg := _dict.get('error_msg')) is not None:
            args['error_msg'] = error_msg
        if (error_count := _dict.get('error_count')) is not None:
            args['error_count'] = error_count
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a JobLogSummaryLogErrors object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'error_code') and self.error_code is not None:
            _dict['error_code'] = self.error_code
        if hasattr(self, 'error_msg') and self.error_msg is not None:
            _dict['error_msg'] = self.error_msg
        if hasattr(self, 'error_count') and self.error_count is not None:
            _dict['error_count'] = self.error_count
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this JobLogSummaryLogErrors object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'JobLogSummaryLogErrors') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'JobLogSummaryLogErrors') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other


class JobLogSummaryRepoDownloadJob:
    """
    Repo download Job log summary.

    :param float scanned_file_count: (optional) Number of files scanned.
    :param float quarantined_file_count: (optional) Number of files quarantined.
    :param str detected_filetype: (optional) Detected template or data file type.
    :param str inputs_count: (optional) Number of inputs detected.
    :param str outputs_count: (optional) Number of outputs detected.
    """

    def __init__(
        self,
        *,
        scanned_file_count: Optional[float] = None,
        quarantined_file_count: Optional[float] = None,
        detected_filetype: Optional[str] = None,
        inputs_count: Optional[str] = None,
        outputs_count: Optional[str] = None,
    ) -> None:
        """
        Initialize a JobLogSummaryRepoDownloadJob object.

        """
        self.scanned_file_count = scanned_file_count
        self.quarantined_file_count = quarantined_file_count
        self.detected_filetype = detected_filetype
        self.inputs_count = inputs_count
        self.outputs_count = outputs_count

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'JobLogSummaryRepoDownloadJob':
        """Initialize a JobLogSummaryRepoDownloadJob object from a json dictionary."""
        args = {}
        if (scanned_file_count := _dict.get('scanned_file_count')) is not None:
            args['scanned_file_count'] = scanned_file_count
        if (quarantined_file_count := _dict.get('quarantined_file_count')) is not None:
            args['quarantined_file_count'] = quarantined_file_count
        if (detected_filetype := _dict.get('detected_filetype')) is not None:
            args['detected_filetype'] = detected_filetype
        if (inputs_count := _dict.get('inputs_count')) is not None:
            args['inputs_count'] = inputs_count
        if (outputs_count := _dict.get('outputs_count')) is not None:
            args['outputs_count'] = outputs_count
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a JobLogSummaryRepoDownloadJob object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'scanned_file_count') and getattr(self, 'scanned_file_count') is not None:
            _dict['scanned_file_count'] = getattr(self, 'scanned_file_count')
        if hasattr(self, 'quarantined_file_count') and getattr(self, 'quarantined_file_count') is not None:
            _dict['quarantined_file_count'] = getattr(self, 'quarantined_file_count')
        if hasattr(self, 'detected_filetype') and getattr(self, 'detected_filetype') is not None:
            _dict['detected_filetype'] = getattr(self, 'detected_filetype')
        if hasattr(self, 'inputs_count') and getattr(self, 'inputs_count') is not None:
            _dict['inputs_count'] = getattr(self, 'inputs_count')
        if hasattr(self, 'outputs_count') and getattr(self, 'outputs_count') is not None:
            _dict['outputs_count'] = getattr(self, 'outputs_count')
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this JobLogSummaryRepoDownloadJob object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'JobLogSummaryRepoDownloadJob') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'JobLogSummaryRepoDownloadJob') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other


class JobLogSummarySystemJob:
    """
    System Job log summary.

    :param float target_count: (optional) number of targets or hosts.
    :param float success: (optional) Number of passed.
    :param float failed: (optional) Number of failed.
    """

    def __init__(
        self,
        *,
        target_count: Optional[float] = None,
        success: Optional[float] = None,
        failed: Optional[float] = None,
    ) -> None:
        """
        Initialize a JobLogSummarySystemJob object.

        :param float success: (optional) Number of passed.
        :param float failed: (optional) Number of failed.
        """
        self.target_count = target_count
        self.success = success
        self.failed = failed

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'JobLogSummarySystemJob':
        """Initialize a JobLogSummarySystemJob object from a json dictionary."""
        args = {}
        if (target_count := _dict.get('target_count')) is not None:
            args['target_count'] = target_count
        if (success := _dict.get('success')) is not None:
            args['success'] = success
        if (failed := _dict.get('failed')) is not None:
            args['failed'] = failed
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a JobLogSummarySystemJob object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'target_count') and getattr(self, 'target_count') is not None:
            _dict['target_count'] = getattr(self, 'target_count')
        if hasattr(self, 'success') and self.success is not None:
            _dict['success'] = self.success
        if hasattr(self, 'failed') and self.failed is not None:
            _dict['failed'] = self.failed
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this JobLogSummarySystemJob object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'JobLogSummarySystemJob') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'JobLogSummarySystemJob') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other


class JobLogSummaryWorkspaceJob:
    """
    Workspace Job log summary.

    :param float resources_add: (optional) Number of resources add.
    :param float resources_modify: (optional) Number of resources modify.
    :param float resources_destroy: (optional) Number of resources destroy.
    """

    def __init__(
        self,
        *,
        resources_add: Optional[float] = None,
        resources_modify: Optional[float] = None,
        resources_destroy: Optional[float] = None,
    ) -> None:
        """
        Initialize a JobLogSummaryWorkspaceJob object.

        """
        self.resources_add = resources_add
        self.resources_modify = resources_modify
        self.resources_destroy = resources_destroy

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'JobLogSummaryWorkspaceJob':
        """Initialize a JobLogSummaryWorkspaceJob object from a json dictionary."""
        args = {}
        if (resources_add := _dict.get('resources_add')) is not None:
            args['resources_add'] = resources_add
        if (resources_modify := _dict.get('resources_modify')) is not None:
            args['resources_modify'] = resources_modify
        if (resources_destroy := _dict.get('resources_destroy')) is not None:
            args['resources_destroy'] = resources_destroy
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a JobLogSummaryWorkspaceJob object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'resources_add') and getattr(self, 'resources_add') is not None:
            _dict['resources_add'] = getattr(self, 'resources_add')
        if hasattr(self, 'resources_modify') and getattr(self, 'resources_modify') is not None:
            _dict['resources_modify'] = getattr(self, 'resources_modify')
        if hasattr(self, 'resources_destroy') and getattr(self, 'resources_destroy') is not None:
            _dict['resources_destroy'] = getattr(self, 'resources_destroy')
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this JobLogSummaryWorkspaceJob object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'JobLogSummaryWorkspaceJob') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'JobLogSummaryWorkspaceJob') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other


class JobStatus:
    """
    Job Status.

    :param float position_in_queue: (optional) Position of job in pending queue.
    :param float total_in_queue: (optional) Total no. of jobs in pending queue.
    :param JobStatusWorkspace workspace_job_status: (optional) Workspace Job Status.
    :param JobStatusAction action_job_status: (optional) Action Job Status.
    :param JobStatusSystem system_job_status: (optional) System Job Status.
    :param JobStatusFlow flow_job_status: (optional) Environment Flow JOB Status.
    """

    def __init__(
        self,
        *,
        position_in_queue: Optional[float] = None,
        total_in_queue: Optional[float] = None,
        workspace_job_status: Optional['JobStatusWorkspace'] = None,
        action_job_status: Optional['JobStatusAction'] = None,
        system_job_status: Optional['JobStatusSystem'] = None,
        flow_job_status: Optional['JobStatusFlow'] = None,
    ) -> None:
        """
        Initialize a JobStatus object.

        :param float position_in_queue: (optional) Position of job in pending
               queue.
        :param float total_in_queue: (optional) Total no. of jobs in pending queue.
        :param JobStatusWorkspace workspace_job_status: (optional) Workspace Job
               Status.
        :param JobStatusAction action_job_status: (optional) Action Job Status.
        :param JobStatusSystem system_job_status: (optional) System Job Status.
        :param JobStatusFlow flow_job_status: (optional) Environment Flow JOB
               Status.
        """
        self.position_in_queue = position_in_queue
        self.total_in_queue = total_in_queue
        self.workspace_job_status = workspace_job_status
        self.action_job_status = action_job_status
        self.system_job_status = system_job_status
        self.flow_job_status = flow_job_status

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'JobStatus':
        """Initialize a JobStatus object from a json dictionary."""
        args = {}
        if (position_in_queue := _dict.get('position_in_queue')) is not None:
            args['position_in_queue'] = position_in_queue
        if (total_in_queue := _dict.get('total_in_queue')) is not None:
            args['total_in_queue'] = total_in_queue
        if (workspace_job_status := _dict.get('workspace_job_status')) is not None:
            args['workspace_job_status'] = JobStatusWorkspace.from_dict(workspace_job_status)
        if (action_job_status := _dict.get('action_job_status')) is not None:
            args['action_job_status'] = JobStatusAction.from_dict(action_job_status)
        if (system_job_status := _dict.get('system_job_status')) is not None:
            args['system_job_status'] = JobStatusSystem.from_dict(system_job_status)
        if (flow_job_status := _dict.get('flow_job_status')) is not None:
            args['flow_job_status'] = JobStatusFlow.from_dict(flow_job_status)
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a JobStatus object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'position_in_queue') and self.position_in_queue is not None:
            _dict['position_in_queue'] = self.position_in_queue
        if hasattr(self, 'total_in_queue') and self.total_in_queue is not None:
            _dict['total_in_queue'] = self.total_in_queue
        if hasattr(self, 'workspace_job_status') and self.workspace_job_status is not None:
            if isinstance(self.workspace_job_status, dict):
                _dict['workspace_job_status'] = self.workspace_job_status
            else:
                _dict['workspace_job_status'] = self.workspace_job_status.to_dict()
        if hasattr(self, 'action_job_status') and self.action_job_status is not None:
            if isinstance(self.action_job_status, dict):
                _dict['action_job_status'] = self.action_job_status
            else:
                _dict['action_job_status'] = self.action_job_status.to_dict()
        if hasattr(self, 'system_job_status') and self.system_job_status is not None:
            if isinstance(self.system_job_status, dict):
                _dict['system_job_status'] = self.system_job_status
            else:
                _dict['system_job_status'] = self.system_job_status.to_dict()
        if hasattr(self, 'flow_job_status') and self.flow_job_status is not None:
            if isinstance(self.flow_job_status, dict):
                _dict['flow_job_status'] = self.flow_job_status
            else:
                _dict['flow_job_status'] = self.flow_job_status.to_dict()
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this JobStatus object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'JobStatus') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'JobStatus') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other


class JobStatusAction:
    """
    Action Job Status.

    :param str action_name: (optional) Action name.
    :param str status_code: (optional) Status of Jobs.
    :param str status_message: (optional) Action Job status message - to be
          displayed along with the action_status_code.
    :param str bastion_status_code: (optional) Status of Resources.
    :param str bastion_status_message: (optional) Bastion status message - to be
          displayed along with the bastion_status_code;.
    :param str targets_status_code: (optional) Status of Resources.
    :param str targets_status_message: (optional) Aggregated status message for all
          target resources,  to be displayed along with the targets_status_code;.
    :param datetime updated_at: (optional) Job status updation timestamp.
    """

    def __init__(
        self,
        *,
        action_name: Optional[str] = None,
        status_code: Optional[str] = None,
        status_message: Optional[str] = None,
        bastion_status_code: Optional[str] = None,
        bastion_status_message: Optional[str] = None,
        targets_status_code: Optional[str] = None,
        targets_status_message: Optional[str] = None,
        updated_at: Optional[datetime] = None,
    ) -> None:
        """
        Initialize a JobStatusAction object.

        :param str action_name: (optional) Action name.
        :param str status_code: (optional) Status of Jobs.
        :param str status_message: (optional) Action Job status message - to be
               displayed along with the action_status_code.
        :param str bastion_status_code: (optional) Status of Resources.
        :param str bastion_status_message: (optional) Bastion status message - to
               be displayed along with the bastion_status_code;.
        :param str targets_status_code: (optional) Status of Resources.
        :param str targets_status_message: (optional) Aggregated status message for
               all target resources,  to be displayed along with the targets_status_code;.
        :param datetime updated_at: (optional) Job status updation timestamp.
        """
        self.action_name = action_name
        self.status_code = status_code
        self.status_message = status_message
        self.bastion_status_code = bastion_status_code
        self.bastion_status_message = bastion_status_message
        self.targets_status_code = targets_status_code
        self.targets_status_message = targets_status_message
        self.updated_at = updated_at

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'JobStatusAction':
        """Initialize a JobStatusAction object from a json dictionary."""
        args = {}
        if (action_name := _dict.get('action_name')) is not None:
            args['action_name'] = action_name
        if (status_code := _dict.get('status_code')) is not None:
            args['status_code'] = status_code
        if (status_message := _dict.get('status_message')) is not None:
            args['status_message'] = status_message
        if (bastion_status_code := _dict.get('bastion_status_code')) is not None:
            args['bastion_status_code'] = bastion_status_code
        if (bastion_status_message := _dict.get('bastion_status_message')) is not None:
            args['bastion_status_message'] = bastion_status_message
        if (targets_status_code := _dict.get('targets_status_code')) is not None:
            args['targets_status_code'] = targets_status_code
        if (targets_status_message := _dict.get('targets_status_message')) is not None:
            args['targets_status_message'] = targets_status_message
        if (updated_at := _dict.get('updated_at')) is not None:
            args['updated_at'] = string_to_datetime(updated_at)
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a JobStatusAction object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'action_name') and self.action_name is not None:
            _dict['action_name'] = self.action_name
        if hasattr(self, 'status_code') and self.status_code is not None:
            _dict['status_code'] = self.status_code
        if hasattr(self, 'status_message') and self.status_message is not None:
            _dict['status_message'] = self.status_message
        if hasattr(self, 'bastion_status_code') and self.bastion_status_code is not None:
            _dict['bastion_status_code'] = self.bastion_status_code
        if hasattr(self, 'bastion_status_message') and self.bastion_status_message is not None:
            _dict['bastion_status_message'] = self.bastion_status_message
        if hasattr(self, 'targets_status_code') and self.targets_status_code is not None:
            _dict['targets_status_code'] = self.targets_status_code
        if hasattr(self, 'targets_status_message') and self.targets_status_message is not None:
            _dict['targets_status_message'] = self.targets_status_message
        if hasattr(self, 'updated_at') and self.updated_at is not None:
            _dict['updated_at'] = datetime_to_string(self.updated_at)
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this JobStatusAction object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'JobStatusAction') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'JobStatusAction') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

    class StatusCodeEnum(str, Enum):
        """
        Status of Jobs.
        """

        JOB_PENDING = 'job_pending'
        JOB_IN_PROGRESS = 'job_in_progress'
        JOB_FINISHED = 'job_finished'
        JOB_FAILED = 'job_failed'
        JOB_CANCELLED = 'job_cancelled'
        JOB_STOPPED = 'job_stopped'
        JOB_STOP_IN_PROGRESS = 'job_stop_in_progress'
        JOB_READY_TO_EXECUTE = 'job_ready_to_execute'

    class BastionStatusCodeEnum(str, Enum):
        """
        Status of Resources.
        """

        NONE = 'none'
        READY = 'ready'
        PROCESSING = 'processing'
        ERROR = 'error'

    class TargetsStatusCodeEnum(str, Enum):
        """
        Status of Resources.
        """

        NONE = 'none'
        READY = 'ready'
        PROCESSING = 'processing'
        ERROR = 'error'


class JobStatusFlow:
    """
    Environment Flow JOB Status.

    :param str flow_id: (optional) flow id.
    :param str flow_name: (optional) flow name.
    :param str status_code: (optional) Status of Jobs.
    :param str status_message: (optional) Flow Job status message - to be displayed
          along with the status_code;.
    :param List[JobStatusWorkitem] workitems: (optional) Environment's individual
          workItem status details;.
    :param datetime updated_at: (optional) Job status updation timestamp.
    """

    def __init__(
        self,
        *,
        flow_id: Optional[str] = None,
        flow_name: Optional[str] = None,
        status_code: Optional[str] = None,
        status_message: Optional[str] = None,
        workitems: Optional[List['JobStatusWorkitem']] = None,
        updated_at: Optional[datetime] = None,
    ) -> None:
        """
        Initialize a JobStatusFlow object.

        :param str flow_id: (optional) flow id.
        :param str flow_name: (optional) flow name.
        :param str status_code: (optional) Status of Jobs.
        :param str status_message: (optional) Flow Job status message - to be
               displayed along with the status_code;.
        :param List[JobStatusWorkitem] workitems: (optional) Environment's
               individual workItem status details;.
        :param datetime updated_at: (optional) Job status updation timestamp.
        """
        self.flow_id = flow_id
        self.flow_name = flow_name
        self.status_code = status_code
        self.status_message = status_message
        self.workitems = workitems
        self.updated_at = updated_at

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'JobStatusFlow':
        """Initialize a JobStatusFlow object from a json dictionary."""
        args = {}
        if (flow_id := _dict.get('flow_id')) is not None:
            args['flow_id'] = flow_id
        if (flow_name := _dict.get('flow_name')) is not None:
            args['flow_name'] = flow_name
        if (status_code := _dict.get('status_code')) is not None:
            args['status_code'] = status_code
        if (status_message := _dict.get('status_message')) is not None:
            args['status_message'] = status_message
        if (workitems := _dict.get('workitems')) is not None:
            args['workitems'] = [JobStatusWorkitem.from_dict(v) for v in workitems]
        if (updated_at := _dict.get('updated_at')) is not None:
            args['updated_at'] = string_to_datetime(updated_at)
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a JobStatusFlow object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'flow_id') and self.flow_id is not None:
            _dict['flow_id'] = self.flow_id
        if hasattr(self, 'flow_name') and self.flow_name is not None:
            _dict['flow_name'] = self.flow_name
        if hasattr(self, 'status_code') and self.status_code is not None:
            _dict['status_code'] = self.status_code
        if hasattr(self, 'status_message') and self.status_message is not None:
            _dict['status_message'] = self.status_message
        if hasattr(self, 'workitems') and self.workitems is not None:
            workitems_list = []
            for v in self.workitems:
                if isinstance(v, dict):
                    workitems_list.append(v)
                else:
                    workitems_list.append(v.to_dict())
            _dict['workitems'] = workitems_list
        if hasattr(self, 'updated_at') and self.updated_at is not None:
            _dict['updated_at'] = datetime_to_string(self.updated_at)
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this JobStatusFlow object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'JobStatusFlow') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'JobStatusFlow') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

    class StatusCodeEnum(str, Enum):
        """
        Status of Jobs.
        """

        JOB_PENDING = 'job_pending'
        JOB_IN_PROGRESS = 'job_in_progress'
        JOB_FINISHED = 'job_finished'
        JOB_FAILED = 'job_failed'
        JOB_CANCELLED = 'job_cancelled'
        JOB_STOPPED = 'job_stopped'
        JOB_STOP_IN_PROGRESS = 'job_stop_in_progress'
        JOB_READY_TO_EXECUTE = 'job_ready_to_execute'


class JobStatusSchematicsResources:
    """
    schematics Resources Job Status.

    :param str status_code: (optional) Status of Jobs.
    :param str status_message: (optional) system job status message.
    :param str schematics_resource_id: (optional) id for each resource which is
          targeted as a part of system job.
    :param datetime updated_at: (optional) Job status updation timestamp.
    """

    def __init__(
        self,
        *,
        status_code: Optional[str] = None,
        status_message: Optional[str] = None,
        schematics_resource_id: Optional[str] = None,
        updated_at: Optional[datetime] = None,
    ) -> None:
        """
        Initialize a JobStatusSchematicsResources object.

        :param str status_code: (optional) Status of Jobs.
        :param str status_message: (optional) system job status message.
        :param str schematics_resource_id: (optional) id for each resource which is
               targeted as a part of system job.
        :param datetime updated_at: (optional) Job status updation timestamp.
        """
        self.status_code = status_code
        self.status_message = status_message
        self.schematics_resource_id = schematics_resource_id
        self.updated_at = updated_at

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'JobStatusSchematicsResources':
        """Initialize a JobStatusSchematicsResources object from a json dictionary."""
        args = {}
        if (status_code := _dict.get('status_code')) is not None:
            args['status_code'] = status_code
        if (status_message := _dict.get('status_message')) is not None:
            args['status_message'] = status_message
        if (schematics_resource_id := _dict.get('schematics_resource_id')) is not None:
            args['schematics_resource_id'] = schematics_resource_id
        if (updated_at := _dict.get('updated_at')) is not None:
            args['updated_at'] = string_to_datetime(updated_at)
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a JobStatusSchematicsResources object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'status_code') and self.status_code is not None:
            _dict['status_code'] = self.status_code
        if hasattr(self, 'status_message') and self.status_message is not None:
            _dict['status_message'] = self.status_message
        if hasattr(self, 'schematics_resource_id') and self.schematics_resource_id is not None:
            _dict['schematics_resource_id'] = self.schematics_resource_id
        if hasattr(self, 'updated_at') and self.updated_at is not None:
            _dict['updated_at'] = datetime_to_string(self.updated_at)
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this JobStatusSchematicsResources object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'JobStatusSchematicsResources') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'JobStatusSchematicsResources') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

    class StatusCodeEnum(str, Enum):
        """
        Status of Jobs.
        """

        JOB_PENDING = 'job_pending'
        JOB_IN_PROGRESS = 'job_in_progress'
        JOB_FINISHED = 'job_finished'
        JOB_FAILED = 'job_failed'
        JOB_CANCELLED = 'job_cancelled'
        JOB_STOPPED = 'job_stopped'
        JOB_STOP_IN_PROGRESS = 'job_stop_in_progress'
        JOB_READY_TO_EXECUTE = 'job_ready_to_execute'


class JobStatusSystem:
    """
    System Job Status.

    :param str system_status_message: (optional) System job message.
    :param str system_status_code: (optional) Status of Jobs.
    :param List[JobStatusSchematicsResources] schematics_resource_status: (optional)
          job staus for each schematics resource.
    :param datetime updated_at: (optional) Job status updation timestamp.
    """

    def __init__(
        self,
        *,
        system_status_message: Optional[str] = None,
        system_status_code: Optional[str] = None,
        schematics_resource_status: Optional[List['JobStatusSchematicsResources']] = None,
        updated_at: Optional[datetime] = None,
    ) -> None:
        """
        Initialize a JobStatusSystem object.

        :param str system_status_message: (optional) System job message.
        :param str system_status_code: (optional) Status of Jobs.
        :param List[JobStatusSchematicsResources] schematics_resource_status:
               (optional) job staus for each schematics resource.
        :param datetime updated_at: (optional) Job status updation timestamp.
        """
        self.system_status_message = system_status_message
        self.system_status_code = system_status_code
        self.schematics_resource_status = schematics_resource_status
        self.updated_at = updated_at

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'JobStatusSystem':
        """Initialize a JobStatusSystem object from a json dictionary."""
        args = {}
        if (system_status_message := _dict.get('system_status_message')) is not None:
            args['system_status_message'] = system_status_message
        if (system_status_code := _dict.get('system_status_code')) is not None:
            args['system_status_code'] = system_status_code
        if (schematics_resource_status := _dict.get('schematics_resource_status')) is not None:
            args['schematics_resource_status'] = [
                JobStatusSchematicsResources.from_dict(v) for v in schematics_resource_status
            ]
        if (updated_at := _dict.get('updated_at')) is not None:
            args['updated_at'] = string_to_datetime(updated_at)
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a JobStatusSystem object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'system_status_message') and self.system_status_message is not None:
            _dict['system_status_message'] = self.system_status_message
        if hasattr(self, 'system_status_code') and self.system_status_code is not None:
            _dict['system_status_code'] = self.system_status_code
        if hasattr(self, 'schematics_resource_status') and self.schematics_resource_status is not None:
            schematics_resource_status_list = []
            for v in self.schematics_resource_status:
                if isinstance(v, dict):
                    schematics_resource_status_list.append(v)
                else:
                    schematics_resource_status_list.append(v.to_dict())
            _dict['schematics_resource_status'] = schematics_resource_status_list
        if hasattr(self, 'updated_at') and self.updated_at is not None:
            _dict['updated_at'] = datetime_to_string(self.updated_at)
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this JobStatusSystem object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'JobStatusSystem') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'JobStatusSystem') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

    class SystemStatusCodeEnum(str, Enum):
        """
        Status of Jobs.
        """

        JOB_PENDING = 'job_pending'
        JOB_IN_PROGRESS = 'job_in_progress'
        JOB_FINISHED = 'job_finished'
        JOB_FAILED = 'job_failed'
        JOB_CANCELLED = 'job_cancelled'
        JOB_STOPPED = 'job_stopped'
        JOB_STOP_IN_PROGRESS = 'job_stop_in_progress'
        JOB_READY_TO_EXECUTE = 'job_ready_to_execute'


class JobStatusTemplate:
    """
    Template Job Status.

    :param str template_id: (optional) Template Id.
    :param str template_name: (optional) Template name.
    :param int flow_index: (optional) Index of the template in the Flow.
    :param str status_code: (optional) Status of Jobs.
    :param str status_message: (optional) Template job status message (eg.
          VPCt1_Apply_Pending, for a 'VPCt1' Template).
    :param datetime updated_at: (optional) Job status updation timestamp.
    """

    def __init__(
        self,
        *,
        template_id: Optional[str] = None,
        template_name: Optional[str] = None,
        flow_index: Optional[int] = None,
        status_code: Optional[str] = None,
        status_message: Optional[str] = None,
        updated_at: Optional[datetime] = None,
    ) -> None:
        """
        Initialize a JobStatusTemplate object.

        :param str template_id: (optional) Template Id.
        :param str template_name: (optional) Template name.
        :param int flow_index: (optional) Index of the template in the Flow.
        :param str status_code: (optional) Status of Jobs.
        :param str status_message: (optional) Template job status message (eg.
               VPCt1_Apply_Pending, for a 'VPCt1' Template).
        :param datetime updated_at: (optional) Job status updation timestamp.
        """
        self.template_id = template_id
        self.template_name = template_name
        self.flow_index = flow_index
        self.status_code = status_code
        self.status_message = status_message
        self.updated_at = updated_at

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'JobStatusTemplate':
        """Initialize a JobStatusTemplate object from a json dictionary."""
        args = {}
        if (template_id := _dict.get('template_id')) is not None:
            args['template_id'] = template_id
        if (template_name := _dict.get('template_name')) is not None:
            args['template_name'] = template_name
        if (flow_index := _dict.get('flow_index')) is not None:
            args['flow_index'] = flow_index
        if (status_code := _dict.get('status_code')) is not None:
            args['status_code'] = status_code
        if (status_message := _dict.get('status_message')) is not None:
            args['status_message'] = status_message
        if (updated_at := _dict.get('updated_at')) is not None:
            args['updated_at'] = string_to_datetime(updated_at)
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a JobStatusTemplate object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'template_id') and self.template_id is not None:
            _dict['template_id'] = self.template_id
        if hasattr(self, 'template_name') and self.template_name is not None:
            _dict['template_name'] = self.template_name
        if hasattr(self, 'flow_index') and self.flow_index is not None:
            _dict['flow_index'] = self.flow_index
        if hasattr(self, 'status_code') and self.status_code is not None:
            _dict['status_code'] = self.status_code
        if hasattr(self, 'status_message') and self.status_message is not None:
            _dict['status_message'] = self.status_message
        if hasattr(self, 'updated_at') and self.updated_at is not None:
            _dict['updated_at'] = datetime_to_string(self.updated_at)
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this JobStatusTemplate object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'JobStatusTemplate') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'JobStatusTemplate') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

    class StatusCodeEnum(str, Enum):
        """
        Status of Jobs.
        """

        JOB_PENDING = 'job_pending'
        JOB_IN_PROGRESS = 'job_in_progress'
        JOB_FINISHED = 'job_finished'
        JOB_FAILED = 'job_failed'
        JOB_CANCELLED = 'job_cancelled'
        JOB_STOPPED = 'job_stopped'
        JOB_STOP_IN_PROGRESS = 'job_stop_in_progress'
        JOB_READY_TO_EXECUTE = 'job_ready_to_execute'


class JobStatusWorkitem:
    """
    Individual workitem status info.

    :param str workspace_id: (optional) Workspace id.
    :param str workspace_name: (optional) workspace name.
    :param str job_id: (optional) workspace job id.
    :param str status_code: (optional) Status of Jobs.
    :param str status_message: (optional) workitem job status message;.
    :param datetime updated_at: (optional) workitem job status updation timestamp.
    """

    def __init__(
        self,
        *,
        workspace_id: Optional[str] = None,
        workspace_name: Optional[str] = None,
        job_id: Optional[str] = None,
        status_code: Optional[str] = None,
        status_message: Optional[str] = None,
        updated_at: Optional[datetime] = None,
    ) -> None:
        """
        Initialize a JobStatusWorkitem object.

        :param str workspace_id: (optional) Workspace id.
        :param str workspace_name: (optional) workspace name.
        :param str job_id: (optional) workspace job id.
        :param str status_code: (optional) Status of Jobs.
        :param str status_message: (optional) workitem job status message;.
        :param datetime updated_at: (optional) workitem job status updation
               timestamp.
        """
        self.workspace_id = workspace_id
        self.workspace_name = workspace_name
        self.job_id = job_id
        self.status_code = status_code
        self.status_message = status_message
        self.updated_at = updated_at

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'JobStatusWorkitem':
        """Initialize a JobStatusWorkitem object from a json dictionary."""
        args = {}
        if (workspace_id := _dict.get('workspace_id')) is not None:
            args['workspace_id'] = workspace_id
        if (workspace_name := _dict.get('workspace_name')) is not None:
            args['workspace_name'] = workspace_name
        if (job_id := _dict.get('job_id')) is not None:
            args['job_id'] = job_id
        if (status_code := _dict.get('status_code')) is not None:
            args['status_code'] = status_code
        if (status_message := _dict.get('status_message')) is not None:
            args['status_message'] = status_message
        if (updated_at := _dict.get('updated_at')) is not None:
            args['updated_at'] = string_to_datetime(updated_at)
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a JobStatusWorkitem object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'workspace_id') and self.workspace_id is not None:
            _dict['workspace_id'] = self.workspace_id
        if hasattr(self, 'workspace_name') and self.workspace_name is not None:
            _dict['workspace_name'] = self.workspace_name
        if hasattr(self, 'job_id') and self.job_id is not None:
            _dict['job_id'] = self.job_id
        if hasattr(self, 'status_code') and self.status_code is not None:
            _dict['status_code'] = self.status_code
        if hasattr(self, 'status_message') and self.status_message is not None:
            _dict['status_message'] = self.status_message
        if hasattr(self, 'updated_at') and self.updated_at is not None:
            _dict['updated_at'] = datetime_to_string(self.updated_at)
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this JobStatusWorkitem object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'JobStatusWorkitem') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'JobStatusWorkitem') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

    class StatusCodeEnum(str, Enum):
        """
        Status of Jobs.
        """

        JOB_PENDING = 'job_pending'
        JOB_IN_PROGRESS = 'job_in_progress'
        JOB_FINISHED = 'job_finished'
        JOB_FAILED = 'job_failed'
        JOB_CANCELLED = 'job_cancelled'
        JOB_STOPPED = 'job_stopped'
        JOB_STOP_IN_PROGRESS = 'job_stop_in_progress'
        JOB_READY_TO_EXECUTE = 'job_ready_to_execute'


class JobStatusWorkspace:
    """
    Workspace Job Status.

    :param str workspace_name: (optional) Workspace name.
    :param str status_code: (optional) Status of Jobs.
    :param str status_message: (optional) Workspace job status message (eg.
          App1_Setup_Pending, for a 'Setup' flow in the 'App1' Workspace).
    :param JobStatusFlow flow_status: (optional) Environment Flow JOB Status.
    :param List[JobStatusTemplate] template_status: (optional) Workspace Flow
          Template job status.
    :param datetime updated_at: (optional) Job status updation timestamp.
    :param List[CommandsInfo] commands: (optional) List of terraform commands
          executed and their status.
    """

    def __init__(
        self,
        *,
        workspace_name: Optional[str] = None,
        status_code: Optional[str] = None,
        status_message: Optional[str] = None,
        flow_status: Optional['JobStatusFlow'] = None,
        template_status: Optional[List['JobStatusTemplate']] = None,
        updated_at: Optional[datetime] = None,
        commands: Optional[List['CommandsInfo']] = None,
    ) -> None:
        """
        Initialize a JobStatusWorkspace object.

        :param str workspace_name: (optional) Workspace name.
        :param str status_code: (optional) Status of Jobs.
        :param str status_message: (optional) Workspace job status message (eg.
               App1_Setup_Pending, for a 'Setup' flow in the 'App1' Workspace).
        :param JobStatusFlow flow_status: (optional) Environment Flow JOB Status.
        :param List[JobStatusTemplate] template_status: (optional) Workspace Flow
               Template job status.
        :param datetime updated_at: (optional) Job status updation timestamp.
        """
        self.workspace_name = workspace_name
        self.status_code = status_code
        self.status_message = status_message
        self.flow_status = flow_status
        self.template_status = template_status
        self.updated_at = updated_at
        self.commands = commands

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'JobStatusWorkspace':
        """Initialize a JobStatusWorkspace object from a json dictionary."""
        args = {}
        if (workspace_name := _dict.get('workspace_name')) is not None:
            args['workspace_name'] = workspace_name
        if (status_code := _dict.get('status_code')) is not None:
            args['status_code'] = status_code
        if (status_message := _dict.get('status_message')) is not None:
            args['status_message'] = status_message
        if (flow_status := _dict.get('flow_status')) is not None:
            args['flow_status'] = JobStatusFlow.from_dict(flow_status)
        if (template_status := _dict.get('template_status')) is not None:
            args['template_status'] = [JobStatusTemplate.from_dict(v) for v in template_status]
        if (updated_at := _dict.get('updated_at')) is not None:
            args['updated_at'] = string_to_datetime(updated_at)
        if (commands := _dict.get('commands')) is not None:
            args['commands'] = [CommandsInfo.from_dict(v) for v in commands]
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a JobStatusWorkspace object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'workspace_name') and self.workspace_name is not None:
            _dict['workspace_name'] = self.workspace_name
        if hasattr(self, 'status_code') and self.status_code is not None:
            _dict['status_code'] = self.status_code
        if hasattr(self, 'status_message') and self.status_message is not None:
            _dict['status_message'] = self.status_message
        if hasattr(self, 'flow_status') and self.flow_status is not None:
            if isinstance(self.flow_status, dict):
                _dict['flow_status'] = self.flow_status
            else:
                _dict['flow_status'] = self.flow_status.to_dict()
        if hasattr(self, 'template_status') and self.template_status is not None:
            template_status_list = []
            for v in self.template_status:
                if isinstance(v, dict):
                    template_status_list.append(v)
                else:
                    template_status_list.append(v.to_dict())
            _dict['template_status'] = template_status_list
        if hasattr(self, 'updated_at') and self.updated_at is not None:
            _dict['updated_at'] = datetime_to_string(self.updated_at)
        if hasattr(self, 'commands') and getattr(self, 'commands') is not None:
            commands_list = []
            for v in getattr(self, 'commands'):
                if isinstance(v, dict):
                    commands_list.append(v)
                else:
                    commands_list.append(v.to_dict())
            _dict['commands'] = commands_list
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this JobStatusWorkspace object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'JobStatusWorkspace') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'JobStatusWorkspace') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

    class StatusCodeEnum(str, Enum):
        """
        Status of Jobs.
        """

        JOB_PENDING = 'job_pending'
        JOB_IN_PROGRESS = 'job_in_progress'
        JOB_FINISHED = 'job_finished'
        JOB_FAILED = 'job_failed'
        JOB_CANCELLED = 'job_cancelled'
        JOB_STOPPED = 'job_stopped'
        JOB_STOP_IN_PROGRESS = 'job_stop_in_progress'
        JOB_READY_TO_EXECUTE = 'job_ready_to_execute'


class KMSDiscovery:
    """
    Discover kms instances in the account based on location.

    :param int total_count: (optional) The total number of records.
    :param int limit: The number of records returned.
    :param int offset: The skipped number of records.
    :param List[KMSInstances] kms_instances: (optional) The list of kms instances.
    """

    def __init__(
        self,
        limit: int,
        offset: int,
        *,
        total_count: Optional[int] = None,
        kms_instances: Optional[List['KMSInstances']] = None,
    ) -> None:
        """
        Initialize a KMSDiscovery object.

        :param int limit: The number of records returned.
        :param int offset: The skipped number of records.
        :param int total_count: (optional) The total number of records.
        :param List[KMSInstances] kms_instances: (optional) The list of kms
               instances.
        """
        self.total_count = total_count
        self.limit = limit
        self.offset = offset
        self.kms_instances = kms_instances

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'KMSDiscovery':
        """Initialize a KMSDiscovery object from a json dictionary."""
        args = {}
        if (total_count := _dict.get('total_count')) is not None:
            args['total_count'] = total_count
        if (limit := _dict.get('limit')) is not None:
            args['limit'] = limit
        else:
            raise ValueError('Required property \'limit\' not present in KMSDiscovery JSON')
        if (offset := _dict.get('offset')) is not None:
            args['offset'] = offset
        else:
            raise ValueError('Required property \'offset\' not present in KMSDiscovery JSON')
        if (kms_instances := _dict.get('kms_instances')) is not None:
            args['kms_instances'] = [KMSInstances.from_dict(v) for v in kms_instances]
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a KMSDiscovery object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'total_count') and self.total_count is not None:
            _dict['total_count'] = self.total_count
        if hasattr(self, 'limit') and self.limit is not None:
            _dict['limit'] = self.limit
        if hasattr(self, 'offset') and self.offset is not None:
            _dict['offset'] = self.offset
        if hasattr(self, 'kms_instances') and self.kms_instances is not None:
            kms_instances_list = []
            for v in self.kms_instances:
                if isinstance(v, dict):
                    kms_instances_list.append(v)
                else:
                    kms_instances_list.append(v.to_dict())
            _dict['kms_instances'] = kms_instances_list
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this KMSDiscovery object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'KMSDiscovery') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'KMSDiscovery') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other


class KMSInstances:
    """
    User defined kms instances.

    :param str location: (optional) The location to integrate kms instance. For
          example, location can be `US` and `EU`.
    :param str encryption_scheme: (optional) The encryption scheme values.
          **Allowable values** [`byok`,`kyok`].
    :param str resource_group: (optional) The kms instance resource group to
          integrate.
    :param str kms_crn: (optional) The primary kms CRN information.
    :param str kms_name: (optional) The kms instance name.
    :param str kms_private_endpoint: (optional) The kms instance private endpoints.
    :param str kms_public_endpoint: (optional) The kms instance public endpoints.
    :param List[KMSInstancesKeys] keys: (optional) Detailed list of keys.
    """

    def __init__(
        self,
        *,
        location: Optional[str] = None,
        encryption_scheme: Optional[str] = None,
        resource_group: Optional[str] = None,
        kms_crn: Optional[str] = None,
        kms_name: Optional[str] = None,
        kms_private_endpoint: Optional[str] = None,
        kms_public_endpoint: Optional[str] = None,
        keys: Optional[List['KMSInstancesKeys']] = None,
    ) -> None:
        """
        Initialize a KMSInstances object.

        :param str location: (optional) The location to integrate kms instance. For
               example, location can be `US` and `EU`.
        :param str encryption_scheme: (optional) The encryption scheme values.
               **Allowable values** [`byok`,`kyok`].
        :param str resource_group: (optional) The kms instance resource group to
               integrate.
        :param str kms_crn: (optional) The primary kms CRN information.
        :param str kms_name: (optional) The kms instance name.
        :param str kms_private_endpoint: (optional) The kms instance private
               endpoints.
        :param str kms_public_endpoint: (optional) The kms instance public
               endpoints.
        :param List[KMSInstancesKeys] keys: (optional) Detailed list of keys.
        """
        self.location = location
        self.encryption_scheme = encryption_scheme
        self.resource_group = resource_group
        self.kms_crn = kms_crn
        self.kms_name = kms_name
        self.kms_private_endpoint = kms_private_endpoint
        self.kms_public_endpoint = kms_public_endpoint
        self.keys = keys

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'KMSInstances':
        """Initialize a KMSInstances object from a json dictionary."""
        args = {}
        if (location := _dict.get('location')) is not None:
            args['location'] = location
        if (encryption_scheme := _dict.get('encryption_scheme')) is not None:
            args['encryption_scheme'] = encryption_scheme
        if (resource_group := _dict.get('resource_group')) is not None:
            args['resource_group'] = resource_group
        if (kms_crn := _dict.get('kms_crn')) is not None:
            args['kms_crn'] = kms_crn
        if (kms_name := _dict.get('kms_name')) is not None:
            args['kms_name'] = kms_name
        if (kms_private_endpoint := _dict.get('kms_private_endpoint')) is not None:
            args['kms_private_endpoint'] = kms_private_endpoint
        if (kms_public_endpoint := _dict.get('kms_public_endpoint')) is not None:
            args['kms_public_endpoint'] = kms_public_endpoint
        if (keys := _dict.get('keys')) is not None:
            args['keys'] = [KMSInstancesKeys.from_dict(v) for v in keys]
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a KMSInstances object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'location') and self.location is not None:
            _dict['location'] = self.location
        if hasattr(self, 'encryption_scheme') and self.encryption_scheme is not None:
            _dict['encryption_scheme'] = self.encryption_scheme
        if hasattr(self, 'resource_group') and self.resource_group is not None:
            _dict['resource_group'] = self.resource_group
        if hasattr(self, 'kms_crn') and self.kms_crn is not None:
            _dict['kms_crn'] = self.kms_crn
        if hasattr(self, 'kms_name') and self.kms_name is not None:
            _dict['kms_name'] = self.kms_name
        if hasattr(self, 'kms_private_endpoint') and self.kms_private_endpoint is not None:
            _dict['kms_private_endpoint'] = self.kms_private_endpoint
        if hasattr(self, 'kms_public_endpoint') and self.kms_public_endpoint is not None:
            _dict['kms_public_endpoint'] = self.kms_public_endpoint
        if hasattr(self, 'keys') and self.keys is not None:
            keys_list = []
            for v in self.keys:
                if isinstance(v, dict):
                    keys_list.append(v)
                else:
                    keys_list.append(v.to_dict())
            _dict['keys'] = keys_list
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this KMSInstances object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'KMSInstances') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'KMSInstances') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other


class KMSInstancesKeys:
    """
    KMSInstancesKeys.

    :param str name: (optional) The name of the root key.
    :param str crn: (optional) The kms CRN of the root key.
    :param str error: (optional) The error message details.
    """

    def __init__(
        self,
        *,
        name: Optional[str] = None,
        crn: Optional[str] = None,
        error: Optional[str] = None,
    ) -> None:
        """
        Initialize a KMSInstancesKeys object.

        :param str name: (optional) The name of the root key.
        :param str crn: (optional) The kms CRN of the root key.
        :param str error: (optional) The error message details.
        """
        self.name = name
        self.crn = crn
        self.error = error

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'KMSInstancesKeys':
        """Initialize a KMSInstancesKeys object from a json dictionary."""
        args = {}
        if (name := _dict.get('name')) is not None:
            args['name'] = name
        if (crn := _dict.get('crn')) is not None:
            args['crn'] = crn
        if (error := _dict.get('error')) is not None:
            args['error'] = error
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a KMSInstancesKeys object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'name') and self.name is not None:
            _dict['name'] = self.name
        if hasattr(self, 'crn') and self.crn is not None:
            _dict['crn'] = self.crn
        if hasattr(self, 'error') and self.error is not None:
            _dict['error'] = self.error
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this KMSInstancesKeys object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'KMSInstancesKeys') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'KMSInstancesKeys') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other


class KMSSettings:
    """
    User defined kms settings information.

    :param str location: (optional) The location to integrate kms instance. For
          example, location can be `US` and `EU`.
    :param str encryption_scheme: (optional) The encryption scheme values.
          **Allowable values** [`byok`,`kyok`].
    :param str resource_group: (optional) The kms instance resource group to
          integrate.
    :param KMSSettingsPrimaryCrk primary_crk: (optional) The primary kms instance
          details.
    :param KMSSettingsSecondaryCrk secondary_crk: (optional) The secondary kms
          instance details.
    """

    def __init__(
        self,
        *,
        location: Optional[str] = None,
        encryption_scheme: Optional[str] = None,
        resource_group: Optional[str] = None,
        primary_crk: Optional['KMSSettingsPrimaryCrk'] = None,
        secondary_crk: Optional['KMSSettingsSecondaryCrk'] = None,
    ) -> None:
        """
        Initialize a KMSSettings object.

        :param str location: (optional) The location to integrate kms instance. For
               example, location can be `US` and `EU`.
        :param str encryption_scheme: (optional) The encryption scheme values.
               **Allowable values** [`byok`,`kyok`].
        :param str resource_group: (optional) The kms instance resource group to
               integrate.
        :param KMSSettingsPrimaryCrk primary_crk: (optional) The primary kms
               instance details.
        :param KMSSettingsSecondaryCrk secondary_crk: (optional) The secondary kms
               instance details.
        """
        self.location = location
        self.encryption_scheme = encryption_scheme
        self.resource_group = resource_group
        self.primary_crk = primary_crk
        self.secondary_crk = secondary_crk

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'KMSSettings':
        """Initialize a KMSSettings object from a json dictionary."""
        args = {}
        if (location := _dict.get('location')) is not None:
            args['location'] = location
        if (encryption_scheme := _dict.get('encryption_scheme')) is not None:
            args['encryption_scheme'] = encryption_scheme
        if (resource_group := _dict.get('resource_group')) is not None:
            args['resource_group'] = resource_group
        if (primary_crk := _dict.get('primary_crk')) is not None:
            args['primary_crk'] = KMSSettingsPrimaryCrk.from_dict(primary_crk)
        if (secondary_crk := _dict.get('secondary_crk')) is not None:
            args['secondary_crk'] = KMSSettingsSecondaryCrk.from_dict(secondary_crk)
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a KMSSettings object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'location') and self.location is not None:
            _dict['location'] = self.location
        if hasattr(self, 'encryption_scheme') and self.encryption_scheme is not None:
            _dict['encryption_scheme'] = self.encryption_scheme
        if hasattr(self, 'resource_group') and self.resource_group is not None:
            _dict['resource_group'] = self.resource_group
        if hasattr(self, 'primary_crk') and self.primary_crk is not None:
            if isinstance(self.primary_crk, dict):
                _dict['primary_crk'] = self.primary_crk
            else:
                _dict['primary_crk'] = self.primary_crk.to_dict()
        if hasattr(self, 'secondary_crk') and self.secondary_crk is not None:
            if isinstance(self.secondary_crk, dict):
                _dict['secondary_crk'] = self.secondary_crk
            else:
                _dict['secondary_crk'] = self.secondary_crk.to_dict()
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this KMSSettings object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'KMSSettings') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'KMSSettings') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other


class KMSSettingsPrimaryCrk:
    """
    The primary kms instance details.

    :param str kms_name: (optional) The primary kms instance name.
    :param str kms_private_endpoint: (optional) The primary kms instance private
          endpoint.
    :param str key_crn: (optional) The CRN of the primary root key.
    """

    def __init__(
        self,
        *,
        kms_name: Optional[str] = None,
        kms_private_endpoint: Optional[str] = None,
        key_crn: Optional[str] = None,
    ) -> None:
        """
        Initialize a KMSSettingsPrimaryCrk object.

        :param str kms_name: (optional) The primary kms instance name.
        :param str kms_private_endpoint: (optional) The primary kms instance
               private endpoint.
        :param str key_crn: (optional) The CRN of the primary root key.
        """
        self.kms_name = kms_name
        self.kms_private_endpoint = kms_private_endpoint
        self.key_crn = key_crn

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'KMSSettingsPrimaryCrk':
        """Initialize a KMSSettingsPrimaryCrk object from a json dictionary."""
        args = {}
        if (kms_name := _dict.get('kms_name')) is not None:
            args['kms_name'] = kms_name
        if (kms_private_endpoint := _dict.get('kms_private_endpoint')) is not None:
            args['kms_private_endpoint'] = kms_private_endpoint
        if (key_crn := _dict.get('key_crn')) is not None:
            args['key_crn'] = key_crn
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a KMSSettingsPrimaryCrk object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'kms_name') and self.kms_name is not None:
            _dict['kms_name'] = self.kms_name
        if hasattr(self, 'kms_private_endpoint') and self.kms_private_endpoint is not None:
            _dict['kms_private_endpoint'] = self.kms_private_endpoint
        if hasattr(self, 'key_crn') and self.key_crn is not None:
            _dict['key_crn'] = self.key_crn
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this KMSSettingsPrimaryCrk object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'KMSSettingsPrimaryCrk') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'KMSSettingsPrimaryCrk') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other


class KMSSettingsSecondaryCrk:
    """
    The secondary kms instance details.

    :param str kms_name: (optional) The secondary kms instance name.
    :param str kms_private_endpoint: (optional) The secondary kms instance private
          endpoint.
    :param str key_crn: (optional) The CRN of the secondary key.
    """

    def __init__(
        self,
        *,
        kms_name: Optional[str] = None,
        kms_private_endpoint: Optional[str] = None,
        key_crn: Optional[str] = None,
    ) -> None:
        """
        Initialize a KMSSettingsSecondaryCrk object.

        :param str kms_name: (optional) The secondary kms instance name.
        :param str kms_private_endpoint: (optional) The secondary kms instance
               private endpoint.
        :param str key_crn: (optional) The CRN of the secondary key.
        """
        self.kms_name = kms_name
        self.kms_private_endpoint = kms_private_endpoint
        self.key_crn = key_crn

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'KMSSettingsSecondaryCrk':
        """Initialize a KMSSettingsSecondaryCrk object from a json dictionary."""
        args = {}
        if (kms_name := _dict.get('kms_name')) is not None:
            args['kms_name'] = kms_name
        if (kms_private_endpoint := _dict.get('kms_private_endpoint')) is not None:
            args['kms_private_endpoint'] = kms_private_endpoint
        if (key_crn := _dict.get('key_crn')) is not None:
            args['key_crn'] = key_crn
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a KMSSettingsSecondaryCrk object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'kms_name') and self.kms_name is not None:
            _dict['kms_name'] = self.kms_name
        if hasattr(self, 'kms_private_endpoint') and self.kms_private_endpoint is not None:
            _dict['kms_private_endpoint'] = self.kms_private_endpoint
        if hasattr(self, 'key_crn') and self.key_crn is not None:
            _dict['key_crn'] = self.key_crn
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this KMSSettingsSecondaryCrk object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'KMSSettingsSecondaryCrk') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'KMSSettingsSecondaryCrk') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other


class LastJob:
    """
    Last job details.

    :param str job_id: (optional) ID of last job.
    :param str job_name: (optional) Name of the last job.
    :param str job_status: (optional) Status of the last job.
    """

    def __init__(
        self,
        *,
        job_id: Optional[str] = None,
        job_name: Optional[str] = None,
        job_status: Optional[str] = None,
    ) -> None:
        """
        Initialize a LastJob object.

        :param str job_id: (optional) ID of last job.
        :param str job_name: (optional) Name of the last job.
        :param str job_status: (optional) Status of the last job.
        """
        self.job_id = job_id
        self.job_name = job_name
        self.job_status = job_status

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'LastJob':
        """Initialize a LastJob object from a json dictionary."""
        args = {}
        if (job_id := _dict.get('job_id')) is not None:
            args['job_id'] = job_id
        if (job_name := _dict.get('job_name')) is not None:
            args['job_name'] = job_name
        if (job_status := _dict.get('job_status')) is not None:
            args['job_status'] = job_status
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a LastJob object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'job_id') and self.job_id is not None:
            _dict['job_id'] = self.job_id
        if hasattr(self, 'job_name') and self.job_name is not None:
            _dict['job_name'] = self.job_name
        if hasattr(self, 'job_status') and self.job_status is not None:
            _dict['job_status'] = self.job_status
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this LastJob object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'LastJob') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'LastJob') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other


class LogStoreResponse:
    """
    Log file URL for job that ran against your workspace.

    :param str engine_name: (optional) The provisioning engine that was used for the
          job.
    :param str engine_version: (optional) The version of the provisioning engine
          that was used for the job.
    :param str id: (optional) The ID that was assigned to your Terraform template of
          IBM Cloud catalog software template.
    :param str log_store_url: (optional) The URL to access the logs that were
          created during the plan, apply, or destroy job.
    """

    def __init__(
        self,
        *,
        engine_name: Optional[str] = None,
        engine_version: Optional[str] = None,
        id: Optional[str] = None,
        log_store_url: Optional[str] = None,
    ) -> None:
        """
        Initialize a LogStoreResponse object.

        :param str engine_name: (optional) The provisioning engine that was used
               for the job.
        :param str engine_version: (optional) The version of the provisioning
               engine that was used for the job.
        :param str id: (optional) The ID that was assigned to your Terraform
               template of IBM Cloud catalog software template.
        :param str log_store_url: (optional) The URL to access the logs that were
               created during the plan, apply, or destroy job.
        """
        self.engine_name = engine_name
        self.engine_version = engine_version
        self.id = id
        self.log_store_url = log_store_url

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'LogStoreResponse':
        """Initialize a LogStoreResponse object from a json dictionary."""
        args = {}
        if (engine_name := _dict.get('engine_name')) is not None:
            args['engine_name'] = engine_name
        if (engine_version := _dict.get('engine_version')) is not None:
            args['engine_version'] = engine_version
        if (id := _dict.get('id')) is not None:
            args['id'] = id
        if (log_store_url := _dict.get('log_store_url')) is not None:
            args['log_store_url'] = log_store_url
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a LogStoreResponse object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'engine_name') and self.engine_name is not None:
            _dict['engine_name'] = self.engine_name
        if hasattr(self, 'engine_version') and self.engine_version is not None:
            _dict['engine_version'] = self.engine_version
        if hasattr(self, 'id') and self.id is not None:
            _dict['id'] = self.id
        if hasattr(self, 'log_store_url') and self.log_store_url is not None:
            _dict['log_store_url'] = self.log_store_url
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this LogStoreResponse object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'LogStoreResponse') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'LogStoreResponse') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other


class LogStoreResponseList:
    """
    List of log file URL that ran against your workspace.

    :param List[LogStoreResponse] runtime_data: (optional) Runtime data.
    """

    def __init__(
        self,
        *,
        runtime_data: Optional[List['LogStoreResponse']] = None,
    ) -> None:
        """
        Initialize a LogStoreResponseList object.

        :param List[LogStoreResponse] runtime_data: (optional) Runtime data.
        """
        self.runtime_data = runtime_data

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'LogStoreResponseList':
        """Initialize a LogStoreResponseList object from a json dictionary."""
        args = {}
        if (runtime_data := _dict.get('runtime_data')) is not None:
            args['runtime_data'] = [LogStoreResponse.from_dict(v) for v in runtime_data]
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a LogStoreResponseList object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'runtime_data') and self.runtime_data is not None:
            runtime_data_list = []
            for v in self.runtime_data:
                if isinstance(v, dict):
                    runtime_data_list.append(v)
                else:
                    runtime_data_list.append(v.to_dict())
            _dict['runtime_data'] = runtime_data_list
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this LogStoreResponseList object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'LogStoreResponseList') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'LogStoreResponseList') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other


class LogSummary:
    """
    Summary information extracted from the job logs.

    :param str activity_status: (optional) The status of your activity or job. To
          retrieve the URL to your job logs, use the GET
          /v1/workspaces/{id}/actions/{action_id}/logs API.
          * **COMPLETED**: The job completed successfully.
          * **CREATED**: The job was created, but the provisioning, modification, or
          removal of IBM Cloud resources has not started yet.
          * **FAILED**: An error occurred during the plan, apply, or destroy job. Use the
          job ID to retrieve the URL to the log files for your job.
          * **IN PROGRESS**: The job is in progress. You can use the log_url to access the
          logs.
    :param str detected_template_type: (optional) Template detected type.
    :param int discarded_files: (optional) Numner of discarded files.
    :param str error: (optional) Numner of errors in log.
    :param int resources_added: (optional) Numner of resources added.
    :param int resources_destroyed: (optional) Numner of resources destroyed.
    :param int resources_modified: (optional) Numner of resources modified.
    :param int scanned_files: (optional) Numner of filed scanned.
    :param int template_variable_count: (optional) Numner of template variables.
    :param float time_taken: (optional) Elapsed time to run the job.
    """

    def __init__(
        self,
        *,
        activity_status: Optional[str] = None,
        detected_template_type: Optional[str] = None,
        discarded_files: Optional[int] = None,
        error: Optional[str] = None,
        resources_added: Optional[int] = None,
        resources_destroyed: Optional[int] = None,
        resources_modified: Optional[int] = None,
        scanned_files: Optional[int] = None,
        template_variable_count: Optional[int] = None,
        time_taken: Optional[float] = None,
    ) -> None:
        """
        Initialize a LogSummary object.

        :param str activity_status: (optional) The status of your activity or job.
               To retrieve the URL to your job logs, use the GET
               /v1/workspaces/{id}/actions/{action_id}/logs API.
               * **COMPLETED**: The job completed successfully.
               * **CREATED**: The job was created, but the provisioning, modification, or
               removal of IBM Cloud resources has not started yet.
               * **FAILED**: An error occurred during the plan, apply, or destroy job. Use
               the job ID to retrieve the URL to the log files for your job.
               * **IN PROGRESS**: The job is in progress. You can use the log_url to
               access the logs.
        :param str detected_template_type: (optional) Template detected type.
        :param int discarded_files: (optional) Numner of discarded files.
        :param str error: (optional) Numner of errors in log.
        :param int resources_added: (optional) Numner of resources added.
        :param int resources_destroyed: (optional) Numner of resources destroyed.
        :param int resources_modified: (optional) Numner of resources modified.
        :param int scanned_files: (optional) Numner of filed scanned.
        :param int template_variable_count: (optional) Numner of template
               variables.
        :param float time_taken: (optional) Elapsed time to run the job.
        """
        self.activity_status = activity_status
        self.detected_template_type = detected_template_type
        self.discarded_files = discarded_files
        self.error = error
        self.resources_added = resources_added
        self.resources_destroyed = resources_destroyed
        self.resources_modified = resources_modified
        self.scanned_files = scanned_files
        self.template_variable_count = template_variable_count
        self.time_taken = time_taken

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'LogSummary':
        """Initialize a LogSummary object from a json dictionary."""
        args = {}
        if (activity_status := _dict.get('activity_status')) is not None:
            args['activity_status'] = activity_status
        if (detected_template_type := _dict.get('detected_template_type')) is not None:
            args['detected_template_type'] = detected_template_type
        if (discarded_files := _dict.get('discarded_files')) is not None:
            args['discarded_files'] = discarded_files
        if (error := _dict.get('error')) is not None:
            args['error'] = error
        if (resources_added := _dict.get('resources_added')) is not None:
            args['resources_added'] = resources_added
        if (resources_destroyed := _dict.get('resources_destroyed')) is not None:
            args['resources_destroyed'] = resources_destroyed
        if (resources_modified := _dict.get('resources_modified')) is not None:
            args['resources_modified'] = resources_modified
        if (scanned_files := _dict.get('scanned_files')) is not None:
            args['scanned_files'] = scanned_files
        if (template_variable_count := _dict.get('template_variable_count')) is not None:
            args['template_variable_count'] = template_variable_count
        if (time_taken := _dict.get('time_taken')) is not None:
            args['time_taken'] = time_taken
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a LogSummary object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'activity_status') and self.activity_status is not None:
            _dict['activity_status'] = self.activity_status
        if hasattr(self, 'detected_template_type') and self.detected_template_type is not None:
            _dict['detected_template_type'] = self.detected_template_type
        if hasattr(self, 'discarded_files') and self.discarded_files is not None:
            _dict['discarded_files'] = self.discarded_files
        if hasattr(self, 'error') and self.error is not None:
            _dict['error'] = self.error
        if hasattr(self, 'resources_added') and self.resources_added is not None:
            _dict['resources_added'] = self.resources_added
        if hasattr(self, 'resources_destroyed') and self.resources_destroyed is not None:
            _dict['resources_destroyed'] = self.resources_destroyed
        if hasattr(self, 'resources_modified') and self.resources_modified is not None:
            _dict['resources_modified'] = self.resources_modified
        if hasattr(self, 'scanned_files') and self.scanned_files is not None:
            _dict['scanned_files'] = self.scanned_files
        if hasattr(self, 'template_variable_count') and self.template_variable_count is not None:
            _dict['template_variable_count'] = self.template_variable_count
        if hasattr(self, 'time_taken') and self.time_taken is not None:
            _dict['time_taken'] = self.time_taken
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this LogSummary object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'LogSummary') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'LogSummary') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other


class OutputValuesInner:
    """
    OutputValuesInner.

    :param str folder: (optional) The subfolder in the GitHub or GitLab repository
          where your Terraform template is stored. If the template is stored in the root
          directory, `.` is returned.
    :param str id: (optional) The ID that was assigned to your Terraform template or
          IBM Cloud catalog software template.
    :param List[dict] output_values: (optional) A list of Terraform output values.
    :param str value_type: (optional) The Terraform version that was used to apply
          your template.
    """

    def __init__(
        self,
        *,
        folder: Optional[str] = None,
        id: Optional[str] = None,
        output_values: Optional[List[dict]] = None,
        value_type: Optional[str] = None,
    ) -> None:
        """
        Initialize a OutputValuesInner object.

        :param str folder: (optional) The subfolder in the GitHub or GitLab
               repository where your Terraform template is stored. If the template is
               stored in the root directory, `.` is returned.
        :param str id: (optional) The ID that was assigned to your Terraform
               template or IBM Cloud catalog software template.
        :param List[dict] output_values: (optional) A list of Terraform output
               values.
        :param str value_type: (optional) The Terraform version that was used to
               apply your template.
        """
        self.folder = folder
        self.id = id
        self.output_values = output_values
        self.value_type = value_type

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'OutputValuesInner':
        """Initialize a OutputValuesInner object from a json dictionary."""
        args = {}
        if (folder := _dict.get('folder')) is not None:
            args['folder'] = folder
        if (id := _dict.get('id')) is not None:
            args['id'] = id
        if (output_values := _dict.get('output_values')) is not None:
            args['output_values'] = output_values
        if (value_type := _dict.get('value_type')) is not None:
            args['value_type'] = value_type
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a OutputValuesInner object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'folder') and self.folder is not None:
            _dict['folder'] = self.folder
        if hasattr(self, 'id') and self.id is not None:
            _dict['id'] = self.id
        if hasattr(self, 'output_values') and self.output_values is not None:
            _dict['output_values'] = self.output_values
        if hasattr(self, 'value_type') and self.value_type is not None:
            _dict['value_type'] = self.value_type
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this OutputValuesInner object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'OutputValuesInner') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'OutputValuesInner') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other


class Policy:
    """
    Detailed information about the Schematics customization policy.  This policy can be
    used to customize the behaviour or the core Schematics service.

    :param str name: (optional) Name of Schematics customization policy.
    :param str description: (optional) The description of Schematics customization
          policy.
    :param str resource_group: (optional) The resource group name for the policy.
          By default, Policy will be created in `default` Resource Group.
    :param List[str] tags: (optional) Tags for the Schematics customization policy.
    :param str location: (optional) List of locations supported by IBM Cloud
          Schematics service.  While creating your workspace or action, choose the right
          region, since it cannot be changed.  Note, this does not limit the location of
          the IBM Cloud resources, provisioned using Schematics.
    :param UserState state: (optional) User defined status of the Schematics object.
    :param str kind: (optional) Policy kind or categories for managing and deriving
          policy decision
            * `agent_assignment_policy` Agent assignment policy for job execution.
    :param PolicyObjects target: (optional) The objects for the Schematics policy.
    :param PolicyParameter parameter: (optional) The parameter to tune the
          Schematics policy.
    :param str id: (optional) The system generated policy Id.
    :param str crn: (optional) The policy CRN.
    :param str account: (optional) The Account id.
    :param List[ScopedResource] scoped_resources: (optional) List of scoped
          Schematics resources targeted by the policy.
    :param datetime created_at: (optional) The policy creation time.
    :param str created_by: (optional) The user who created the policy.
    :param datetime updated_at: (optional) The policy updation time.
    """

    def __init__(
        self,
        *,
        name: Optional[str] = None,
        description: Optional[str] = None,
        resource_group: Optional[str] = None,
        tags: Optional[List[str]] = None,
        location: Optional[str] = None,
        state: Optional['UserState'] = None,
        kind: Optional[str] = None,
        target: Optional['PolicyObjects'] = None,
        parameter: Optional['PolicyParameter'] = None,
        id: Optional[str] = None,
        crn: Optional[str] = None,
        account: Optional[str] = None,
        scoped_resources: Optional[List['ScopedResource']] = None,
        created_at: Optional[datetime] = None,
        created_by: Optional[str] = None,
        updated_at: Optional[datetime] = None,
    ) -> None:
        """
        Initialize a Policy object.

        :param str name: (optional) Name of Schematics customization policy.
        :param str description: (optional) The description of Schematics
               customization policy.
        :param str resource_group: (optional) The resource group name for the
               policy.  By default, Policy will be created in `default` Resource Group.
        :param List[str] tags: (optional) Tags for the Schematics customization
               policy.
        :param str location: (optional) List of locations supported by IBM Cloud
               Schematics service.  While creating your workspace or action, choose the
               right region, since it cannot be changed.  Note, this does not limit the
               location of the IBM Cloud resources, provisioned using Schematics.
        :param UserState state: (optional) User defined status of the Schematics
               object.
        :param str kind: (optional) Policy kind or categories for managing and
               deriving policy decision
                 * `agent_assignment_policy` Agent assignment policy for job execution.
        :param PolicyObjects target: (optional) The objects for the Schematics
               policy.
        :param PolicyParameter parameter: (optional) The parameter to tune the
               Schematics policy.
        :param List[ScopedResource] scoped_resources: (optional) List of scoped
               Schematics resources targeted by the policy.
        """
        self.name = name
        self.description = description
        self.resource_group = resource_group
        self.tags = tags
        self.location = location
        self.state = state
        self.kind = kind
        self.target = target
        self.parameter = parameter
        self.id = id
        self.crn = crn
        self.account = account
        self.scoped_resources = scoped_resources
        self.created_at = created_at
        self.created_by = created_by
        self.updated_at = updated_at

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'Policy':
        """Initialize a Policy object from a json dictionary."""
        args = {}
        if (name := _dict.get('name')) is not None:
            args['name'] = name
        if (description := _dict.get('description')) is not None:
            args['description'] = description
        if (resource_group := _dict.get('resource_group')) is not None:
            args['resource_group'] = resource_group
        if (tags := _dict.get('tags')) is not None:
            args['tags'] = tags
        if (location := _dict.get('location')) is not None:
            args['location'] = location
        if (state := _dict.get('state')) is not None:
            args['state'] = UserState.from_dict(state)
        if (kind := _dict.get('kind')) is not None:
            args['kind'] = kind
        if (target := _dict.get('target')) is not None:
            args['target'] = PolicyObjects.from_dict(target)
        if (parameter := _dict.get('parameter')) is not None:
            args['parameter'] = PolicyParameter.from_dict(parameter)
        if (id := _dict.get('id')) is not None:
            args['id'] = id
        if (crn := _dict.get('crn')) is not None:
            args['crn'] = crn
        if (account := _dict.get('account')) is not None:
            args['account'] = account
        if (scoped_resources := _dict.get('scoped_resources')) is not None:
            args['scoped_resources'] = [ScopedResource.from_dict(v) for v in scoped_resources]
        if (created_at := _dict.get('created_at')) is not None:
            args['created_at'] = string_to_datetime(created_at)
        if (created_by := _dict.get('created_by')) is not None:
            args['created_by'] = created_by
        if (updated_at := _dict.get('updated_at')) is not None:
            args['updated_at'] = string_to_datetime(updated_at)
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a Policy object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'name') and self.name is not None:
            _dict['name'] = self.name
        if hasattr(self, 'description') and self.description is not None:
            _dict['description'] = self.description
        if hasattr(self, 'resource_group') and self.resource_group is not None:
            _dict['resource_group'] = self.resource_group
        if hasattr(self, 'tags') and self.tags is not None:
            _dict['tags'] = self.tags
        if hasattr(self, 'location') and self.location is not None:
            _dict['location'] = self.location
        if hasattr(self, 'state') and self.state is not None:
            if isinstance(self.state, dict):
                _dict['state'] = self.state
            else:
                _dict['state'] = self.state.to_dict()
        if hasattr(self, 'kind') and self.kind is not None:
            _dict['kind'] = self.kind
        if hasattr(self, 'target') and self.target is not None:
            if isinstance(self.target, dict):
                _dict['target'] = self.target
            else:
                _dict['target'] = self.target.to_dict()
        if hasattr(self, 'parameter') and self.parameter is not None:
            if isinstance(self.parameter, dict):
                _dict['parameter'] = self.parameter
            else:
                _dict['parameter'] = self.parameter.to_dict()
        if hasattr(self, 'id') and getattr(self, 'id') is not None:
            _dict['id'] = getattr(self, 'id')
        if hasattr(self, 'crn') and getattr(self, 'crn') is not None:
            _dict['crn'] = getattr(self, 'crn')
        if hasattr(self, 'account') and getattr(self, 'account') is not None:
            _dict['account'] = getattr(self, 'account')
        if hasattr(self, 'scoped_resources') and self.scoped_resources is not None:
            scoped_resources_list = []
            for v in self.scoped_resources:
                if isinstance(v, dict):
                    scoped_resources_list.append(v)
                else:
                    scoped_resources_list.append(v.to_dict())
            _dict['scoped_resources'] = scoped_resources_list
        if hasattr(self, 'created_at') and getattr(self, 'created_at') is not None:
            _dict['created_at'] = datetime_to_string(getattr(self, 'created_at'))
        if hasattr(self, 'created_by') and getattr(self, 'created_by') is not None:
            _dict['created_by'] = getattr(self, 'created_by')
        if hasattr(self, 'updated_at') and getattr(self, 'updated_at') is not None:
            _dict['updated_at'] = datetime_to_string(getattr(self, 'updated_at'))
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this Policy object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'Policy') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'Policy') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

    class LocationEnum(str, Enum):
        """
        List of locations supported by IBM Cloud Schematics service.  While creating your
        workspace or action, choose the right region, since it cannot be changed.  Note,
        this does not limit the location of the IBM Cloud resources, provisioned using
        Schematics.
        """

        US_SOUTH = 'us-south'
        US_EAST = 'us-east'
        EU_GB = 'eu-gb'
        EU_DE = 'eu-de'

    class KindEnum(str, Enum):
        """
        Policy kind or categories for managing and deriving policy decision
          * `agent_assignment_policy` Agent assignment policy for job execution.
        """

        AGENT_ASSIGNMENT_POLICY = 'agent_assignment_policy'


class PolicyList:
    """
    The list of Schematics customization policies.

    :param int total_count: (optional) The total number of policy records.
    :param int limit: (optional) The number of policy records returned.
    :param int offset: The skipped number of policy records.
    :param List[PolicyLite] policies: (optional) The list of Schematics policies.
    """

    def __init__(
        self,
        offset: int,
        *,
        total_count: Optional[int] = None,
        limit: Optional[int] = None,
        policies: Optional[List['PolicyLite']] = None,
    ) -> None:
        """
        Initialize a PolicyList object.

        :param int offset: The skipped number of policy records.
        """
        self.total_count = total_count
        self.limit = limit
        self.offset = offset
        self.policies = policies

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'PolicyList':
        """Initialize a PolicyList object from a json dictionary."""
        args = {}
        if (total_count := _dict.get('total_count')) is not None:
            args['total_count'] = total_count
        if (limit := _dict.get('limit')) is not None:
            args['limit'] = limit
        if (offset := _dict.get('offset')) is not None:
            args['offset'] = offset
        else:
            raise ValueError('Required property \'offset\' not present in PolicyList JSON')
        if (policies := _dict.get('policies')) is not None:
            args['policies'] = [PolicyLite.from_dict(v) for v in policies]
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a PolicyList object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'total_count') and getattr(self, 'total_count') is not None:
            _dict['total_count'] = getattr(self, 'total_count')
        if hasattr(self, 'limit') and getattr(self, 'limit') is not None:
            _dict['limit'] = getattr(self, 'limit')
        if hasattr(self, 'offset') and self.offset is not None:
            _dict['offset'] = self.offset
        if hasattr(self, 'policies') and getattr(self, 'policies') is not None:
            policies_list = []
            for v in getattr(self, 'policies'):
                if isinstance(v, dict):
                    policies_list.append(v)
                else:
                    policies_list.append(v.to_dict())
            _dict['policies'] = policies_list
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this PolicyList object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'PolicyList') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'PolicyList') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other


class PolicyLite:
    """
    The summary of Schematics policy.

    :param str name: (optional) The name of Schematics customization policy.
    :param str id: (optional) The system generated Policy Id.
    :param str crn: (optional) The policy CRN.
    :param str account: (optional) The Account id.
    :param str description: (optional) The description of Schematics customization
          policy.
    :param str resource_group: (optional) Resource-group name for the Policy.  By
          default, Policy will be created in Default Resource Group.
    :param List[str] tags: (optional) Tags for the Schematics customization policy.
    :param str location: (optional) List of locations supported by IBM Cloud
          Schematics service.  While creating your workspace or action, choose the right
          region, since it cannot be changed.  Note, this does not limit the location of
          the IBM Cloud resources, provisioned using Schematics.
    :param UserState state: (optional) User defined status of the Schematics object.
    :param str policy_kind: (optional) Policy kind or categories for managing and
          deriving policy decision
            * `agent_assignment_policy` Agent assignment policy for job execution.
    :param datetime created_at: (optional) The policy creation time.
    :param str created_by: (optional) The user who created the Policy.
    :param datetime updated_at: (optional) The policy updation time.
    :param str updated_by: (optional) The user who updated the policy.
    """

    def __init__(
        self,
        *,
        name: Optional[str] = None,
        id: Optional[str] = None,
        crn: Optional[str] = None,
        account: Optional[str] = None,
        description: Optional[str] = None,
        resource_group: Optional[str] = None,
        tags: Optional[List[str]] = None,
        location: Optional[str] = None,
        state: Optional['UserState'] = None,
        policy_kind: Optional[str] = None,
        created_at: Optional[datetime] = None,
        created_by: Optional[str] = None,
        updated_at: Optional[datetime] = None,
        updated_by: Optional[str] = None,
    ) -> None:
        """
        Initialize a PolicyLite object.

        :param str location: (optional) List of locations supported by IBM Cloud
               Schematics service.  While creating your workspace or action, choose the
               right region, since it cannot be changed.  Note, this does not limit the
               location of the IBM Cloud resources, provisioned using Schematics.
        :param UserState state: (optional) User defined status of the Schematics
               object.
        :param str policy_kind: (optional) Policy kind or categories for managing
               and deriving policy decision
                 * `agent_assignment_policy` Agent assignment policy for job execution.
        """
        self.name = name
        self.id = id
        self.crn = crn
        self.account = account
        self.description = description
        self.resource_group = resource_group
        self.tags = tags
        self.location = location
        self.state = state
        self.policy_kind = policy_kind
        self.created_at = created_at
        self.created_by = created_by
        self.updated_at = updated_at
        self.updated_by = updated_by

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'PolicyLite':
        """Initialize a PolicyLite object from a json dictionary."""
        args = {}
        if (name := _dict.get('name')) is not None:
            args['name'] = name
        if (id := _dict.get('id')) is not None:
            args['id'] = id
        if (crn := _dict.get('crn')) is not None:
            args['crn'] = crn
        if (account := _dict.get('account')) is not None:
            args['account'] = account
        if (description := _dict.get('description')) is not None:
            args['description'] = description
        if (resource_group := _dict.get('resource_group')) is not None:
            args['resource_group'] = resource_group
        if (tags := _dict.get('tags')) is not None:
            args['tags'] = tags
        if (location := _dict.get('location')) is not None:
            args['location'] = location
        if (state := _dict.get('state')) is not None:
            args['state'] = UserState.from_dict(state)
        if (policy_kind := _dict.get('policy_kind')) is not None:
            args['policy_kind'] = policy_kind
        if (created_at := _dict.get('created_at')) is not None:
            args['created_at'] = string_to_datetime(created_at)
        if (created_by := _dict.get('created_by')) is not None:
            args['created_by'] = created_by
        if (updated_at := _dict.get('updated_at')) is not None:
            args['updated_at'] = string_to_datetime(updated_at)
        if (updated_by := _dict.get('updated_by')) is not None:
            args['updated_by'] = updated_by
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a PolicyLite object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'name') and getattr(self, 'name') is not None:
            _dict['name'] = getattr(self, 'name')
        if hasattr(self, 'id') and getattr(self, 'id') is not None:
            _dict['id'] = getattr(self, 'id')
        if hasattr(self, 'crn') and getattr(self, 'crn') is not None:
            _dict['crn'] = getattr(self, 'crn')
        if hasattr(self, 'account') and getattr(self, 'account') is not None:
            _dict['account'] = getattr(self, 'account')
        if hasattr(self, 'description') and getattr(self, 'description') is not None:
            _dict['description'] = getattr(self, 'description')
        if hasattr(self, 'resource_group') and getattr(self, 'resource_group') is not None:
            _dict['resource_group'] = getattr(self, 'resource_group')
        if hasattr(self, 'tags') and getattr(self, 'tags') is not None:
            _dict['tags'] = getattr(self, 'tags')
        if hasattr(self, 'location') and self.location is not None:
            _dict['location'] = self.location
        if hasattr(self, 'state') and self.state is not None:
            if isinstance(self.state, dict):
                _dict['state'] = self.state
            else:
                _dict['state'] = self.state.to_dict()
        if hasattr(self, 'policy_kind') and self.policy_kind is not None:
            _dict['policy_kind'] = self.policy_kind
        if hasattr(self, 'created_at') and getattr(self, 'created_at') is not None:
            _dict['created_at'] = datetime_to_string(getattr(self, 'created_at'))
        if hasattr(self, 'created_by') and getattr(self, 'created_by') is not None:
            _dict['created_by'] = getattr(self, 'created_by')
        if hasattr(self, 'updated_at') and getattr(self, 'updated_at') is not None:
            _dict['updated_at'] = datetime_to_string(getattr(self, 'updated_at'))
        if hasattr(self, 'updated_by') and getattr(self, 'updated_by') is not None:
            _dict['updated_by'] = getattr(self, 'updated_by')
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this PolicyLite object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'PolicyLite') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'PolicyLite') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

    class LocationEnum(str, Enum):
        """
        List of locations supported by IBM Cloud Schematics service.  While creating your
        workspace or action, choose the right region, since it cannot be changed.  Note,
        this does not limit the location of the IBM Cloud resources, provisioned using
        Schematics.
        """

        US_SOUTH = 'us-south'
        US_EAST = 'us-east'
        EU_GB = 'eu-gb'
        EU_DE = 'eu-de'

    class PolicyKindEnum(str, Enum):
        """
        Policy kind or categories for managing and deriving policy decision
          * `agent_assignment_policy` Agent assignment policy for job execution.
        """

        AGENT_ASSIGNMENT_POLICY = 'agent_assignment_policy'


class PolicyObjectSelector:
    """
    Selector rule to dynamically select Schematics object based on the following metadata
    attributes.  The rule can be defined as follows ((tags in ["policy:secured-job",
    "policy:dept_id:A00132"]) AND (resource_grous in ["default", "sales_rg"])).

    :param str kind: (optional) Name of the Schematics automation resource.
    :param List[str] tags: (optional) The tag based selector.
    :param List[str] resource_groups: (optional) The resource group based selector.
    :param List[str] locations: (optional) The location based selector.
    """

    def __init__(
        self,
        *,
        kind: Optional[str] = None,
        tags: Optional[List[str]] = None,
        resource_groups: Optional[List[str]] = None,
        locations: Optional[List[str]] = None,
    ) -> None:
        """
        Initialize a PolicyObjectSelector object.

        :param str kind: (optional) Name of the Schematics automation resource.
        :param List[str] tags: (optional) The tag based selector.
        :param List[str] resource_groups: (optional) The resource group based
               selector.
        :param List[str] locations: (optional) The location based selector.
        """
        self.kind = kind
        self.tags = tags
        self.resource_groups = resource_groups
        self.locations = locations

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'PolicyObjectSelector':
        """Initialize a PolicyObjectSelector object from a json dictionary."""
        args = {}
        if (kind := _dict.get('kind')) is not None:
            args['kind'] = kind
        if (tags := _dict.get('tags')) is not None:
            args['tags'] = tags
        if (resource_groups := _dict.get('resource_groups')) is not None:
            args['resource_groups'] = resource_groups
        if (locations := _dict.get('locations')) is not None:
            args['locations'] = locations
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a PolicyObjectSelector object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'kind') and self.kind is not None:
            _dict['kind'] = self.kind
        if hasattr(self, 'tags') and self.tags is not None:
            _dict['tags'] = self.tags
        if hasattr(self, 'resource_groups') and self.resource_groups is not None:
            _dict['resource_groups'] = self.resource_groups
        if hasattr(self, 'locations') and self.locations is not None:
            _dict['locations'] = self.locations
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this PolicyObjectSelector object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'PolicyObjectSelector') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'PolicyObjectSelector') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

    class KindEnum(str, Enum):
        """
        Name of the Schematics automation resource.
        """

        WORKSPACE = 'workspace'
        ACTION = 'action'
        SYSTEM = 'system'
        ENVIRONMENT = 'environment'

    class LocationsEnum(str, Enum):
        """
        List of locations supported by IBM Cloud Schematics service.  While creating your
        workspace or action, choose the right region, since it cannot be changed.  Note,
        this does not limit the location of the IBM Cloud resources, provisioned using
        Schematics.
        """

        US_SOUTH = 'us-south'
        US_EAST = 'us-east'
        EU_GB = 'eu-gb'
        EU_DE = 'eu-de'


class PolicyObjects:
    """
    The objects for the Schematics policy.

    :param str selector_kind: (optional) Types of schematics object selector.
    :param List[str] selector_ids: (optional) Static selectors of schematics object
          ids (agent, workspace or action) for the Schematics policy.
    :param List[PolicyObjectSelector] selector_scope: (optional) Selectors to
          dynamically list of schematics object ids (agent, workspace or action) for the
          Schematics policy.
    """

    def __init__(
        self,
        *,
        selector_kind: Optional[str] = None,
        selector_ids: Optional[List[str]] = None,
        selector_scope: Optional[List['PolicyObjectSelector']] = None,
    ) -> None:
        """
        Initialize a PolicyObjects object.

        :param str selector_kind: (optional) Types of schematics object selector.
        :param List[str] selector_ids: (optional) Static selectors of schematics
               object ids (agent, workspace or action) for the Schematics policy.
        :param List[PolicyObjectSelector] selector_scope: (optional) Selectors to
               dynamically list of schematics object ids (agent, workspace or action) for
               the Schematics policy.
        """
        self.selector_kind = selector_kind
        self.selector_ids = selector_ids
        self.selector_scope = selector_scope

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'PolicyObjects':
        """Initialize a PolicyObjects object from a json dictionary."""
        args = {}
        if (selector_kind := _dict.get('selector_kind')) is not None:
            args['selector_kind'] = selector_kind
        if (selector_ids := _dict.get('selector_ids')) is not None:
            args['selector_ids'] = selector_ids
        if (selector_scope := _dict.get('selector_scope')) is not None:
            args['selector_scope'] = [PolicyObjectSelector.from_dict(v) for v in selector_scope]
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a PolicyObjects object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'selector_kind') and self.selector_kind is not None:
            _dict['selector_kind'] = self.selector_kind
        if hasattr(self, 'selector_ids') and self.selector_ids is not None:
            _dict['selector_ids'] = self.selector_ids
        if hasattr(self, 'selector_scope') and self.selector_scope is not None:
            selector_scope_list = []
            for v in self.selector_scope:
                if isinstance(v, dict):
                    selector_scope_list.append(v)
                else:
                    selector_scope_list.append(v.to_dict())
            _dict['selector_scope'] = selector_scope_list
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this PolicyObjects object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'PolicyObjects') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'PolicyObjects') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

    class SelectorKindEnum(str, Enum):
        """
        Types of schematics object selector.
        """

        IDS = 'ids'
        SCOPED = 'scoped'


class PolicyParameter:
    """
    The parameter to tune the Schematics policy.

    :param AgentAssignmentPolicyParameter agent_assignment_policy_parameter:
          (optional) Parameters for the `agent_assignment_policy`.
    """

    def __init__(
        self,
        *,
        agent_assignment_policy_parameter: Optional['AgentAssignmentPolicyParameter'] = None,
    ) -> None:
        """
        Initialize a PolicyParameter object.

        :param AgentAssignmentPolicyParameter agent_assignment_policy_parameter:
               (optional) Parameters for the `agent_assignment_policy`.
        """
        self.agent_assignment_policy_parameter = agent_assignment_policy_parameter

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'PolicyParameter':
        """Initialize a PolicyParameter object from a json dictionary."""
        args = {}
        if (agent_assignment_policy_parameter := _dict.get('agent_assignment_policy_parameter')) is not None:
            args['agent_assignment_policy_parameter'] = AgentAssignmentPolicyParameter.from_dict(
                agent_assignment_policy_parameter
            )
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a PolicyParameter object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'agent_assignment_policy_parameter') and self.agent_assignment_policy_parameter is not None:
            if isinstance(self.agent_assignment_policy_parameter, dict):
                _dict['agent_assignment_policy_parameter'] = self.agent_assignment_policy_parameter
            else:
                _dict['agent_assignment_policy_parameter'] = self.agent_assignment_policy_parameter.to_dict()
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this PolicyParameter object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'PolicyParameter') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'PolicyParameter') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other


class ResourceGroupResponse:
    """
    A list of resource groups that your account has access to.

    :param str account_id: (optional) The ID of the account for which you listed the
          resource groups.
    :param str crn: (optional) The CRN of the resource group.
    :param bool default: (optional) If set to **true**, the resource group is used
          as the default resource group for your account. If set to **false**, the
          resource group is not used as the default resource group in your account.
    :param str name: (optional) The name of the resource group.
    :param str resource_group_id: (optional) The ID of the resource group.
    :param str state: (optional) The state of the resource group.
    """

    def __init__(
        self,
        *,
        account_id: Optional[str] = None,
        crn: Optional[str] = None,
        default: Optional[bool] = None,
        name: Optional[str] = None,
        resource_group_id: Optional[str] = None,
        state: Optional[str] = None,
    ) -> None:
        """
        Initialize a ResourceGroupResponse object.

        :param str account_id: (optional) The ID of the account for which you
               listed the resource groups.
        :param str crn: (optional) The CRN of the resource group.
        :param bool default: (optional) If set to **true**, the resource group is
               used as the default resource group for your account. If set to **false**,
               the resource group is not used as the default resource group in your
               account.
        :param str name: (optional) The name of the resource group.
        :param str resource_group_id: (optional) The ID of the resource group.
        :param str state: (optional) The state of the resource group.
        """
        self.account_id = account_id
        self.crn = crn
        self.default = default
        self.name = name
        self.resource_group_id = resource_group_id
        self.state = state

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'ResourceGroupResponse':
        """Initialize a ResourceGroupResponse object from a json dictionary."""
        args = {}
        if (account_id := _dict.get('account_id')) is not None:
            args['account_id'] = account_id
        if (crn := _dict.get('crn')) is not None:
            args['crn'] = crn
        if (default := _dict.get('default')) is not None:
            args['default'] = default
        if (name := _dict.get('name')) is not None:
            args['name'] = name
        if (resource_group_id := _dict.get('resource_group_id')) is not None:
            args['resource_group_id'] = resource_group_id
        if (state := _dict.get('state')) is not None:
            args['state'] = state
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a ResourceGroupResponse object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'account_id') and self.account_id is not None:
            _dict['account_id'] = self.account_id
        if hasattr(self, 'crn') and self.crn is not None:
            _dict['crn'] = self.crn
        if hasattr(self, 'default') and self.default is not None:
            _dict['default'] = self.default
        if hasattr(self, 'name') and self.name is not None:
            _dict['name'] = self.name
        if hasattr(self, 'resource_group_id') and self.resource_group_id is not None:
            _dict['resource_group_id'] = self.resource_group_id
        if hasattr(self, 'state') and self.state is not None:
            _dict['state'] = self.state
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this ResourceGroupResponse object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'ResourceGroupResponse') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'ResourceGroupResponse') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other


class ResourceQuery:
    """
    Describe resource query.

    :param str query_type: (optional) Type of the query(workspaces).
    :param List[ResourceQueryParam] query_condition: (optional)
    :param List[str] query_select: (optional) List of query selection parameters.
    """

    def __init__(
        self,
        *,
        query_type: Optional[str] = None,
        query_condition: Optional[List['ResourceQueryParam']] = None,
        query_select: Optional[List[str]] = None,
    ) -> None:
        """
        Initialize a ResourceQuery object.

        :param str query_type: (optional) Type of the query(workspaces).
        :param List[ResourceQueryParam] query_condition: (optional)
        :param List[str] query_select: (optional) List of query selection
               parameters.
        """
        self.query_type = query_type
        self.query_condition = query_condition
        self.query_select = query_select

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'ResourceQuery':
        """Initialize a ResourceQuery object from a json dictionary."""
        args = {}
        if (query_type := _dict.get('query_type')) is not None:
            args['query_type'] = query_type
        if (query_condition := _dict.get('query_condition')) is not None:
            args['query_condition'] = [ResourceQueryParam.from_dict(v) for v in query_condition]
        if (query_select := _dict.get('query_select')) is not None:
            args['query_select'] = query_select
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a ResourceQuery object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'query_type') and self.query_type is not None:
            _dict['query_type'] = self.query_type
        if hasattr(self, 'query_condition') and self.query_condition is not None:
            query_condition_list = []
            for v in self.query_condition:
                if isinstance(v, dict):
                    query_condition_list.append(v)
                else:
                    query_condition_list.append(v.to_dict())
            _dict['query_condition'] = query_condition_list
        if hasattr(self, 'query_select') and self.query_select is not None:
            _dict['query_select'] = self.query_select
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this ResourceQuery object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'ResourceQuery') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'ResourceQuery') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

    class QueryTypeEnum(str, Enum):
        """
        Type of the query(workspaces).
        """

        WORKSPACES = 'workspaces'


class ResourceQueryParam:
    """
    Describe resource query param.

    :param str name: (optional) Name of the resource query param.
    :param str value: (optional) Value of the resource query param.
    :param str description: (optional) Description of resource query param variable.
    """

    def __init__(
        self,
        *,
        name: Optional[str] = None,
        value: Optional[str] = None,
        description: Optional[str] = None,
    ) -> None:
        """
        Initialize a ResourceQueryParam object.

        :param str name: (optional) Name of the resource query param.
        :param str value: (optional) Value of the resource query param.
        :param str description: (optional) Description of resource query param
               variable.
        """
        self.name = name
        self.value = value
        self.description = description

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'ResourceQueryParam':
        """Initialize a ResourceQueryParam object from a json dictionary."""
        args = {}
        if (name := _dict.get('name')) is not None:
            args['name'] = name
        if (value := _dict.get('value')) is not None:
            args['value'] = value
        if (description := _dict.get('description')) is not None:
            args['description'] = description
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a ResourceQueryParam object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'name') and self.name is not None:
            _dict['name'] = self.name
        if hasattr(self, 'value') and self.value is not None:
            _dict['value'] = self.value
        if hasattr(self, 'description') and self.description is not None:
            _dict['description'] = self.description
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this ResourceQueryParam object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'ResourceQueryParam') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'ResourceQueryParam') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other


class ResourceQueryRecord:
    """
    Describe resource query record.

    :param str type: (optional) Resource type (cluster, vsi, icd, vpc).
    :param str name: (optional) Resource query name.
    :param str id: (optional) Resource Query id.
    :param datetime created_at: (optional) Resource query creation time.
    :param str created_by: (optional) Email address of user who created the Resource
          query.
    :param datetime updated_at: (optional) Resource query updation time.
    :param str updated_by: (optional) Email address of user who updated the Resource
          query.
    :param List[ResourceQuery] queries: (optional)
    """

    def __init__(
        self,
        *,
        type: Optional[str] = None,
        name: Optional[str] = None,
        id: Optional[str] = None,
        created_at: Optional[datetime] = None,
        created_by: Optional[str] = None,
        updated_at: Optional[datetime] = None,
        updated_by: Optional[str] = None,
        queries: Optional[List['ResourceQuery']] = None,
    ) -> None:
        """
        Initialize a ResourceQueryRecord object.

        :param str type: (optional) Resource type (cluster, vsi, icd, vpc).
        :param str name: (optional) Resource query name.
        :param List[ResourceQuery] queries: (optional)
        """
        self.type = type
        self.name = name
        self.id = id
        self.created_at = created_at
        self.created_by = created_by
        self.updated_at = updated_at
        self.updated_by = updated_by
        self.queries = queries

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'ResourceQueryRecord':
        """Initialize a ResourceQueryRecord object from a json dictionary."""
        args = {}
        if (type := _dict.get('type')) is not None:
            args['type'] = type
        if (name := _dict.get('name')) is not None:
            args['name'] = name
        if (id := _dict.get('id')) is not None:
            args['id'] = id
        if (created_at := _dict.get('created_at')) is not None:
            args['created_at'] = string_to_datetime(created_at)
        if (created_by := _dict.get('created_by')) is not None:
            args['created_by'] = created_by
        if (updated_at := _dict.get('updated_at')) is not None:
            args['updated_at'] = string_to_datetime(updated_at)
        if (updated_by := _dict.get('updated_by')) is not None:
            args['updated_by'] = updated_by
        if (queries := _dict.get('queries')) is not None:
            args['queries'] = [ResourceQuery.from_dict(v) for v in queries]
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a ResourceQueryRecord object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'type') and self.type is not None:
            _dict['type'] = self.type
        if hasattr(self, 'name') and self.name is not None:
            _dict['name'] = self.name
        if hasattr(self, 'id') and getattr(self, 'id') is not None:
            _dict['id'] = getattr(self, 'id')
        if hasattr(self, 'created_at') and getattr(self, 'created_at') is not None:
            _dict['created_at'] = datetime_to_string(getattr(self, 'created_at'))
        if hasattr(self, 'created_by') and getattr(self, 'created_by') is not None:
            _dict['created_by'] = getattr(self, 'created_by')
        if hasattr(self, 'updated_at') and getattr(self, 'updated_at') is not None:
            _dict['updated_at'] = datetime_to_string(getattr(self, 'updated_at'))
        if hasattr(self, 'updated_by') and getattr(self, 'updated_by') is not None:
            _dict['updated_by'] = getattr(self, 'updated_by')
        if hasattr(self, 'queries') and self.queries is not None:
            queries_list = []
            for v in self.queries:
                if isinstance(v, dict):
                    queries_list.append(v)
                else:
                    queries_list.append(v.to_dict())
            _dict['queries'] = queries_list
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this ResourceQueryRecord object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'ResourceQueryRecord') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'ResourceQueryRecord') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

    class TypeEnum(str, Enum):
        """
        Resource type (cluster, vsi, icd, vpc).
        """

        VSI = 'vsi'


class ResourceQueryRecordList:
    """
    List of Resource query records.

    :param int total_count: (optional) Total number of records.
    :param int limit: Number of records returned.
    :param int offset: Skipped number of records.
    :param List[ResourceQueryRecord] resource_queries: (optional) List of resource
          query records. (Deprecated ResourceQueries. Instead, use resource_queries.).
    """

    def __init__(
        self,
        limit: int,
        offset: int,
        *,
        total_count: Optional[int] = None,
        resource_queries: Optional[List['ResourceQueryRecord']] = None,
    ) -> None:
        """
        Initialize a ResourceQueryRecordList object.

        :param int limit: Number of records returned.
        :param int offset: Skipped number of records.
        :param int total_count: (optional) Total number of records.
        :param List[ResourceQueryRecord] resource_queries: (optional) List of
               resource query records. (Deprecated ResourceQueries. Instead, use
               resource_queries.).
        """
        self.total_count = total_count
        self.limit = limit
        self.offset = offset
        self.resource_queries = resource_queries

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'ResourceQueryRecordList':
        """Initialize a ResourceQueryRecordList object from a json dictionary."""
        args = {}
        if (total_count := _dict.get('total_count')) is not None:
            args['total_count'] = total_count
        if (limit := _dict.get('limit')) is not None:
            args['limit'] = limit
        else:
            raise ValueError('Required property \'limit\' not present in ResourceQueryRecordList JSON')
        if (offset := _dict.get('offset')) is not None:
            args['offset'] = offset
        else:
            raise ValueError('Required property \'offset\' not present in ResourceQueryRecordList JSON')
        if (resource_queries := _dict.get('resource_queries')) is not None:
            args['resource_queries'] = [ResourceQueryRecord.from_dict(v) for v in resource_queries]
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a ResourceQueryRecordList object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'total_count') and self.total_count is not None:
            _dict['total_count'] = self.total_count
        if hasattr(self, 'limit') and self.limit is not None:
            _dict['limit'] = self.limit
        if hasattr(self, 'offset') and self.offset is not None:
            _dict['offset'] = self.offset
        if hasattr(self, 'resource_queries') and self.resource_queries is not None:
            resource_queries_list = []
            for v in self.resource_queries:
                if isinstance(v, dict):
                    resource_queries_list.append(v)
                else:
                    resource_queries_list.append(v.to_dict())
            _dict['resource_queries'] = resource_queries_list
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this ResourceQueryRecordList object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'ResourceQueryRecordList') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'ResourceQueryRecordList') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other


class ResourceQueryResponseRecord:
    """
    Describe resource query.

    :param List[ResourceQueryResponseRecordResponse] response: (optional)
    """

    def __init__(
        self,
        *,
        response: Optional[List['ResourceQueryResponseRecordResponse']] = None,
    ) -> None:
        """
        Initialize a ResourceQueryResponseRecord object.

        :param List[ResourceQueryResponseRecordResponse] response: (optional)
        """
        self.response = response

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'ResourceQueryResponseRecord':
        """Initialize a ResourceQueryResponseRecord object from a json dictionary."""
        args = {}
        if (response := _dict.get('response')) is not None:
            args['response'] = [ResourceQueryResponseRecordResponse.from_dict(v) for v in response]
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a ResourceQueryResponseRecord object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'response') and self.response is not None:
            response_list = []
            for v in self.response:
                if isinstance(v, dict):
                    response_list.append(v)
                else:
                    response_list.append(v.to_dict())
            _dict['response'] = response_list
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this ResourceQueryResponseRecord object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'ResourceQueryResponseRecord') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'ResourceQueryResponseRecord') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other


class ResourceQueryResponseRecordQueryOutput:
    """
    List of query output values.

    :param str name: (optional) Name of the output param.
    :param str value: (optional) value of the output param.
    """

    def __init__(
        self,
        *,
        name: Optional[str] = None,
        value: Optional[str] = None,
    ) -> None:
        """
        Initialize a ResourceQueryResponseRecordQueryOutput object.

        :param str name: (optional) Name of the output param.
        :param str value: (optional) value of the output param.
        """
        self.name = name
        self.value = value

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'ResourceQueryResponseRecordQueryOutput':
        """Initialize a ResourceQueryResponseRecordQueryOutput object from a json dictionary."""
        args = {}
        if (name := _dict.get('name')) is not None:
            args['name'] = name
        if (value := _dict.get('value')) is not None:
            args['value'] = value
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a ResourceQueryResponseRecordQueryOutput object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'name') and self.name is not None:
            _dict['name'] = self.name
        if hasattr(self, 'value') and self.value is not None:
            _dict['value'] = self.value
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this ResourceQueryResponseRecordQueryOutput object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'ResourceQueryResponseRecordQueryOutput') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'ResourceQueryResponseRecordQueryOutput') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other


class ResourceQueryResponseRecordResponse:
    """
    ResourceQueryResponseRecordResponse.

    :param str query_type: (optional) Type of the query(workspaces).
    :param List[ResourceQueryParam] query_condition: (optional)
    :param List[str] query_select: (optional) List of query selection parameters.
    :param List[ResourceQueryResponseRecordQueryOutput] query_output: (optional)
    """

    def __init__(
        self,
        *,
        query_type: Optional[str] = None,
        query_condition: Optional[List['ResourceQueryParam']] = None,
        query_select: Optional[List[str]] = None,
        query_output: Optional[List['ResourceQueryResponseRecordQueryOutput']] = None,
    ) -> None:
        """
        Initialize a ResourceQueryResponseRecordResponse object.

        :param str query_type: (optional) Type of the query(workspaces).
        :param List[ResourceQueryParam] query_condition: (optional)
        :param List[str] query_select: (optional) List of query selection
               parameters.
        :param List[ResourceQueryResponseRecordQueryOutput] query_output:
               (optional)
        """
        self.query_type = query_type
        self.query_condition = query_condition
        self.query_select = query_select
        self.query_output = query_output

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'ResourceQueryResponseRecordResponse':
        """Initialize a ResourceQueryResponseRecordResponse object from a json dictionary."""
        args = {}
        if (query_type := _dict.get('query_type')) is not None:
            args['query_type'] = query_type
        if (query_condition := _dict.get('query_condition')) is not None:
            args['query_condition'] = [ResourceQueryParam.from_dict(v) for v in query_condition]
        if (query_select := _dict.get('query_select')) is not None:
            args['query_select'] = query_select
        if (query_output := _dict.get('query_output')) is not None:
            args['query_output'] = [ResourceQueryResponseRecordQueryOutput.from_dict(v) for v in query_output]
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a ResourceQueryResponseRecordResponse object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'query_type') and self.query_type is not None:
            _dict['query_type'] = self.query_type
        if hasattr(self, 'query_condition') and self.query_condition is not None:
            query_condition_list = []
            for v in self.query_condition:
                if isinstance(v, dict):
                    query_condition_list.append(v)
                else:
                    query_condition_list.append(v.to_dict())
            _dict['query_condition'] = query_condition_list
        if hasattr(self, 'query_select') and self.query_select is not None:
            _dict['query_select'] = self.query_select
        if hasattr(self, 'query_output') and self.query_output is not None:
            query_output_list = []
            for v in self.query_output:
                if isinstance(v, dict):
                    query_output_list.append(v)
                else:
                    query_output_list.append(v.to_dict())
            _dict['query_output'] = query_output_list
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this ResourceQueryResponseRecordResponse object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'ResourceQueryResponseRecordResponse') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'ResourceQueryResponseRecordResponse') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

    class QueryTypeEnum(str, Enum):
        """
        Type of the query(workspaces).
        """

        WORKSPACES = 'workspaces'


class SchematicsLocations:
    """
    Information about the location.

    :param str name: (optional) The name of the location.
    :param str id: (optional) The ID of the location.
    :param str country: (optional) The country where the location is located.
    :param str geography: (optional) The geography that the location belongs to.
    :param str geography_code: (optional) Geographical continent locations code
          having the data centres of IBM Cloud Schematics service.
    :param str metro: (optional) The metro area that the location belongs to.
    :param str multizone_metro: (optional) The multizone metro area that the
          location belongs to.
    :param str kind: (optional) The kind of location.
    :param List[str] paired_region: (optional) The list of paired regions used by
          Schematics.
    :param bool restricted: (optional) The restricted region.
    :param List[AgentMetadataInfo] agent_metadata: (optional) The metadata of an
          agent.
    """

    def __init__(
        self,
        *,
        name: Optional[str] = None,
        id: Optional[str] = None,
        country: Optional[str] = None,
        geography: Optional[str] = None,
        geography_code: Optional[str] = None,
        metro: Optional[str] = None,
        multizone_metro: Optional[str] = None,
        kind: Optional[str] = None,
        paired_region: Optional[List[str]] = None,
        restricted: Optional[bool] = None,
        agent_metadata: Optional[List['AgentMetadataInfo']] = None,
    ) -> None:
        """
        Initialize a SchematicsLocations object.

        :param str name: (optional) The name of the location.
        :param str id: (optional) The ID of the location.
        :param str country: (optional) The country where the location is located.
        :param str geography: (optional) The geography that the location belongs
               to.
        :param str geography_code: (optional) Geographical continent locations code
               having the data centres of IBM Cloud Schematics service.
        :param str metro: (optional) The metro area that the location belongs to.
        :param str multizone_metro: (optional) The multizone metro area that the
               location belongs to.
        :param str kind: (optional) The kind of location.
        :param List[str] paired_region: (optional) The list of paired regions used
               by Schematics.
        :param bool restricted: (optional) The restricted region.
        :param List[AgentMetadataInfo] agent_metadata: (optional) The metadata of
               an agent.
        """
        self.name = name
        self.id = id
        self.country = country
        self.geography = geography
        self.geography_code = geography_code
        self.metro = metro
        self.multizone_metro = multizone_metro
        self.kind = kind
        self.paired_region = paired_region
        self.restricted = restricted
        self.agent_metadata = agent_metadata

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'SchematicsLocations':
        """Initialize a SchematicsLocations object from a json dictionary."""
        args = {}
        if (name := _dict.get('name')) is not None:
            args['name'] = name
        if (id := _dict.get('id')) is not None:
            args['id'] = id
        if (country := _dict.get('country')) is not None:
            args['country'] = country
        if (geography := _dict.get('geography')) is not None:
            args['geography'] = geography
        if (geography_code := _dict.get('geography_code')) is not None:
            args['geography_code'] = geography_code
        if (metro := _dict.get('metro')) is not None:
            args['metro'] = metro
        if (multizone_metro := _dict.get('multizone_metro')) is not None:
            args['multizone_metro'] = multizone_metro
        if (kind := _dict.get('kind')) is not None:
            args['kind'] = kind
        if (paired_region := _dict.get('paired_region')) is not None:
            args['paired_region'] = paired_region
        if (restricted := _dict.get('restricted')) is not None:
            args['restricted'] = restricted
        if (agent_metadata := _dict.get('agent_metadata')) is not None:
            args['agent_metadata'] = [AgentMetadataInfo.from_dict(v) for v in agent_metadata]
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a SchematicsLocations object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'name') and self.name is not None:
            _dict['name'] = self.name
        if hasattr(self, 'id') and self.id is not None:
            _dict['id'] = self.id
        if hasattr(self, 'country') and self.country is not None:
            _dict['country'] = self.country
        if hasattr(self, 'geography') and self.geography is not None:
            _dict['geography'] = self.geography
        if hasattr(self, 'geography_code') and self.geography_code is not None:
            _dict['geography_code'] = self.geography_code
        if hasattr(self, 'metro') and self.metro is not None:
            _dict['metro'] = self.metro
        if hasattr(self, 'multizone_metro') and self.multizone_metro is not None:
            _dict['multizone_metro'] = self.multizone_metro
        if hasattr(self, 'kind') and self.kind is not None:
            _dict['kind'] = self.kind
        if hasattr(self, 'paired_region') and self.paired_region is not None:
            _dict['paired_region'] = self.paired_region
        if hasattr(self, 'restricted') and self.restricted is not None:
            _dict['restricted'] = self.restricted
        if hasattr(self, 'agent_metadata') and self.agent_metadata is not None:
            agent_metadata_list = []
            for v in self.agent_metadata:
                if isinstance(v, dict):
                    agent_metadata_list.append(v)
                else:
                    agent_metadata_list.append(v.to_dict())
            _dict['agent_metadata'] = agent_metadata_list
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this SchematicsLocations object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'SchematicsLocations') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'SchematicsLocations') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other


class SchematicsLocationsList:
    """
    The list of locations details.

    :param List[SchematicsLocationsLite] locations: (optional) The list of
          locations.
    """

    def __init__(
        self,
        *,
        locations: Optional[List['SchematicsLocationsLite']] = None,
    ) -> None:
        """
        Initialize a SchematicsLocationsList object.

        :param List[SchematicsLocationsLite] locations: (optional) The list of
               locations.
        """
        self.locations = locations

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'SchematicsLocationsList':
        """Initialize a SchematicsLocationsList object from a json dictionary."""
        args = {}
        if (locations := _dict.get('locations')) is not None:
            args['locations'] = [SchematicsLocationsLite.from_dict(v) for v in locations]
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a SchematicsLocationsList object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'locations') and self.locations is not None:
            locations_list = []
            for v in self.locations:
                if isinstance(v, dict):
                    locations_list.append(v)
                else:
                    locations_list.append(v.to_dict())
            _dict['locations'] = locations_list
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this SchematicsLocationsList object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'SchematicsLocationsList') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'SchematicsLocationsList') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other


class SchematicsLocationsLite:
    """
    An individual location details.

    :param str region: (optional) The Geographical region code having the data
          centres of the IBM Cloud Schematics service.
    :param str metro: (optional) The Geographical city locations having the data
          centres of the IBM Cloud Schematics service.
    :param str geography_code: (optional) The Geographical continent locations code
          having the data centres of the IBM Cloud Schematics service.
    :param str geography: (optional) The Geographical continent locations having the
          data centres of the IBM Cloud Schematics service.
    :param str country: (optional) The Country locations having the data centres of
          the IBM Cloud Schematics service.
    :param str kind: (optional) The kind of location.
    :param List[str] paired_region: (optional) The list of paired regions used by
          the Schematics.
    :param bool restricted: (optional) The restricted region.
    :param str display_name: (optional) Display name for the region.
    :param str schematics_regional_public_endpoint: (optional) Schematics public
          endpoint for the region.
    :param str schematics_regional_private_endpoint: (optional) Schematics private
          endpoint for the region.
    """

    def __init__(
        self,
        *,
        region: Optional[str] = None,
        metro: Optional[str] = None,
        geography_code: Optional[str] = None,
        geography: Optional[str] = None,
        country: Optional[str] = None,
        kind: Optional[str] = None,
        paired_region: Optional[List[str]] = None,
        restricted: Optional[bool] = None,
        display_name: Optional[str] = None,
        schematics_regional_public_endpoint: Optional[str] = None,
        schematics_regional_private_endpoint: Optional[str] = None,
    ) -> None:
        """
        Initialize a SchematicsLocationsLite object.

        :param str region: (optional) The Geographical region code having the data
               centres of the IBM Cloud Schematics service.
        :param str metro: (optional) The Geographical city locations having the
               data centres of the IBM Cloud Schematics service.
        :param str geography_code: (optional) The Geographical continent locations
               code having the data centres of the IBM Cloud Schematics service.
        :param str geography: (optional) The Geographical continent locations
               having the data centres of the IBM Cloud Schematics service.
        :param str country: (optional) The Country locations having the data
               centres of the IBM Cloud Schematics service.
        :param str kind: (optional) The kind of location.
        :param List[str] paired_region: (optional) The list of paired regions used
               by the Schematics.
        :param bool restricted: (optional) The restricted region.
        :param str display_name: (optional) Display name for the region.
        :param str schematics_regional_public_endpoint: (optional) Schematics
               public endpoint for the region.
        :param str schematics_regional_private_endpoint: (optional) Schematics
               private endpoint for the region.
        """
        self.region = region
        self.metro = metro
        self.geography_code = geography_code
        self.geography = geography
        self.country = country
        self.kind = kind
        self.paired_region = paired_region
        self.restricted = restricted
        self.display_name = display_name
        self.schematics_regional_public_endpoint = schematics_regional_public_endpoint
        self.schematics_regional_private_endpoint = schematics_regional_private_endpoint

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'SchematicsLocationsLite':
        """Initialize a SchematicsLocationsLite object from a json dictionary."""
        args = {}
        if (region := _dict.get('region')) is not None:
            args['region'] = region
        if (metro := _dict.get('metro')) is not None:
            args['metro'] = metro
        if (geography_code := _dict.get('geography_code')) is not None:
            args['geography_code'] = geography_code
        if (geography := _dict.get('geography')) is not None:
            args['geography'] = geography
        if (country := _dict.get('country')) is not None:
            args['country'] = country
        if (kind := _dict.get('kind')) is not None:
            args['kind'] = kind
        if (paired_region := _dict.get('paired_region')) is not None:
            args['paired_region'] = paired_region
        if (restricted := _dict.get('restricted')) is not None:
            args['restricted'] = restricted
        if (display_name := _dict.get('display_name')) is not None:
            args['display_name'] = display_name
        if (schematics_regional_public_endpoint := _dict.get('schematics_regional_public_endpoint')) is not None:
            args['schematics_regional_public_endpoint'] = schematics_regional_public_endpoint
        if (schematics_regional_private_endpoint := _dict.get('schematics_regional_private_endpoint')) is not None:
            args['schematics_regional_private_endpoint'] = schematics_regional_private_endpoint
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a SchematicsLocationsLite object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'region') and self.region is not None:
            _dict['region'] = self.region
        if hasattr(self, 'metro') and self.metro is not None:
            _dict['metro'] = self.metro
        if hasattr(self, 'geography_code') and self.geography_code is not None:
            _dict['geography_code'] = self.geography_code
        if hasattr(self, 'geography') and self.geography is not None:
            _dict['geography'] = self.geography
        if hasattr(self, 'country') and self.country is not None:
            _dict['country'] = self.country
        if hasattr(self, 'kind') and self.kind is not None:
            _dict['kind'] = self.kind
        if hasattr(self, 'paired_region') and self.paired_region is not None:
            _dict['paired_region'] = self.paired_region
        if hasattr(self, 'restricted') and self.restricted is not None:
            _dict['restricted'] = self.restricted
        if hasattr(self, 'display_name') and self.display_name is not None:
            _dict['display_name'] = self.display_name
        if (
            hasattr(self, 'schematics_regional_public_endpoint')
            and self.schematics_regional_public_endpoint is not None
        ):
            _dict['schematics_regional_public_endpoint'] = self.schematics_regional_public_endpoint
        if (
            hasattr(self, 'schematics_regional_private_endpoint')
            and self.schematics_regional_private_endpoint is not None
        ):
            _dict['schematics_regional_private_endpoint'] = self.schematics_regional_private_endpoint
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this SchematicsLocationsLite object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'SchematicsLocationsLite') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'SchematicsLocationsLite') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other


class ScopedResource:
    """
    scoped Schematics resource.

    :param str kind: (optional) Name of the Schematics automation resource.
    :param str id: (optional) Schematics resource Id.
    """

    def __init__(
        self,
        *,
        kind: Optional[str] = None,
        id: Optional[str] = None,
    ) -> None:
        """
        Initialize a ScopedResource object.

        :param str kind: (optional) Name of the Schematics automation resource.
        :param str id: (optional) Schematics resource Id.
        """
        self.kind = kind
        self.id = id

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'ScopedResource':
        """Initialize a ScopedResource object from a json dictionary."""
        args = {}
        if (kind := _dict.get('kind')) is not None:
            args['kind'] = kind
        if (id := _dict.get('id')) is not None:
            args['id'] = id
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a ScopedResource object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'kind') and self.kind is not None:
            _dict['kind'] = self.kind
        if hasattr(self, 'id') and self.id is not None:
            _dict['id'] = self.id
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this ScopedResource object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'ScopedResource') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'ScopedResource') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

    class KindEnum(str, Enum):
        """
        Name of the Schematics automation resource.
        """

        WORKSPACE = 'workspace'
        ACTION = 'action'
        SYSTEM = 'system'
        ENVIRONMENT = 'environment'


class ServiceExtensions:
    """
    Service Extensions.

    :param str name: (optional) Name of the Service Data.
    :param object value: (optional) Values of service data.
    :param str type: (optional) Type of the value string, int, bool.
    """

    def __init__(
        self,
        *,
        name: Optional[str] = None,
        value: Optional[object] = None,
        type: Optional[str] = None,
    ) -> None:
        """
        Initialize a ServiceExtensions object.

        :param str name: (optional) Name of the Service Data.
        :param object value: (optional) Values of service data.
        :param str type: (optional) Type of the value string, int, bool.
        """
        self.name = name
        self.value = value
        self.type = type

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'ServiceExtensions':
        """Initialize a ServiceExtensions object from a json dictionary."""
        args = {}
        if (name := _dict.get('name')) is not None:
            args['name'] = name
        if (value := _dict.get('value')) is not None:
            args['value'] = value
        if (type := _dict.get('type')) is not None:
            args['type'] = type
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a ServiceExtensions object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'name') and self.name is not None:
            _dict['name'] = self.name
        if hasattr(self, 'value') and self.value is not None:
            _dict['value'] = self.value
        if hasattr(self, 'type') and self.type is not None:
            _dict['type'] = self.type
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this ServiceExtensions object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'ServiceExtensions') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'ServiceExtensions') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other


class SharedTargetData:
    """
    Information about the Target used by the templates originating from the  IBM Cloud
    catalog offerings. This information is not relevant for workspace created using your
    own Terraform template.

    :param str cluster_created_on: (optional) Cluster created on.
    :param str cluster_id: (optional) The ID of the cluster where you want to
          provision the resources of all IBM Cloud catalog templates that are included in
          the catalog offering.
    :param str cluster_name: (optional) The cluster name.
    :param str cluster_type: (optional) The cluster type.
    :param List[dict] entitlement_keys: (optional) The entitlement key that you want
          to use to install IBM Cloud entitled software.
    :param str namespace: (optional) The Kubernetes namespace or OpenShift project
          where the resources of all IBM Cloud catalog templates that are included in the
          catalog offering are deployed into.
    :param str region: (optional) The IBM Cloud region that you want to use for the
          resources of all IBM Cloud catalog templates that are included in the catalog
          offering.
    :param str resource_group_id: (optional) The ID of the resource group that you
          want to use for the resources of all IBM Cloud catalog templates that are
          included in the catalog offering.
    :param int worker_count: (optional) The cluster worker count.
    :param str worker_machine_type: (optional) The cluster worker type.
    """

    def __init__(
        self,
        *,
        cluster_created_on: Optional[str] = None,
        cluster_id: Optional[str] = None,
        cluster_name: Optional[str] = None,
        cluster_type: Optional[str] = None,
        entitlement_keys: Optional[List[dict]] = None,
        namespace: Optional[str] = None,
        region: Optional[str] = None,
        resource_group_id: Optional[str] = None,
        worker_count: Optional[int] = None,
        worker_machine_type: Optional[str] = None,
    ) -> None:
        """
        Initialize a SharedTargetData object.

        :param str cluster_created_on: (optional) Cluster created on.
        :param str cluster_id: (optional) The ID of the cluster where you want to
               provision the resources of all IBM Cloud catalog templates that are
               included in the catalog offering.
        :param str cluster_name: (optional) The cluster name.
        :param str cluster_type: (optional) The cluster type.
        :param List[dict] entitlement_keys: (optional) The entitlement key that you
               want to use to install IBM Cloud entitled software.
        :param str namespace: (optional) The Kubernetes namespace or OpenShift
               project where the resources of all IBM Cloud catalog templates that are
               included in the catalog offering are deployed into.
        :param str region: (optional) The IBM Cloud region that you want to use for
               the resources of all IBM Cloud catalog templates that are included in the
               catalog offering.
        :param str resource_group_id: (optional) The ID of the resource group that
               you want to use for the resources of all IBM Cloud catalog templates that
               are included in the catalog offering.
        :param int worker_count: (optional) The cluster worker count.
        :param str worker_machine_type: (optional) The cluster worker type.
        """
        self.cluster_created_on = cluster_created_on
        self.cluster_id = cluster_id
        self.cluster_name = cluster_name
        self.cluster_type = cluster_type
        self.entitlement_keys = entitlement_keys
        self.namespace = namespace
        self.region = region
        self.resource_group_id = resource_group_id
        self.worker_count = worker_count
        self.worker_machine_type = worker_machine_type

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'SharedTargetData':
        """Initialize a SharedTargetData object from a json dictionary."""
        args = {}
        if (cluster_created_on := _dict.get('cluster_created_on')) is not None:
            args['cluster_created_on'] = cluster_created_on
        if (cluster_id := _dict.get('cluster_id')) is not None:
            args['cluster_id'] = cluster_id
        if (cluster_name := _dict.get('cluster_name')) is not None:
            args['cluster_name'] = cluster_name
        if (cluster_type := _dict.get('cluster_type')) is not None:
            args['cluster_type'] = cluster_type
        if (entitlement_keys := _dict.get('entitlement_keys')) is not None:
            args['entitlement_keys'] = entitlement_keys
        if (namespace := _dict.get('namespace')) is not None:
            args['namespace'] = namespace
        if (region := _dict.get('region')) is not None:
            args['region'] = region
        if (resource_group_id := _dict.get('resource_group_id')) is not None:
            args['resource_group_id'] = resource_group_id
        if (worker_count := _dict.get('worker_count')) is not None:
            args['worker_count'] = worker_count
        if (worker_machine_type := _dict.get('worker_machine_type')) is not None:
            args['worker_machine_type'] = worker_machine_type
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a SharedTargetData object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'cluster_created_on') and self.cluster_created_on is not None:
            _dict['cluster_created_on'] = self.cluster_created_on
        if hasattr(self, 'cluster_id') and self.cluster_id is not None:
            _dict['cluster_id'] = self.cluster_id
        if hasattr(self, 'cluster_name') and self.cluster_name is not None:
            _dict['cluster_name'] = self.cluster_name
        if hasattr(self, 'cluster_type') and self.cluster_type is not None:
            _dict['cluster_type'] = self.cluster_type
        if hasattr(self, 'entitlement_keys') and self.entitlement_keys is not None:
            _dict['entitlement_keys'] = self.entitlement_keys
        if hasattr(self, 'namespace') and self.namespace is not None:
            _dict['namespace'] = self.namespace
        if hasattr(self, 'region') and self.region is not None:
            _dict['region'] = self.region
        if hasattr(self, 'resource_group_id') and self.resource_group_id is not None:
            _dict['resource_group_id'] = self.resource_group_id
        if hasattr(self, 'worker_count') and self.worker_count is not None:
            _dict['worker_count'] = self.worker_count
        if hasattr(self, 'worker_machine_type') and self.worker_machine_type is not None:
            _dict['worker_machine_type'] = self.worker_machine_type
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this SharedTargetData object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'SharedTargetData') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'SharedTargetData') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other


class SharedTargetDataResponse:
    """
    Information about the Target used by the templates originating from IBM Cloud catalog
    offerings. This information is not relevant when you create a workspace from your own
    Terraform template.

    :param str cluster_id: (optional) The ID of the cluster where you want to
          provision the resources of all IBM Cloud catalog templates that are included in
          the catalog offering.
    :param str cluster_name: (optional) Target cluster name.
    :param List[dict] entitlement_keys: (optional) The entitlement key that you want
          to use to install IBM Cloud entitled software.
    :param str namespace: (optional) The Kubernetes namespace or OpenShift project
          where the resources of all IBM Cloud catalog templates that are included in the
          catalog offering are deployed into.
    :param str region: (optional) The IBM Cloud region that you want to use for the
          resources of all IBM Cloud catalog templates that are included in the catalog
          offering.
    :param str resource_group_id: (optional) The ID of the resource group that you
          want to use for the resources of all IBM Cloud catalog templates that are
          included in the catalog offering.
    """

    def __init__(
        self,
        *,
        cluster_id: Optional[str] = None,
        cluster_name: Optional[str] = None,
        entitlement_keys: Optional[List[dict]] = None,
        namespace: Optional[str] = None,
        region: Optional[str] = None,
        resource_group_id: Optional[str] = None,
    ) -> None:
        """
        Initialize a SharedTargetDataResponse object.

        :param str cluster_id: (optional) The ID of the cluster where you want to
               provision the resources of all IBM Cloud catalog templates that are
               included in the catalog offering.
        :param str cluster_name: (optional) Target cluster name.
        :param List[dict] entitlement_keys: (optional) The entitlement key that you
               want to use to install IBM Cloud entitled software.
        :param str namespace: (optional) The Kubernetes namespace or OpenShift
               project where the resources of all IBM Cloud catalog templates that are
               included in the catalog offering are deployed into.
        :param str region: (optional) The IBM Cloud region that you want to use for
               the resources of all IBM Cloud catalog templates that are included in the
               catalog offering.
        :param str resource_group_id: (optional) The ID of the resource group that
               you want to use for the resources of all IBM Cloud catalog templates that
               are included in the catalog offering.
        """
        self.cluster_id = cluster_id
        self.cluster_name = cluster_name
        self.entitlement_keys = entitlement_keys
        self.namespace = namespace
        self.region = region
        self.resource_group_id = resource_group_id

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'SharedTargetDataResponse':
        """Initialize a SharedTargetDataResponse object from a json dictionary."""
        args = {}
        if (cluster_id := _dict.get('cluster_id')) is not None:
            args['cluster_id'] = cluster_id
        if (cluster_name := _dict.get('cluster_name')) is not None:
            args['cluster_name'] = cluster_name
        if (entitlement_keys := _dict.get('entitlement_keys')) is not None:
            args['entitlement_keys'] = entitlement_keys
        if (namespace := _dict.get('namespace')) is not None:
            args['namespace'] = namespace
        if (region := _dict.get('region')) is not None:
            args['region'] = region
        if (resource_group_id := _dict.get('resource_group_id')) is not None:
            args['resource_group_id'] = resource_group_id
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a SharedTargetDataResponse object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'cluster_id') and self.cluster_id is not None:
            _dict['cluster_id'] = self.cluster_id
        if hasattr(self, 'cluster_name') and self.cluster_name is not None:
            _dict['cluster_name'] = self.cluster_name
        if hasattr(self, 'entitlement_keys') and self.entitlement_keys is not None:
            _dict['entitlement_keys'] = self.entitlement_keys
        if hasattr(self, 'namespace') and self.namespace is not None:
            _dict['namespace'] = self.namespace
        if hasattr(self, 'region') and self.region is not None:
            _dict['region'] = self.region
        if hasattr(self, 'resource_group_id') and self.resource_group_id is not None:
            _dict['resource_group_id'] = self.resource_group_id
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this SharedTargetDataResponse object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'SharedTargetDataResponse') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'SharedTargetDataResponse') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other


class StateStoreResponse:
    """
    Information about workspace runtime data.

    :param str engine_name: (optional) The provisioning engine that was used to
          apply the Terraform template or IBM Cloud catalog software template.
    :param str engine_version: (optional) The version of the provisioning engine
          that was used.
    :param str id: (optional) The ID that was assigned to your Terraform template or
          IBM Cloud catalog software template.
    :param str state_store_url: (optional) The URL where the Terraform statefile
          (`terraform.tfstate`) is stored. You can use the statefile to find an overview
          of IBM Cloud resources that were created by Schematics. Schematics uses the
          statefile as an inventory list to determine future create, update, or deletion
          jobs.
    """

    def __init__(
        self,
        *,
        engine_name: Optional[str] = None,
        engine_version: Optional[str] = None,
        id: Optional[str] = None,
        state_store_url: Optional[str] = None,
    ) -> None:
        """
        Initialize a StateStoreResponse object.

        :param str engine_name: (optional) The provisioning engine that was used to
               apply the Terraform template or IBM Cloud catalog software template.
        :param str engine_version: (optional) The version of the provisioning
               engine that was used.
        :param str id: (optional) The ID that was assigned to your Terraform
               template or IBM Cloud catalog software template.
        :param str state_store_url: (optional) The URL where the Terraform
               statefile (`terraform.tfstate`) is stored. You can use the statefile to
               find an overview of IBM Cloud resources that were created by Schematics.
               Schematics uses the statefile as an inventory list to determine future
               create, update, or deletion jobs.
        """
        self.engine_name = engine_name
        self.engine_version = engine_version
        self.id = id
        self.state_store_url = state_store_url

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'StateStoreResponse':
        """Initialize a StateStoreResponse object from a json dictionary."""
        args = {}
        if (engine_name := _dict.get('engine_name')) is not None:
            args['engine_name'] = engine_name
        if (engine_version := _dict.get('engine_version')) is not None:
            args['engine_version'] = engine_version
        if (id := _dict.get('id')) is not None:
            args['id'] = id
        if (state_store_url := _dict.get('state_store_url')) is not None:
            args['state_store_url'] = state_store_url
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a StateStoreResponse object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'engine_name') and self.engine_name is not None:
            _dict['engine_name'] = self.engine_name
        if hasattr(self, 'engine_version') and self.engine_version is not None:
            _dict['engine_version'] = self.engine_version
        if hasattr(self, 'id') and self.id is not None:
            _dict['id'] = self.id
        if hasattr(self, 'state_store_url') and self.state_store_url is not None:
            _dict['state_store_url'] = self.state_store_url
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this StateStoreResponse object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'StateStoreResponse') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'StateStoreResponse') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other


class StateStoreResponseList:
    """
    Information about the Terraform statefile URL.

    :param List[StateStoreResponse] runtime_data: (optional) Information about
          workspace runtime data.
    """

    def __init__(
        self,
        *,
        runtime_data: Optional[List['StateStoreResponse']] = None,
    ) -> None:
        """
        Initialize a StateStoreResponseList object.

        :param List[StateStoreResponse] runtime_data: (optional) Information about
               workspace runtime data.
        """
        self.runtime_data = runtime_data

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'StateStoreResponseList':
        """Initialize a StateStoreResponseList object from a json dictionary."""
        args = {}
        if (runtime_data := _dict.get('runtime_data')) is not None:
            args['runtime_data'] = [StateStoreResponse.from_dict(v) for v in runtime_data]
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a StateStoreResponseList object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'runtime_data') and self.runtime_data is not None:
            runtime_data_list = []
            for v in self.runtime_data:
                if isinstance(v, dict):
                    runtime_data_list.append(v)
                else:
                    runtime_data_list.append(v.to_dict())
            _dict['runtime_data'] = runtime_data_list
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this StateStoreResponseList object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'StateStoreResponseList') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'StateStoreResponseList') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other


class SystemLock:
    """
    System lock status.

    :param bool sys_locked: (optional) Is the automation locked by a Schematic job
          ?.
    :param str sys_locked_by: (optional) Name of the User who performed the job,
          that lead to the locking of the automation.
    :param datetime sys_locked_at: (optional) When the User performed the job that
          lead to locking of the automation ?.
    """

    def __init__(
        self,
        *,
        sys_locked: Optional[bool] = None,
        sys_locked_by: Optional[str] = None,
        sys_locked_at: Optional[datetime] = None,
    ) -> None:
        """
        Initialize a SystemLock object.

        :param bool sys_locked: (optional) Is the automation locked by a Schematic
               job ?.
        :param str sys_locked_by: (optional) Name of the User who performed the
               job, that lead to the locking of the automation.
        :param datetime sys_locked_at: (optional) When the User performed the job
               that lead to locking of the automation ?.
        """
        self.sys_locked = sys_locked
        self.sys_locked_by = sys_locked_by
        self.sys_locked_at = sys_locked_at

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'SystemLock':
        """Initialize a SystemLock object from a json dictionary."""
        args = {}
        if (sys_locked := _dict.get('sys_locked')) is not None:
            args['sys_locked'] = sys_locked
        if (sys_locked_by := _dict.get('sys_locked_by')) is not None:
            args['sys_locked_by'] = sys_locked_by
        if (sys_locked_at := _dict.get('sys_locked_at')) is not None:
            args['sys_locked_at'] = string_to_datetime(sys_locked_at)
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a SystemLock object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'sys_locked') and self.sys_locked is not None:
            _dict['sys_locked'] = self.sys_locked
        if hasattr(self, 'sys_locked_by') and self.sys_locked_by is not None:
            _dict['sys_locked_by'] = self.sys_locked_by
        if hasattr(self, 'sys_locked_at') and self.sys_locked_at is not None:
            _dict['sys_locked_at'] = datetime_to_string(self.sys_locked_at)
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this SystemLock object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'SystemLock') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'SystemLock') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other


class TemplateMetaDataResponse:
    """
    Template metadata response.

    :param str type: (optional) The template type such as **terraform**,
          **ansible**, **helm**, **cloudpak**, or **bash script**.
    :param List[VariableData] variables: List of variables and its metadata.
    """

    def __init__(
        self,
        variables: List['VariableData'],
        *,
        type: Optional[str] = None,
    ) -> None:
        """
        Initialize a TemplateMetaDataResponse object.

        :param List[VariableData] variables: List of variables and its metadata.
        :param str type: (optional) The template type such as **terraform**,
               **ansible**, **helm**, **cloudpak**, or **bash script**.
        """
        self.type = type
        self.variables = variables

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'TemplateMetaDataResponse':
        """Initialize a TemplateMetaDataResponse object from a json dictionary."""
        args = {}
        if (type := _dict.get('type')) is not None:
            args['type'] = type
        if (variables := _dict.get('variables')) is not None:
            args['variables'] = [VariableData.from_dict(v) for v in variables]
        else:
            raise ValueError('Required property \'variables\' not present in TemplateMetaDataResponse JSON')
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a TemplateMetaDataResponse object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'type') and self.type is not None:
            _dict['type'] = self.type
        if hasattr(self, 'variables') and self.variables is not None:
            variables_list = []
            for v in self.variables:
                if isinstance(v, dict):
                    variables_list.append(v)
                else:
                    variables_list.append(v.to_dict())
            _dict['variables'] = variables_list
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this TemplateMetaDataResponse object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'TemplateMetaDataResponse') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'TemplateMetaDataResponse') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other


class TemplateReadme:
    """
    The `README.md` file for the template used by the workspace.

    :param str readme: (optional) The `README.md` file for the template used by the
          workspace.
    """

    def __init__(
        self,
        *,
        readme: Optional[str] = None,
    ) -> None:
        """
        Initialize a TemplateReadme object.

        :param str readme: (optional) The `README.md` file for the template used by
               the workspace.
        """
        self.readme = readme

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'TemplateReadme':
        """Initialize a TemplateReadme object from a json dictionary."""
        args = {}
        if (readme := _dict.get('readme')) is not None:
            args['readme'] = readme
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a TemplateReadme object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'readme') and self.readme is not None:
            _dict['readme'] = self.readme
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this TemplateReadme object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'TemplateReadme') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'TemplateReadme') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other


class TemplateRepoRequest:
    """
    Input variables for the Template repoository, while creating a workspace.

    :param str branch: (optional) The repository branch.
    :param str release: (optional) The repository release.
    :param str repo_sha_value: (optional) The repository SHA value.
    :param str repo_url: (optional) The repository URL.
    :param str url: (optional) The source URL.
    :param bool skip_submodules_checkout: (optional) Set this variable to checkout
          git sub-modules.
    """

    def __init__(
        self,
        *,
        branch: Optional[str] = None,
        release: Optional[str] = None,
        repo_sha_value: Optional[str] = None,
        repo_url: Optional[str] = None,
        url: Optional[str] = None,
        skip_submodules_checkout: Optional[bool] = None,
    ) -> None:
        """
        Initialize a TemplateRepoRequest object.

        :param str branch: (optional) The repository branch.
        :param str release: (optional) The repository release.
        :param str repo_sha_value: (optional) The repository SHA value.
        :param str repo_url: (optional) The repository URL.
        :param str url: (optional) The source URL.
        :param bool skip_submodules_checkout: (optional) Set this variable to
               checkout git sub-modules.
        """
        self.branch = branch
        self.release = release
        self.repo_sha_value = repo_sha_value
        self.repo_url = repo_url
        self.url = url
        self.skip_submodules_checkout = skip_submodules_checkout

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'TemplateRepoRequest':
        """Initialize a TemplateRepoRequest object from a json dictionary."""
        args = {}
        if (branch := _dict.get('branch')) is not None:
            args['branch'] = branch
        if (release := _dict.get('release')) is not None:
            args['release'] = release
        if (repo_sha_value := _dict.get('repo_sha_value')) is not None:
            args['repo_sha_value'] = repo_sha_value
        if (repo_url := _dict.get('repo_url')) is not None:
            args['repo_url'] = repo_url
        if (url := _dict.get('url')) is not None:
            args['url'] = url
        if (skip_submodules_checkout := _dict.get('skip_submodules_checkout')) is not None:
            args['skip_submodules_checkout'] = skip_submodules_checkout
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a TemplateRepoRequest object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'branch') and self.branch is not None:
            _dict['branch'] = self.branch
        if hasattr(self, 'release') and self.release is not None:
            _dict['release'] = self.release
        if hasattr(self, 'repo_sha_value') and self.repo_sha_value is not None:
            _dict['repo_sha_value'] = self.repo_sha_value
        if hasattr(self, 'repo_url') and self.repo_url is not None:
            _dict['repo_url'] = self.repo_url
        if hasattr(self, 'url') and self.url is not None:
            _dict['url'] = self.url
        if hasattr(self, 'skip_submodules_checkout') and self.skip_submodules_checkout is not None:
            _dict['skip_submodules_checkout'] = self.skip_submodules_checkout
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this TemplateRepoRequest object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'TemplateRepoRequest') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'TemplateRepoRequest') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other


class TemplateRepoResponse:
    """
    Information about the Template repository used by the workspace.

    :param str branch: (optional) The repository branch.
    :param str full_url: (optional) Full repository URL.
    :param bool has_uploadedgitrepotar: (optional) Has uploaded Git repository tar.
    :param str release: (optional) The repository release.
    :param str repo_sha_value: (optional) The repository SHA value.
    :param str repo_url: (optional) The repository URL. For more information, about
          using `.netrc` in `env_values`, see [Usage of private module
          template](https://cloud.ibm.com/docs/schematics?topic=schematics-download-modules-pvt-git).
    :param str url: (optional) The source URL.
    :param bool skip_submodules_checkout: (optional) Set this variable to checkout
          git sub-modules.
    """

    def __init__(
        self,
        *,
        branch: Optional[str] = None,
        full_url: Optional[str] = None,
        has_uploadedgitrepotar: Optional[bool] = None,
        release: Optional[str] = None,
        repo_sha_value: Optional[str] = None,
        repo_url: Optional[str] = None,
        url: Optional[str] = None,
        skip_submodules_checkout: Optional[bool] = None,
    ) -> None:
        """
        Initialize a TemplateRepoResponse object.

        :param str branch: (optional) The repository branch.
        :param str full_url: (optional) Full repository URL.
        :param bool has_uploadedgitrepotar: (optional) Has uploaded Git repository
               tar.
        :param str release: (optional) The repository release.
        :param str repo_sha_value: (optional) The repository SHA value.
        :param str repo_url: (optional) The repository URL. For more information,
               about using `.netrc` in `env_values`, see [Usage of private module
               template](https://cloud.ibm.com/docs/schematics?topic=schematics-download-modules-pvt-git).
        :param str url: (optional) The source URL.
        :param bool skip_submodules_checkout: (optional) Set this variable to
               checkout git sub-modules.
        """
        self.branch = branch
        self.full_url = full_url
        self.has_uploadedgitrepotar = has_uploadedgitrepotar
        self.release = release
        self.repo_sha_value = repo_sha_value
        self.repo_url = repo_url
        self.url = url
        self.skip_submodules_checkout = skip_submodules_checkout

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'TemplateRepoResponse':
        """Initialize a TemplateRepoResponse object from a json dictionary."""
        args = {}
        if (branch := _dict.get('branch')) is not None:
            args['branch'] = branch
        if (full_url := _dict.get('full_url')) is not None:
            args['full_url'] = full_url
        if (has_uploadedgitrepotar := _dict.get('has_uploadedgitrepotar')) is not None:
            args['has_uploadedgitrepotar'] = has_uploadedgitrepotar
        if (release := _dict.get('release')) is not None:
            args['release'] = release
        if (repo_sha_value := _dict.get('repo_sha_value')) is not None:
            args['repo_sha_value'] = repo_sha_value
        if (repo_url := _dict.get('repo_url')) is not None:
            args['repo_url'] = repo_url
        if (url := _dict.get('url')) is not None:
            args['url'] = url
        if (skip_submodules_checkout := _dict.get('skip_submodules_checkout')) is not None:
            args['skip_submodules_checkout'] = skip_submodules_checkout
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a TemplateRepoResponse object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'branch') and self.branch is not None:
            _dict['branch'] = self.branch
        if hasattr(self, 'full_url') and self.full_url is not None:
            _dict['full_url'] = self.full_url
        if hasattr(self, 'has_uploadedgitrepotar') and self.has_uploadedgitrepotar is not None:
            _dict['has_uploadedgitrepotar'] = self.has_uploadedgitrepotar
        if hasattr(self, 'release') and self.release is not None:
            _dict['release'] = self.release
        if hasattr(self, 'repo_sha_value') and self.repo_sha_value is not None:
            _dict['repo_sha_value'] = self.repo_sha_value
        if hasattr(self, 'repo_url') and self.repo_url is not None:
            _dict['repo_url'] = self.repo_url
        if hasattr(self, 'url') and self.url is not None:
            _dict['url'] = self.url
        if hasattr(self, 'skip_submodules_checkout') and self.skip_submodules_checkout is not None:
            _dict['skip_submodules_checkout'] = self.skip_submodules_checkout
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this TemplateRepoResponse object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'TemplateRepoResponse') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'TemplateRepoResponse') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other


class TemplateRepoTarUploadResponse:
    """
    Response after uploading Template in tar file format.

    :param str file_value: (optional) Tar file value.
    :param bool has_received_file: (optional) Has received tar file?.
    :param str id: (optional) Template ID.
    """

    def __init__(
        self,
        *,
        file_value: Optional[str] = None,
        has_received_file: Optional[bool] = None,
        id: Optional[str] = None,
    ) -> None:
        """
        Initialize a TemplateRepoTarUploadResponse object.

        :param str file_value: (optional) Tar file value.
        :param bool has_received_file: (optional) Has received tar file?.
        :param str id: (optional) Template ID.
        """
        self.file_value = file_value
        self.has_received_file = has_received_file
        self.id = id

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'TemplateRepoTarUploadResponse':
        """Initialize a TemplateRepoTarUploadResponse object from a json dictionary."""
        args = {}
        if (file_value := _dict.get('file_value')) is not None:
            args['file_value'] = file_value
        if (has_received_file := _dict.get('has_received_file')) is not None:
            args['has_received_file'] = has_received_file
        if (id := _dict.get('id')) is not None:
            args['id'] = id
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a TemplateRepoTarUploadResponse object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'file_value') and self.file_value is not None:
            _dict['file_value'] = self.file_value
        if hasattr(self, 'has_received_file') and self.has_received_file is not None:
            _dict['has_received_file'] = self.has_received_file
        if hasattr(self, 'id') and self.id is not None:
            _dict['id'] = self.id
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this TemplateRepoTarUploadResponse object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'TemplateRepoTarUploadResponse') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'TemplateRepoTarUploadResponse') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other


class TemplateRepoUpdateRequest:
    """
    Input to update the template repository data.

    :param str branch: (optional) The repository branch.
    :param str release: (optional) The repository release.
    :param str repo_sha_value: (optional) The repository SHA value.
    :param str repo_url: (optional) The repository URL.
    :param str url: (optional) The source URL.
    :param bool skip_submodules_checkout: (optional) Set this variable to checkout
          git sub-modules.
    """

    def __init__(
        self,
        *,
        branch: Optional[str] = None,
        release: Optional[str] = None,
        repo_sha_value: Optional[str] = None,
        repo_url: Optional[str] = None,
        url: Optional[str] = None,
        skip_submodules_checkout: Optional[bool] = None,
    ) -> None:
        """
        Initialize a TemplateRepoUpdateRequest object.

        :param str branch: (optional) The repository branch.
        :param str release: (optional) The repository release.
        :param str repo_sha_value: (optional) The repository SHA value.
        :param str repo_url: (optional) The repository URL.
        :param str url: (optional) The source URL.
        :param bool skip_submodules_checkout: (optional) Set this variable to
               checkout git sub-modules.
        """
        self.branch = branch
        self.release = release
        self.repo_sha_value = repo_sha_value
        self.repo_url = repo_url
        self.url = url
        self.skip_submodules_checkout = skip_submodules_checkout

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'TemplateRepoUpdateRequest':
        """Initialize a TemplateRepoUpdateRequest object from a json dictionary."""
        args = {}
        if (branch := _dict.get('branch')) is not None:
            args['branch'] = branch
        if (release := _dict.get('release')) is not None:
            args['release'] = release
        if (repo_sha_value := _dict.get('repo_sha_value')) is not None:
            args['repo_sha_value'] = repo_sha_value
        if (repo_url := _dict.get('repo_url')) is not None:
            args['repo_url'] = repo_url
        if (url := _dict.get('url')) is not None:
            args['url'] = url
        if (skip_submodules_checkout := _dict.get('skip_submodules_checkout')) is not None:
            args['skip_submodules_checkout'] = skip_submodules_checkout
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a TemplateRepoUpdateRequest object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'branch') and self.branch is not None:
            _dict['branch'] = self.branch
        if hasattr(self, 'release') and self.release is not None:
            _dict['release'] = self.release
        if hasattr(self, 'repo_sha_value') and self.repo_sha_value is not None:
            _dict['repo_sha_value'] = self.repo_sha_value
        if hasattr(self, 'repo_url') and self.repo_url is not None:
            _dict['repo_url'] = self.repo_url
        if hasattr(self, 'url') and self.url is not None:
            _dict['url'] = self.url
        if hasattr(self, 'skip_submodules_checkout') and self.skip_submodules_checkout is not None:
            _dict['skip_submodules_checkout'] = self.skip_submodules_checkout
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this TemplateRepoUpdateRequest object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'TemplateRepoUpdateRequest') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'TemplateRepoUpdateRequest') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other


class TemplateResources:
    """
    Information about the resources provisioned by the Terraform template.

    :param str folder: (optional) The subfolder in GitHub or GitLab where your
          Terraform templates are stored.  If your template is stored in the root
          directory, `.` is returned.
    :param str id: (optional) The ID that was assigned to your Terraform template or
          IBM Cloud catalog software template.
    :param datetime generated_at: (optional) Last refreshed timestamp of the
          terraform resource.
    :param List[dict] null_resources: (optional) List of null resources.
    :param List[dict] related_resources: (optional) Information about the IBM Cloud
          resources that are associated with your workspace.
    :param List[dict] resources: (optional) Information about the IBM Cloud
          resources that are associated with your workspace. **Note** The
          `resource_tainted` flag marks `true` when an instance is times out after few
          hours, if your resource provisioning takes longer duration. When you rerun the
          apply plan, based on the `resource_taint` flag result the provisioning continues
          from the state where the provisioning has stopped.
    :param int resources_count: (optional) Number of resources.
    :param str type: (optional) The Terraform version that was used to apply your
          template.
    """

    def __init__(
        self,
        *,
        folder: Optional[str] = None,
        id: Optional[str] = None,
        generated_at: Optional[datetime] = None,
        null_resources: Optional[List[dict]] = None,
        related_resources: Optional[List[dict]] = None,
        resources: Optional[List[dict]] = None,
        resources_count: Optional[int] = None,
        type: Optional[str] = None,
    ) -> None:
        """
        Initialize a TemplateResources object.

        :param str folder: (optional) The subfolder in GitHub or GitLab where your
               Terraform templates are stored.  If your template is stored in the root
               directory, `.` is returned.
        :param str id: (optional) The ID that was assigned to your Terraform
               template or IBM Cloud catalog software template.
        :param datetime generated_at: (optional) Last refreshed timestamp of the
               terraform resource.
        :param List[dict] null_resources: (optional) List of null resources.
        :param List[dict] related_resources: (optional) Information about the IBM
               Cloud resources that are associated with your workspace.
        :param List[dict] resources: (optional) Information about the IBM Cloud
               resources that are associated with your workspace. **Note** The
               `resource_tainted` flag marks `true` when an instance is times out after
               few hours, if your resource provisioning takes longer duration. When you
               rerun the apply plan, based on the `resource_taint` flag result the
               provisioning continues from the state where the provisioning has stopped.
        :param int resources_count: (optional) Number of resources.
        :param str type: (optional) The Terraform version that was used to apply
               your template.
        """
        self.folder = folder
        self.id = id
        self.generated_at = generated_at
        self.null_resources = null_resources
        self.related_resources = related_resources
        self.resources = resources
        self.resources_count = resources_count
        self.type = type

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'TemplateResources':
        """Initialize a TemplateResources object from a json dictionary."""
        args = {}
        if (folder := _dict.get('folder')) is not None:
            args['folder'] = folder
        if (id := _dict.get('id')) is not None:
            args['id'] = id
        if (generated_at := _dict.get('generated_at')) is not None:
            args['generated_at'] = string_to_datetime(generated_at)
        if (null_resources := _dict.get('null_resources')) is not None:
            args['null_resources'] = null_resources
        if (related_resources := _dict.get('related_resources')) is not None:
            args['related_resources'] = related_resources
        if (resources := _dict.get('resources')) is not None:
            args['resources'] = resources
        if (resources_count := _dict.get('resources_count')) is not None:
            args['resources_count'] = resources_count
        if (type := _dict.get('type')) is not None:
            args['type'] = type
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a TemplateResources object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'folder') and self.folder is not None:
            _dict['folder'] = self.folder
        if hasattr(self, 'id') and self.id is not None:
            _dict['id'] = self.id
        if hasattr(self, 'generated_at') and self.generated_at is not None:
            _dict['generated_at'] = datetime_to_string(self.generated_at)
        if hasattr(self, 'null_resources') and self.null_resources is not None:
            _dict['null_resources'] = self.null_resources
        if hasattr(self, 'related_resources') and self.related_resources is not None:
            _dict['related_resources'] = self.related_resources
        if hasattr(self, 'resources') and self.resources is not None:
            _dict['resources'] = self.resources
        if hasattr(self, 'resources_count') and self.resources_count is not None:
            _dict['resources_count'] = self.resources_count
        if hasattr(self, 'type') and self.type is not None:
            _dict['type'] = self.type
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this TemplateResources object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'TemplateResources') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'TemplateResources') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other


class TemplateRunTimeDataResponse:
    """
    Information about the provisioning engine, state file, and runtime logs.

    :param str engine_cmd: (optional) The command that was used to apply the
          Terraform template or IBM Cloud catalog software template.
    :param str engine_name: (optional) The provisioning engine that was used to
          apply the Terraform template or IBM Cloud catalog software template.
    :param str engine_version: (optional) The version of the provisioning engine
          that was used.
    :param str id: (optional) The ID that was assigned to your Terraform template or
          IBM Cloud catalog software template.
    :param str log_store_url: (optional) The URL to access the logs that were
          created during the creation, update, or deletion of your IBM Cloud resources.
    :param List[dict] output_values: (optional) List of Output values.
    :param List[List[dict]] resources: (optional) List of resources.
    :param str state_store_url: (optional) The URL where the Terraform statefile
          (`terraform.tfstate`) is stored. You can use the statefile to find an overview
          of IBM Cloud resources that were created by Schematics. Schematics uses the
          statefile as an inventory list to determine future create, update, or deletion
          jobs.
    """

    def __init__(
        self,
        *,
        engine_cmd: Optional[str] = None,
        engine_name: Optional[str] = None,
        engine_version: Optional[str] = None,
        id: Optional[str] = None,
        log_store_url: Optional[str] = None,
        output_values: Optional[List[dict]] = None,
        resources: Optional[List[List[dict]]] = None,
        state_store_url: Optional[str] = None,
    ) -> None:
        """
        Initialize a TemplateRunTimeDataResponse object.

        :param str engine_cmd: (optional) The command that was used to apply the
               Terraform template or IBM Cloud catalog software template.
        :param str engine_name: (optional) The provisioning engine that was used to
               apply the Terraform template or IBM Cloud catalog software template.
        :param str engine_version: (optional) The version of the provisioning
               engine that was used.
        :param str id: (optional) The ID that was assigned to your Terraform
               template or IBM Cloud catalog software template.
        :param str log_store_url: (optional) The URL to access the logs that were
               created during the creation, update, or deletion of your IBM Cloud
               resources.
        :param List[dict] output_values: (optional) List of Output values.
        :param List[List[dict]] resources: (optional) List of resources.
        :param str state_store_url: (optional) The URL where the Terraform
               statefile (`terraform.tfstate`) is stored. You can use the statefile to
               find an overview of IBM Cloud resources that were created by Schematics.
               Schematics uses the statefile as an inventory list to determine future
               create, update, or deletion jobs.
        """
        self.engine_cmd = engine_cmd
        self.engine_name = engine_name
        self.engine_version = engine_version
        self.id = id
        self.log_store_url = log_store_url
        self.output_values = output_values
        self.resources = resources
        self.state_store_url = state_store_url

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'TemplateRunTimeDataResponse':
        """Initialize a TemplateRunTimeDataResponse object from a json dictionary."""
        args = {}
        if (engine_cmd := _dict.get('engine_cmd')) is not None:
            args['engine_cmd'] = engine_cmd
        if (engine_name := _dict.get('engine_name')) is not None:
            args['engine_name'] = engine_name
        if (engine_version := _dict.get('engine_version')) is not None:
            args['engine_version'] = engine_version
        if (id := _dict.get('id')) is not None:
            args['id'] = id
        if (log_store_url := _dict.get('log_store_url')) is not None:
            args['log_store_url'] = log_store_url
        if (output_values := _dict.get('output_values')) is not None:
            args['output_values'] = output_values
        if (resources := _dict.get('resources')) is not None:
            args['resources'] = resources
        if (state_store_url := _dict.get('state_store_url')) is not None:
            args['state_store_url'] = state_store_url
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a TemplateRunTimeDataResponse object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'engine_cmd') and self.engine_cmd is not None:
            _dict['engine_cmd'] = self.engine_cmd
        if hasattr(self, 'engine_name') and self.engine_name is not None:
            _dict['engine_name'] = self.engine_name
        if hasattr(self, 'engine_version') and self.engine_version is not None:
            _dict['engine_version'] = self.engine_version
        if hasattr(self, 'id') and self.id is not None:
            _dict['id'] = self.id
        if hasattr(self, 'log_store_url') and self.log_store_url is not None:
            _dict['log_store_url'] = self.log_store_url
        if hasattr(self, 'output_values') and self.output_values is not None:
            _dict['output_values'] = self.output_values
        if hasattr(self, 'resources') and self.resources is not None:
            _dict['resources'] = self.resources
        if hasattr(self, 'state_store_url') and self.state_store_url is not None:
            _dict['state_store_url'] = self.state_store_url
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this TemplateRunTimeDataResponse object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'TemplateRunTimeDataResponse') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'TemplateRunTimeDataResponse') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other


class TemplateSourceDataRequest:
    """
    Input parameters to define input variables for your Terraform template.

    :param List[dict] env_values: (optional) A list of environment variables that
          you want to apply during the execution of a bash script or Terraform job. This
          field must be provided as a list of key-value pairs, for example,
          **TF_LOG=debug**. Each entry will be a map with one entry where `key is the
          environment variable name and value is value`. You can define environment
          variables for IBM Cloud catalog offerings that are provisioned by using a bash
          script. See [example to use special environment
          variable](https://cloud.ibm.com/docs/schematics?topic=schematics-set-parallelism#parallelism-example)
           that are supported by Schematics.
    :param List[EnvironmentValuesMetadata] env_values_metadata: (optional)
          Environment variables metadata.
    :param str folder: (optional) The subfolder in your GitHub or GitLab repository
          where your Terraform template is stored.
    :param bool compact: (optional) True, to use the files from the specified folder
          & subfolder in your GitHub or GitLab repository and ignore the other folders in
          the repository. For more information, see [Compact download for Schematics
          workspace](https://cloud.ibm.com/docs/schematics?topic=schematics-compact-download&interface=ui).
    :param str init_state_file: (optional) The content of an existing Terraform
          statefile that you want to import in to your workspace. To get the content of a
          Terraform statefile for a specific Terraform template in an existing workspace,
          run `ibmcloud terraform state pull --id <workspace_id> --template
          <template_id>`.
    :param List[InjectTerraformTemplateInner] injectors: (optional) Array of
          injectable terraform blocks.
    :param str type: (optional) The Terraform version that you want to use to run
          your Terraform code. Enter `terraform_v1.1` to use Terraform version 1.1, and
          `terraform_v1.0` to use Terraform version 1.0. This is a required variable. If
          the Terraform version is not specified, By default, Schematics selects the
          version from your template. For more information, refer to [Terraform
          version](https://cloud.ibm.com/docs/schematics?topic=schematics-workspace-setup&interface=ui#create-workspace_ui).
    :param str uninstall_script_name: (optional) Uninstall script name.
    :param str values: (optional) A list of variable values that you want to apply
          during the Helm chart installation. The list must be provided in JSON format,
          such as `"autoscaling: enabled: true minReplicas: 2"`. The values that you
          define here override the default Helm chart values. This field is supported only
          for IBM Cloud catalog offerings that are provisioned by using the Terraform Helm
          provider.
    :param List[dict] values_metadata: (optional) List of values metadata.
    :param List[WorkspaceVariableRequest] variablestore: (optional) VariablesRequest
          -.
    """

    def __init__(
        self,
        *,
        env_values: Optional[List[dict]] = None,
        env_values_metadata: Optional[List['EnvironmentValuesMetadata']] = None,
        folder: Optional[str] = None,
        compact: Optional[bool] = None,
        init_state_file: Optional[str] = None,
        injectors: Optional[List['InjectTerraformTemplateInner']] = None,
        type: Optional[str] = None,
        uninstall_script_name: Optional[str] = None,
        values: Optional[str] = None,
        values_metadata: Optional[List[dict]] = None,
        variablestore: Optional[List['WorkspaceVariableRequest']] = None,
    ) -> None:
        """
        Initialize a TemplateSourceDataRequest object.

        :param List[dict] env_values: (optional) A list of environment variables
               that you want to apply during the execution of a bash script or Terraform
               job. This field must be provided as a list of key-value pairs, for example,
               **TF_LOG=debug**. Each entry will be a map with one entry where `key is the
               environment variable name and value is value`. You can define environment
               variables for IBM Cloud catalog offerings that are provisioned by using a
               bash script. See [example to use special environment
               variable](https://cloud.ibm.com/docs/schematics?topic=schematics-set-parallelism#parallelism-example)
                that are supported by Schematics.
        :param List[EnvironmentValuesMetadata] env_values_metadata: (optional)
               Environment variables metadata.
        :param str folder: (optional) The subfolder in your GitHub or GitLab
               repository where your Terraform template is stored.
        :param bool compact: (optional) True, to use the files from the specified
               folder & subfolder in your GitHub or GitLab repository and ignore the other
               folders in the repository. For more information, see [Compact download for
               Schematics
               workspace](https://cloud.ibm.com/docs/schematics?topic=schematics-compact-download&interface=ui).
        :param str init_state_file: (optional) The content of an existing Terraform
               statefile that you want to import in to your workspace. To get the content
               of a Terraform statefile for a specific Terraform template in an existing
               workspace, run `ibmcloud terraform state pull --id <workspace_id>
               --template <template_id>`.
        :param List[InjectTerraformTemplateInner] injectors: (optional) Array of
               injectable terraform blocks.
        :param str type: (optional) The Terraform version that you want to use to
               run your Terraform code. Enter `terraform_v1.1` to use Terraform version
               1.1, and `terraform_v1.0` to use Terraform version 1.0. This is a required
               variable. If the Terraform version is not specified, By default, Schematics
               selects the version from your template. For more information, refer to
               [Terraform
               version](https://cloud.ibm.com/docs/schematics?topic=schematics-workspace-setup&interface=ui#create-workspace_ui).
        :param str uninstall_script_name: (optional) Uninstall script name.
        :param str values: (optional) A list of variable values that you want to
               apply during the Helm chart installation. The list must be provided in JSON
               format, such as `"autoscaling: enabled: true minReplicas: 2"`. The values
               that you define here override the default Helm chart values. This field is
               supported only for IBM Cloud catalog offerings that are provisioned by
               using the Terraform Helm provider.
        :param List[dict] values_metadata: (optional) List of values metadata.
        :param List[WorkspaceVariableRequest] variablestore: (optional)
               VariablesRequest -.
        """
        self.env_values = env_values
        self.env_values_metadata = env_values_metadata
        self.folder = folder
        self.compact = compact
        self.init_state_file = init_state_file
        self.injectors = injectors
        self.type = type
        self.uninstall_script_name = uninstall_script_name
        self.values = values
        self.values_metadata = values_metadata
        self.variablestore = variablestore

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'TemplateSourceDataRequest':
        """Initialize a TemplateSourceDataRequest object from a json dictionary."""
        args = {}
        if (env_values := _dict.get('env_values')) is not None:
            args['env_values'] = env_values
        if (env_values_metadata := _dict.get('env_values_metadata')) is not None:
            args['env_values_metadata'] = [EnvironmentValuesMetadata.from_dict(v) for v in env_values_metadata]
        if (folder := _dict.get('folder')) is not None:
            args['folder'] = folder
        if (compact := _dict.get('compact')) is not None:
            args['compact'] = compact
        if (init_state_file := _dict.get('init_state_file')) is not None:
            args['init_state_file'] = init_state_file
        if (injectors := _dict.get('injectors')) is not None:
            args['injectors'] = [InjectTerraformTemplateInner.from_dict(v) for v in injectors]
        if (type := _dict.get('type')) is not None:
            args['type'] = type
        if (uninstall_script_name := _dict.get('uninstall_script_name')) is not None:
            args['uninstall_script_name'] = uninstall_script_name
        if (values := _dict.get('values')) is not None:
            args['values'] = values
        if (values_metadata := _dict.get('values_metadata')) is not None:
            args['values_metadata'] = values_metadata
        if (variablestore := _dict.get('variablestore')) is not None:
            args['variablestore'] = [WorkspaceVariableRequest.from_dict(v) for v in variablestore]
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a TemplateSourceDataRequest object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'env_values') and self.env_values is not None:
            _dict['env_values'] = self.env_values
        if hasattr(self, 'env_values_metadata') and self.env_values_metadata is not None:
            env_values_metadata_list = []
            for v in self.env_values_metadata:
                if isinstance(v, dict):
                    env_values_metadata_list.append(v)
                else:
                    env_values_metadata_list.append(v.to_dict())
            _dict['env_values_metadata'] = env_values_metadata_list
        if hasattr(self, 'folder') and self.folder is not None:
            _dict['folder'] = self.folder
        if hasattr(self, 'compact') and self.compact is not None:
            _dict['compact'] = self.compact
        if hasattr(self, 'init_state_file') and self.init_state_file is not None:
            _dict['init_state_file'] = self.init_state_file
        if hasattr(self, 'injectors') and self.injectors is not None:
            injectors_list = []
            for v in self.injectors:
                if isinstance(v, dict):
                    injectors_list.append(v)
                else:
                    injectors_list.append(v.to_dict())
            _dict['injectors'] = injectors_list
        if hasattr(self, 'type') and self.type is not None:
            _dict['type'] = self.type
        if hasattr(self, 'uninstall_script_name') and self.uninstall_script_name is not None:
            _dict['uninstall_script_name'] = self.uninstall_script_name
        if hasattr(self, 'values') and self.values is not None:
            _dict['values'] = self.values
        if hasattr(self, 'values_metadata') and self.values_metadata is not None:
            _dict['values_metadata'] = self.values_metadata
        if hasattr(self, 'variablestore') and self.variablestore is not None:
            variablestore_list = []
            for v in self.variablestore:
                if isinstance(v, dict):
                    variablestore_list.append(v)
                else:
                    variablestore_list.append(v.to_dict())
            _dict['variablestore'] = variablestore_list
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this TemplateSourceDataRequest object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'TemplateSourceDataRequest') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'TemplateSourceDataRequest') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other


class TemplateSourceDataResponse:
    """
    Information about the input variables that are used in the template.

    :param List[EnvVariableResponse] env_values: (optional) List of environment
          values.
    :param str folder: (optional) The subfolder in your GitHub or GitLab repository
          where your Terraform template is stored. If your template is stored in the root
          directory, `.` is returned.
    :param bool compact: (optional) True, to use the files from the specified folder
          & subfolder in your GitHub or GitLab repository and ignore the other folders in
          the repository.
    :param bool has_githubtoken: (optional) Has github token.
    :param str id: (optional) The ID that was assigned to your Terraform template or
          IBM Cloud catalog software template.
    :param str type: (optional) The Terraform version that was used to run your
          Terraform code.
    :param str uninstall_script_name: (optional) Uninstall script name.
    :param str values: (optional) A list of variable values that you want to apply
          during the Helm chart installation. The list must be provided in JSON format,
          such as `"autoscaling: enabled: true minReplicas: 2"`. The values that you
          define here override the default Helm chart values. This field is supported only
          for IBM Cloud catalog offerings that are provisioned by using the Terraform Helm
          provider.
    :param List[dict] values_metadata: (optional) A list of input variables that are
          associated with the workspace.
    :param str values_url: (optional) The API endpoint to access the input variables
          that you defined for your template.
    :param List[WorkspaceVariableResponse] variablestore: (optional) Information
          about the input variables that your template uses.
    """

    def __init__(
        self,
        *,
        env_values: Optional[List['EnvVariableResponse']] = None,
        folder: Optional[str] = None,
        compact: Optional[bool] = None,
        has_githubtoken: Optional[bool] = None,
        id: Optional[str] = None,
        type: Optional[str] = None,
        uninstall_script_name: Optional[str] = None,
        values: Optional[str] = None,
        values_metadata: Optional[List[dict]] = None,
        values_url: Optional[str] = None,
        variablestore: Optional[List['WorkspaceVariableResponse']] = None,
    ) -> None:
        """
        Initialize a TemplateSourceDataResponse object.

        :param List[EnvVariableResponse] env_values: (optional) List of environment
               values.
        :param str folder: (optional) The subfolder in your GitHub or GitLab
               repository where your Terraform template is stored. If your template is
               stored in the root directory, `.` is returned.
        :param bool compact: (optional) True, to use the files from the specified
               folder & subfolder in your GitHub or GitLab repository and ignore the other
               folders in the repository.
        :param bool has_githubtoken: (optional) Has github token.
        :param str id: (optional) The ID that was assigned to your Terraform
               template or IBM Cloud catalog software template.
        :param str type: (optional) The Terraform version that was used to run your
               Terraform code.
        :param str uninstall_script_name: (optional) Uninstall script name.
        :param str values: (optional) A list of variable values that you want to
               apply during the Helm chart installation. The list must be provided in JSON
               format, such as `"autoscaling: enabled: true minReplicas: 2"`. The values
               that you define here override the default Helm chart values. This field is
               supported only for IBM Cloud catalog offerings that are provisioned by
               using the Terraform Helm provider.
        :param List[dict] values_metadata: (optional) A list of input variables
               that are associated with the workspace.
        :param str values_url: (optional) The API endpoint to access the input
               variables that you defined for your template.
        :param List[WorkspaceVariableResponse] variablestore: (optional)
               Information about the input variables that your template uses.
        """
        self.env_values = env_values
        self.folder = folder
        self.compact = compact
        self.has_githubtoken = has_githubtoken
        self.id = id
        self.type = type
        self.uninstall_script_name = uninstall_script_name
        self.values = values
        self.values_metadata = values_metadata
        self.values_url = values_url
        self.variablestore = variablestore

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'TemplateSourceDataResponse':
        """Initialize a TemplateSourceDataResponse object from a json dictionary."""
        args = {}
        if (env_values := _dict.get('env_values')) is not None:
            args['env_values'] = [EnvVariableResponse.from_dict(v) for v in env_values]
        if (folder := _dict.get('folder')) is not None:
            args['folder'] = folder
        if (compact := _dict.get('compact')) is not None:
            args['compact'] = compact
        if (has_githubtoken := _dict.get('has_githubtoken')) is not None:
            args['has_githubtoken'] = has_githubtoken
        if (id := _dict.get('id')) is not None:
            args['id'] = id
        if (type := _dict.get('type')) is not None:
            args['type'] = type
        if (uninstall_script_name := _dict.get('uninstall_script_name')) is not None:
            args['uninstall_script_name'] = uninstall_script_name
        if (values := _dict.get('values')) is not None:
            args['values'] = values
        if (values_metadata := _dict.get('values_metadata')) is not None:
            args['values_metadata'] = values_metadata
        if (values_url := _dict.get('values_url')) is not None:
            args['values_url'] = values_url
        if (variablestore := _dict.get('variablestore')) is not None:
            args['variablestore'] = [WorkspaceVariableResponse.from_dict(v) for v in variablestore]
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a TemplateSourceDataResponse object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'env_values') and self.env_values is not None:
            env_values_list = []
            for v in self.env_values:
                if isinstance(v, dict):
                    env_values_list.append(v)
                else:
                    env_values_list.append(v.to_dict())
            _dict['env_values'] = env_values_list
        if hasattr(self, 'folder') and self.folder is not None:
            _dict['folder'] = self.folder
        if hasattr(self, 'compact') and self.compact is not None:
            _dict['compact'] = self.compact
        if hasattr(self, 'has_githubtoken') and self.has_githubtoken is not None:
            _dict['has_githubtoken'] = self.has_githubtoken
        if hasattr(self, 'id') and self.id is not None:
            _dict['id'] = self.id
        if hasattr(self, 'type') and self.type is not None:
            _dict['type'] = self.type
        if hasattr(self, 'uninstall_script_name') and self.uninstall_script_name is not None:
            _dict['uninstall_script_name'] = self.uninstall_script_name
        if hasattr(self, 'values') and self.values is not None:
            _dict['values'] = self.values
        if hasattr(self, 'values_metadata') and self.values_metadata is not None:
            _dict['values_metadata'] = self.values_metadata
        if hasattr(self, 'values_url') and self.values_url is not None:
            _dict['values_url'] = self.values_url
        if hasattr(self, 'variablestore') and self.variablestore is not None:
            variablestore_list = []
            for v in self.variablestore:
                if isinstance(v, dict):
                    variablestore_list.append(v)
                else:
                    variablestore_list.append(v.to_dict())
            _dict['variablestore'] = variablestore_list
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this TemplateSourceDataResponse object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'TemplateSourceDataResponse') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'TemplateSourceDataResponse') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other


class TemplateStateStore:
    """
    The content of the Terraform statefile (`terraform.tfstate`).

    :param float version: (optional)
    :param str terraform_version: (optional)
    :param float serial: (optional)
    :param str lineage: (optional)
    :param List[dict] modules: (optional)
    """

    def __init__(
        self,
        *,
        version: Optional[float] = None,
        terraform_version: Optional[str] = None,
        serial: Optional[float] = None,
        lineage: Optional[str] = None,
        modules: Optional[List[dict]] = None,
    ) -> None:
        """
        Initialize a TemplateStateStore object.

        :param float version: (optional)
        :param str terraform_version: (optional)
        :param float serial: (optional)
        :param str lineage: (optional)
        :param List[dict] modules: (optional)
        """
        self.version = version
        self.terraform_version = terraform_version
        self.serial = serial
        self.lineage = lineage
        self.modules = modules

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'TemplateStateStore':
        """Initialize a TemplateStateStore object from a json dictionary."""
        args = {}
        if (version := _dict.get('version')) is not None:
            args['version'] = version
        if (terraform_version := _dict.get('terraform_version')) is not None:
            args['terraform_version'] = terraform_version
        if (serial := _dict.get('serial')) is not None:
            args['serial'] = serial
        if (lineage := _dict.get('lineage')) is not None:
            args['lineage'] = lineage
        if (modules := _dict.get('modules')) is not None:
            args['modules'] = modules
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a TemplateStateStore object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'version') and self.version is not None:
            _dict['version'] = self.version
        if hasattr(self, 'terraform_version') and self.terraform_version is not None:
            _dict['terraform_version'] = self.terraform_version
        if hasattr(self, 'serial') and self.serial is not None:
            _dict['serial'] = self.serial
        if hasattr(self, 'lineage') and self.lineage is not None:
            _dict['lineage'] = self.lineage
        if hasattr(self, 'modules') and self.modules is not None:
            _dict['modules'] = self.modules
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this TemplateStateStore object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'TemplateStateStore') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'TemplateStateStore') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other


class TemplateValues:
    """
    Information about the input variables that are declared in the template that your
    workspace points to.

    :param List[dict] values_metadata: (optional) Information about workspace
          variable metadata.
    """

    def __init__(
        self,
        *,
        values_metadata: Optional[List[dict]] = None,
    ) -> None:
        """
        Initialize a TemplateValues object.

        :param List[dict] values_metadata: (optional) Information about workspace
               variable metadata.
        """
        self.values_metadata = values_metadata

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'TemplateValues':
        """Initialize a TemplateValues object from a json dictionary."""
        args = {}
        if (values_metadata := _dict.get('values_metadata')) is not None:
            args['values_metadata'] = values_metadata
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a TemplateValues object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'values_metadata') and self.values_metadata is not None:
            _dict['values_metadata'] = self.values_metadata
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this TemplateValues object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'TemplateValues') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'TemplateValues') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other


class TerraformCommand:
    """
    Inputs for running a Terraform command on the workspace.

    :param str command: (optional) You must provide the command to execute.
          Supported commands are `show`,`taint`, `untaint`, `state`, `import`, `output`,
          `drift`.
    :param str command_params: (optional) The required address parameters for the
          command name. You can send the option flag and address parameter in the payload.
          **Syntax ** "command_params": "<option>=<flag>", "<address>". **Example **
          "command_params": "-allow-missing=true", "-lock=true",
          "data.template_file.test".
    :param str command_name: (optional) The optional name for the command block.
    :param str command_desc: (optional) The optional text to describe the command
          block.
    :param str command_on_error: (optional) Instruction to continue or break in case
          of error.
    :param str command_depends_on: (optional) Dependency on previous commands.
    :param str command_status: (optional) Displays the command executed status,
          either `success` or `failure`.
    """

    def __init__(
        self,
        *,
        command: Optional[str] = None,
        command_params: Optional[str] = None,
        command_name: Optional[str] = None,
        command_desc: Optional[str] = None,
        command_on_error: Optional[str] = None,
        command_depends_on: Optional[str] = None,
        command_status: Optional[str] = None,
    ) -> None:
        """
        Initialize a TerraformCommand object.

        :param str command: (optional) You must provide the command to execute.
               Supported commands are `show`,`taint`, `untaint`, `state`, `import`,
               `output`, `drift`.
        :param str command_params: (optional) The required address parameters for
               the command name. You can send the option flag and address parameter in the
               payload. **Syntax ** "command_params": "<option>=<flag>", "<address>".
               **Example ** "command_params": "-allow-missing=true", "-lock=true",
               "data.template_file.test".
        :param str command_name: (optional) The optional name for the command
               block.
        :param str command_desc: (optional) The optional text to describe the
               command block.
        :param str command_on_error: (optional) Instruction to continue or break in
               case of error.
        :param str command_depends_on: (optional) Dependency on previous commands.
        :param str command_status: (optional) Displays the command executed status,
               either `success` or `failure`.
        """
        self.command = command
        self.command_params = command_params
        self.command_name = command_name
        self.command_desc = command_desc
        self.command_on_error = command_on_error
        self.command_depends_on = command_depends_on
        self.command_status = command_status

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'TerraformCommand':
        """Initialize a TerraformCommand object from a json dictionary."""
        args = {}
        if (command := _dict.get('command')) is not None:
            args['command'] = command
        if (command_params := _dict.get('command_params')) is not None:
            args['command_params'] = command_params
        if (command_name := _dict.get('command_name')) is not None:
            args['command_name'] = command_name
        if (command_desc := _dict.get('command_desc')) is not None:
            args['command_desc'] = command_desc
        if (command_on_error := _dict.get('command_on_error')) is not None:
            args['command_on_error'] = command_on_error
        if (command_depends_on := _dict.get('command_depends_on')) is not None:
            args['command_depends_on'] = command_depends_on
        if (command_status := _dict.get('command_status')) is not None:
            args['command_status'] = command_status
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a TerraformCommand object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'command') and self.command is not None:
            _dict['command'] = self.command
        if hasattr(self, 'command_params') and self.command_params is not None:
            _dict['command_params'] = self.command_params
        if hasattr(self, 'command_name') and self.command_name is not None:
            _dict['command_name'] = self.command_name
        if hasattr(self, 'command_desc') and self.command_desc is not None:
            _dict['command_desc'] = self.command_desc
        if hasattr(self, 'command_on_error') and self.command_on_error is not None:
            _dict['command_on_error'] = self.command_on_error
        if hasattr(self, 'command_depends_on') and self.command_depends_on is not None:
            _dict['command_depends_on'] = self.command_depends_on
        if hasattr(self, 'command_status') and self.command_status is not None:
            _dict['command_status'] = self.command_status
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this TerraformCommand object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'TerraformCommand') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'TerraformCommand') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other


class UserState:
    """
    User defined status of the Schematics object.

    :param str state: (optional) User-defined states
            * `draft` Object can be modified; can be used by Jobs run by the author,
          during execution
            * `live` Object can be modified; can be used by Jobs during execution
            * `locked` Object cannot be modified; can be used by Jobs during execution
            * `disable` Object can be modified. cannot be used by Jobs during execution.
    :param str set_by: (optional) Name of the User who set the state of the Object.
    :param datetime set_at: (optional) When the User who set the state of the
          Object.
    """

    def __init__(
        self,
        *,
        state: Optional[str] = None,
        set_by: Optional[str] = None,
        set_at: Optional[datetime] = None,
    ) -> None:
        """
        Initialize a UserState object.

        :param str state: (optional) User-defined states
                 * `draft` Object can be modified; can be used by Jobs run by the author,
               during execution
                 * `live` Object can be modified; can be used by Jobs during execution
                 * `locked` Object cannot be modified; can be used by Jobs during
               execution
                 * `disable` Object can be modified. cannot be used by Jobs during
               execution.
        :param str set_by: (optional) Name of the User who set the state of the
               Object.
        :param datetime set_at: (optional) When the User who set the state of the
               Object.
        """
        self.state = state
        self.set_by = set_by
        self.set_at = set_at

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'UserState':
        """Initialize a UserState object from a json dictionary."""
        args = {}
        if (state := _dict.get('state')) is not None:
            args['state'] = state
        if (set_by := _dict.get('set_by')) is not None:
            args['set_by'] = set_by
        if (set_at := _dict.get('set_at')) is not None:
            args['set_at'] = string_to_datetime(set_at)
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a UserState object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'state') and self.state is not None:
            _dict['state'] = self.state
        if hasattr(self, 'set_by') and self.set_by is not None:
            _dict['set_by'] = self.set_by
        if hasattr(self, 'set_at') and self.set_at is not None:
            _dict['set_at'] = datetime_to_string(self.set_at)
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this UserState object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'UserState') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'UserState') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

    class StateEnum(str, Enum):
        """
        User-defined states
          * `draft` Object can be modified; can be used by Jobs run by the author, during
        execution
          * `live` Object can be modified; can be used by Jobs during execution
          * `locked` Object cannot be modified; can be used by Jobs during execution
          * `disable` Object can be modified. cannot be used by Jobs during execution.
        """

        DRAFT = 'draft'
        LIVE = 'live'
        LOCKED = 'locked'
        DISABLE = 'disable'


class UserValues:
    """
    UserValues -.

    :param List[dict] env_values: (optional) A list of environment variables that
          you want to apply during the execution of a bash script or Terraform job. This
          field must be provided as a list of key-value pairs, for example,
          **TF_LOG=debug**. Each entry will be a map with one entry where `key is the
          environment variable name and value is value`. You can define environment
          variables for IBM Cloud catalog offerings that are provisioned by using a bash
          script. See [example to use special environment
          variable](https://cloud.ibm.com/docs/schematics?topic=schematics-set-parallelism#parallelism-example)
           that are supported by Schematics.
    :param List[EnvVariableRequestMap] env_values_map: (optional) A list of
          environment variables that you want to apply during the execution of a bash
          script or Terraform job. This field must be provided as a list of key-value
          pairs, for example, **TF_LOG=debug**. Each entry will be a map with one entry
          where `key is the environment variable name and value is value`. You can define
          environment variables for IBM Cloud catalog offerings that are provisioned by
          using a bash script. See [example to use special environment
          variable](https://cloud.ibm.com/docs/schematics?topic=schematics-set-parallelism#parallelism-example)
           that are supported by Schematics.
    :param str values: (optional) User values.
    :param List[WorkspaceVariableResponse] variablestore: (optional) Information
          about the input variables that your template uses.
    """

    def __init__(
        self,
        *,
        env_values: Optional[List[dict]] = None,
        env_values_map: Optional[List['EnvVariableRequestMap']] = None,
        values: Optional[str] = None,
        variablestore: Optional[List['WorkspaceVariableResponse']] = None,
    ) -> None:
        """
        Initialize a UserValues object.

        :param List[dict] env_values: (optional) A list of environment variables
               that you want to apply during the execution of a bash script or Terraform
               job. This field must be provided as a list of key-value pairs, for example,
               **TF_LOG=debug**. Each entry will be a map with one entry where `key is the
               environment variable name and value is value`. You can define environment
               variables for IBM Cloud catalog offerings that are provisioned by using a
               bash script. See [example to use special environment
               variable](https://cloud.ibm.com/docs/schematics?topic=schematics-set-parallelism#parallelism-example)
                that are supported by Schematics.
        :param List[EnvVariableRequestMap] env_values_map: (optional) A list of
               environment variables that you want to apply during the execution of a bash
               script or Terraform job. This field must be provided as a list of key-value
               pairs, for example, **TF_LOG=debug**. Each entry will be a map with one
               entry where `key is the environment variable name and value is value`. You
               can define environment variables for IBM Cloud catalog offerings that are
               provisioned by using a bash script. See [example to use special environment
               variable](https://cloud.ibm.com/docs/schematics?topic=schematics-set-parallelism#parallelism-example)
                that are supported by Schematics.
        :param str values: (optional) User values.
        :param List[WorkspaceVariableResponse] variablestore: (optional)
               Information about the input variables that your template uses.
        """
        self.env_values = env_values
        self.env_values_map = env_values_map
        self.values = values
        self.variablestore = variablestore

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'UserValues':
        """Initialize a UserValues object from a json dictionary."""
        args = {}
        if (env_values := _dict.get('env_values')) is not None:
            args['env_values'] = env_values
        if (env_values_map := _dict.get('env_values_map')) is not None:
            args['env_values_map'] = [EnvVariableRequestMap.from_dict(v) for v in env_values_map]
        if (values := _dict.get('values')) is not None:
            args['values'] = values
        if (variablestore := _dict.get('variablestore')) is not None:
            args['variablestore'] = [WorkspaceVariableResponse.from_dict(v) for v in variablestore]
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a UserValues object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'env_values') and self.env_values is not None:
            _dict['env_values'] = self.env_values
        if hasattr(self, 'env_values_map') and self.env_values_map is not None:
            env_values_map_list = []
            for v in self.env_values_map:
                if isinstance(v, dict):
                    env_values_map_list.append(v)
                else:
                    env_values_map_list.append(v.to_dict())
            _dict['env_values_map'] = env_values_map_list
        if hasattr(self, 'values') and self.values is not None:
            _dict['values'] = self.values
        if hasattr(self, 'variablestore') and self.variablestore is not None:
            variablestore_list = []
            for v in self.variablestore:
                if isinstance(v, dict):
                    variablestore_list.append(v)
                else:
                    variablestore_list.append(v.to_dict())
            _dict['variablestore'] = variablestore_list
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this UserValues object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'UserValues') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'UserValues') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other


class VariableData:
    """
    User editable variable data and system generated reference to the value.

    :param str name: (optional) The name of the variable. For example, `name =
          "inventory username"`.
    :param str value: (optional) The value for the variable or reference to the
          value. For example, `value = "<provide your ssh_key_value with \n>"`.
    :param bool use_default: (optional) True, will ignore the data in the value
          attribute, instead the data in metadata.default_value will be used.
    :param VariableMetadata metadata: (optional) An user editable metadata for the
          variables.
    :param str link: (optional) The reference link to the variable value By default
          the expression points to `$self.value`.
    """

    def __init__(
        self,
        *,
        name: Optional[str] = None,
        value: Optional[str] = None,
        use_default: Optional[bool] = None,
        metadata: Optional['VariableMetadata'] = None,
        link: Optional[str] = None,
    ) -> None:
        """
        Initialize a VariableData object.

        :param str name: (optional) The name of the variable. For example, `name =
               "inventory username"`.
        :param str value: (optional) The value for the variable or reference to the
               value. For example, `value = "<provide your ssh_key_value with \n>"`.
        :param bool use_default: (optional) True, will ignore the data in the value
               attribute, instead the data in metadata.default_value will be used.
        :param VariableMetadata metadata: (optional) An user editable metadata for
               the variables.
        """
        self.name = name
        self.value = value
        self.use_default = use_default
        self.metadata = metadata
        self.link = link

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'VariableData':
        """Initialize a VariableData object from a json dictionary."""
        args = {}
        if (name := _dict.get('name')) is not None:
            args['name'] = name
        if (value := _dict.get('value')) is not None:
            args['value'] = value
        if (use_default := _dict.get('use_default')) is not None:
            args['use_default'] = use_default
        if (metadata := _dict.get('metadata')) is not None:
            args['metadata'] = VariableMetadata.from_dict(metadata)
        if (link := _dict.get('link')) is not None:
            args['link'] = link
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a VariableData object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'name') and self.name is not None:
            _dict['name'] = self.name
        if hasattr(self, 'value') and self.value is not None:
            _dict['value'] = self.value
        if hasattr(self, 'use_default') and self.use_default is not None:
            _dict['use_default'] = self.use_default
        if hasattr(self, 'metadata') and self.metadata is not None:
            if isinstance(self.metadata, dict):
                _dict['metadata'] = self.metadata
            else:
                _dict['metadata'] = self.metadata.to_dict()
        if hasattr(self, 'link') and getattr(self, 'link') is not None:
            _dict['link'] = getattr(self, 'link')
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this VariableData object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'VariableData') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'VariableData') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other


class VariableMetadata:
    """
    An user editable metadata for the variables.

    :param str type: (optional) Type of the variable.
    :param List[str] aliases: (optional) The list of aliases for the variable name.
    :param str description: (optional) The description of the meta data.
    :param str cloud_data_type: (optional) Cloud data type of the variable. eg.
          resource_group_id, region, vpc_id.
    :param str default_value: (optional) Default value for the variable only if the
          override value is not specified.
    :param str link_status: (optional) The status of the link.
    :param bool secure: (optional) Is the variable secure or sensitive ?.
    :param bool immutable: (optional) Is the variable readonly ?.
    :param bool hidden: (optional) If **true**, the variable is not displayed on UI
          or Command line.
    :param bool required: (optional) If the variable required?.
    :param List[str] options: (optional) The list of possible values for this
          variable.  If type is **integer** or **date**, then the array of string is
          converted to array of integers or date during the runtime.
    :param int min_value: (optional) The minimum value of the variable. Applicable
          for the integer type.
    :param int max_value: (optional) The maximum value of the variable. Applicable
          for the integer type.
    :param int min_length: (optional) The minimum length of the variable value.
          Applicable for the string type.
    :param int max_length: (optional) The maximum length of the variable value.
          Applicable for the string type.
    :param str matches: (optional) The regex for the variable value.
    :param int position: (optional) The relative position of this variable in a
          list.
    :param str group_by: (optional) The display name of the group this variable
          belongs to.
    :param str source: (optional) The source of this meta-data.
    """

    def __init__(
        self,
        *,
        type: Optional[str] = None,
        aliases: Optional[List[str]] = None,
        description: Optional[str] = None,
        cloud_data_type: Optional[str] = None,
        default_value: Optional[str] = None,
        link_status: Optional[str] = None,
        secure: Optional[bool] = None,
        immutable: Optional[bool] = None,
        hidden: Optional[bool] = None,
        required: Optional[bool] = None,
        options: Optional[List[str]] = None,
        min_value: Optional[int] = None,
        max_value: Optional[int] = None,
        min_length: Optional[int] = None,
        max_length: Optional[int] = None,
        matches: Optional[str] = None,
        position: Optional[int] = None,
        group_by: Optional[str] = None,
        source: Optional[str] = None,
    ) -> None:
        """
        Initialize a VariableMetadata object.

        :param str type: (optional) Type of the variable.
        :param List[str] aliases: (optional) The list of aliases for the variable
               name.
        :param str description: (optional) The description of the meta data.
        :param str cloud_data_type: (optional) Cloud data type of the variable. eg.
               resource_group_id, region, vpc_id.
        :param str default_value: (optional) Default value for the variable only if
               the override value is not specified.
        :param str link_status: (optional) The status of the link.
        :param bool secure: (optional) Is the variable secure or sensitive ?.
        :param bool immutable: (optional) Is the variable readonly ?.
        :param bool hidden: (optional) If **true**, the variable is not displayed
               on UI or Command line.
        :param bool required: (optional) If the variable required?.
        :param List[str] options: (optional) The list of possible values for this
               variable.  If type is **integer** or **date**, then the array of string is
               converted to array of integers or date during the runtime.
        :param int min_value: (optional) The minimum value of the variable.
               Applicable for the integer type.
        :param int max_value: (optional) The maximum value of the variable.
               Applicable for the integer type.
        :param int min_length: (optional) The minimum length of the variable value.
               Applicable for the string type.
        :param int max_length: (optional) The maximum length of the variable value.
               Applicable for the string type.
        :param str matches: (optional) The regex for the variable value.
        :param int position: (optional) The relative position of this variable in a
               list.
        :param str group_by: (optional) The display name of the group this variable
               belongs to.
        :param str source: (optional) The source of this meta-data.
        """
        self.type = type
        self.aliases = aliases
        self.description = description
        self.cloud_data_type = cloud_data_type
        self.default_value = default_value
        self.link_status = link_status
        self.secure = secure
        self.immutable = immutable
        self.hidden = hidden
        self.required = required
        self.options = options
        self.min_value = min_value
        self.max_value = max_value
        self.min_length = min_length
        self.max_length = max_length
        self.matches = matches
        self.position = position
        self.group_by = group_by
        self.source = source

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'VariableMetadata':
        """Initialize a VariableMetadata object from a json dictionary."""
        args = {}
        if (type := _dict.get('type')) is not None:
            args['type'] = type
        if (aliases := _dict.get('aliases')) is not None:
            args['aliases'] = aliases
        if (description := _dict.get('description')) is not None:
            args['description'] = description
        if (cloud_data_type := _dict.get('cloud_data_type')) is not None:
            args['cloud_data_type'] = cloud_data_type
        if (default_value := _dict.get('default_value')) is not None:
            args['default_value'] = default_value
        if (link_status := _dict.get('link_status')) is not None:
            args['link_status'] = link_status
        if (secure := _dict.get('secure')) is not None:
            args['secure'] = secure
        if (immutable := _dict.get('immutable')) is not None:
            args['immutable'] = immutable
        if (hidden := _dict.get('hidden')) is not None:
            args['hidden'] = hidden
        if (required := _dict.get('required')) is not None:
            args['required'] = required
        if (options := _dict.get('options')) is not None:
            args['options'] = options
        if (min_value := _dict.get('min_value')) is not None:
            args['min_value'] = min_value
        if (max_value := _dict.get('max_value')) is not None:
            args['max_value'] = max_value
        if (min_length := _dict.get('min_length')) is not None:
            args['min_length'] = min_length
        if (max_length := _dict.get('max_length')) is not None:
            args['max_length'] = max_length
        if (matches := _dict.get('matches')) is not None:
            args['matches'] = matches
        if (position := _dict.get('position')) is not None:
            args['position'] = position
        if (group_by := _dict.get('group_by')) is not None:
            args['group_by'] = group_by
        if (source := _dict.get('source')) is not None:
            args['source'] = source
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a VariableMetadata object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'type') and self.type is not None:
            _dict['type'] = self.type
        if hasattr(self, 'aliases') and self.aliases is not None:
            _dict['aliases'] = self.aliases
        if hasattr(self, 'description') and self.description is not None:
            _dict['description'] = self.description
        if hasattr(self, 'cloud_data_type') and self.cloud_data_type is not None:
            _dict['cloud_data_type'] = self.cloud_data_type
        if hasattr(self, 'default_value') and self.default_value is not None:
            _dict['default_value'] = self.default_value
        if hasattr(self, 'link_status') and self.link_status is not None:
            _dict['link_status'] = self.link_status
        if hasattr(self, 'secure') and self.secure is not None:
            _dict['secure'] = self.secure
        if hasattr(self, 'immutable') and self.immutable is not None:
            _dict['immutable'] = self.immutable
        if hasattr(self, 'hidden') and self.hidden is not None:
            _dict['hidden'] = self.hidden
        if hasattr(self, 'required') and self.required is not None:
            _dict['required'] = self.required
        if hasattr(self, 'options') and self.options is not None:
            _dict['options'] = self.options
        if hasattr(self, 'min_value') and self.min_value is not None:
            _dict['min_value'] = self.min_value
        if hasattr(self, 'max_value') and self.max_value is not None:
            _dict['max_value'] = self.max_value
        if hasattr(self, 'min_length') and self.min_length is not None:
            _dict['min_length'] = self.min_length
        if hasattr(self, 'max_length') and self.max_length is not None:
            _dict['max_length'] = self.max_length
        if hasattr(self, 'matches') and self.matches is not None:
            _dict['matches'] = self.matches
        if hasattr(self, 'position') and self.position is not None:
            _dict['position'] = self.position
        if hasattr(self, 'group_by') and self.group_by is not None:
            _dict['group_by'] = self.group_by
        if hasattr(self, 'source') and self.source is not None:
            _dict['source'] = self.source
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this VariableMetadata object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'VariableMetadata') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'VariableMetadata') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

    class TypeEnum(str, Enum):
        """
        Type of the variable.
        """

        BOOLEAN = 'boolean'
        STRING = 'string'
        INTEGER = 'integer'
        DATE = 'date'
        ARRAY = 'array'
        LIST = 'list'
        MAP = 'map'
        COMPLEX = 'complex'
        LINK = 'link'

    class LinkStatusEnum(str, Enum):
        """
        The status of the link.
        """

        NORMAL = 'normal'
        BROKEN = 'broken'


class VersionResponse:
    """
    Successful response when you retrieve detailed information about the IBM Cloud
    Schematics API.

    :param str builddate: (optional) The date when the API version was built.
    :param str buildno: (optional) The build number that the API is based on.
    :param str commitsha: (optional) The SHA value for the Git commit that
          represents the latest version of the API.
    :param str helm_provider_version: (optional) The Terraform Helm provider version
          that is used when you install Helm charts with Schematics.
    :param str helm_version: (optional) The Helm version that is used when you
          install Helm charts with Schematics.
    :param dict supported_template_types: (optional) Supported template types.
    :param str terraform_provider_version: (optional) The version of the IBM Cloud
          Terraform provider plug-in that is used when you apply Terraform templates with
          Schematics.
    :param str terraform_version: (optional) The Terraform version that is used when
          you apply Terraform templates with Schematics.
    """

    def __init__(
        self,
        *,
        builddate: Optional[str] = None,
        buildno: Optional[str] = None,
        commitsha: Optional[str] = None,
        helm_provider_version: Optional[str] = None,
        helm_version: Optional[str] = None,
        supported_template_types: Optional[dict] = None,
        terraform_provider_version: Optional[str] = None,
        terraform_version: Optional[str] = None,
    ) -> None:
        """
        Initialize a VersionResponse object.

        :param str builddate: (optional) The date when the API version was built.
        :param str buildno: (optional) The build number that the API is based on.
        :param str commitsha: (optional) The SHA value for the Git commit that
               represents the latest version of the API.
        :param str helm_provider_version: (optional) The Terraform Helm provider
               version that is used when you install Helm charts with Schematics.
        :param str helm_version: (optional) The Helm version that is used when you
               install Helm charts with Schematics.
        :param dict supported_template_types: (optional) Supported template types.
        :param str terraform_provider_version: (optional) The version of the IBM
               Cloud Terraform provider plug-in that is used when you apply Terraform
               templates with Schematics.
        :param str terraform_version: (optional) The Terraform version that is used
               when you apply Terraform templates with Schematics.
        """
        self.builddate = builddate
        self.buildno = buildno
        self.commitsha = commitsha
        self.helm_provider_version = helm_provider_version
        self.helm_version = helm_version
        self.supported_template_types = supported_template_types
        self.terraform_provider_version = terraform_provider_version
        self.terraform_version = terraform_version

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'VersionResponse':
        """Initialize a VersionResponse object from a json dictionary."""
        args = {}
        if (builddate := _dict.get('builddate')) is not None:
            args['builddate'] = builddate
        if (buildno := _dict.get('buildno')) is not None:
            args['buildno'] = buildno
        if (commitsha := _dict.get('commitsha')) is not None:
            args['commitsha'] = commitsha
        if (helm_provider_version := _dict.get('helm_provider_version')) is not None:
            args['helm_provider_version'] = helm_provider_version
        if (helm_version := _dict.get('helm_version')) is not None:
            args['helm_version'] = helm_version
        if (supported_template_types := _dict.get('supported_template_types')) is not None:
            args['supported_template_types'] = supported_template_types
        if (terraform_provider_version := _dict.get('terraform_provider_version')) is not None:
            args['terraform_provider_version'] = terraform_provider_version
        if (terraform_version := _dict.get('terraform_version')) is not None:
            args['terraform_version'] = terraform_version
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a VersionResponse object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'builddate') and self.builddate is not None:
            _dict['builddate'] = self.builddate
        if hasattr(self, 'buildno') and self.buildno is not None:
            _dict['buildno'] = self.buildno
        if hasattr(self, 'commitsha') and self.commitsha is not None:
            _dict['commitsha'] = self.commitsha
        if hasattr(self, 'helm_provider_version') and self.helm_provider_version is not None:
            _dict['helm_provider_version'] = self.helm_provider_version
        if hasattr(self, 'helm_version') and self.helm_version is not None:
            _dict['helm_version'] = self.helm_version
        if hasattr(self, 'supported_template_types') and self.supported_template_types is not None:
            _dict['supported_template_types'] = self.supported_template_types
        if hasattr(self, 'terraform_provider_version') and self.terraform_provider_version is not None:
            _dict['terraform_provider_version'] = self.terraform_provider_version
        if hasattr(self, 'terraform_version') and self.terraform_version is not None:
            _dict['terraform_version'] = self.terraform_version
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this VersionResponse object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'VersionResponse') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'VersionResponse') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other


class WorkspaceActivities:
    """
    List of workspace jobs.

    :param List[WorkspaceActivity] actions: (optional) List of workspace jobs.
    :param str workspace_id: (optional) The ID of the workspace.
    :param str workspace_name: (optional) The name of the workspace.
    """

    def __init__(
        self,
        *,
        actions: Optional[List['WorkspaceActivity']] = None,
        workspace_id: Optional[str] = None,
        workspace_name: Optional[str] = None,
    ) -> None:
        """
        Initialize a WorkspaceActivities object.

        :param List[WorkspaceActivity] actions: (optional) List of workspace jobs.
        :param str workspace_id: (optional) The ID of the workspace.
        :param str workspace_name: (optional) The name of the workspace.
        """
        self.actions = actions
        self.workspace_id = workspace_id
        self.workspace_name = workspace_name

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'WorkspaceActivities':
        """Initialize a WorkspaceActivities object from a json dictionary."""
        args = {}
        if (actions := _dict.get('actions')) is not None:
            args['actions'] = [WorkspaceActivity.from_dict(v) for v in actions]
        if (workspace_id := _dict.get('workspace_id')) is not None:
            args['workspace_id'] = workspace_id
        if (workspace_name := _dict.get('workspace_name')) is not None:
            args['workspace_name'] = workspace_name
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a WorkspaceActivities object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'actions') and self.actions is not None:
            actions_list = []
            for v in self.actions:
                if isinstance(v, dict):
                    actions_list.append(v)
                else:
                    actions_list.append(v.to_dict())
            _dict['actions'] = actions_list
        if hasattr(self, 'workspace_id') and self.workspace_id is not None:
            _dict['workspace_id'] = self.workspace_id
        if hasattr(self, 'workspace_name') and self.workspace_name is not None:
            _dict['workspace_name'] = self.workspace_name
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this WorkspaceActivities object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'WorkspaceActivities') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'WorkspaceActivities') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other


class WorkspaceActivity:
    """
    Information about the workspace jobs.

    :param str action_id: (optional) The ID of the activity or job.  You can use the
          ID to retrieve the logs for that job by using the `GET
          /v1/workspaces/{id}/actions/{action_id}/logs` API.
    :param List[str] message: (optional) Information about the success or failure of
          your job,  including a success or error code and the timestamp when the job
          succeeded or failed.
    :param str name: (optional) The type of actovoty or job that ran against your
          workspace.
           * **APPLY**: The apply job was created when you used the `PUT
          /v1/workspaces/{id}/apply` API to apply a Terraform template in IBM Cloud.
           * **DESTROY**: The destroy job was created when you used the `DELETE
          /v1/workspaces/{id}/destroy` API to remove all resources that are associated
          with your workspace.
           * **PLAN**: The plan job was created when you used the `POST
          /v1/workspaces/{id}/plan` API to create a Terraform execution plan.
    :param datetime performed_at: (optional) The timestamp when the job was
          initiated.
    :param str performed_by: (optional) The user ID who initiated the job.
    :param str status: (optional) The status of your activity or job. To retrieve
          the URL to your job logs, use the GET
          /v1/workspaces/{id}/actions/{action_id}/logs API.
          * **COMPLETED**: The job completed successfully.
          * **CREATED**: The job was created, but the provisioning, modification, or
          removal of IBM Cloud resources has not started yet.
          * **FAILED**: An error occurred during the plan, apply, or destroy job. Use the
          job ID to retrieve the URL to the log files for your job.
          * **IN PROGRESS**: The job is in progress. You can use the log_url to access the
          logs.
    :param List[WorkspaceActivityTemplate] templates: (optional) List of template
          activities.
    """

    def __init__(
        self,
        *,
        action_id: Optional[str] = None,
        message: Optional[List[str]] = None,
        name: Optional[str] = None,
        performed_at: Optional[datetime] = None,
        performed_by: Optional[str] = None,
        status: Optional[str] = None,
        templates: Optional[List['WorkspaceActivityTemplate']] = None,
    ) -> None:
        """
        Initialize a WorkspaceActivity object.

        :param str action_id: (optional) The ID of the activity or job.  You can
               use the ID to retrieve the logs for that job by using the `GET
               /v1/workspaces/{id}/actions/{action_id}/logs` API.
        :param List[str] message: (optional) Information about the success or
               failure of your job,  including a success or error code and the timestamp
               when the job succeeded or failed.
        :param str name: (optional) The type of actovoty or job that ran against
               your workspace.
                * **APPLY**: The apply job was created when you used the `PUT
               /v1/workspaces/{id}/apply` API to apply a Terraform template in IBM Cloud.
                * **DESTROY**: The destroy job was created when you used the `DELETE
               /v1/workspaces/{id}/destroy` API to remove all resources that are
               associated with your workspace.
                * **PLAN**: The plan job was created when you used the `POST
               /v1/workspaces/{id}/plan` API to create a Terraform execution plan.
        :param datetime performed_at: (optional) The timestamp when the job was
               initiated.
        :param str performed_by: (optional) The user ID who initiated the job.
        :param str status: (optional) The status of your activity or job. To
               retrieve the URL to your job logs, use the GET
               /v1/workspaces/{id}/actions/{action_id}/logs API.
               * **COMPLETED**: The job completed successfully.
               * **CREATED**: The job was created, but the provisioning, modification, or
               removal of IBM Cloud resources has not started yet.
               * **FAILED**: An error occurred during the plan, apply, or destroy job. Use
               the job ID to retrieve the URL to the log files for your job.
               * **IN PROGRESS**: The job is in progress. You can use the log_url to
               access the logs.
        :param List[WorkspaceActivityTemplate] templates: (optional) List of
               template activities.
        """
        self.action_id = action_id
        self.message = message
        self.name = name
        self.performed_at = performed_at
        self.performed_by = performed_by
        self.status = status
        self.templates = templates

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'WorkspaceActivity':
        """Initialize a WorkspaceActivity object from a json dictionary."""
        args = {}
        if (action_id := _dict.get('action_id')) is not None:
            args['action_id'] = action_id
        if (message := _dict.get('message')) is not None:
            args['message'] = message
        if (name := _dict.get('name')) is not None:
            args['name'] = name
        if (performed_at := _dict.get('performed_at')) is not None:
            args['performed_at'] = string_to_datetime(performed_at)
        if (performed_by := _dict.get('performed_by')) is not None:
            args['performed_by'] = performed_by
        if (status := _dict.get('status')) is not None:
            args['status'] = status
        if (templates := _dict.get('templates')) is not None:
            args['templates'] = [WorkspaceActivityTemplate.from_dict(v) for v in templates]
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a WorkspaceActivity object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'action_id') and self.action_id is not None:
            _dict['action_id'] = self.action_id
        if hasattr(self, 'message') and self.message is not None:
            _dict['message'] = self.message
        if hasattr(self, 'name') and self.name is not None:
            _dict['name'] = self.name
        if hasattr(self, 'performed_at') and self.performed_at is not None:
            _dict['performed_at'] = datetime_to_string(self.performed_at)
        if hasattr(self, 'performed_by') and self.performed_by is not None:
            _dict['performed_by'] = self.performed_by
        if hasattr(self, 'status') and self.status is not None:
            _dict['status'] = self.status
        if hasattr(self, 'templates') and self.templates is not None:
            templates_list = []
            for v in self.templates:
                if isinstance(v, dict):
                    templates_list.append(v)
                else:
                    templates_list.append(v.to_dict())
            _dict['templates'] = templates_list
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this WorkspaceActivity object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'WorkspaceActivity') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'WorkspaceActivity') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other


class WorkspaceActivityApplyResult:
    """
    Response after successfully initiating a request to `apply` the Terraform template in
    IBM Cloud.

    :param str activityid: (optional) The ID of the activity or job that was created
          when you initiated a request to `apply` a Terraform template.  You can use the
          ID to retrieve log file by using the `GET
          /v1/workspaces/{id}/actions/{action_id}/logs` API.
    """

    def __init__(
        self,
        *,
        activityid: Optional[str] = None,
    ) -> None:
        """
        Initialize a WorkspaceActivityApplyResult object.

        :param str activityid: (optional) The ID of the activity or job that was
               created when you initiated a request to `apply` a Terraform template.  You
               can use the ID to retrieve log file by using the `GET
               /v1/workspaces/{id}/actions/{action_id}/logs` API.
        """
        self.activityid = activityid

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'WorkspaceActivityApplyResult':
        """Initialize a WorkspaceActivityApplyResult object from a json dictionary."""
        args = {}
        if (activityid := _dict.get('activityid')) is not None:
            args['activityid'] = activityid
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a WorkspaceActivityApplyResult object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'activityid') and self.activityid is not None:
            _dict['activityid'] = self.activityid
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this WorkspaceActivityApplyResult object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'WorkspaceActivityApplyResult') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'WorkspaceActivityApplyResult') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other


class WorkspaceActivityCommandResult:
    """
    Response after successfully initiating a request to run a workspace command on the
    stack of resources provisioned using Terraform.

    :param str activityid: (optional) The ID of the job that was created when you
          initiated a request to `apply` a Terraform template.  You can use the ID to
          retrieve log file by using the `GET
          /v1/workspaces/{id}/actions/{action_id}/logs` API.
    """

    def __init__(
        self,
        *,
        activityid: Optional[str] = None,
    ) -> None:
        """
        Initialize a WorkspaceActivityCommandResult object.

        :param str activityid: (optional) The ID of the job that was created when
               you initiated a request to `apply` a Terraform template.  You can use the
               ID to retrieve log file by using the `GET
               /v1/workspaces/{id}/actions/{action_id}/logs` API.
        """
        self.activityid = activityid

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'WorkspaceActivityCommandResult':
        """Initialize a WorkspaceActivityCommandResult object from a json dictionary."""
        args = {}
        if (activityid := _dict.get('activityid')) is not None:
            args['activityid'] = activityid
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a WorkspaceActivityCommandResult object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'activityid') and self.activityid is not None:
            _dict['activityid'] = self.activityid
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this WorkspaceActivityCommandResult object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'WorkspaceActivityCommandResult') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'WorkspaceActivityCommandResult') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other


class WorkspaceActivityDestroyResult:
    """
    Response after successfully initiating a request to `destroy` the stack of resources
    provisioned using Terraform.

    :param str activityid: (optional) The ID of the activity or job that was created
          when you initiated a request to `destroy` a Terraform template.  You can use the
          ID to retrieve log file by using the `GET
          /v1/workspaces/{id}/actions/{action_id}/logs` API.
    """

    def __init__(
        self,
        *,
        activityid: Optional[str] = None,
    ) -> None:
        """
        Initialize a WorkspaceActivityDestroyResult object.

        :param str activityid: (optional) The ID of the activity or job that was
               created when you initiated a request to `destroy` a Terraform template.
               You can use the ID to retrieve log file by using the `GET
               /v1/workspaces/{id}/actions/{action_id}/logs` API.
        """
        self.activityid = activityid

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'WorkspaceActivityDestroyResult':
        """Initialize a WorkspaceActivityDestroyResult object from a json dictionary."""
        args = {}
        if (activityid := _dict.get('activityid')) is not None:
            args['activityid'] = activityid
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a WorkspaceActivityDestroyResult object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'activityid') and self.activityid is not None:
            _dict['activityid'] = self.activityid
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this WorkspaceActivityDestroyResult object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'WorkspaceActivityDestroyResult') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'WorkspaceActivityDestroyResult') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other


class WorkspaceActivityLogs:
    """
    Workspace job logs for all the templates in the workspace.

    :param str action_id: (optional) The ID of the activity or job that ran against
          your workspace.
    :param str name: (optional) The type of actovoty or job that ran against your
          workspace.
           * **APPLY**: The apply job was created when you used the `PUT
          /v1/workspaces/{id}/apply` API to apply a Terraform template in IBM Cloud.
           * **DESTROY**: The destroy job was created when you used the `DELETE
          /v1/workspaces/{id}/destroy` API to remove all resources that are associated
          with your workspace.
           * **PLAN**: The plan job was created when you used the `POST
          /v1/workspaces/{id}/plan` API to create a Terraform execution plan.
    :param List[WorkspaceActivityTemplateLogs] templates: (optional) List of
          templates in the workspace.
    """

    def __init__(
        self,
        *,
        action_id: Optional[str] = None,
        name: Optional[str] = None,
        templates: Optional[List['WorkspaceActivityTemplateLogs']] = None,
    ) -> None:
        """
        Initialize a WorkspaceActivityLogs object.

        :param str action_id: (optional) The ID of the activity or job that ran
               against your workspace.
        :param str name: (optional) The type of actovoty or job that ran against
               your workspace.
                * **APPLY**: The apply job was created when you used the `PUT
               /v1/workspaces/{id}/apply` API to apply a Terraform template in IBM Cloud.
                * **DESTROY**: The destroy job was created when you used the `DELETE
               /v1/workspaces/{id}/destroy` API to remove all resources that are
               associated with your workspace.
                * **PLAN**: The plan job was created when you used the `POST
               /v1/workspaces/{id}/plan` API to create a Terraform execution plan.
        :param List[WorkspaceActivityTemplateLogs] templates: (optional) List of
               templates in the workspace.
        """
        self.action_id = action_id
        self.name = name
        self.templates = templates

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'WorkspaceActivityLogs':
        """Initialize a WorkspaceActivityLogs object from a json dictionary."""
        args = {}
        if (action_id := _dict.get('action_id')) is not None:
            args['action_id'] = action_id
        if (name := _dict.get('name')) is not None:
            args['name'] = name
        if (templates := _dict.get('templates')) is not None:
            args['templates'] = [WorkspaceActivityTemplateLogs.from_dict(v) for v in templates]
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a WorkspaceActivityLogs object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'action_id') and self.action_id is not None:
            _dict['action_id'] = self.action_id
        if hasattr(self, 'name') and self.name is not None:
            _dict['name'] = self.name
        if hasattr(self, 'templates') and self.templates is not None:
            templates_list = []
            for v in self.templates:
                if isinstance(v, dict):
                    templates_list.append(v)
                else:
                    templates_list.append(v.to_dict())
            _dict['templates'] = templates_list
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this WorkspaceActivityLogs object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'WorkspaceActivityLogs') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'WorkspaceActivityLogs') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other


class WorkspaceActivityOptionsTemplate:
    """
    Workspace job options template.

    :param List[str] target: (optional) A list of Terraform resources to target.
    :param List[str] tf_vars: (optional) Terraform variables for the workspace job
          options.
    """

    def __init__(
        self,
        *,
        target: Optional[List[str]] = None,
        tf_vars: Optional[List[str]] = None,
    ) -> None:
        """
        Initialize a WorkspaceActivityOptionsTemplate object.

        :param List[str] target: (optional) A list of Terraform resources to
               target.
        :param List[str] tf_vars: (optional) Terraform variables for the workspace
               job options.
        """
        self.target = target
        self.tf_vars = tf_vars

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'WorkspaceActivityOptionsTemplate':
        """Initialize a WorkspaceActivityOptionsTemplate object from a json dictionary."""
        args = {}
        if (target := _dict.get('target')) is not None:
            args['target'] = target
        if (tf_vars := _dict.get('tf_vars')) is not None:
            args['tf_vars'] = tf_vars
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a WorkspaceActivityOptionsTemplate object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'target') and self.target is not None:
            _dict['target'] = self.target
        if hasattr(self, 'tf_vars') and self.tf_vars is not None:
            _dict['tf_vars'] = self.tf_vars
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this WorkspaceActivityOptionsTemplate object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'WorkspaceActivityOptionsTemplate') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'WorkspaceActivityOptionsTemplate') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other


class WorkspaceActivityPlanResult:
    """
    Response after successfully initiating a request to `plan` the Terraform template in
    IBM Cloud.

    :param str activityid: (optional) The ID of the activity or job that was created
          when you initiated a request to `plan` a Terraform template.  You can use the ID
          to retrieve log file by using the `GET
          /v1/workspaces/{id}/actions/{action_id}/logs` API.
    """

    def __init__(
        self,
        *,
        activityid: Optional[str] = None,
    ) -> None:
        """
        Initialize a WorkspaceActivityPlanResult object.

        :param str activityid: (optional) The ID of the activity or job that was
               created when you initiated a request to `plan` a Terraform template.  You
               can use the ID to retrieve log file by using the `GET
               /v1/workspaces/{id}/actions/{action_id}/logs` API.
        """
        self.activityid = activityid

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'WorkspaceActivityPlanResult':
        """Initialize a WorkspaceActivityPlanResult object from a json dictionary."""
        args = {}
        if (activityid := _dict.get('activityid')) is not None:
            args['activityid'] = activityid
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a WorkspaceActivityPlanResult object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'activityid') and self.activityid is not None:
            _dict['activityid'] = self.activityid
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this WorkspaceActivityPlanResult object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'WorkspaceActivityPlanResult') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'WorkspaceActivityPlanResult') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other


class WorkspaceActivityRefreshResult:
    """
    Response after successfully initiating a request to `refresh` the Terraform template
    in IBM Cloud.

    :param str activityid: (optional) The ID of the activity or job that was created
          for your workspace `refresh` activity or job.  You can use the ID to retrieve
          the log file by using the `GET /v1/workspaces/{id}/actions/{action_id}/logs`
          API.
    """

    def __init__(
        self,
        *,
        activityid: Optional[str] = None,
    ) -> None:
        """
        Initialize a WorkspaceActivityRefreshResult object.

        :param str activityid: (optional) The ID of the activity or job that was
               created for your workspace `refresh` activity or job.  You can use the ID
               to retrieve the log file by using the `GET
               /v1/workspaces/{id}/actions/{action_id}/logs` API.
        """
        self.activityid = activityid

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'WorkspaceActivityRefreshResult':
        """Initialize a WorkspaceActivityRefreshResult object from a json dictionary."""
        args = {}
        if (activityid := _dict.get('activityid')) is not None:
            args['activityid'] = activityid
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a WorkspaceActivityRefreshResult object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'activityid') and self.activityid is not None:
            _dict['activityid'] = self.activityid
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this WorkspaceActivityRefreshResult object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'WorkspaceActivityRefreshResult') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'WorkspaceActivityRefreshResult') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other


class WorkspaceActivityTemplate:
    """
    Information about the template in the workspace.

    :param datetime end_time: (optional) End time for the job.
    :param LogSummary log_summary: (optional) Summary information extracted from the
          job logs.
    :param str log_url: (optional) Log URL.
    :param str message: (optional) Message.
    :param datetime start_time: (optional) Job start time.
    :param str status: (optional) The status of your activity or job. To retrieve
          the URL to your job logs, use the GET
          /v1/workspaces/{id}/actions/{action_id}/logs API.
          * **COMPLETED**: The job completed successfully.
          * **CREATED**: The job was created, but the provisioning, modification, or
          removal of IBM Cloud resources has not started yet.
          * **FAILED**: An error occurred during the plan, apply, or destroy job. Use the
          job ID to retrieve the URL to the log files for your job.
          * **IN PROGRESS**: The job is in progress. You can use the log_url to access the
          logs.
    :param str template_id: (optional) The ID that was assigned to your Terraform
          template or IBM Cloud catalog software template.
    :param str template_type: (optional) The type of template.
    """

    def __init__(
        self,
        *,
        end_time: Optional[datetime] = None,
        log_summary: Optional['LogSummary'] = None,
        log_url: Optional[str] = None,
        message: Optional[str] = None,
        start_time: Optional[datetime] = None,
        status: Optional[str] = None,
        template_id: Optional[str] = None,
        template_type: Optional[str] = None,
    ) -> None:
        """
        Initialize a WorkspaceActivityTemplate object.

        :param datetime end_time: (optional) End time for the job.
        :param LogSummary log_summary: (optional) Summary information extracted
               from the job logs.
        :param str log_url: (optional) Log URL.
        :param str message: (optional) Message.
        :param datetime start_time: (optional) Job start time.
        :param str status: (optional) The status of your activity or job. To
               retrieve the URL to your job logs, use the GET
               /v1/workspaces/{id}/actions/{action_id}/logs API.
               * **COMPLETED**: The job completed successfully.
               * **CREATED**: The job was created, but the provisioning, modification, or
               removal of IBM Cloud resources has not started yet.
               * **FAILED**: An error occurred during the plan, apply, or destroy job. Use
               the job ID to retrieve the URL to the log files for your job.
               * **IN PROGRESS**: The job is in progress. You can use the log_url to
               access the logs.
        :param str template_id: (optional) The ID that was assigned to your
               Terraform template or IBM Cloud catalog software template.
        :param str template_type: (optional) The type of template.
        """
        self.end_time = end_time
        self.log_summary = log_summary
        self.log_url = log_url
        self.message = message
        self.start_time = start_time
        self.status = status
        self.template_id = template_id
        self.template_type = template_type

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'WorkspaceActivityTemplate':
        """Initialize a WorkspaceActivityTemplate object from a json dictionary."""
        args = {}
        if (end_time := _dict.get('end_time')) is not None:
            args['end_time'] = string_to_datetime(end_time)
        if (log_summary := _dict.get('log_summary')) is not None:
            args['log_summary'] = LogSummary.from_dict(log_summary)
        if (log_url := _dict.get('log_url')) is not None:
            args['log_url'] = log_url
        if (message := _dict.get('message')) is not None:
            args['message'] = message
        if (start_time := _dict.get('start_time')) is not None:
            args['start_time'] = string_to_datetime(start_time)
        if (status := _dict.get('status')) is not None:
            args['status'] = status
        if (template_id := _dict.get('template_id')) is not None:
            args['template_id'] = template_id
        if (template_type := _dict.get('template_type')) is not None:
            args['template_type'] = template_type
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a WorkspaceActivityTemplate object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'end_time') and self.end_time is not None:
            _dict['end_time'] = datetime_to_string(self.end_time)
        if hasattr(self, 'log_summary') and self.log_summary is not None:
            if isinstance(self.log_summary, dict):
                _dict['log_summary'] = self.log_summary
            else:
                _dict['log_summary'] = self.log_summary.to_dict()
        if hasattr(self, 'log_url') and self.log_url is not None:
            _dict['log_url'] = self.log_url
        if hasattr(self, 'message') and self.message is not None:
            _dict['message'] = self.message
        if hasattr(self, 'start_time') and self.start_time is not None:
            _dict['start_time'] = datetime_to_string(self.start_time)
        if hasattr(self, 'status') and self.status is not None:
            _dict['status'] = self.status
        if hasattr(self, 'template_id') and self.template_id is not None:
            _dict['template_id'] = self.template_id
        if hasattr(self, 'template_type') and self.template_type is not None:
            _dict['template_type'] = self.template_type
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this WorkspaceActivityTemplate object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'WorkspaceActivityTemplate') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'WorkspaceActivityTemplate') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other


class WorkspaceActivityTemplateLogs:
    """
    Information about the log URL for a job that ran for a template against your
    workspace.

    :param str log_url: (optional) The URL to access the logs that were created
          during the plan, apply, or destroy job.
    :param str template_id: (optional) The ID that was assigned to your Terraform
          template or IBM Cloud catalog software template.
    :param str template_type: (optional) The type of template.
    """

    def __init__(
        self,
        *,
        log_url: Optional[str] = None,
        template_id: Optional[str] = None,
        template_type: Optional[str] = None,
    ) -> None:
        """
        Initialize a WorkspaceActivityTemplateLogs object.

        :param str log_url: (optional) The URL to access the logs that were created
               during the plan, apply, or destroy job.
        :param str template_id: (optional) The ID that was assigned to your
               Terraform template or IBM Cloud catalog software template.
        :param str template_type: (optional) The type of template.
        """
        self.log_url = log_url
        self.template_id = template_id
        self.template_type = template_type

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'WorkspaceActivityTemplateLogs':
        """Initialize a WorkspaceActivityTemplateLogs object from a json dictionary."""
        args = {}
        if (log_url := _dict.get('log_url')) is not None:
            args['log_url'] = log_url
        if (template_id := _dict.get('template_id')) is not None:
            args['template_id'] = template_id
        if (template_type := _dict.get('template_type')) is not None:
            args['template_type'] = template_type
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a WorkspaceActivityTemplateLogs object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'log_url') and self.log_url is not None:
            _dict['log_url'] = self.log_url
        if hasattr(self, 'template_id') and self.template_id is not None:
            _dict['template_id'] = self.template_id
        if hasattr(self, 'template_type') and self.template_type is not None:
            _dict['template_type'] = self.template_type
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this WorkspaceActivityTemplateLogs object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'WorkspaceActivityTemplateLogs') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'WorkspaceActivityTemplateLogs') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other


class WorkspaceBulkDeleteResponse:
    """
    The response after successfully initiating the bulk job to delete multiple workspaces.

    :param str job: (optional) The workspace deletion job name.
    :param str job_id: (optional) The workspace deletion job id.
    """

    def __init__(
        self,
        *,
        job: Optional[str] = None,
        job_id: Optional[str] = None,
    ) -> None:
        """
        Initialize a WorkspaceBulkDeleteResponse object.

        :param str job: (optional) The workspace deletion job name.
        :param str job_id: (optional) The workspace deletion job id.
        """
        self.job = job
        self.job_id = job_id

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'WorkspaceBulkDeleteResponse':
        """Initialize a WorkspaceBulkDeleteResponse object from a json dictionary."""
        args = {}
        if (job := _dict.get('job')) is not None:
            args['job'] = job
        if (job_id := _dict.get('job_id')) is not None:
            args['job_id'] = job_id
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a WorkspaceBulkDeleteResponse object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'job') and self.job is not None:
            _dict['job'] = self.job
        if hasattr(self, 'job_id') and self.job_id is not None:
            _dict['job_id'] = self.job_id
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this WorkspaceBulkDeleteResponse object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'WorkspaceBulkDeleteResponse') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'WorkspaceBulkDeleteResponse') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other


class WorkspaceJobResponse:
    """
    The response from the workspace bulk job status.

    :param WorkspaceJobStatusType job_status: (optional) Status of the workspace
          bulk job.
    """

    def __init__(
        self,
        *,
        job_status: Optional['WorkspaceJobStatusType'] = None,
    ) -> None:
        """
        Initialize a WorkspaceJobResponse object.

        :param WorkspaceJobStatusType job_status: (optional) Status of the
               workspace bulk job.
        """
        self.job_status = job_status

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'WorkspaceJobResponse':
        """Initialize a WorkspaceJobResponse object from a json dictionary."""
        args = {}
        if (job_status := _dict.get('job_status')) is not None:
            args['job_status'] = WorkspaceJobStatusType.from_dict(job_status)
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a WorkspaceJobResponse object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'job_status') and self.job_status is not None:
            if isinstance(self.job_status, dict):
                _dict['job_status'] = self.job_status
            else:
                _dict['job_status'] = self.job_status.to_dict()
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this WorkspaceJobResponse object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'WorkspaceJobResponse') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'WorkspaceJobResponse') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other


class WorkspaceJobStatusType:
    """
    Status of the workspace bulk job.

    :param List[str] failed: (optional) List of failed workspace jobs.
    :param List[str] in_progress: (optional) List of in_progress workspace jobs.
    :param List[str] success: (optional) List of successful workspace jobs.
    :param datetime last_updated_on: (optional) Workspace job status updated at.
    """

    def __init__(
        self,
        *,
        failed: Optional[List[str]] = None,
        in_progress: Optional[List[str]] = None,
        success: Optional[List[str]] = None,
        last_updated_on: Optional[datetime] = None,
    ) -> None:
        """
        Initialize a WorkspaceJobStatusType object.

        :param List[str] failed: (optional) List of failed workspace jobs.
        :param List[str] in_progress: (optional) List of in_progress workspace
               jobs.
        :param List[str] success: (optional) List of successful workspace jobs.
        :param datetime last_updated_on: (optional) Workspace job status updated
               at.
        """
        self.failed = failed
        self.in_progress = in_progress
        self.success = success
        self.last_updated_on = last_updated_on

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'WorkspaceJobStatusType':
        """Initialize a WorkspaceJobStatusType object from a json dictionary."""
        args = {}
        if (failed := _dict.get('failed')) is not None:
            args['failed'] = failed
        if (in_progress := _dict.get('in_progress')) is not None:
            args['in_progress'] = in_progress
        if (success := _dict.get('success')) is not None:
            args['success'] = success
        if (last_updated_on := _dict.get('last_updated_on')) is not None:
            args['last_updated_on'] = string_to_datetime(last_updated_on)
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a WorkspaceJobStatusType object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'failed') and self.failed is not None:
            _dict['failed'] = self.failed
        if hasattr(self, 'in_progress') and self.in_progress is not None:
            _dict['in_progress'] = self.in_progress
        if hasattr(self, 'success') and self.success is not None:
            _dict['success'] = self.success
        if hasattr(self, 'last_updated_on') and self.last_updated_on is not None:
            _dict['last_updated_on'] = datetime_to_string(self.last_updated_on)
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this WorkspaceJobStatusType object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'WorkspaceJobStatusType') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'WorkspaceJobStatusType') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other


class WorkspaceResponse:
    """
    Workspace details.

    :param List[str] applied_shareddata_ids: (optional) Deprecated: List of applied
          shared dataset ID.
    :param CatalogRef catalog_ref: (optional) Information about the software
          template that you chose from the IBM Cloud catalog. This information is returned
          for IBM Cloud catalog offerings only.
    :param datetime created_at: (optional) The timestamp when the workspace was
          created.
    :param str created_by: (optional) The user ID that created the workspace.
    :param str crn: (optional) The workspace CRN.
    :param Dependencies dependencies: (optional) Workspace dependencies.
    :param str description: (optional) The description of the workspace.
    :param str id: (optional) The unique identifier of the workspace.
    :param datetime last_health_check_at: (optional) The timestamp when the last
          health check was performed by Schematics.
    :param str location: (optional) The IBM Cloud location where your workspace was
          provisioned.
    :param str name: (optional) The name of the workspace.
    :param str resource_group: (optional) The resource group the workspace was
          provisioned in.
    :param List[TemplateRunTimeDataResponse] runtime_data: (optional) Information
          about the provisioning engine, state file, and runtime logs.
    :param SharedTargetDataResponse shared_data: (optional) Information about the
          Target used by the templates originating from IBM Cloud catalog offerings. This
          information is not relevant when you create a workspace from your own Terraform
          template.
    :param str status: (optional) The status of the workspace.
            **Active**: After you successfully ran your infrastructure code by applying
          your Terraform execution plan, the state of your workspace changes to `Active`.
            **Connecting**: Schematics tries to connect to the template in your source
          repo. If successfully connected, the template is downloaded and metadata, such
          as input parameters, is extracted. After the template is downloaded, the state
          of the workspace changes to `Scanning`.
            **Draft**: The workspace is created without a reference to a GitHub or GitLab
          repository.
            **Failed**: If errors occur during the execution of your infrastructure code
          in IBM Cloud Schematics, your workspace status is set to `Failed`.
            **Inactive**: The Terraform template was scanned successfully and the
          workspace creation is complete. You can now start running Schematics plan and
          apply jobs to provision the IBM Cloud resources that you specified in your
          template. If you have an `Active` workspace and decide to remove all your
          resources, your workspace is set to `Inactive` after all your resources are
          removed.
            **In progress**: When you instruct IBM Cloud Schematics to run your
          infrastructure code by applying your Terraform execution plan, the status of our
          workspace changes to `In progress`.
            **Scanning**: The download of the Terraform template is complete and
          vulnerability scanning started. If the scan is successful, the workspace state
          changes to `Inactive`. If errors in your template are found, the state changes
          to `Template Error`.
            **Stopped**: The Schematics plan, apply, or destroy job was cancelled
          manually.
            **Template Error**: The Schematics template contains errors and cannot be
          processed.
    :param List[str] tags: (optional) A list of tags that are associated with the
          workspace.
    :param List[TemplateSourceDataResponse] template_data: (optional) Information
          about the Terraform or IBM Cloud software template that you want to use.
    :param str template_ref: (optional) Workspace template reference.
    :param TemplateRepoResponse template_repo: (optional) Information about the
          Template repository used by the workspace.
    :param List[str] type: (optional) The Terraform version that was used to run
          your Terraform code.
    :param datetime updated_at: (optional) The timestamp when the workspace was last
          updated.
    :param str updated_by: (optional) The user ID that updated the workspace.
    :param str cart_id: (optional) The associate cart order ID.
    :param str project_id: (optional) The associate project ID.
    :param str last_action_name: (optional) Name of the last Action performed on
          workspace.
    :param str last_activity_id: (optional) ID of last Activity performed.
    :param LastJob last_job: (optional) Last job details.
    :param WorkspaceStatusResponse workspace_status: (optional) Response that
          indicate the status of the workspace as either frozen or locked.
    :param WorkspaceStatusMessage workspace_status_msg: (optional) Information about
          the last job that ran against the workspace. -.
    :param AgentInfo agent: (optional) Agent name, Agent id and associated policy ID
          information.
    :param List[VariableData] settings: (optional) Input settings to be applied to
          the workspace, for example, `job_timeout_override`.
    :param str git_token_ref: (optional) secrets manager reference to git token.
    :param EncryptionInfo encryption: (optional) Encryption details about the
          workspace such as scheme (byok/kyok) and key CRN.
    """

    def __init__(
        self,
        *,
        applied_shareddata_ids: Optional[List[str]] = None,
        catalog_ref: Optional['CatalogRef'] = None,
        created_at: Optional[datetime] = None,
        created_by: Optional[str] = None,
        crn: Optional[str] = None,
        dependencies: Optional['Dependencies'] = None,
        description: Optional[str] = None,
        id: Optional[str] = None,
        last_health_check_at: Optional[datetime] = None,
        location: Optional[str] = None,
        name: Optional[str] = None,
        resource_group: Optional[str] = None,
        runtime_data: Optional[List['TemplateRunTimeDataResponse']] = None,
        shared_data: Optional['SharedTargetDataResponse'] = None,
        status: Optional[str] = None,
        tags: Optional[List[str]] = None,
        template_data: Optional[List['TemplateSourceDataResponse']] = None,
        template_ref: Optional[str] = None,
        template_repo: Optional['TemplateRepoResponse'] = None,
        type: Optional[List[str]] = None,
        updated_at: Optional[datetime] = None,
        updated_by: Optional[str] = None,
        cart_id: Optional[str] = None,
        project_id: Optional[str] = None,
        last_action_name: Optional[str] = None,
        last_activity_id: Optional[str] = None,
        last_job: Optional['LastJob'] = None,
        workspace_status: Optional['WorkspaceStatusResponse'] = None,
        workspace_status_msg: Optional['WorkspaceStatusMessage'] = None,
        agent: Optional['AgentInfo'] = None,
        settings: Optional[List['VariableData']] = None,
        git_token_ref: Optional[str] = None,
        encryption: Optional['EncryptionInfo'] = None,
    ) -> None:
        """
        Initialize a WorkspaceResponse object.

        :param List[str] applied_shareddata_ids: (optional) Deprecated: List of
               applied shared dataset ID.
        :param CatalogRef catalog_ref: (optional) Information about the software
               template that you chose from the IBM Cloud catalog. This information is
               returned for IBM Cloud catalog offerings only.
        :param Dependencies dependencies: (optional) Workspace dependencies.
        :param str description: (optional) The description of the workspace.
        :param str location: (optional) The IBM Cloud location where your workspace
               was provisioned.
        :param str name: (optional) The name of the workspace.
        :param str resource_group: (optional) The resource group the workspace was
               provisioned in.
        :param SharedTargetDataResponse shared_data: (optional) Information about
               the Target used by the templates originating from IBM Cloud catalog
               offerings. This information is not relevant when you create a workspace
               from your own Terraform template.
        :param str status: (optional) The status of the workspace.
                 **Active**: After you successfully ran your infrastructure code by
               applying your Terraform execution plan, the state of your workspace changes
               to `Active`.
                 **Connecting**: Schematics tries to connect to the template in your
               source repo. If successfully connected, the template is downloaded and
               metadata, such as input parameters, is extracted. After the template is
               downloaded, the state of the workspace changes to `Scanning`.
                 **Draft**: The workspace is created without a reference to a GitHub or
               GitLab repository.
                 **Failed**: If errors occur during the execution of your infrastructure
               code in IBM Cloud Schematics, your workspace status is set to `Failed`.
                 **Inactive**: The Terraform template was scanned successfully and the
               workspace creation is complete. You can now start running Schematics plan
               and apply jobs to provision the IBM Cloud resources that you specified in
               your template. If you have an `Active` workspace and decide to remove all
               your resources, your workspace is set to `Inactive` after all your
               resources are removed.
                 **In progress**: When you instruct IBM Cloud Schematics to run your
               infrastructure code by applying your Terraform execution plan, the status
               of our workspace changes to `In progress`.
                 **Scanning**: The download of the Terraform template is complete and
               vulnerability scanning started. If the scan is successful, the workspace
               state changes to `Inactive`. If errors in your template are found, the
               state changes to `Template Error`.
                 **Stopped**: The Schematics plan, apply, or destroy job was cancelled
               manually.
                 **Template Error**: The Schematics template contains errors and cannot be
               processed.
        :param List[str] tags: (optional) A list of tags that are associated with
               the workspace.
        :param List[TemplateSourceDataResponse] template_data: (optional)
               Information about the Terraform or IBM Cloud software template that you
               want to use.
        :param str template_ref: (optional) Workspace template reference.
        :param TemplateRepoResponse template_repo: (optional) Information about the
               Template repository used by the workspace.
        :param List[str] type: (optional) The Terraform version that was used to
               run your Terraform code.
        :param str cart_id: (optional) The associate cart order ID.
        :param str project_id: (optional) The associate project ID.
        :param str last_action_name: (optional) Name of the last Action performed
               on workspace.
        :param str last_activity_id: (optional) ID of last Activity performed.
        :param LastJob last_job: (optional) Last job details.
        :param WorkspaceStatusResponse workspace_status: (optional) Response that
               indicate the status of the workspace as either frozen or locked.
        :param WorkspaceStatusMessage workspace_status_msg: (optional) Information
               about the last job that ran against the workspace. -.
        :param AgentInfo agent: (optional) Agent name, Agent id and associated
               policy ID information.
        :param List[VariableData] settings: (optional) Input settings to be applied
               to the workspace, for example, `job_timeout_override`.
        """
        self.applied_shareddata_ids = applied_shareddata_ids
        self.catalog_ref = catalog_ref
        self.created_at = created_at
        self.created_by = created_by
        self.crn = crn
        self.dependencies = dependencies
        self.description = description
        self.id = id
        self.last_health_check_at = last_health_check_at
        self.location = location
        self.name = name
        self.resource_group = resource_group
        self.runtime_data = runtime_data
        self.shared_data = shared_data
        self.status = status
        self.tags = tags
        self.template_data = template_data
        self.template_ref = template_ref
        self.template_repo = template_repo
        self.type = type
        self.updated_at = updated_at
        self.updated_by = updated_by
        self.cart_id = cart_id
        self.project_id = project_id
        self.last_action_name = last_action_name
        self.last_activity_id = last_activity_id
        self.last_job = last_job
        self.workspace_status = workspace_status
        self.workspace_status_msg = workspace_status_msg
        self.agent = agent
        self.settings = settings
        self.git_token_ref = git_token_ref
        self.encryption = encryption

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'WorkspaceResponse':
        """Initialize a WorkspaceResponse object from a json dictionary."""
        args = {}
        if (applied_shareddata_ids := _dict.get('applied_shareddata_ids')) is not None:
            args['applied_shareddata_ids'] = applied_shareddata_ids
        if (catalog_ref := _dict.get('catalog_ref')) is not None:
            args['catalog_ref'] = CatalogRef.from_dict(catalog_ref)
        if (created_at := _dict.get('created_at')) is not None:
            args['created_at'] = string_to_datetime(created_at)
        if (created_by := _dict.get('created_by')) is not None:
            args['created_by'] = created_by
        if (crn := _dict.get('crn')) is not None:
            args['crn'] = crn
        if (dependencies := _dict.get('dependencies')) is not None:
            args['dependencies'] = Dependencies.from_dict(dependencies)
        if (description := _dict.get('description')) is not None:
            args['description'] = description
        if (id := _dict.get('id')) is not None:
            args['id'] = id
        if (last_health_check_at := _dict.get('last_health_check_at')) is not None:
            args['last_health_check_at'] = string_to_datetime(last_health_check_at)
        if (location := _dict.get('location')) is not None:
            args['location'] = location
        if (name := _dict.get('name')) is not None:
            args['name'] = name
        if (resource_group := _dict.get('resource_group')) is not None:
            args['resource_group'] = resource_group
        if (runtime_data := _dict.get('runtime_data')) is not None:
            args['runtime_data'] = [TemplateRunTimeDataResponse.from_dict(v) for v in runtime_data]
        if (shared_data := _dict.get('shared_data')) is not None:
            args['shared_data'] = SharedTargetDataResponse.from_dict(shared_data)
        if (status := _dict.get('status')) is not None:
            args['status'] = status
        if (tags := _dict.get('tags')) is not None:
            args['tags'] = tags
        if (template_data := _dict.get('template_data')) is not None:
            args['template_data'] = [TemplateSourceDataResponse.from_dict(v) for v in template_data]
        if (template_ref := _dict.get('template_ref')) is not None:
            args['template_ref'] = template_ref
        if (template_repo := _dict.get('template_repo')) is not None:
            args['template_repo'] = TemplateRepoResponse.from_dict(template_repo)
        if (type := _dict.get('type')) is not None:
            args['type'] = type
        if (updated_at := _dict.get('updated_at')) is not None:
            args['updated_at'] = string_to_datetime(updated_at)
        if (updated_by := _dict.get('updated_by')) is not None:
            args['updated_by'] = updated_by
        if (cart_id := _dict.get('cart_id')) is not None:
            args['cart_id'] = cart_id
        if (project_id := _dict.get('project_id')) is not None:
            args['project_id'] = project_id
        if (last_action_name := _dict.get('last_action_name')) is not None:
            args['last_action_name'] = last_action_name
        if (last_activity_id := _dict.get('last_activity_id')) is not None:
            args['last_activity_id'] = last_activity_id
        if (last_job := _dict.get('last_job')) is not None:
            args['last_job'] = LastJob.from_dict(last_job)
        if (workspace_status := _dict.get('workspace_status')) is not None:
            args['workspace_status'] = WorkspaceStatusResponse.from_dict(workspace_status)
        if (workspace_status_msg := _dict.get('workspace_status_msg')) is not None:
            args['workspace_status_msg'] = WorkspaceStatusMessage.from_dict(workspace_status_msg)
        if (agent := _dict.get('agent')) is not None:
            args['agent'] = AgentInfo.from_dict(agent)
        if (settings := _dict.get('settings')) is not None:
            args['settings'] = [VariableData.from_dict(v) for v in settings]
        if (git_token_ref := _dict.get('git_token_ref')) is not None:
            args['git_token_ref'] = git_token_ref
        if (encryption := _dict.get('encryption')) is not None:
            args['encryption'] = EncryptionInfo.from_dict(encryption)
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a WorkspaceResponse object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'applied_shareddata_ids') and self.applied_shareddata_ids is not None:
            _dict['applied_shareddata_ids'] = self.applied_shareddata_ids
        if hasattr(self, 'catalog_ref') and self.catalog_ref is not None:
            if isinstance(self.catalog_ref, dict):
                _dict['catalog_ref'] = self.catalog_ref
            else:
                _dict['catalog_ref'] = self.catalog_ref.to_dict()
        if hasattr(self, 'created_at') and getattr(self, 'created_at') is not None:
            _dict['created_at'] = datetime_to_string(getattr(self, 'created_at'))
        if hasattr(self, 'created_by') and getattr(self, 'created_by') is not None:
            _dict['created_by'] = getattr(self, 'created_by')
        if hasattr(self, 'crn') and getattr(self, 'crn') is not None:
            _dict['crn'] = getattr(self, 'crn')
        if hasattr(self, 'dependencies') and self.dependencies is not None:
            if isinstance(self.dependencies, dict):
                _dict['dependencies'] = self.dependencies
            else:
                _dict['dependencies'] = self.dependencies.to_dict()
        if hasattr(self, 'description') and self.description is not None:
            _dict['description'] = self.description
        if hasattr(self, 'id') and getattr(self, 'id') is not None:
            _dict['id'] = getattr(self, 'id')
        if hasattr(self, 'last_health_check_at') and getattr(self, 'last_health_check_at') is not None:
            _dict['last_health_check_at'] = datetime_to_string(getattr(self, 'last_health_check_at'))
        if hasattr(self, 'location') and self.location is not None:
            _dict['location'] = self.location
        if hasattr(self, 'name') and self.name is not None:
            _dict['name'] = self.name
        if hasattr(self, 'resource_group') and self.resource_group is not None:
            _dict['resource_group'] = self.resource_group
        if hasattr(self, 'runtime_data') and getattr(self, 'runtime_data') is not None:
            runtime_data_list = []
            for v in getattr(self, 'runtime_data'):
                if isinstance(v, dict):
                    runtime_data_list.append(v)
                else:
                    runtime_data_list.append(v.to_dict())
            _dict['runtime_data'] = runtime_data_list
        if hasattr(self, 'shared_data') and self.shared_data is not None:
            if isinstance(self.shared_data, dict):
                _dict['shared_data'] = self.shared_data
            else:
                _dict['shared_data'] = self.shared_data.to_dict()
        if hasattr(self, 'status') and self.status is not None:
            _dict['status'] = self.status
        if hasattr(self, 'tags') and self.tags is not None:
            _dict['tags'] = self.tags
        if hasattr(self, 'template_data') and self.template_data is not None:
            template_data_list = []
            for v in self.template_data:
                if isinstance(v, dict):
                    template_data_list.append(v)
                else:
                    template_data_list.append(v.to_dict())
            _dict['template_data'] = template_data_list
        if hasattr(self, 'template_ref') and self.template_ref is not None:
            _dict['template_ref'] = self.template_ref
        if hasattr(self, 'template_repo') and self.template_repo is not None:
            if isinstance(self.template_repo, dict):
                _dict['template_repo'] = self.template_repo
            else:
                _dict['template_repo'] = self.template_repo.to_dict()
        if hasattr(self, 'type') and self.type is not None:
            _dict['type'] = self.type
        if hasattr(self, 'updated_at') and getattr(self, 'updated_at') is not None:
            _dict['updated_at'] = datetime_to_string(getattr(self, 'updated_at'))
        if hasattr(self, 'updated_by') and getattr(self, 'updated_by') is not None:
            _dict['updated_by'] = getattr(self, 'updated_by')
        if hasattr(self, 'cart_id') and self.cart_id is not None:
            _dict['cart_id'] = self.cart_id
        if hasattr(self, 'project_id') and self.project_id is not None:
            _dict['project_id'] = self.project_id
        if hasattr(self, 'last_action_name') and self.last_action_name is not None:
            _dict['last_action_name'] = self.last_action_name
        if hasattr(self, 'last_activity_id') and self.last_activity_id is not None:
            _dict['last_activity_id'] = self.last_activity_id
        if hasattr(self, 'last_job') and self.last_job is not None:
            if isinstance(self.last_job, dict):
                _dict['last_job'] = self.last_job
            else:
                _dict['last_job'] = self.last_job.to_dict()
        if hasattr(self, 'workspace_status') and self.workspace_status is not None:
            if isinstance(self.workspace_status, dict):
                _dict['workspace_status'] = self.workspace_status
            else:
                _dict['workspace_status'] = self.workspace_status.to_dict()
        if hasattr(self, 'workspace_status_msg') and self.workspace_status_msg is not None:
            if isinstance(self.workspace_status_msg, dict):
                _dict['workspace_status_msg'] = self.workspace_status_msg
            else:
                _dict['workspace_status_msg'] = self.workspace_status_msg.to_dict()
        if hasattr(self, 'agent') and self.agent is not None:
            if isinstance(self.agent, dict):
                _dict['agent'] = self.agent
            else:
                _dict['agent'] = self.agent.to_dict()
        if hasattr(self, 'settings') and self.settings is not None:
            settings_list = []
            for v in self.settings:
                if isinstance(v, dict):
                    settings_list.append(v)
                else:
                    settings_list.append(v.to_dict())
            _dict['settings'] = settings_list
        if hasattr(self, 'git_token_ref') and getattr(self, 'git_token_ref') is not None:
            _dict['git_token_ref'] = getattr(self, 'git_token_ref')
        if hasattr(self, 'encryption') and getattr(self, 'encryption') is not None:
            if isinstance(getattr(self, 'encryption'), dict):
                _dict['encryption'] = getattr(self, 'encryption')
            else:
                _dict['encryption'] = getattr(self, 'encryption').to_dict()
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this WorkspaceResponse object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'WorkspaceResponse') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'WorkspaceResponse') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other


class WorkspaceResponseList:
    """
    List of workspaces.

    :param int count: (optional) The number of workspaces in the IBM Cloud account
          that you have access to and that matched your search criteria.
    :param int limit: The `limit` value that you set in your API request and that
          represents the maximum number of workspaces that you wanted to list.
    :param int offset: The `offset` value that you set in your API request. The
          offset value represents the position number of the workspace from which you
          wanted to start listing your workspaces.
    :param List[WorkspaceResponse] workspaces: (optional) The list of workspaces
          that was included in your API response.
    """

    def __init__(
        self,
        limit: int,
        offset: int,
        *,
        count: Optional[int] = None,
        workspaces: Optional[List['WorkspaceResponse']] = None,
    ) -> None:
        """
        Initialize a WorkspaceResponseList object.

        :param int limit: The `limit` value that you set in your API request and
               that represents the maximum number of workspaces that you wanted to list.
        :param int offset: The `offset` value that you set in your API request. The
               offset value represents the position number of the workspace from which you
               wanted to start listing your workspaces.
        :param int count: (optional) The number of workspaces in the IBM Cloud
               account that you have access to and that matched your search criteria.
        :param List[WorkspaceResponse] workspaces: (optional) The list of
               workspaces that was included in your API response.
        """
        self.count = count
        self.limit = limit
        self.offset = offset
        self.workspaces = workspaces

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'WorkspaceResponseList':
        """Initialize a WorkspaceResponseList object from a json dictionary."""
        args = {}
        if (count := _dict.get('count')) is not None:
            args['count'] = count
        if (limit := _dict.get('limit')) is not None:
            args['limit'] = limit
        else:
            raise ValueError('Required property \'limit\' not present in WorkspaceResponseList JSON')
        if (offset := _dict.get('offset')) is not None:
            args['offset'] = offset
        else:
            raise ValueError('Required property \'offset\' not present in WorkspaceResponseList JSON')
        if (workspaces := _dict.get('workspaces')) is not None:
            args['workspaces'] = [WorkspaceResponse.from_dict(v) for v in workspaces]
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a WorkspaceResponseList object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'count') and self.count is not None:
            _dict['count'] = self.count
        if hasattr(self, 'limit') and self.limit is not None:
            _dict['limit'] = self.limit
        if hasattr(self, 'offset') and self.offset is not None:
            _dict['offset'] = self.offset
        if hasattr(self, 'workspaces') and self.workspaces is not None:
            workspaces_list = []
            for v in self.workspaces:
                if isinstance(v, dict):
                    workspaces_list.append(v)
                else:
                    workspaces_list.append(v.to_dict())
            _dict['workspaces'] = workspaces_list
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this WorkspaceResponseList object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'WorkspaceResponseList') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'WorkspaceResponseList') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other


class WorkspaceStatusMessage:
    """
    Information about the last job that ran against the workspace. -.

    :param str status_code: (optional) The success or error code that was returned
          for the last plan, apply, or destroy job that ran against your workspace.
    :param str status_msg: (optional) The success or error message that was returned
          for the last plan, apply, or destroy job that ran against your workspace.
    """

    def __init__(
        self,
        *,
        status_code: Optional[str] = None,
        status_msg: Optional[str] = None,
    ) -> None:
        """
        Initialize a WorkspaceStatusMessage object.

        :param str status_code: (optional) The success or error code that was
               returned for the last plan, apply, or destroy job that ran against your
               workspace.
        :param str status_msg: (optional) The success or error message that was
               returned for the last plan, apply, or destroy job that ran against your
               workspace.
        """
        self.status_code = status_code
        self.status_msg = status_msg

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'WorkspaceStatusMessage':
        """Initialize a WorkspaceStatusMessage object from a json dictionary."""
        args = {}
        if (status_code := _dict.get('status_code')) is not None:
            args['status_code'] = status_code
        if (status_msg := _dict.get('status_msg')) is not None:
            args['status_msg'] = status_msg
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a WorkspaceStatusMessage object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'status_code') and self.status_code is not None:
            _dict['status_code'] = self.status_code
        if hasattr(self, 'status_msg') and self.status_msg is not None:
            _dict['status_msg'] = self.status_msg
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this WorkspaceStatusMessage object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'WorkspaceStatusMessage') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'WorkspaceStatusMessage') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other


class WorkspaceStatusRequest:
    """
    WorkspaceStatusRequest -.

    :param bool frozen: (optional) If set to true, the workspace is frozen and
          changes to the workspace are disabled.
    :param datetime frozen_at: (optional) The timestamp when the workspace was
          frozen.
    :param str frozen_by: (optional) The user ID that froze the workspace.
    :param bool locked: (optional) If set to true, the workspace is locked and
          disabled for changes.
    :param str locked_by: (optional) The user ID that initiated a resource-related
          job, such as applying or destroying resources, that locked the workspace.
    :param datetime locked_time: (optional) The timestamp when the workspace was
          locked.
    """

    def __init__(
        self,
        *,
        frozen: Optional[bool] = None,
        frozen_at: Optional[datetime] = None,
        frozen_by: Optional[str] = None,
        locked: Optional[bool] = None,
        locked_by: Optional[str] = None,
        locked_time: Optional[datetime] = None,
    ) -> None:
        """
        Initialize a WorkspaceStatusRequest object.

        :param bool frozen: (optional) If set to true, the workspace is frozen and
               changes to the workspace are disabled.
        :param datetime frozen_at: (optional) The timestamp when the workspace was
               frozen.
        :param str frozen_by: (optional) The user ID that froze the workspace.
        :param bool locked: (optional) If set to true, the workspace is locked and
               disabled for changes.
        :param str locked_by: (optional) The user ID that initiated a
               resource-related job, such as applying or destroying resources, that locked
               the workspace.
        :param datetime locked_time: (optional) The timestamp when the workspace
               was locked.
        """
        self.frozen = frozen
        self.frozen_at = frozen_at
        self.frozen_by = frozen_by
        self.locked = locked
        self.locked_by = locked_by
        self.locked_time = locked_time

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'WorkspaceStatusRequest':
        """Initialize a WorkspaceStatusRequest object from a json dictionary."""
        args = {}
        if (frozen := _dict.get('frozen')) is not None:
            args['frozen'] = frozen
        if (frozen_at := _dict.get('frozen_at')) is not None:
            args['frozen_at'] = string_to_datetime(frozen_at)
        if (frozen_by := _dict.get('frozen_by')) is not None:
            args['frozen_by'] = frozen_by
        if (locked := _dict.get('locked')) is not None:
            args['locked'] = locked
        if (locked_by := _dict.get('locked_by')) is not None:
            args['locked_by'] = locked_by
        if (locked_time := _dict.get('locked_time')) is not None:
            args['locked_time'] = string_to_datetime(locked_time)
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a WorkspaceStatusRequest object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'frozen') and self.frozen is not None:
            _dict['frozen'] = self.frozen
        if hasattr(self, 'frozen_at') and self.frozen_at is not None:
            _dict['frozen_at'] = datetime_to_string(self.frozen_at)
        if hasattr(self, 'frozen_by') and self.frozen_by is not None:
            _dict['frozen_by'] = self.frozen_by
        if hasattr(self, 'locked') and self.locked is not None:
            _dict['locked'] = self.locked
        if hasattr(self, 'locked_by') and self.locked_by is not None:
            _dict['locked_by'] = self.locked_by
        if hasattr(self, 'locked_time') and self.locked_time is not None:
            _dict['locked_time'] = datetime_to_string(self.locked_time)
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this WorkspaceStatusRequest object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'WorkspaceStatusRequest') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'WorkspaceStatusRequest') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other


class WorkspaceStatusResponse:
    """
    Response that indicate the status of the workspace as either frozen or locked.

    :param bool frozen: (optional) If set to true, the workspace is frozen and
          changes to the workspace are disabled.
    :param datetime frozen_at: (optional) The timestamp when the workspace was
          frozen.
    :param str frozen_by: (optional) The user ID that froze the workspace.
    :param bool locked: (optional) If set to true, the workspace is locked and
          disabled for changes.
    :param str locked_by: (optional) The user ID that initiated a resource-related
          job, such as applying or destroying resources, that locked the workspace.
    :param datetime locked_time: (optional) The timestamp when the workspace was
          locked.
    """

    def __init__(
        self,
        *,
        frozen: Optional[bool] = None,
        frozen_at: Optional[datetime] = None,
        frozen_by: Optional[str] = None,
        locked: Optional[bool] = None,
        locked_by: Optional[str] = None,
        locked_time: Optional[datetime] = None,
    ) -> None:
        """
        Initialize a WorkspaceStatusResponse object.

        :param bool frozen: (optional) If set to true, the workspace is frozen and
               changes to the workspace are disabled.
        :param datetime frozen_at: (optional) The timestamp when the workspace was
               frozen.
        :param str frozen_by: (optional) The user ID that froze the workspace.
        :param bool locked: (optional) If set to true, the workspace is locked and
               disabled for changes.
        :param str locked_by: (optional) The user ID that initiated a
               resource-related job, such as applying or destroying resources, that locked
               the workspace.
        :param datetime locked_time: (optional) The timestamp when the workspace
               was locked.
        """
        self.frozen = frozen
        self.frozen_at = frozen_at
        self.frozen_by = frozen_by
        self.locked = locked
        self.locked_by = locked_by
        self.locked_time = locked_time

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'WorkspaceStatusResponse':
        """Initialize a WorkspaceStatusResponse object from a json dictionary."""
        args = {}
        if (frozen := _dict.get('frozen')) is not None:
            args['frozen'] = frozen
        if (frozen_at := _dict.get('frozen_at')) is not None:
            args['frozen_at'] = string_to_datetime(frozen_at)
        if (frozen_by := _dict.get('frozen_by')) is not None:
            args['frozen_by'] = frozen_by
        if (locked := _dict.get('locked')) is not None:
            args['locked'] = locked
        if (locked_by := _dict.get('locked_by')) is not None:
            args['locked_by'] = locked_by
        if (locked_time := _dict.get('locked_time')) is not None:
            args['locked_time'] = string_to_datetime(locked_time)
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a WorkspaceStatusResponse object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'frozen') and self.frozen is not None:
            _dict['frozen'] = self.frozen
        if hasattr(self, 'frozen_at') and self.frozen_at is not None:
            _dict['frozen_at'] = datetime_to_string(self.frozen_at)
        if hasattr(self, 'frozen_by') and self.frozen_by is not None:
            _dict['frozen_by'] = self.frozen_by
        if hasattr(self, 'locked') and self.locked is not None:
            _dict['locked'] = self.locked
        if hasattr(self, 'locked_by') and self.locked_by is not None:
            _dict['locked_by'] = self.locked_by
        if hasattr(self, 'locked_time') and self.locked_time is not None:
            _dict['locked_time'] = datetime_to_string(self.locked_time)
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this WorkspaceStatusResponse object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'WorkspaceStatusResponse') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'WorkspaceStatusResponse') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other


class WorkspaceStatusUpdateRequest:
    """
    Input to update the workspace status.

    :param bool frozen: (optional) If set to true, the workspace is frozen and
          changes to the workspace are disabled.
    :param datetime frozen_at: (optional) Frozen at.
    :param str frozen_by: (optional) Frozen by.
    :param bool locked: (optional) Locked status.
    :param str locked_by: (optional) Locked by.
    :param datetime locked_time: (optional) Locked at.
    """

    def __init__(
        self,
        *,
        frozen: Optional[bool] = None,
        frozen_at: Optional[datetime] = None,
        frozen_by: Optional[str] = None,
        locked: Optional[bool] = None,
        locked_by: Optional[str] = None,
        locked_time: Optional[datetime] = None,
    ) -> None:
        """
        Initialize a WorkspaceStatusUpdateRequest object.

        :param bool frozen: (optional) If set to true, the workspace is frozen and
               changes to the workspace are disabled.
        :param datetime frozen_at: (optional) Frozen at.
        :param str frozen_by: (optional) Frozen by.
        :param bool locked: (optional) Locked status.
        :param str locked_by: (optional) Locked by.
        :param datetime locked_time: (optional) Locked at.
        """
        self.frozen = frozen
        self.frozen_at = frozen_at
        self.frozen_by = frozen_by
        self.locked = locked
        self.locked_by = locked_by
        self.locked_time = locked_time

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'WorkspaceStatusUpdateRequest':
        """Initialize a WorkspaceStatusUpdateRequest object from a json dictionary."""
        args = {}
        if (frozen := _dict.get('frozen')) is not None:
            args['frozen'] = frozen
        if (frozen_at := _dict.get('frozen_at')) is not None:
            args['frozen_at'] = string_to_datetime(frozen_at)
        if (frozen_by := _dict.get('frozen_by')) is not None:
            args['frozen_by'] = frozen_by
        if (locked := _dict.get('locked')) is not None:
            args['locked'] = locked
        if (locked_by := _dict.get('locked_by')) is not None:
            args['locked_by'] = locked_by
        if (locked_time := _dict.get('locked_time')) is not None:
            args['locked_time'] = string_to_datetime(locked_time)
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a WorkspaceStatusUpdateRequest object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'frozen') and self.frozen is not None:
            _dict['frozen'] = self.frozen
        if hasattr(self, 'frozen_at') and self.frozen_at is not None:
            _dict['frozen_at'] = datetime_to_string(self.frozen_at)
        if hasattr(self, 'frozen_by') and self.frozen_by is not None:
            _dict['frozen_by'] = self.frozen_by
        if hasattr(self, 'locked') and self.locked is not None:
            _dict['locked'] = self.locked
        if hasattr(self, 'locked_by') and self.locked_by is not None:
            _dict['locked_by'] = self.locked_by
        if hasattr(self, 'locked_time') and self.locked_time is not None:
            _dict['locked_time'] = datetime_to_string(self.locked_time)
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this WorkspaceStatusUpdateRequest object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'WorkspaceStatusUpdateRequest') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'WorkspaceStatusUpdateRequest') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other


class WorkspaceTemplateValuesResponse:
    """
    Response with the template details in your workspace.

    :param List[TemplateRunTimeDataResponse] runtime_data: (optional) Information
          about the provisioning engine, state file, and runtime logs.
    :param SharedTargetData shared_data: (optional) Information about the Target
          used by the templates originating from the  IBM Cloud catalog offerings. This
          information is not relevant for workspace created using your own Terraform
          template.
    :param List[TemplateSourceDataResponse] template_data: (optional) Information
          about the input variables that are used in the template.
    """

    def __init__(
        self,
        *,
        runtime_data: Optional[List['TemplateRunTimeDataResponse']] = None,
        shared_data: Optional['SharedTargetData'] = None,
        template_data: Optional[List['TemplateSourceDataResponse']] = None,
    ) -> None:
        """
        Initialize a WorkspaceTemplateValuesResponse object.

        :param List[TemplateRunTimeDataResponse] runtime_data: (optional)
               Information about the provisioning engine, state file, and runtime logs.
        :param SharedTargetData shared_data: (optional) Information about the
               Target used by the templates originating from the  IBM Cloud catalog
               offerings. This information is not relevant for workspace created using
               your own Terraform template.
        :param List[TemplateSourceDataResponse] template_data: (optional)
               Information about the input variables that are used in the template.
        """
        self.runtime_data = runtime_data
        self.shared_data = shared_data
        self.template_data = template_data

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'WorkspaceTemplateValuesResponse':
        """Initialize a WorkspaceTemplateValuesResponse object from a json dictionary."""
        args = {}
        if (runtime_data := _dict.get('runtime_data')) is not None:
            args['runtime_data'] = [TemplateRunTimeDataResponse.from_dict(v) for v in runtime_data]
        if (shared_data := _dict.get('shared_data')) is not None:
            args['shared_data'] = SharedTargetData.from_dict(shared_data)
        if (template_data := _dict.get('template_data')) is not None:
            args['template_data'] = [TemplateSourceDataResponse.from_dict(v) for v in template_data]
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a WorkspaceTemplateValuesResponse object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'runtime_data') and self.runtime_data is not None:
            runtime_data_list = []
            for v in self.runtime_data:
                if isinstance(v, dict):
                    runtime_data_list.append(v)
                else:
                    runtime_data_list.append(v.to_dict())
            _dict['runtime_data'] = runtime_data_list
        if hasattr(self, 'shared_data') and self.shared_data is not None:
            if isinstance(self.shared_data, dict):
                _dict['shared_data'] = self.shared_data
            else:
                _dict['shared_data'] = self.shared_data.to_dict()
        if hasattr(self, 'template_data') and self.template_data is not None:
            template_data_list = []
            for v in self.template_data:
                if isinstance(v, dict):
                    template_data_list.append(v)
                else:
                    template_data_list.append(v.to_dict())
            _dict['template_data'] = template_data_list
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this WorkspaceTemplateValuesResponse object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'WorkspaceTemplateValuesResponse') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'WorkspaceTemplateValuesResponse') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other


class WorkspaceVariableRequest:
    """
    Input variables for your workspace.

    :param str description: (optional) The description of your input variable.
    :param str name: (optional) The name of the variable.
    :param bool secure: (optional) If set to `true`, the value of your input
          variable is protected and not returned in your API response.
    :param str type: (optional) `Terraform v0.11` supports `string`, `list`, `map`
          data type. For more information, about the syntax, see [Configuring input
          variables](https://www.terraform.io/docs/configuration-0-11/variables.html).
          <br> `Terraform v0.12` additionally, supports `bool`, `number` and complex data
          types such as `list(type)`, `map(type)`,
          `object({attribute name=type,..})`, `set(type)`, `tuple([type])`. For more
          information, about the syntax to use the complex data type, see [Configuring
          variables](https://www.terraform.io/docs/configuration/variables.html#type-constraints).
    :param bool use_default: (optional) Variable uses default value; and is not
          over-ridden.
    :param str value: (optional) Enter the value as a string for the primitive types
          such as `bool`, `number`, `string`, and `HCL` format for the complex variables,
          as you provide in a `.tfvars` file. **You need to enter escaped string of `HCL`
          format for the complex variable value**. For more information, about how to
          declare variables in a terraform configuration file and provide value to
          schematics, see [Providing values for the declared
          variables](https://cloud.ibm.com/docs/schematics?topic=schematics-create-tf-config#declare-variable).
    """

    def __init__(
        self,
        *,
        description: Optional[str] = None,
        name: Optional[str] = None,
        secure: Optional[bool] = None,
        type: Optional[str] = None,
        use_default: Optional[bool] = None,
        value: Optional[str] = None,
    ) -> None:
        """
        Initialize a WorkspaceVariableRequest object.

        :param str description: (optional) The description of your input variable.
        :param str name: (optional) The name of the variable.
        :param bool secure: (optional) If set to `true`, the value of your input
               variable is protected and not returned in your API response.
        :param str type: (optional) `Terraform v0.11` supports `string`, `list`,
               `map` data type. For more information, about the syntax, see [Configuring
               input
               variables](https://www.terraform.io/docs/configuration-0-11/variables.html).
               <br> `Terraform v0.12` additionally, supports `bool`, `number` and complex
               data types such as `list(type)`, `map(type)`,
               `object({attribute name=type,..})`, `set(type)`, `tuple([type])`. For more
               information, about the syntax to use the complex data type, see
               [Configuring
               variables](https://www.terraform.io/docs/configuration/variables.html#type-constraints).
        :param bool use_default: (optional) Variable uses default value; and is not
               over-ridden.
        :param str value: (optional) Enter the value as a string for the primitive
               types such as `bool`, `number`, `string`, and `HCL` format for the complex
               variables, as you provide in a `.tfvars` file. **You need to enter escaped
               string of `HCL` format for the complex variable value**. For more
               information, about how to declare variables in a terraform configuration
               file and provide value to schematics, see [Providing values for the
               declared
               variables](https://cloud.ibm.com/docs/schematics?topic=schematics-create-tf-config#declare-variable).
        """
        self.description = description
        self.name = name
        self.secure = secure
        self.type = type
        self.use_default = use_default
        self.value = value

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'WorkspaceVariableRequest':
        """Initialize a WorkspaceVariableRequest object from a json dictionary."""
        args = {}
        if (description := _dict.get('description')) is not None:
            args['description'] = description
        if (name := _dict.get('name')) is not None:
            args['name'] = name
        if (secure := _dict.get('secure')) is not None:
            args['secure'] = secure
        if (type := _dict.get('type')) is not None:
            args['type'] = type
        if (use_default := _dict.get('use_default')) is not None:
            args['use_default'] = use_default
        if (value := _dict.get('value')) is not None:
            args['value'] = value
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a WorkspaceVariableRequest object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'description') and self.description is not None:
            _dict['description'] = self.description
        if hasattr(self, 'name') and self.name is not None:
            _dict['name'] = self.name
        if hasattr(self, 'secure') and self.secure is not None:
            _dict['secure'] = self.secure
        if hasattr(self, 'type') and self.type is not None:
            _dict['type'] = self.type
        if hasattr(self, 'use_default') and self.use_default is not None:
            _dict['use_default'] = self.use_default
        if hasattr(self, 'value') and self.value is not None:
            _dict['value'] = self.value
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this WorkspaceVariableRequest object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'WorkspaceVariableRequest') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'WorkspaceVariableRequest') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other


class WorkspaceVariableResponse:
    """
    The description of your input variable.

    :param str description: (optional) The description of your input variable.
    :param str name: (optional) The name of the variable.
    :param bool secure: (optional) If set to `true`, the value of your input
          variable is protected and not returned in your API response.
    :param str type: (optional) `Terraform v0.11` supports `string`, `list`, `map`
          data type. For more information, about the syntax, see [Configuring input
          variables](https://www.terraform.io/docs/configuration-0-11/variables.html).
          <br> `Terraform v0.12` additionally, supports `bool`, `number` and complex data
          types such as `list(type)`, `map(type)`,
          `object({attribute name=type,..})`, `set(type)`, `tuple([type])`. For more
          information, about the syntax to use the complex data type, see [Configuring
          variables](https://www.terraform.io/docs/configuration/variables.html#type-constraints).
    :param str value: (optional) Enter the value as a string for the primitive types
          such as `bool`, `number`, `string`, and `HCL` format for the complex variables,
          as you provide in a `.tfvars` file. **You need to enter escaped string of `HCL`
          format for the complex variable value**. For more information, about how to
          declare variables in a terraform configuration file and provide value to
          schematics, see [Providing values for the declared
          variables](https://cloud.ibm.com/docs/schematics?topic=schematics-create-tf-config#declare-variable).
    """

    def __init__(
        self,
        *,
        description: Optional[str] = None,
        name: Optional[str] = None,
        secure: Optional[bool] = None,
        type: Optional[str] = None,
        value: Optional[str] = None,
    ) -> None:
        """
        Initialize a WorkspaceVariableResponse object.

        :param str description: (optional) The description of your input variable.
        :param str name: (optional) The name of the variable.
        :param bool secure: (optional) If set to `true`, the value of your input
               variable is protected and not returned in your API response.
        :param str type: (optional) `Terraform v0.11` supports `string`, `list`,
               `map` data type. For more information, about the syntax, see [Configuring
               input
               variables](https://www.terraform.io/docs/configuration-0-11/variables.html).
               <br> `Terraform v0.12` additionally, supports `bool`, `number` and complex
               data types such as `list(type)`, `map(type)`,
               `object({attribute name=type,..})`, `set(type)`, `tuple([type])`. For more
               information, about the syntax to use the complex data type, see
               [Configuring
               variables](https://www.terraform.io/docs/configuration/variables.html#type-constraints).
        :param str value: (optional) Enter the value as a string for the primitive
               types such as `bool`, `number`, `string`, and `HCL` format for the complex
               variables, as you provide in a `.tfvars` file. **You need to enter escaped
               string of `HCL` format for the complex variable value**. For more
               information, about how to declare variables in a terraform configuration
               file and provide value to schematics, see [Providing values for the
               declared
               variables](https://cloud.ibm.com/docs/schematics?topic=schematics-create-tf-config#declare-variable).
        """
        self.description = description
        self.name = name
        self.secure = secure
        self.type = type
        self.value = value

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'WorkspaceVariableResponse':
        """Initialize a WorkspaceVariableResponse object from a json dictionary."""
        args = {}
        if (description := _dict.get('description')) is not None:
            args['description'] = description
        if (name := _dict.get('name')) is not None:
            args['name'] = name
        if (secure := _dict.get('secure')) is not None:
            args['secure'] = secure
        if (type := _dict.get('type')) is not None:
            args['type'] = type
        if (value := _dict.get('value')) is not None:
            args['value'] = value
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a WorkspaceVariableResponse object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'description') and self.description is not None:
            _dict['description'] = self.description
        if hasattr(self, 'name') and self.name is not None:
            _dict['name'] = self.name
        if hasattr(self, 'secure') and self.secure is not None:
            _dict['secure'] = self.secure
        if hasattr(self, 'type') and self.type is not None:
            _dict['type'] = self.type
        if hasattr(self, 'value') and self.value is not None:
            _dict['value'] = self.value
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this WorkspaceVariableResponse object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'WorkspaceVariableResponse') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'WorkspaceVariableResponse') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other
